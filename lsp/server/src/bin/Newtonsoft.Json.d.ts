// Generated for: Newtonsoft.Json 13.0.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.8.0.0
/* eslint-disable */

import './System.Runtime';

type DateTime = Date & { kind?: 'utc' | 'local' | 'unspecified' }

type DateTimeOffset = Date & { offset?: number }

import { Duplex } from 'stream';

/** A JavaScript projection of a .NET type. */
interface IType {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): IType;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace Newtonsoft.Json {
		/**
		 * Specifies how constructors are used when initializing objects during deserialization
		 * by the {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export enum ConstructorHandling {
			/**
			 * First attempt to use the public default constructor, then fall back to a single
			 * parameterized constructor, then to the non-public default constructor.
			 */
			Default = 0,

			/**
			 * Json.NET will use a non-public default constructor before falling back to a
			 * parameterized constructor.
			 */
			AllowNonPublicDefaultConstructor = 1,
		}
	}

	export namespace Newtonsoft.Json {
		/** Specifies how dates are formatted when writing JSON text. */
		export enum DateFormatHandling {
			/** Dates are written in the ISO 8601 format, e.g. "2012-03-21T05:40Z" . */
			IsoDateFormat = 0,

			/** Dates are written in the Microsoft JSON format, e.g. "\/Date(1198908717056)\/" . */
			MicrosoftDateFormat = 1,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies how date formatted strings, e.g. "\/Date(1198908717056)\/" and
		 * "2012-03-21T05:40Z" , are parsed when reading JSON text.
		 */
		export enum DateParseHandling {
			/** Date formatted strings are not parsed to a date type and are read as strings. */
			None = 0,

			/**
			 * Date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z" , are
			 * parsed to {@link System.DateTime}.
			 */
			DateTime = 1,

			/**
			 * Date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z" , are
			 * parsed to {@link System.DateTimeOffset}.
			 */
			DateTimeOffset = 2,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies how to treat the time value when converting between string and
		 * {@link System.DateTime}.
		 */
		export enum DateTimeZoneHandling {
			/**
			 * Treat as local time. If the {@link System.DateTime} object represents a Coordinated
			 * Universal Time (UTC), it is converted to the local time.
			 */
			Local = 0,

			/**
			 * Treat as a UTC. If the {@link System.DateTime} object represents a local time, it is
			 * converted to a UTC.
			 */
			Utc = 1,

			/**
			 * Treat as a local time if a {@link System.DateTime} is being converted to a string. If
			 * a string is being converted to {@link System.DateTime}, convert to a local time if a
			 * time zone is specified.
			 */
			Unspecified = 2,

			/** Time zone information should be preserved when converting. */
			RoundtripKind = 3,
		}
	}

	export namespace Newtonsoft.Json {
		/** The default JSON name table implementation. */
		export class DefaultJsonNameTable extends Newtonsoft.Json.JsonNameTable {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.DefaultJsonNameTable} class.
			 */
			constructor();

			/**
			 * Gets a string containing the same characters as the specified range of characters in
			 * the given array.
			 */
			Get(
				key: System.Char[],
				start: number,
				length: number,
			): string | undefined;

			/**
			 * Adds the specified string into name table.
			 *
			 * This method is not thread-safe.
			 */
			Add(key: string): string;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies default value handling options for the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export enum DefaultValueHandling {
			/**
			 * Include members where the member value is the same as the member's default value when
			 * serializing objects. Included members are written to JSON. Has no effect when
			 * deserializing.
			 */
			Include = 0,

			/**
			 * Ignore members where the member value is the same as the member's default value when
			 * serializing objects so that it is not written to JSON. This option will ignore all
			 * default values (e.g. null for objects and nullable types; 0 for integers, decimals and
			 * floating point numbers; and false for booleans). The default value ignored can be
			 * changed by placing the {@link System.ComponentModel.DefaultValueAttribute} on the
			 * property.
			 */
			Ignore = 1,

			/**
			 * Members with a default value but no JSON will be set to their default value when
			 * deserializing.
			 */
			Populate = 2,

			/**
			 * Ignore members where the member value is the same as the member's default value when
			 * serializing objects and set members to their default value when deserializing.
			 */
			IgnoreAndPopulate = 3,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies float format handling options when writing special floating point numbers,
		 * e.g. {@link System.Double.NaN}, {@link System.Double.PositiveInfinity} and
		 * {@link System.Double.NegativeInfinity} with {@link Newtonsoft.Json.JsonWriter}.
		 */
		export enum FloatFormatHandling {
			/**
			 * Write special floating point values as strings in JSON, e.g. "NaN" , "Infinity" ,
			 * "-Infinity" .
			 */
			String = 0,

			/**
			 * Write special floating point values as symbols in JSON, e.g. NaN , Infinity ,
			 * -Infinity . Note that this will produce non-valid JSON.
			 */
			Symbol = 1,

			/**
			 * Write special floating point values as the property's default value in JSON, e.g. 0.0
			 * for a {@link System.Double} property, null for a {@link System.Nullable<>} of
			 * {@link System.Double} property.
			 */
			DefaultValue = 2,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON
		 * text.
		 */
		export enum FloatParseHandling {
			/**
			 * Floating point numbers are parsed to
			 * {@link Newtonsoft.Json.FloatParseHandling.Double}.
			 */
			Double = 0,

			/**
			 * Floating point numbers are parsed to
			 * {@link Newtonsoft.Json.FloatParseHandling.Decimal}.
			 */
			Decimal = 1,
		}
	}

	export namespace Newtonsoft.Json {
		/** Specifies formatting options for the {@link Newtonsoft.Json.JsonTextWriter}. */
		export enum Formatting {
			/** No special formatting is applied. This is the default. */
			None = 0,

			/**
			 * Causes child objects to be indented according to the
			 * {@link Newtonsoft.Json.JsonTextWriter.Indentation} and
			 * {@link Newtonsoft.Json.JsonTextWriter.IndentChar} settings.
			 */
			Indented = 1,
		}
	}

	export namespace Newtonsoft.Json {
		/** [Generic type factory] Provides an interface for using pooled arrays. */
		export function IArrayPool$(T: IType): IType;

		/** Provides an interface for using pooled arrays. */
		export interface IArrayPool$1<T> {
			/**
			 * Rent an array from the pool. This array must be returned when it is no longer needed.
			 */
			Rent(minimumLength: number): T[];

			Return(array: T[] | undefined): void;
		}
	}

	export namespace Newtonsoft.Json {
		/** Provides an interface to enable a class to return line and position information. */
		export interface IJsonLineInfo {
			/** Gets the current line number. */
			readonly LineNumber: number;

			/** Gets the current line position. */
			readonly LinePosition: number;

			/** Gets a value indicating whether the class can return line information. */
			HasLineInfo(): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Instructs the {@link Newtonsoft.Json.JsonSerializer} how to serialize the collection.
		 */
		export class JsonArrayAttribute extends Newtonsoft.Json.JsonContainerAttribute {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonArrayAttribute} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonObjectAttribute} class
			 * with a flag indicating whether the array can contain null items.
			 */
			constructor(allowNullItems: boolean);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonArrayAttribute} class
			 * with the specified container Id.
			 */
			constructor(id: string);

			/** Gets or sets a value indicating whether null items are allowed in the collection. */
			AllowNullItems: boolean;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Instructs the {@link Newtonsoft.Json.JsonSerializer} to use the specified constructor
		 * when deserializing that object.
		 */
		export class JsonConstructorAttribute extends System.Attribute {
			constructor();
		}
	}

	export namespace Newtonsoft.Json {
		/** Instructs the {@link Newtonsoft.Json.JsonSerializer} how to serialize the object. */
		export class JsonContainerAttribute extends System.Attribute {
			/** Gets or sets the id. */
			Id?: string;

			/** Gets or sets the title. */
			Title?: string;

			/** Gets or sets the description. */
			Description?: string;

			/** Gets or sets the collection's items converter. */
			ItemConverterType?: System.Type;

			/**
			 * The parameter list to use when constructing the {@link Newtonsoft.Json.JsonConverter}
			 * described by {@link Newtonsoft.Json.JsonContainerAttribute.ItemConverterType}. If null
			 * , the default constructor is used. When non- null , there must be a constructor
			 * defined in the {@link Newtonsoft.Json.JsonConverter} that exactly matches the number,
			 * order, and type of these parameters.
			 */
			ItemConverterParameters?: System.Object[];

			/**
			 * Gets or sets the {@link System.Type} of the
			 * {@link Newtonsoft.Json.Serialization.NamingStrategy}.
			 */
			NamingStrategyType?: System.Type;

			/**
			 * The parameter list to use when constructing the
			 * {@link Newtonsoft.Json.Serialization.NamingStrategy} described by
			 * {@link Newtonsoft.Json.JsonContainerAttribute.NamingStrategyType}. If null , the
			 * default constructor is used. When non- null , there must be a constructor defined in
			 * the {@link Newtonsoft.Json.Serialization.NamingStrategy} that exactly matches the
			 * number, order, and type of these parameters.
			 */
			NamingStrategyParameters?: System.Object[];

			/** Gets or sets a value that indicates whether to preserve object references. */
			IsReference: boolean;

			/**
			 * Gets or sets a value that indicates whether to preserve collection's items references.
			 */
			ItemIsReference: boolean;

			/**
			 * Gets or sets the reference loop handling used when serializing the collection's items.
			 */
			ItemReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			/** Gets or sets the type name handling used when serializing the collection's items. */
			ItemTypeNameHandling: Newtonsoft.Json.TypeNameHandling;
		}
	}

	export namespace Newtonsoft.Json {
		/** Provides methods for converting between .NET types and JSON types. */
		export namespace JsonConvert {
			/**
			 * Gets or sets a function that creates default
			 * {@link Newtonsoft.Json.JsonSerializerSettings}. Default settings are automatically
			 * used by serialization methods on {@link Newtonsoft.Json.JsonConvert}, and
			 * {@link Newtonsoft.Json.Linq.JToken.ToObject`<>} and
			 * {@link Newtonsoft.Json.Linq.JToken.FromObject(System.Object)} on
			 * {@link Newtonsoft.Json.Linq.JToken}. To serialize without using any default settings
			 * create a {@link Newtonsoft.Json.JsonSerializer} with
			 * {@link Newtonsoft.Json.JsonSerializer.Create}.
			 */
			export var DefaultSettings: System.Func$1<Newtonsoft.Json.JsonSerializerSettings> | undefined;

			/** Converts the {@link System.DateTime} to its JSON string representation. */
			export function ToString(value: DateTime): string;

			/**
			 * Converts the {@link System.DateTime} to its JSON string representation using the
			 * {@link Newtonsoft.Json.DateFormatHandling} specified.
			 */
			export function ToString(
				value: DateTime,
				format: Newtonsoft.Json.DateFormatHandling,
				timeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling,
			): string;

			/** Converts the {@link System.DateTimeOffset} to its JSON string representation. */
			export function ToString(value: DateTimeOffset): string;

			/**
			 * Converts the {@link System.DateTimeOffset} to its JSON string representation using the
			 * {@link Newtonsoft.Json.DateFormatHandling} specified.
			 */
			export function ToString(
				value: DateTimeOffset,
				format: Newtonsoft.Json.DateFormatHandling,
			): string;

			/** Converts the {@link System.Boolean} to its JSON string representation. */
			export function ToString(value: boolean): string;

			/** Converts the {@link System.Char} to its JSON string representation. */
			export function ToString(value: System.Char): string;

			/** Converts the {@link System.Enum} to its JSON string representation. */
			export function ToString(value: System.Enum): string;

			/** Converts the {@link System.Int32} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.Int16} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.UInt16} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.UInt32} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.Int64} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.UInt64} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.Single} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.Double} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.Byte} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.SByte} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.Decimal} to its JSON string representation. */
			export function ToString(value: System.Decimal): string;

			/** Converts the {@link System.Guid} to its JSON string representation. */
			export function ToString(value: string): string;

			/** Converts the {@link System.TimeSpan} to its JSON string representation. */
			export function ToString(value: number): string;

			/** Converts the {@link System.Uri} to its JSON string representation. */
			export function ToString(value: System.Uri | undefined): string;

			/** Converts the {@link System.String} to its JSON string representation. */
			export function ToString(value: string | undefined): string;

			/** Converts the {@link System.String} to its JSON string representation. */
			export function ToString(
				value: string | undefined,
				delimiter: System.Char,
			): string;

			/** Converts the {@link System.String} to its JSON string representation. */
			export function ToString(
				value: string | undefined,
				delimiter: System.Char,
				stringEscapeHandling: Newtonsoft.Json.StringEscapeHandling,
			): string;

			/** Converts the {@link System.Object} to its JSON string representation. */
			export function ToString(value: System.Object | undefined): string;

			/** Serializes the specified object to a JSON string. */
			export function SerializeObject(value: System.Object | undefined): string;

			/** Serializes the specified object to a JSON string using formatting. */
			export function SerializeObject(
				value: System.Object | undefined,
				formatting: Newtonsoft.Json.Formatting,
			): string;

			/**
			 * Serializes the specified object to a JSON string using a collection of
			 * {@link Newtonsoft.Json.JsonConverter}.
			 */
			export function SerializeObject(
				value: System.Object | undefined,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			/**
			 * Serializes the specified object to a JSON string using formatting and a collection of
			 * {@link Newtonsoft.Json.JsonConverter}.
			 */
			export function SerializeObject(
				value: System.Object | undefined,
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			/**
			 * Serializes the specified object to a JSON string using
			 * {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			export function SerializeObject(
				value: System.Object | undefined,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): string;

			/**
			 * Serializes the specified object to a JSON string using a type, formatting and
			 * {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			export function SerializeObject(
				value: System.Object | undefined,
				type: System.Type | undefined,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): string;

			/**
			 * Serializes the specified object to a JSON string using formatting and
			 * {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			export function SerializeObject(
				value: System.Object | undefined,
				formatting: Newtonsoft.Json.Formatting,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): string;

			/**
			 * Serializes the specified object to a JSON string using a type, formatting and
			 * {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			export function SerializeObject(
				value: System.Object | undefined,
				type: System.Type | undefined,
				formatting: Newtonsoft.Json.Formatting,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): string;

			/** Deserializes the JSON to a .NET object. */
			export function DeserializeObject(value: string): System.Object | undefined;

			/**
			 * Deserializes the JSON to a .NET object using
			 * {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			export function DeserializeObject(
				value: string,
				settings: Newtonsoft.Json.JsonSerializerSettings,
			): System.Object | undefined;

			/** Deserializes the JSON to the specified .NET type. */
			export function DeserializeObject(
				value: string,
				type: System.Type,
			): System.Object | undefined;

			/** Deserializes the JSON to the specified .NET type. */
			export function DeserializeObject<T>(value: string): T;

			/** Deserializes the JSON to the given anonymous type. */
			export function DeserializeAnonymousType<T>(
				value: string,
				anonymousTypeObject: T,
			): T;

			/**
			 * Deserializes the JSON to the given anonymous type using
			 * {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			export function DeserializeAnonymousType<T>(
				value: string,
				anonymousTypeObject: T,
				settings: Newtonsoft.Json.JsonSerializerSettings,
			): T;

			/**
			 * Deserializes the JSON to the specified .NET type using a collection of
			 * {@link Newtonsoft.Json.JsonConverter}.
			 */
			export function DeserializeObject<T>(
				value: string,
				converters: Newtonsoft.Json.JsonConverter[],
			): T;

			/**
			 * Deserializes the JSON to the specified .NET type using
			 * {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			export function DeserializeObject<T>(
				value: string,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): T;

			/**
			 * Deserializes the JSON to the specified .NET type using a collection of
			 * {@link Newtonsoft.Json.JsonConverter}.
			 */
			export function DeserializeObject(
				value: string,
				type: System.Type,
				converters: Newtonsoft.Json.JsonConverter[],
			): System.Object | undefined;

			/**
			 * Deserializes the JSON to the specified .NET type using
			 * {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			export function DeserializeObject(
				value: string,
				type: System.Type | undefined,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): System.Object | undefined;

			/** Populates the object with values from the JSON string. */
			export function PopulateObject(
				value: string,
				target: System.Object,
			): void;

			/**
			 * Populates the object with values from the JSON string using
			 * {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			export function PopulateObject(
				value: string,
				target: System.Object,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): void;

			/** Serializes the {@link System.Xml.XmlNode} to a JSON string. */
			export function SerializeXmlNode(node: unknown | undefined): string;

			/** Serializes the {@link System.Xml.XmlNode} to a JSON string using formatting. */
			export function SerializeXmlNode(
				node: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
			): string;

			/**
			 * Serializes the {@link System.Xml.XmlNode} to a JSON string using formatting and omits
			 * the root object if `omitRootObject` is true .
			 */
			export function SerializeXmlNode(
				node: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
				omitRootObject: boolean,
			): string;

			/** Deserializes the {@link System.Xml.XmlNode} from a JSON string. */
			export function DeserializeXmlNode(value: string): unknown | undefined;

			/**
			 * Deserializes the {@link System.Xml.XmlNode} from a JSON string nested in a root
			 * element specified by `deserializeRootElementName`.
			 */
			export function DeserializeXmlNode(
				value: string,
				deserializeRootElementName: string | undefined,
			): unknown | undefined;

			/**
			 * Deserializes the {@link System.Xml.XmlNode} from a JSON string nested in a root
			 * element specified by `deserializeRootElementName` and writes a Json.NET array
			 * attribute for collections.
			 */
			export function DeserializeXmlNode(
				value: string,
				deserializeRootElementName: string | undefined,
				writeArrayAttribute: boolean,
			): unknown | undefined;

			/**
			 * Deserializes the {@link System.Xml.XmlNode} from a JSON string nested in a root
			 * element specified by `deserializeRootElementName`, writes a Json.NET array attribute
			 * for collections, and encodes special characters.
			 */
			export function DeserializeXmlNode(
				value: string,
				deserializeRootElementName: string | undefined,
				writeArrayAttribute: boolean,
				encodeSpecialCharacters: boolean,
			): unknown | undefined;

			/** Serializes the {@link System.Xml.Linq.XNode} to a JSON string. */
			export function SerializeXNode(node: unknown | undefined): string;

			/** Serializes the {@link System.Xml.Linq.XNode} to a JSON string using formatting. */
			export function SerializeXNode(
				node: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
			): string;

			/**
			 * Serializes the {@link System.Xml.Linq.XNode} to a JSON string using formatting and
			 * omits the root object if `omitRootObject` is true .
			 */
			export function SerializeXNode(
				node: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
				omitRootObject: boolean,
			): string;

			/** Deserializes the {@link System.Xml.Linq.XNode} from a JSON string. */
			export function DeserializeXNode(value: string): unknown | undefined;

			/**
			 * Deserializes the {@link System.Xml.Linq.XNode} from a JSON string nested in a root
			 * element specified by `deserializeRootElementName`.
			 */
			export function DeserializeXNode(
				value: string,
				deserializeRootElementName: string | undefined,
			): unknown | undefined;

			/**
			 * Deserializes the {@link System.Xml.Linq.XNode} from a JSON string nested in a root
			 * element specified by `deserializeRootElementName` and writes a Json.NET array
			 * attribute for collections.
			 */
			export function DeserializeXNode(
				value: string,
				deserializeRootElementName: string | undefined,
				writeArrayAttribute: boolean,
			): unknown | undefined;

			/**
			 * Deserializes the {@link System.Xml.Linq.XNode} from a JSON string nested in a root
			 * element specified by `deserializeRootElementName`, writes a Json.NET array attribute
			 * for collections, and encodes special characters.
			 */
			export function DeserializeXNode(
				value: string,
				deserializeRootElementName: string | undefined,
				writeArrayAttribute: boolean,
				encodeSpecialCharacters: boolean,
			): unknown | undefined;
		}
	}

	export namespace Newtonsoft.Json {
		/** Converts an object to and from JSON. */
		export class JsonConverter {
			/**
			 * Gets a value indicating whether this {@link Newtonsoft.Json.JsonConverter} can read
			 * JSON.
			 */
			readonly CanRead: boolean;

			/**
			 * Gets a value indicating whether this {@link Newtonsoft.Json.JsonConverter} can write
			 * JSON.
			 */
			readonly CanWrite: boolean;

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		/** [Generic type factory] Converts an object to and from JSON. */
		export function JsonConverter$(T: IType): typeof JsonConverter$1<any>;

		/** Converts an object to and from JSON. */
		export class JsonConverter$1<T> extends Newtonsoft.Json.JsonConverter {
			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: T,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: T,
				hasExistingValue: boolean,
				serializer: Newtonsoft.Json.JsonSerializer,
			): T;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Instructs the {@link Newtonsoft.Json.JsonSerializer} to use the specified
		 * {@link Newtonsoft.Json.JsonConverter} when serializing the member or class.
		 */
		export class JsonConverterAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonConverterAttribute}
			 * class.
			 */
			constructor(converterType: System.Type);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonConverterAttribute}
			 * class.
			 */
			constructor(
				converterType: System.Type,
				converterParameters: System.Object[],
			);

			/** Gets the {@link System.Type} of the {@link Newtonsoft.Json.JsonConverter}. */
			readonly ConverterType: System.Type;

			/**
			 * The parameter list to use when constructing the {@link Newtonsoft.Json.JsonConverter}
			 * described by {@link Newtonsoft.Json.JsonConverterAttribute.ConverterType}. If null ,
			 * the default constructor is used.
			 */
			readonly ConverterParameters?: System.Object[];
		}
	}

	export namespace Newtonsoft.Json {
		/** Represents a collection of {@link Newtonsoft.Json.JsonConverter}. */
		export class JsonConverterCollection extends System.Collections.ObjectModel.Collection$1<Newtonsoft.Json.JsonConverter> {
			constructor();
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Instructs the {@link Newtonsoft.Json.JsonSerializer} how to serialize the collection.
		 */
		export class JsonDictionaryAttribute extends Newtonsoft.Json.JsonContainerAttribute {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonDictionaryAttribute}
			 * class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonDictionaryAttribute}
			 * class with the specified container Id.
			 */
			constructor(id: string);
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * The exception thrown when an error occurs during JSON serialization or
		 * deserialization.
		 */
		export class JsonException extends System.Exception {
			/** Initializes a new instance of the {@link Newtonsoft.Json.JsonException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonException} class with a
			 * specified error message.
			 */
			constructor(message: string);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Instructs the {@link Newtonsoft.Json.JsonSerializer} to deserialize properties with no
		 * matching class member into the specified collection and write values during
		 * serialization.
		 */
		export class JsonExtensionDataAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonExtensionDataAttribute}
			 * class.
			 */
			constructor();

			/**
			 * Gets or sets a value that indicates whether to write extension data when serializing
			 * the object.
			 */
			WriteData: boolean;

			/**
			 * Gets or sets a value that indicates whether to read extension data when deserializing
			 * the object.
			 */
			ReadData: boolean;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Instructs the {@link Newtonsoft.Json.JsonSerializer} not to serialize the public field
		 * or public read/write property value.
		 */
		export class JsonIgnoreAttribute extends System.Attribute {
			constructor();
		}
	}

	export namespace Newtonsoft.Json {
		/** Base class for a table of atomized string objects. */
		export class JsonNameTable {
			/**
			 * Gets a string containing the same characters as the specified range of characters in
			 * the given array.
			 */
			Get(
				key: System.Char[],
				start: number,
				length: number,
			): string | undefined;
		}
	}

	export namespace Newtonsoft.Json {
		/** Instructs the {@link Newtonsoft.Json.JsonSerializer} how to serialize the object. */
		export class JsonObjectAttribute extends Newtonsoft.Json.JsonContainerAttribute {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonObjectAttribute} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonObjectAttribute} class
			 * with the specified member serialization.
			 */
			constructor(memberSerialization: Newtonsoft.Json.MemberSerialization);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonObjectAttribute} class
			 * with the specified container Id.
			 */
			constructor(id: string);

			/** Gets or sets the member serialization. */
			MemberSerialization: Newtonsoft.Json.MemberSerialization;

			/** Gets or sets the missing member handling used when deserializing this object. */
			MissingMemberHandling: Newtonsoft.Json.MissingMemberHandling;

			/**
			 * Gets or sets how the object's properties with null values are handled during
			 * serialization and deserialization.
			 */
			ItemNullValueHandling: Newtonsoft.Json.NullValueHandling;

			/** Gets or sets a value that indicates whether the object's properties are required. */
			ItemRequired: Newtonsoft.Json.Required;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Instructs the {@link Newtonsoft.Json.JsonSerializer} to always serialize the member
		 * with the specified name.
		 */
		export class JsonPropertyAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonPropertyAttribute} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonPropertyAttribute} class
			 * with the specified name.
			 */
			constructor(propertyName: string);

			/**
			 * Gets or sets the {@link Newtonsoft.Json.JsonConverter} type used when serializing the
			 * property's collection items.
			 */
			ItemConverterType?: System.Type;

			/**
			 * The parameter list to use when constructing the {@link Newtonsoft.Json.JsonConverter}
			 * described by {@link Newtonsoft.Json.JsonPropertyAttribute.ItemConverterType}. If null
			 * , the default constructor is used. When non- null , there must be a constructor
			 * defined in the {@link Newtonsoft.Json.JsonConverter} that exactly matches the number,
			 * order, and type of these parameters.
			 */
			ItemConverterParameters?: System.Object[];

			/**
			 * Gets or sets the {@link System.Type} of the
			 * {@link Newtonsoft.Json.Serialization.NamingStrategy}.
			 */
			NamingStrategyType?: System.Type;

			/**
			 * The parameter list to use when constructing the
			 * {@link Newtonsoft.Json.Serialization.NamingStrategy} described by
			 * {@link Newtonsoft.Json.JsonPropertyAttribute.NamingStrategyType}. If null , the
			 * default constructor is used. When non- null , there must be a constructor defined in
			 * the {@link Newtonsoft.Json.Serialization.NamingStrategy} that exactly matches the
			 * number, order, and type of these parameters.
			 */
			NamingStrategyParameters?: System.Object[];

			/** Gets or sets the null value handling used when serializing this property. */
			NullValueHandling: Newtonsoft.Json.NullValueHandling;

			/** Gets or sets the default value handling used when serializing this property. */
			DefaultValueHandling: Newtonsoft.Json.DefaultValueHandling;

			/** Gets or sets the reference loop handling used when serializing this property. */
			ReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			/** Gets or sets the object creation handling used when deserializing this property. */
			ObjectCreationHandling: Newtonsoft.Json.ObjectCreationHandling;

			/** Gets or sets the type name handling used when serializing this property. */
			TypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			/** Gets or sets whether this property's value is serialized as a reference. */
			IsReference: boolean;

			/** Gets or sets the order of serialization of a member. */
			Order: number;

			/** Gets or sets a value indicating whether this property is required. */
			Required: Newtonsoft.Json.Required;

			/** Gets or sets the name of the property. */
			PropertyName?: string;

			/**
			 * Gets or sets the reference loop handling used when serializing the property's
			 * collection items.
			 */
			ItemReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			/**
			 * Gets or sets the type name handling used when serializing the property's collection
			 * items.
			 */
			ItemTypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			/**
			 * Gets or sets whether this property's collection items are serialized as a reference.
			 */
			ItemIsReference: boolean;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Represents a reader that provides fast, non-cached, forward-only access to serialized
		 * JSON data.
		 */
		export class JsonReader {
			/**
			 * Gets or sets a value indicating whether the source should be closed when this reader
			 * is closed.
			 */
			CloseInput: boolean;

			/**
			 * Gets or sets a value indicating whether multiple pieces of JSON content can be read
			 * from a continuous stream without erroring.
			 */
			SupportMultipleContent: boolean;

			/** Gets the quotation mark character used to enclose the value of a string. */
			QuoteChar: System.Char;

			/** Gets or sets how {@link System.DateTime} time zones are handled when reading JSON. */
			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			/**
			 * Gets or sets how date formatted strings, e.g. "\/Date(1198908717056)\/" and
			 * "2012-03-21T05:40Z", are parsed when reading JSON.
			 */
			DateParseHandling: Newtonsoft.Json.DateParseHandling;

			/**
			 * Gets or sets how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading
			 * JSON text.
			 */
			FloatParseHandling: Newtonsoft.Json.FloatParseHandling;

			/** Gets or sets how custom date formatted strings are parsed when reading JSON. */
			DateFormatString?: string;

			/**
			 * Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will
			 * throw a {@link Newtonsoft.Json.JsonReaderException}. A null value means there is no
			 * maximum.  The default value is 64 .
			 */
			MaxDepth?: number;

			/** Gets the type of the current JSON token. */
			readonly TokenType: Newtonsoft.Json.JsonToken;

			/** Gets the text value of the current JSON token. */
			readonly Value?: System.Object;

			/** Gets the .NET type for the current JSON token. */
			readonly ValueType?: System.Type;

			/** Gets the depth of the current token in the JSON document. */
			readonly Depth: number;

			/** Gets the path of the current JSON token. */
			readonly Path: string;

			/**
			 * Gets or sets the culture used when reading JSON. Defaults to
			 * {@link System.Globalization.CultureInfo.InvariantCulture}.
			 */
			Culture: System.Globalization.CultureInfo;

			/**
			 * Asynchronously reads the next JSON token from the source.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			ReadAsync(cancellationToken?: AbortSignal): Promise<boolean>;

			/**
			 * Asynchronously skips the children of the current token.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			SkipAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.Boolean}.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			ReadAsBooleanAsync(cancellationToken?: AbortSignal): Promise<boolean | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a {@link System.Byte} [].
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			ReadAsBytesAsync(cancellationToken?: AbortSignal): Promise<number[] | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.DateTime}.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			ReadAsDateTimeAsync(cancellationToken?: AbortSignal): Promise<DateTime | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.DateTimeOffset}.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			ReadAsDateTimeOffsetAsync(cancellationToken?: AbortSignal): Promise<DateTimeOffset | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.Decimal}.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			ReadAsDecimalAsync(cancellationToken?: AbortSignal): Promise<System.Decimal | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.Double}.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			ReadAsDoubleAsync(cancellationToken?: AbortSignal): Promise<number | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.Int32}.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			ReadAsInt32Async(cancellationToken?: AbortSignal): Promise<number | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a {@link System.String}.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			ReadAsStringAsync(cancellationToken?: AbortSignal): Promise<string | undefined>;

			/** Reads the next JSON token from the source. */
			Read(): boolean;

			/**
			 * Reads the next JSON token from the source as a {@link System.Nullable<>} of
			 * {@link System.Int32}.
			 */
			ReadAsInt32(): number | undefined;

			/** Reads the next JSON token from the source as a {@link System.String}. */
			ReadAsString(): string | undefined;

			/** Reads the next JSON token from the source as a {@link System.Byte} []. */
			ReadAsBytes(): number[] | undefined;

			/**
			 * Reads the next JSON token from the source as a {@link System.Nullable<>} of
			 * {@link System.Double}.
			 */
			ReadAsDouble(): number | undefined;

			/**
			 * Reads the next JSON token from the source as a {@link System.Nullable<>} of
			 * {@link System.Boolean}.
			 */
			ReadAsBoolean(): boolean | undefined;

			/**
			 * Reads the next JSON token from the source as a {@link System.Nullable<>} of
			 * {@link System.Decimal}.
			 */
			ReadAsDecimal(): System.Decimal | undefined;

			/**
			 * Reads the next JSON token from the source as a {@link System.Nullable<>} of
			 * {@link System.DateTime}.
			 */
			ReadAsDateTime(): DateTime | undefined;

			/**
			 * Reads the next JSON token from the source as a {@link System.Nullable<>} of
			 * {@link System.DateTimeOffset}.
			 */
			ReadAsDateTimeOffset(): DateTimeOffset | undefined;

			/** Skips the children of the current token. */
			Skip(): void;

			/**
			 * Changes the reader's state to {@link Newtonsoft.Json.JsonReader.State.Closed}. If
			 * {@link Newtonsoft.Json.JsonReader.CloseInput} is set to true , the source is also
			 * closed.
			 */
			Close(): void;
		}
	}

	export namespace Newtonsoft.Json {
		/** The exception thrown when an error occurs while reading JSON text. */
		export class JsonReaderException extends Newtonsoft.Json.JsonException {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonReaderException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonReaderException} class
			 * with a specified error message.
			 */
			constructor(message: string);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonReaderException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string,
				innerException: System.Exception,
			);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonReaderException} class
			 * with a specified error message, JSON path, line number, line position, and a reference
			 * to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string,
				path: string,
				lineNumber: number,
				linePosition: number,
				innerException: System.Exception | undefined,
			);

			/** Gets the line number indicating where the error occurred. */
			readonly LineNumber: number;

			/** Gets the line position indicating where the error occurred. */
			readonly LinePosition: number;

			/** Gets the path to the JSON where the error occurred. */
			readonly Path?: string;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Instructs the {@link Newtonsoft.Json.JsonSerializer} to always serialize the member,
		 * and to require that the member has a value.
		 */
		export class JsonRequiredAttribute extends System.Attribute {
			constructor();
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * The exception thrown when an error occurs during JSON serialization or
		 * deserialization.
		 */
		export class JsonSerializationException extends Newtonsoft.Json.JsonException {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonSerializationException}
			 * class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonSerializationException}
			 * class with a specified error message.
			 */
			constructor(message: string);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonSerializationException}
			 * class with a specified error message and a reference to the inner exception that is
			 * the cause of this exception.
			 */
			constructor(
				message: string,
				innerException: System.Exception,
			);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonSerializationException}
			 * class with a specified error message, JSON path, line number, line position, and a
			 * reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string,
				path: string,
				lineNumber: number,
				linePosition: number,
				innerException: System.Exception | undefined,
			);

			/** Gets the line number indicating where the error occurred. */
			readonly LineNumber: number;

			/** Gets the line position indicating where the error occurred. */
			readonly LinePosition: number;

			/** Gets the path to the JSON where the error occurred. */
			readonly Path?: string;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Serializes and deserializes objects into and from the JSON format. The
		 * {@link Newtonsoft.Json.JsonSerializer} enables you to control how objects are encoded
		 * into JSON.
		 */
		export class JsonSerializer {
			/** Initializes a new instance of the {@link Newtonsoft.Json.JsonSerializer} class. */
			constructor();

			/**
			 * Gets or sets the {@link Newtonsoft.Json.Serialization.IReferenceResolver} used by the
			 * serializer when resolving references.
			 */
			ReferenceResolver?: Newtonsoft.Json.Serialization.IReferenceResolver;

			/**
			 * Gets or sets the {@link Newtonsoft.Json.Serialization.ISerializationBinder} used by
			 * the serializer when resolving type names.
			 */
			SerializationBinder: Newtonsoft.Json.Serialization.ISerializationBinder;

			/**
			 * Gets or sets the {@link Newtonsoft.Json.Serialization.ITraceWriter} used by the
			 * serializer when writing trace messages.
			 */
			TraceWriter?: Newtonsoft.Json.Serialization.ITraceWriter;

			/**
			 * Gets or sets the equality comparer used by the serializer when comparing references.
			 */
			EqualityComparer?: System.Collections.IEqualityComparer;

			/**
			 * Gets or sets how type name writing and reading is handled by the serializer. The
			 * default value is {@link Newtonsoft.Json.TypeNameHandling.None}.
			 *
			 * {@link Newtonsoft.Json.JsonSerializer.TypeNameHandling} should be used with caution
			 * when your application deserializes JSON from an external source. Incoming types should
			 * be validated with a custom {@link Newtonsoft.Json.JsonSerializer.SerializationBinder}
			 * when deserializing with a value other than
			 * {@link Newtonsoft.Json.TypeNameHandling.None}.
			 */
			TypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			/**
			 * Gets or sets how a type name assembly is written and resolved by the serializer. The
			 * default value is
			 * {@link System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple}.
			 */
			TypeNameAssemblyFormat: unknown;

			/**
			 * Gets or sets how a type name assembly is written and resolved by the serializer. The
			 * default value is {@link Newtonsoft.Json.TypeNameAssemblyFormatHandling.Simple}.
			 */
			TypeNameAssemblyFormatHandling: Newtonsoft.Json.TypeNameAssemblyFormatHandling;

			/**
			 * Gets or sets how object references are preserved by the serializer. The default value
			 * is {@link Newtonsoft.Json.PreserveReferencesHandling.None}.
			 */
			PreserveReferencesHandling: Newtonsoft.Json.PreserveReferencesHandling;

			/**
			 * Gets or sets how reference loops (e.g. a class referencing itself) is handled. The
			 * default value is {@link Newtonsoft.Json.ReferenceLoopHandling.Error}.
			 */
			ReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			/**
			 * Gets or sets how missing members (e.g. JSON contains a property that isn't a member on
			 * the object) are handled during deserialization. The default value is
			 * {@link Newtonsoft.Json.MissingMemberHandling.Ignore}.
			 */
			MissingMemberHandling: Newtonsoft.Json.MissingMemberHandling;

			/**
			 * Gets or sets how null values are handled during serialization and deserialization. The
			 * default value is {@link Newtonsoft.Json.NullValueHandling.Include}.
			 */
			NullValueHandling: Newtonsoft.Json.NullValueHandling;

			/**
			 * Gets or sets how default values are handled during serialization and deserialization.
			 * The default value is {@link Newtonsoft.Json.DefaultValueHandling.Include}.
			 */
			DefaultValueHandling: Newtonsoft.Json.DefaultValueHandling;

			/**
			 * Gets or sets how objects are created during deserialization. The default value is
			 * {@link Newtonsoft.Json.ObjectCreationHandling.Auto}.
			 */
			ObjectCreationHandling: Newtonsoft.Json.ObjectCreationHandling;

			/**
			 * Gets or sets how constructors are used during deserialization. The default value is
			 * {@link Newtonsoft.Json.ConstructorHandling.Default}.
			 */
			ConstructorHandling: Newtonsoft.Json.ConstructorHandling;

			/**
			 * Gets or sets how metadata properties are used during deserialization. The default
			 * value is {@link Newtonsoft.Json.MetadataPropertyHandling.Default}.
			 */
			MetadataPropertyHandling: Newtonsoft.Json.MetadataPropertyHandling;

			/**
			 * Gets a collection {@link Newtonsoft.Json.JsonConverter} that will be used during
			 * serialization.
			 */
			readonly Converters: Newtonsoft.Json.JsonConverterCollection;

			/**
			 * Gets or sets the contract resolver used by the serializer when serializing .NET
			 * objects to JSON and vice versa.
			 */
			ContractResolver: Newtonsoft.Json.Serialization.IContractResolver;

			/**
			 * Indicates how JSON text output is formatted. The default value is
			 * {@link Newtonsoft.Json.Formatting.None}.
			 */
			Formatting: Newtonsoft.Json.Formatting;

			/**
			 * Gets or sets how dates are written to JSON text. The default value is
			 * {@link Newtonsoft.Json.DateFormatHandling.IsoDateFormat}.
			 */
			DateFormatHandling: Newtonsoft.Json.DateFormatHandling;

			/**
			 * Gets or sets how {@link System.DateTime} time zones are handled during serialization
			 * and deserialization. The default value is
			 * {@link Newtonsoft.Json.DateTimeZoneHandling.RoundtripKind}.
			 */
			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			/**
			 * Gets or sets how date formatted strings, e.g. "\/Date(1198908717056)\/" and
			 * "2012-03-21T05:40Z" , are parsed when reading JSON. The default value is
			 * {@link Newtonsoft.Json.DateParseHandling.DateTime}.
			 */
			DateParseHandling: Newtonsoft.Json.DateParseHandling;

			/**
			 * Gets or sets how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading
			 * JSON text. The default value is {@link Newtonsoft.Json.FloatParseHandling.Double}.
			 */
			FloatParseHandling: Newtonsoft.Json.FloatParseHandling;

			/**
			 * Gets or sets how special floating point numbers, e.g. {@link System.Double.NaN},
			 * {@link System.Double.PositiveInfinity} and {@link System.Double.NegativeInfinity}, are
			 * written as JSON text. The default value is
			 * {@link Newtonsoft.Json.FloatFormatHandling.String}.
			 */
			FloatFormatHandling: Newtonsoft.Json.FloatFormatHandling;

			/**
			 * Gets or sets how strings are escaped when writing JSON text. The default value is
			 * {@link Newtonsoft.Json.StringEscapeHandling.Default}.
			 */
			StringEscapeHandling: Newtonsoft.Json.StringEscapeHandling;

			/**
			 * Gets or sets how {@link System.DateTime} and {@link System.DateTimeOffset} values are
			 * formatted when writing JSON text, and the expected date format when reading JSON text.
			 * The default value is "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK" .
			 */
			DateFormatString: string;

			/**
			 * Gets or sets the culture used when reading JSON. The default value is
			 * {@link System.Globalization.CultureInfo.InvariantCulture}.
			 */
			Culture: System.Globalization.CultureInfo;

			/**
			 * Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will
			 * throw a {@link Newtonsoft.Json.JsonReaderException}. A null value means there is no
			 * maximum. The default value is 64 .
			 */
			MaxDepth?: number;

			/**
			 * Gets a value indicating whether there will be a check for additional JSON content
			 * after deserializing an object. The default value is false .
			 */
			CheckAdditionalContent: boolean;

			/**
			 * Creates a new {@link Newtonsoft.Json.JsonSerializer} instance. The
			 * {@link Newtonsoft.Json.JsonSerializer} will not use default settings  from
			 * {@link Newtonsoft.Json.JsonConvert.DefaultSettings}.
			 */
			static Create(): Newtonsoft.Json.JsonSerializer;

			/**
			 * Creates a new {@link Newtonsoft.Json.JsonSerializer} instance using the specified
			 * {@link Newtonsoft.Json.JsonSerializerSettings}. The
			 * {@link Newtonsoft.Json.JsonSerializer} will not use default settings  from
			 * {@link Newtonsoft.Json.JsonConvert.DefaultSettings}.
			 */
			static Create(settings: Newtonsoft.Json.JsonSerializerSettings | undefined): Newtonsoft.Json.JsonSerializer;

			/**
			 * Creates a new {@link Newtonsoft.Json.JsonSerializer} instance. The
			 * {@link Newtonsoft.Json.JsonSerializer} will use default settings  from
			 * {@link Newtonsoft.Json.JsonConvert.DefaultSettings}.
			 */
			static CreateDefault(): Newtonsoft.Json.JsonSerializer;

			/**
			 * Creates a new {@link Newtonsoft.Json.JsonSerializer} instance using the specified
			 * {@link Newtonsoft.Json.JsonSerializerSettings}. The
			 * {@link Newtonsoft.Json.JsonSerializer} will use default settings  from
			 * {@link Newtonsoft.Json.JsonConvert.DefaultSettings} as well as the specified
			 * {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			static CreateDefault(settings: Newtonsoft.Json.JsonSerializerSettings | undefined): Newtonsoft.Json.JsonSerializer;

			/** Populates the JSON values onto the target object. */
			Populate(
				reader: System.IO.TextReader,
				target: System.Object,
			): void;

			/** Populates the JSON values onto the target object. */
			Populate(
				reader: Newtonsoft.Json.JsonReader,
				target: System.Object,
			): void;

			/**
			 * Deserializes the JSON structure contained by the specified
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			Deserialize(reader: Newtonsoft.Json.JsonReader): System.Object | undefined;

			/**
			 * Deserializes the JSON structure contained by the specified
			 * {@link System.IO.TextReader} into an instance of the specified type.
			 */
			Deserialize(
				reader: System.IO.TextReader,
				objectType: System.Type,
			): System.Object | undefined;

			/**
			 * Deserializes the JSON structure contained by the specified
			 * {@link Newtonsoft.Json.JsonReader} into an instance of the specified type.
			 */
			Deserialize<T>(reader: Newtonsoft.Json.JsonReader): T;

			/**
			 * Deserializes the JSON structure contained by the specified
			 * {@link Newtonsoft.Json.JsonReader} into an instance of the specified type.
			 */
			Deserialize(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type | undefined,
			): System.Object | undefined;

			/**
			 * Serializes the specified {@link System.Object} and writes the JSON structure using the
			 * specified {@link System.IO.TextWriter}.
			 */
			Serialize(
				textWriter: System.IO.TextWriter,
				value: System.Object | undefined,
			): void;

			/**
			 * Serializes the specified {@link System.Object} and writes the JSON structure using the
			 * specified {@link Newtonsoft.Json.JsonWriter}.
			 */
			Serialize(
				jsonWriter: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				objectType: System.Type | undefined,
			): void;

			/**
			 * Serializes the specified {@link System.Object} and writes the JSON structure using the
			 * specified {@link System.IO.TextWriter}.
			 */
			Serialize(
				textWriter: System.IO.TextWriter,
				value: System.Object | undefined,
				objectType: System.Type,
			): void;

			/**
			 * Serializes the specified {@link System.Object} and writes the JSON structure using the
			 * specified {@link Newtonsoft.Json.JsonWriter}.
			 */
			Serialize(
				jsonWriter: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
			): void;
		}
	}

	export namespace Newtonsoft.Json {
		/** Specifies the settings on a {@link Newtonsoft.Json.JsonSerializer} object. */
		export class JsonSerializerSettings {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonSerializerSettings}
			 * class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonSerializerSettings} class
			 * using values copied from the passed in {@link Newtonsoft.Json.JsonSerializerSettings}.
			 */
			constructor(original: Newtonsoft.Json.JsonSerializerSettings);

			/**
			 * Gets or sets how reference loops (e.g. a class referencing itself) are handled. The
			 * default value is {@link Newtonsoft.Json.ReferenceLoopHandling.Error}.
			 */
			ReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			/**
			 * Gets or sets how missing members (e.g. JSON contains a property that isn't a member on
			 * the object) are handled during deserialization. The default value is
			 * {@link Newtonsoft.Json.MissingMemberHandling.Ignore}.
			 */
			MissingMemberHandling: Newtonsoft.Json.MissingMemberHandling;

			/**
			 * Gets or sets how objects are created during deserialization. The default value is
			 * {@link Newtonsoft.Json.ObjectCreationHandling.Auto}.
			 */
			ObjectCreationHandling: Newtonsoft.Json.ObjectCreationHandling;

			/**
			 * Gets or sets how null values are handled during serialization and deserialization. The
			 * default value is {@link Newtonsoft.Json.NullValueHandling.Include}.
			 */
			NullValueHandling: Newtonsoft.Json.NullValueHandling;

			/**
			 * Gets or sets how default values are handled during serialization and deserialization.
			 * The default value is {@link Newtonsoft.Json.DefaultValueHandling.Include}.
			 */
			DefaultValueHandling: Newtonsoft.Json.DefaultValueHandling;

			/**
			 * Gets or sets a {@link Newtonsoft.Json.JsonConverter} collection that will be used
			 * during serialization.
			 */
			Converters: Newtonsoft.Json.JsonConverter[];

			/**
			 * Gets or sets how object references are preserved by the serializer. The default value
			 * is {@link Newtonsoft.Json.PreserveReferencesHandling.None}.
			 */
			PreserveReferencesHandling: Newtonsoft.Json.PreserveReferencesHandling;

			/**
			 * Gets or sets how type name writing and reading is handled by the serializer. The
			 * default value is {@link Newtonsoft.Json.TypeNameHandling.None}.
			 *
			 * {@link Newtonsoft.Json.JsonSerializerSettings.TypeNameHandling} should be used with
			 * caution when your application deserializes JSON from an external source. Incoming
			 * types should be validated with a custom
			 * {@link Newtonsoft.Json.JsonSerializerSettings.SerializationBinder} when deserializing
			 * with a value other than {@link Newtonsoft.Json.TypeNameHandling.None}.
			 */
			TypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			/**
			 * Gets or sets how metadata properties are used during deserialization. The default
			 * value is {@link Newtonsoft.Json.MetadataPropertyHandling.Default}.
			 */
			MetadataPropertyHandling: Newtonsoft.Json.MetadataPropertyHandling;

			/**
			 * Gets or sets how a type name assembly is written and resolved by the serializer. The
			 * default value is
			 * {@link System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple}.
			 */
			TypeNameAssemblyFormat: unknown;

			/**
			 * Gets or sets how a type name assembly is written and resolved by the serializer. The
			 * default value is {@link Newtonsoft.Json.TypeNameAssemblyFormatHandling.Simple}.
			 */
			TypeNameAssemblyFormatHandling: Newtonsoft.Json.TypeNameAssemblyFormatHandling;

			/**
			 * Gets or sets how constructors are used during deserialization. The default value is
			 * {@link Newtonsoft.Json.ConstructorHandling.Default}.
			 */
			ConstructorHandling: Newtonsoft.Json.ConstructorHandling;

			/**
			 * Gets or sets the contract resolver used by the serializer when serializing .NET
			 * objects to JSON and vice versa.
			 */
			ContractResolver?: Newtonsoft.Json.Serialization.IContractResolver;

			/**
			 * Gets or sets the equality comparer used by the serializer when comparing references.
			 */
			EqualityComparer?: System.Collections.IEqualityComparer;

			/**
			 * Gets or sets the {@link Newtonsoft.Json.Serialization.IReferenceResolver} used by the
			 * serializer when resolving references.
			 */
			ReferenceResolver?: Newtonsoft.Json.Serialization.IReferenceResolver;

			/**
			 * Gets or sets a function that creates the
			 * {@link Newtonsoft.Json.Serialization.IReferenceResolver} used by the serializer when
			 * resolving references.
			 */
			ReferenceResolverProvider?: System.Func$1<Newtonsoft.Json.Serialization.IReferenceResolver | undefined>;

			/**
			 * Gets or sets the {@link Newtonsoft.Json.Serialization.ITraceWriter} used by the
			 * serializer when writing trace messages.
			 */
			TraceWriter?: Newtonsoft.Json.Serialization.ITraceWriter;

			/**
			 * Gets or sets the {@link Newtonsoft.Json.Serialization.ISerializationBinder} used by
			 * the serializer when resolving type names.
			 */
			SerializationBinder?: Newtonsoft.Json.Serialization.ISerializationBinder;

			/** Gets or sets the error handler called during serialization and deserialization. */
			Error?: System.EventHandler$1<Newtonsoft.Json.Serialization.ErrorEventArgs>;

			/**
			 * Gets or sets how {@link System.DateTime} and {@link System.DateTimeOffset} values are
			 * formatted when writing JSON text, and the expected date format when reading JSON text.
			 * The default value is "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK" .
			 */
			DateFormatString: string;

			/**
			 * Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will
			 * throw a {@link Newtonsoft.Json.JsonReaderException}. A null value means there is no
			 * maximum. The default value is 64 .
			 */
			MaxDepth?: number;

			/**
			 * Indicates how JSON text output is formatted. The default value is
			 * {@link Newtonsoft.Json.Formatting.None}.
			 */
			Formatting: Newtonsoft.Json.Formatting;

			/**
			 * Gets or sets how dates are written to JSON text. The default value is
			 * {@link Newtonsoft.Json.DateFormatHandling.IsoDateFormat}.
			 */
			DateFormatHandling: Newtonsoft.Json.DateFormatHandling;

			/**
			 * Gets or sets how {@link System.DateTime} time zones are handled during serialization
			 * and deserialization. The default value is
			 * {@link Newtonsoft.Json.DateTimeZoneHandling.RoundtripKind}.
			 */
			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			/**
			 * Gets or sets how date formatted strings, e.g. "\/Date(1198908717056)\/" and
			 * "2012-03-21T05:40Z" , are parsed when reading JSON. The default value is
			 * {@link Newtonsoft.Json.DateParseHandling.DateTime}.
			 */
			DateParseHandling: Newtonsoft.Json.DateParseHandling;

			/**
			 * Gets or sets how special floating point numbers, e.g. {@link System.Double.NaN},
			 * {@link System.Double.PositiveInfinity} and {@link System.Double.NegativeInfinity}, are
			 * written as JSON. The default value is
			 * {@link Newtonsoft.Json.FloatFormatHandling.String}.
			 */
			FloatFormatHandling: Newtonsoft.Json.FloatFormatHandling;

			/**
			 * Gets or sets how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading
			 * JSON text. The default value is {@link Newtonsoft.Json.FloatParseHandling.Double}.
			 */
			FloatParseHandling: Newtonsoft.Json.FloatParseHandling;

			/**
			 * Gets or sets how strings are escaped when writing JSON text. The default value is
			 * {@link Newtonsoft.Json.StringEscapeHandling.Default}.
			 */
			StringEscapeHandling: Newtonsoft.Json.StringEscapeHandling;

			/**
			 * Gets or sets the culture used when reading JSON. The default value is
			 * {@link System.Globalization.CultureInfo.InvariantCulture}.
			 */
			Culture: System.Globalization.CultureInfo;

			/**
			 * Gets a value indicating whether there will be a check for additional content after
			 * deserializing an object. The default value is false .
			 */
			CheckAdditionalContent: boolean;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Represents a reader that provides fast, non-cached, forward-only access to JSON text
		 * data.
		 */
		export class JsonTextReader extends Newtonsoft.Json.JsonReader implements Newtonsoft.Json.IJsonLineInfo {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonTextReader} class with
			 * the specified {@link System.IO.TextReader}.
			 */
			constructor(reader: System.IO.TextReader);

			/** Gets or sets the reader's property name table. */
			PropertyNameTable?: Newtonsoft.Json.JsonNameTable;

			/** Gets or sets the reader's character buffer pool. */
			ArrayPool?: Newtonsoft.Json.IArrayPool$1<System.Char>;

			/** Gets the current line number. */
			readonly LineNumber: number;

			/** Gets the current line position. */
			readonly LinePosition: number;

			/**
			 * Asynchronously reads the next JSON token from the source.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			ReadAsync(cancellationToken?: AbortSignal): Promise<boolean>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.Boolean}.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			ReadAsBooleanAsync(cancellationToken?: AbortSignal): Promise<boolean | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a {@link System.Byte} [].
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			ReadAsBytesAsync(cancellationToken?: AbortSignal): Promise<number[] | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.DateTime}.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			ReadAsDateTimeAsync(cancellationToken?: AbortSignal): Promise<DateTime | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.DateTimeOffset}.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			ReadAsDateTimeOffsetAsync(cancellationToken?: AbortSignal): Promise<DateTimeOffset | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.Decimal}.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			ReadAsDecimalAsync(cancellationToken?: AbortSignal): Promise<System.Decimal | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.Double}.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			ReadAsDoubleAsync(cancellationToken?: AbortSignal): Promise<number | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a
			 * {@link System.Nullable<>} of {@link System.Int32}.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			ReadAsInt32Async(cancellationToken?: AbortSignal): Promise<number | undefined>;

			/**
			 * Asynchronously reads the next JSON token from the source as a {@link System.String}.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			ReadAsStringAsync(cancellationToken?: AbortSignal): Promise<string | undefined>;

			/** Reads the next JSON token from the underlying {@link System.IO.TextReader}. */
			Read(): boolean;

			/**
			 * Reads the next JSON token from the underlying {@link System.IO.TextReader} as a
			 * {@link System.Nullable<>} of {@link System.Int32}.
			 */
			ReadAsInt32(): number | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link System.IO.TextReader} as a
			 * {@link System.Nullable<>} of {@link System.DateTime}.
			 */
			ReadAsDateTime(): DateTime | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link System.IO.TextReader} as a
			 * {@link System.String}.
			 */
			ReadAsString(): string | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link System.IO.TextReader} as a
			 * {@link System.Byte} [].
			 */
			ReadAsBytes(): number[] | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link System.IO.TextReader} as a
			 * {@link System.Nullable<>} of {@link System.Boolean}.
			 */
			ReadAsBoolean(): boolean | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link System.IO.TextReader} as a
			 * {@link System.Nullable<>} of {@link System.DateTimeOffset}.
			 */
			ReadAsDateTimeOffset(): DateTimeOffset | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link System.IO.TextReader} as a
			 * {@link System.Nullable<>} of {@link System.Decimal}.
			 */
			ReadAsDecimal(): System.Decimal | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link System.IO.TextReader} as a
			 * {@link System.Nullable<>} of {@link System.Double}.
			 */
			ReadAsDouble(): number | undefined;

			/**
			 * Changes the reader's state to {@link Newtonsoft.Json.JsonReader.State.Closed}. If
			 * {@link Newtonsoft.Json.JsonReader.CloseInput} is set to true , the underlying
			 * {@link System.IO.TextReader} is also closed.
			 */
			Close(): void;

			/** Gets a value indicating whether the class can return line information. */
			HasLineInfo(): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Represents a writer that provides a fast, non-cached, forward-only way of generating
		 * JSON data.
		 */
		export class JsonTextWriter extends Newtonsoft.Json.JsonWriter {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonTextWriter} class using
			 * the specified {@link System.IO.TextWriter}.
			 */
			constructor(textWriter: System.IO.TextWriter);

			/** Gets or sets the writer's character array pool. */
			ArrayPool?: Newtonsoft.Json.IArrayPool$1<System.Char>;

			/**
			 * Gets or sets how many {@link Newtonsoft.Json.JsonTextWriter.IndentChar} s to write for
			 * each level in the hierarchy when {@link Newtonsoft.Json.JsonWriter.Formatting} is set
			 * to {@link Newtonsoft.Json.Formatting.Indented}.
			 */
			Indentation: number;

			/** Gets or sets which character to use to quote attribute values. */
			QuoteChar: System.Char;

			/**
			 * Gets or sets which character to use for indenting when
			 * {@link Newtonsoft.Json.JsonWriter.Formatting} is set to
			 * {@link Newtonsoft.Json.Formatting.Indented}.
			 */
			IndentChar: System.Char;

			/**
			 * Gets or sets a value indicating whether object names will be surrounded with quotes.
			 */
			QuoteName: boolean;

			/**
			 * Asynchronously flushes whatever is in the buffer to the destination and also flushes
			 * the destination.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			FlushAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously closes this writer. If {@link Newtonsoft.Json.JsonWriter.CloseOutput}
			 * is set to true , the destination is also closed.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			CloseAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the end of the current JSON object or array.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteEndAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes raw JSON without changing the writer's state.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteRawAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a null value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteNullAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the property name of a name/value pair of a JSON object.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WritePropertyNameAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the property name of a name/value pair of a JSON object.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WritePropertyNameAsync(
				name: string,
				escape: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the beginning of a JSON array.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteStartArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the beginning of a JSON object.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteStartObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the start of a constructor with the given name.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteStartConstructorAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes an undefined value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteUndefinedAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the given white space.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteWhitespaceAsync(
				ws: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Boolean} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Boolean} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: boolean | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Byte} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Byte} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Byte} [] value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number[] | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Char} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: System.Char,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Char} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: System.Char | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.DateTime} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: DateTime,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.DateTime} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: DateTime | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.DateTimeOffset} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: DateTimeOffset,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.DateTimeOffset}
			 * value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: DateTimeOffset | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Decimal} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: System.Decimal,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Decimal} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: System.Decimal | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Double} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Double} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Single} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Single} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Guid} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Guid} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Int32} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Int32} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Int64} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Int64} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Object} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: System.Object | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.SByte} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.SByte} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Int16} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Int16} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.String} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.TimeSpan} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.TimeSpan} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.UInt32} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.UInt32} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.UInt64} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.UInt64} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Uri} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: System.Uri | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.UInt16} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.UInt16} value.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a comment /*... containing the specified text.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteCommentAsync(
				text: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the end of an array.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteEndArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the end of a constructor.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteEndConstructorAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the end of a JSON object.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteEndObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes raw JSON where a value is expected and updates the writer's
			 * state.
			 *
			 * Derived classes must override this method to get asynchronous behaviour. Otherwise it
			 * will execute synchronously, returning an already-completed task.
			 */
			WriteRawValueAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Flushes whatever is in the buffer to the underlying {@link System.IO.TextWriter} and
			 * also flushes the underlying {@link System.IO.TextWriter}.
			 */
			Flush(): void;

			/**
			 * Closes this writer. If {@link Newtonsoft.Json.JsonWriter.CloseOutput} is set to true ,
			 * the underlying {@link System.IO.TextWriter} is also closed. If
			 * {@link Newtonsoft.Json.JsonWriter.AutoCompleteOnClose} is set to true , the JSON is
			 * auto-completed.
			 */
			Close(): void;

			/** Writes the beginning of a JSON object. */
			WriteStartObject(): void;

			/** Writes the beginning of a JSON array. */
			WriteStartArray(): void;

			/** Writes the start of a constructor with the given name. */
			WriteStartConstructor(name: string): void;

			/** Writes the property name of a name/value pair on a JSON object. */
			WritePropertyName(name: string): void;

			/** Writes the property name of a name/value pair on a JSON object. */
			WritePropertyName(
				name: string,
				escape: boolean,
			): void;

			/**
			 * Writes a {@link System.Object} value. An error will raised if the value cannot be
			 * written as a single JSON token.
			 */
			WriteValue(value: System.Object | undefined): void;

			/** Writes a null value. */
			WriteNull(): void;

			/** Writes an undefined value. */
			WriteUndefined(): void;

			/** Writes raw JSON. */
			WriteRaw(json: string | undefined): void;

			/** Writes a {@link System.String} value. */
			WriteValue(value: string | undefined): void;

			/** Writes a {@link System.Int32} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt32} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Int64} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt64} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Single} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Single} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Double} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Double} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Boolean} value. */
			WriteValue(value: boolean): void;

			/** Writes a {@link System.Int16} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt16} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Char} value. */
			WriteValue(value: System.Char): void;

			/** Writes a {@link System.Byte} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.SByte} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Decimal} value. */
			WriteValue(value: System.Decimal): void;

			/** Writes a {@link System.DateTime} value. */
			WriteValue(value: DateTime): void;

			/** Writes a {@link System.Byte} [] value. */
			WriteValue(value: number[] | undefined): void;

			/** Writes a {@link System.DateTimeOffset} value. */
			WriteValue(value: DateTimeOffset): void;

			/** Writes a {@link System.Guid} value. */
			WriteValue(value: string): void;

			/** Writes a {@link System.TimeSpan} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Uri} value. */
			WriteValue(value: System.Uri | undefined): void;

			/** Writes a comment /*... containing the specified text. */
			WriteComment(text: string | undefined): void;

			/** Writes the given white space. */
			WriteWhitespace(ws: string): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int32} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt32} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int64} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt64} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Boolean} value. */
			WriteValue(value: boolean | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int16} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt16} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Char} value. */
			WriteValue(value: System.Char | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Byte} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.SByte} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Decimal} value. */
			WriteValue(value: System.Decimal | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.DateTime} value. */
			WriteValue(value: DateTime | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.DateTimeOffset} value. */
			WriteValue(value: DateTimeOffset | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Guid} value. */
			WriteValue(value: string | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.TimeSpan} value. */
			WriteValue(value: number | undefined): void;
		}
	}

	export namespace Newtonsoft.Json {
		/** Specifies the type of JSON token. */
		export enum JsonToken {
			/**
			 * This is returned by the {@link Newtonsoft.Json.JsonReader} if a read method has not
			 * been called.
			 */
			None = 0,

			/** An object start token. */
			StartObject = 1,

			/** An array start token. */
			StartArray = 2,

			/** A constructor start token. */
			StartConstructor = 3,

			/** An object property name. */
			PropertyName = 4,

			/** A comment. */
			Comment = 5,

			/** Raw JSON. */
			Raw = 6,

			/** An integer. */
			Integer = 7,

			/** A float. */
			Float = 8,

			/** A string. */
			String = 9,

			/** A boolean. */
			Boolean = 10,

			/** A null token. */
			Null = 11,

			/** An undefined token. */
			Undefined = 12,

			/** An object end token. */
			EndObject = 13,

			/** An array end token. */
			EndArray = 14,

			/** A constructor end token. */
			EndConstructor = 15,

			/** A Date. */
			Date = 16,

			/** Byte data. */
			Bytes = 17,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Represents a reader that provides {@link Newtonsoft.Json.Schema.JsonSchema}
		 * validation. JSON Schema validation has been moved to its own package. See
		 * https://www.newtonsoft.com/jsonschema for more details.
		 */
		export class JsonValidatingReader extends Newtonsoft.Json.JsonReader {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonValidatingReader} class
			 * that validates the content returned from the given {@link Newtonsoft.Json.JsonReader}.
			 */
			constructor(reader: Newtonsoft.Json.JsonReader);

			/** Gets the text value of the current JSON token. */
			readonly Value: System.Object;

			/** Gets the depth of the current token in the JSON document. */
			readonly Depth: number;

			/** Gets the path of the current JSON token. */
			readonly Path: string;

			/** Gets the quotation mark character used to enclose the value of a string. */
			QuoteChar: System.Char;

			/** Gets the type of the current JSON token. */
			readonly TokenType: Newtonsoft.Json.JsonToken;

			/** Gets the .NET type for the current JSON token. */
			readonly ValueType: System.Type;

			/** Gets or sets the schema. */
			Schema: Newtonsoft.Json.Schema.JsonSchema;

			/**
			 * Gets the {@link Newtonsoft.Json.JsonReader} used to construct this
			 * {@link Newtonsoft.Json.JsonValidatingReader}.
			 */
			readonly Reader: Newtonsoft.Json.JsonReader;

			/**
			 * Changes the reader's state to {@link Newtonsoft.Json.JsonReader.State.Closed}. If
			 * {@link Newtonsoft.Json.JsonReader.CloseInput} is set to true , the underlying
			 * {@link Newtonsoft.Json.JsonReader} is also closed.
			 */
			Close(): void;

			/**
			 * Reads the next JSON token from the underlying {@link Newtonsoft.Json.JsonReader} as a
			 * {@link System.Nullable<>} of {@link System.Int32}.
			 */
			ReadAsInt32(): number | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link Newtonsoft.Json.JsonReader} as a
			 * {@link System.Byte} [].
			 */
			ReadAsBytes(): number[];

			/**
			 * Reads the next JSON token from the underlying {@link Newtonsoft.Json.JsonReader} as a
			 * {@link System.Nullable<>} of {@link System.Decimal}.
			 */
			ReadAsDecimal(): System.Decimal | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link Newtonsoft.Json.JsonReader} as a
			 * {@link System.Nullable<>} of {@link System.Double}.
			 */
			ReadAsDouble(): number | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link Newtonsoft.Json.JsonReader} as a
			 * {@link System.Nullable<>} of {@link System.Boolean}.
			 */
			ReadAsBoolean(): boolean | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link Newtonsoft.Json.JsonReader} as a
			 * {@link System.String}.
			 */
			ReadAsString(): string;

			/**
			 * Reads the next JSON token from the underlying {@link Newtonsoft.Json.JsonReader} as a
			 * {@link System.Nullable<>} of {@link System.DateTime}.
			 */
			ReadAsDateTime(): DateTime | undefined;

			/**
			 * Reads the next JSON token from the underlying {@link Newtonsoft.Json.JsonReader} as a
			 * {@link System.Nullable<>} of {@link System.DateTimeOffset}.
			 */
			ReadAsDateTimeOffset(): DateTimeOffset | undefined;

			/** Reads the next JSON token from the underlying {@link Newtonsoft.Json.JsonReader}. */
			Read(): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Represents a writer that provides a fast, non-cached, forward-only way of generating
		 * JSON data.
		 */
		export class JsonWriter {
			/**
			 * Gets or sets a value indicating whether the destination should be closed when this
			 * writer is closed.
			 */
			CloseOutput: boolean;

			/**
			 * Gets or sets a value indicating whether the JSON should be auto-completed when this
			 * writer is closed.
			 */
			AutoCompleteOnClose: boolean;

			/** Gets the state of the writer. */
			readonly WriteState: Newtonsoft.Json.WriteState;

			/** Gets the path of the writer. */
			readonly Path: string;

			/** Gets or sets a value indicating how JSON text output should be formatted. */
			Formatting: Newtonsoft.Json.Formatting;

			/** Gets or sets how dates are written to JSON text. */
			DateFormatHandling: Newtonsoft.Json.DateFormatHandling;

			/**
			 * Gets or sets how {@link System.DateTime} time zones are handled when writing JSON
			 * text.
			 */
			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			/** Gets or sets how strings are escaped when writing JSON text. */
			StringEscapeHandling: Newtonsoft.Json.StringEscapeHandling;

			/**
			 * Gets or sets how special floating point numbers, e.g. {@link System.Double.NaN},
			 * {@link System.Double.PositiveInfinity} and {@link System.Double.NegativeInfinity}, are
			 * written to JSON text.
			 */
			FloatFormatHandling: Newtonsoft.Json.FloatFormatHandling;

			/**
			 * Gets or sets how {@link System.DateTime} and {@link System.DateTimeOffset} values are
			 * formatted when writing JSON text.
			 */
			DateFormatString?: string;

			/**
			 * Gets or sets the culture used when writing JSON. Defaults to
			 * {@link System.Globalization.CultureInfo.InvariantCulture}.
			 */
			Culture: System.Globalization.CultureInfo;

			/**
			 * Asynchronously closes this writer. If {@link Newtonsoft.Json.JsonWriter.CloseOutput}
			 * is set to true , the destination is also closed.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			CloseAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously flushes whatever is in the buffer to the destination and also flushes
			 * the destination.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			FlushAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes raw JSON without changing the writer's state.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteRawAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the end of the current JSON object or array.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteEndAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the end of an array.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteEndArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the end of a constructor.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteEndConstructorAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the end of a JSON object.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteEndObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes a null value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteNullAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the property name of a name/value pair of a JSON object.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WritePropertyNameAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the property name of a name/value pair of a JSON object.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WritePropertyNameAsync(
				name: string,
				escape: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the beginning of a JSON array.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteStartArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes a comment /*... containing the specified text.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteCommentAsync(
				text: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes raw JSON where a value is expected and updates the writer's
			 * state.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteRawValueAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the start of a constructor with the given name.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteStartConstructorAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the beginning of a JSON object.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteStartObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the current {@link Newtonsoft.Json.JsonReader} token.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteTokenAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the current {@link Newtonsoft.Json.JsonReader} token.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteTokenAsync(
				reader: Newtonsoft.Json.JsonReader,
				writeChildren: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the {@link Newtonsoft.Json.JsonToken} token and its value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteTokenAsync(
				token: Newtonsoft.Json.JsonToken,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the {@link Newtonsoft.Json.JsonToken} token and its value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteTokenAsync(
				token: Newtonsoft.Json.JsonToken,
				value: System.Object | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Boolean} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Boolean} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: boolean | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Byte} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Byte} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Byte} [] value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number[] | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Char} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: System.Char,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Char} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: System.Char | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.DateTime} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: DateTime,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.DateTime} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: DateTime | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.DateTimeOffset} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: DateTimeOffset,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.DateTimeOffset}
			 * value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: DateTimeOffset | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Decimal} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: System.Decimal,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Decimal} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: System.Decimal | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Double} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Double} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Single} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Single} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Guid} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Guid} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Int32} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Int32} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Int64} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Int64} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Object} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: System.Object | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.SByte} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.SByte} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Int16} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.Int16} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.String} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.TimeSpan} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.TimeSpan} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.UInt32} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.UInt32} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.UInt64} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.UInt64} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Uri} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: System.Uri | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.UInt16} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a {@link System.Nullable<>} of {@link System.UInt16} value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes an undefined value.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteUndefinedAsync(cancellationToken?: AbortSignal): Promise<void>;

			/**
			 * Asynchronously writes the given white space.
			 *
			 * The default behaviour is to execute synchronously, returning an already-completed
			 * task. Derived classes can override this behaviour for true asynchronicity.
			 */
			WriteWhitespaceAsync(
				ws: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Flushes whatever is in the buffer to the destination and also flushes the destination.
			 */
			Flush(): void;

			/**
			 * Closes this writer. If {@link Newtonsoft.Json.JsonWriter.CloseOutput} is set to true ,
			 * the destination is also closed. If
			 * {@link Newtonsoft.Json.JsonWriter.AutoCompleteOnClose} is set to true , the JSON is
			 * auto-completed.
			 */
			Close(): void;

			/** Writes the beginning of a JSON object. */
			WriteStartObject(): void;

			/** Writes the end of a JSON object. */
			WriteEndObject(): void;

			/** Writes the beginning of a JSON array. */
			WriteStartArray(): void;

			/** Writes the end of an array. */
			WriteEndArray(): void;

			/** Writes the start of a constructor with the given name. */
			WriteStartConstructor(name: string): void;

			/** Writes the end constructor. */
			WriteEndConstructor(): void;

			/** Writes the property name of a name/value pair of a JSON object. */
			WritePropertyName(name: string): void;

			/** Writes the property name of a name/value pair of a JSON object. */
			WritePropertyName(
				name: string,
				escape: boolean,
			): void;

			/** Writes the end of the current JSON object or array. */
			WriteEnd(): void;

			/** Writes the current {@link Newtonsoft.Json.JsonReader} token and its children. */
			WriteToken(reader: Newtonsoft.Json.JsonReader): void;

			/** Writes the current {@link Newtonsoft.Json.JsonReader} token. */
			WriteToken(
				reader: Newtonsoft.Json.JsonReader,
				writeChildren: boolean,
			): void;

			/** Writes the {@link Newtonsoft.Json.JsonToken} token and its value. */
			WriteToken(
				token: Newtonsoft.Json.JsonToken,
				value: System.Object | undefined,
			): void;

			/** Writes the {@link Newtonsoft.Json.JsonToken} token. */
			WriteToken(token: Newtonsoft.Json.JsonToken): void;

			/** Writes a null value. */
			WriteNull(): void;

			/** Writes an undefined value. */
			WriteUndefined(): void;

			/** Writes raw JSON without changing the writer's state. */
			WriteRaw(json: string | undefined): void;

			/** Writes raw JSON where a value is expected and updates the writer's state. */
			WriteRawValue(json: string | undefined): void;

			/** Writes a {@link System.String} value. */
			WriteValue(value: string | undefined): void;

			/** Writes a {@link System.Int32} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt32} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Int64} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt64} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Single} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Double} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Boolean} value. */
			WriteValue(value: boolean): void;

			/** Writes a {@link System.Int16} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt16} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Char} value. */
			WriteValue(value: System.Char): void;

			/** Writes a {@link System.Byte} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.SByte} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Decimal} value. */
			WriteValue(value: System.Decimal): void;

			/** Writes a {@link System.DateTime} value. */
			WriteValue(value: DateTime): void;

			/** Writes a {@link System.DateTimeOffset} value. */
			WriteValue(value: DateTimeOffset): void;

			/** Writes a {@link System.Guid} value. */
			WriteValue(value: string): void;

			/** Writes a {@link System.TimeSpan} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int32} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt32} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int64} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt64} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Single} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Double} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Boolean} value. */
			WriteValue(value: boolean | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int16} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt16} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Char} value. */
			WriteValue(value: System.Char | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Byte} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.SByte} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Decimal} value. */
			WriteValue(value: System.Decimal | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.DateTime} value. */
			WriteValue(value: DateTime | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.DateTimeOffset} value. */
			WriteValue(value: DateTimeOffset | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Guid} value. */
			WriteValue(value: string | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.TimeSpan} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Byte} [] value. */
			WriteValue(value: number[] | undefined): void;

			/** Writes a {@link System.Uri} value. */
			WriteValue(value: System.Uri | undefined): void;

			/**
			 * Writes a {@link System.Object} value. An error will raised if the value cannot be
			 * written as a single JSON token.
			 */
			WriteValue(value: System.Object | undefined): void;

			/** Writes a comment /*... containing the specified text. */
			WriteComment(text: string | undefined): void;

			/** Writes the given white space. */
			WriteWhitespace(ws: string): void;
		}
	}

	export namespace Newtonsoft.Json {
		/** The exception thrown when an error occurs while writing JSON text. */
		export class JsonWriterException extends Newtonsoft.Json.JsonException {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonWriterException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonWriterException} class
			 * with a specified error message.
			 */
			constructor(message: string);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonWriterException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string,
				innerException: System.Exception,
			);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.JsonWriterException} class
			 * with a specified error message, JSON path and a reference to the inner exception that
			 * is the cause of this exception.
			 */
			constructor(
				message: string,
				path: string,
				innerException: System.Exception | undefined,
			);

			/** Gets the path to the JSON where the error occurred. */
			readonly Path?: string;
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies the member serialization options for the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export enum MemberSerialization {
			/**
			 * All public members are serialized by default. Members can be excluded using
			 * {@link Newtonsoft.Json.JsonIgnoreAttribute} or {@link System.NonSerializedAttribute}.
			 * This is the default member serialization mode.
			 */
			OptOut = 0,

			/**
			 * Only members marked with {@link Newtonsoft.Json.JsonPropertyAttribute} or
			 * {@link System.Runtime.Serialization.DataMemberAttribute} are serialized. This member
			 * serialization mode can also be set by marking the class with
			 * {@link System.Runtime.Serialization.DataContractAttribute}.
			 */
			OptIn = 1,

			/**
			 * All public and private fields are serialized. Members can be excluded using
			 * {@link Newtonsoft.Json.JsonIgnoreAttribute} or {@link System.NonSerializedAttribute}.
			 * This member serialization mode can also be set by marking the class with
			 * {@link System.SerializableAttribute} and setting IgnoreSerializableAttribute on
			 * {@link Newtonsoft.Json.Serialization.DefaultContractResolver} to false .
			 */
			Fields = 2,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies metadata property handling options for the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export enum MetadataPropertyHandling {
			/** Read metadata properties located at the start of a JSON object. */
			Default = 0,

			/**
			 * Read metadata properties located anywhere in a JSON object. Note that this setting
			 * will impact performance.
			 */
			ReadAhead = 1,

			/** Do not try to read metadata properties. */
			Ignore = 2,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies missing member handling options for the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export enum MissingMemberHandling {
			/** Ignore a missing member and do not attempt to deserialize it. */
			Ignore = 0,

			/**
			 * Throw a {@link Newtonsoft.Json.JsonSerializationException} when a missing member is
			 * encountered during deserialization.
			 */
			Error = 1,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies null value handling options for the {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export enum NullValueHandling {
			/** Include null values when serializing and deserializing objects. */
			Include = 0,

			/** Ignore null values when serializing and deserializing objects. */
			Ignore = 1,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies how object creation is handled by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export enum ObjectCreationHandling {
			/** Reuse existing objects, create new objects when needed. */
			Auto = 0,

			/** Only reuse existing objects. */
			Reuse = 1,

			/** Always create new objects. */
			Replace = 2,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies reference handling options for the {@link Newtonsoft.Json.JsonSerializer}.
		 * Note that references cannot be preserved when a value is set via a non-default
		 * constructor such as types that implement
		 * {@link System.Runtime.Serialization.ISerializable}.
		 */
		export enum PreserveReferencesHandling {
			/** Do not preserve references when serializing types. */
			None = 0,

			/** Preserve references when serializing into a JSON object structure. */
			Objects = 1,

			/** Preserve references when serializing into a JSON array structure. */
			Arrays = 2,

			/** Preserve references when serializing. */
			All = 3,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies reference loop handling options for the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export enum ReferenceLoopHandling {
			/**
			 * Throw a {@link Newtonsoft.Json.JsonSerializationException} when a loop is encountered.
			 */
			Error = 0,

			/** Ignore loop references and do not serialize. */
			Ignore = 1,

			/** Serialize loop references. */
			Serialize = 2,
		}
	}

	export namespace Newtonsoft.Json {
		/** Indicating whether a property is required. */
		export enum Required {
			/** The property is not required. The default state. */
			Default = 0,

			/** The property must be defined in JSON but can be a null value. */
			AllowNull = 1,

			/** The property must be defined in JSON and cannot be a null value. */
			Always = 2,

			/** The property is not required but it cannot be a null value. */
			DisallowNull = 3,
		}
	}

	export namespace Newtonsoft.Json {
		/** Specifies how strings are escaped when writing JSON text. */
		export enum StringEscapeHandling {
			/** Only control characters (e.g. newline) are escaped. */
			Default = 0,

			/** All non-ASCII and control characters (e.g. newline) are escaped. */
			EscapeNonAscii = 1,

			/** HTML (&lt;, &gt;, &amp;, ', ") and control characters (e.g. newline) are escaped. */
			EscapeHtml = 2,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Indicates the method that will be used during deserialization for locating and loading
		 * assemblies.
		 */
		export enum TypeNameAssemblyFormatHandling {
			/**
			 * In simple mode, the assembly used during deserialization need not match exactly the
			 * assembly used during serialization. Specifically, the version numbers need not match
			 * as the LoadWithPartialName method of the {@link System.Reflection.Assembly} class is
			 * used to load the assembly.
			 */
			Simple = 0,

			/**
			 * In full mode, the assembly used during deserialization must match exactly the assembly
			 * used during serialization. The Load method of the {@link System.Reflection.Assembly}
			 * class is used to load the assembly.
			 */
			Full = 1,
		}
	}

	export namespace Newtonsoft.Json {
		/**
		 * Specifies type name handling options for the {@link Newtonsoft.Json.JsonSerializer}.
		 *
		 * {@link Newtonsoft.Json.JsonSerializer.TypeNameHandling} should be used with caution
		 * when your application deserializes JSON from an external source. Incoming types should
		 * be validated with a custom {@link Newtonsoft.Json.JsonSerializer.SerializationBinder}
		 * when deserializing with a value other than
		 * {@link Newtonsoft.Json.TypeNameHandling.None}.
		 */
		export enum TypeNameHandling {
			/** Do not include the .NET type name when serializing types. */
			None = 0,

			/** Include the .NET type name when serializing into a JSON object structure. */
			Objects = 1,

			/** Include the .NET type name when serializing into a JSON array structure. */
			Arrays = 2,

			/** Always include the .NET type name when serializing. */
			All = 3,

			/**
			 * Include the .NET type name when the type of the object being serialized is not the
			 * same as its declared type. Note that this doesn't include the root serialized object
			 * by default. To include the root object's type name in JSON you must specify a root
			 * type object with
			 * {@link Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,System.Type,Newtonsoft.Json.JsonSerializerSettings)}
			 * or
			 * {@link Newtonsoft.Json.JsonSerializer.Serialize(Newtonsoft.Json.JsonWriter,System.Object,System.Type)}.
			 */
			Auto = 4,
		}
	}

	export namespace Newtonsoft.Json {
		/** Specifies the state of the {@link Newtonsoft.Json.JsonWriter}. */
		export enum WriteState {
			/**
			 * An exception has been thrown, which has left the {@link Newtonsoft.Json.JsonWriter} in
			 * an invalid state. You may call the {@link Newtonsoft.Json.JsonWriter.Close} method to
			 * put the {@link Newtonsoft.Json.JsonWriter} in the Closed state. Any other
			 * {@link Newtonsoft.Json.JsonWriter} method calls result in an
			 * {@link System.InvalidOperationException} being thrown.
			 */
			Error = 0,

			/** The {@link Newtonsoft.Json.JsonWriter.Close} method has been called. */
			Closed = 1,

			/** An object is being written. */
			Object = 2,

			/** An array is being written. */
			Array = 3,

			/** A constructor is being written. */
			Constructor = 4,

			/** A property is being written. */
			Property = 5,

			/** A {@link Newtonsoft.Json.JsonWriter} write method has not been called. */
			Start = 6,
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** A camel case naming strategy. */
		export class CamelCaseNamingStrategy extends Newtonsoft.Json.Serialization.NamingStrategy {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.CamelCaseNamingStrategy} class.
			 */
			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
			);

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.CamelCaseNamingStrategy} class.
			 */
			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
				processExtensionDataNames: boolean,
			);

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.CamelCaseNamingStrategy} class.
			 */
			constructor();
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Resolves member mappings for a type, camel casing property names. */
		export class CamelCasePropertyNamesContractResolver extends Newtonsoft.Json.Serialization.DefaultContractResolver implements Newtonsoft.Json.Serialization.IContractResolver {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver} class.
			 */
			constructor();

			/** Resolves the contract for a given type. */
			ResolveContract(type: System.Type): Newtonsoft.Json.Serialization.JsonContract;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Used by {@link Newtonsoft.Json.JsonSerializer} to resolve a
		 * {@link Newtonsoft.Json.Serialization.JsonContract} for a given {@link System.Type}.
		 */
		export class DefaultContractResolver implements Newtonsoft.Json.Serialization.IContractResolver {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.DefaultContractResolver} class.
			 */
			constructor();

			/**
			 * Gets a value indicating whether members are being get and set using dynamic code
			 * generation. This value is determined by the runtime permissions available.
			 */
			readonly DynamicCodeGeneration: boolean;

			/** Gets or sets the default members search flags. */
			DefaultMembersSearchFlags: System.Reflection.BindingFlags;

			/**
			 * Gets or sets a value indicating whether compiler generated members should be
			 * serialized.
			 */
			SerializeCompilerGeneratedMembers: boolean;

			/**
			 * Gets or sets a value indicating whether to ignore the
			 * {@link System.Runtime.Serialization.ISerializable} interface when serializing and
			 * deserializing types.
			 */
			IgnoreSerializableInterface: boolean;

			/**
			 * Gets or sets a value indicating whether to ignore the
			 * {@link System.SerializableAttribute} attribute when serializing and deserializing
			 * types.
			 */
			IgnoreSerializableAttribute: boolean;

			/**
			 * Gets or sets a value indicating whether to ignore IsSpecified members when serializing
			 * and deserializing types.
			 */
			IgnoreIsSpecifiedMembers: boolean;

			/**
			 * Gets or sets a value indicating whether to ignore ShouldSerialize members when
			 * serializing and deserializing types.
			 */
			IgnoreShouldSerializeMembers: boolean;

			/**
			 * Gets or sets the naming strategy used to resolve how property names and dictionary
			 * keys are serialized.
			 */
			NamingStrategy?: Newtonsoft.Json.Serialization.NamingStrategy;

			/** Resolves the contract for a given type. */
			ResolveContract(type: System.Type): Newtonsoft.Json.Serialization.JsonContract;

			/** Gets the resolved name of the property. */
			GetResolvedPropertyName(propertyName: string): string;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** The default naming strategy. Property names and dictionary keys are unchanged. */
		export class DefaultNamingStrategy extends Newtonsoft.Json.Serialization.NamingStrategy {
			constructor();
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Represents a trace writer that writes to the application's
		 * {@link System.Diagnostics.TraceListener} instances.
		 */
		export class DiagnosticsTraceWriter implements Newtonsoft.Json.Serialization.ITraceWriter {
			constructor();

			/**
			 * Gets the {@link System.Diagnostics.TraceLevel} that will be used to filter the trace
			 * messages passed to the writer. For example a filter level of
			 * {@link System.Diagnostics.TraceLevel.Info} will exclude
			 * {@link System.Diagnostics.TraceLevel.Verbose} messages and include
			 * {@link System.Diagnostics.TraceLevel.Info},
			 * {@link System.Diagnostics.TraceLevel.Warning} and
			 * {@link System.Diagnostics.TraceLevel.Error} messages.
			 */
			LevelFilter: unknown;

			/** Writes the specified trace level, message and optional exception. */
			Trace(
				level: unknown,
				message: string,
				ex: System.Exception | undefined,
			): void;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Get and set values for a {@link System.Reflection.MemberInfo} using dynamic methods.
		 */
		export class DynamicValueProvider implements Newtonsoft.Json.Serialization.IValueProvider {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.DynamicValueProvider} class.
			 */
			constructor(memberInfo: System.Reflection.MemberInfo);

			/** Sets the value. */
			SetValue(
				target: System.Object,
				value: System.Object | undefined,
			): void;

			/** Gets the value. */
			GetValue(target: System.Object): System.Object | undefined;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Provides information surrounding an error. */
		export class ErrorContext {
			/** Gets the error. */
			readonly Error: System.Exception;

			/** Gets the original object that caused the error. */
			readonly OriginalObject?: System.Object;

			/** Gets the member that caused the error. */
			readonly Member?: System.Object;

			/** Gets the path of the JSON location where the error occurred. */
			readonly Path: string;

			/**
			 * Gets or sets a value indicating whether this
			 * {@link Newtonsoft.Json.Serialization.ErrorContext} is handled.
			 */
			Handled: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Provides data for the Error event. */
		export class ErrorEventArgs extends System.EventArgs {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Serialization.ErrorEventArgs}
			 * class.
			 */
			constructor(
				currentObject: System.Object | undefined,
				errorContext: Newtonsoft.Json.Serialization.ErrorContext,
			);

			/** Gets the current object the error event is being raised against. */
			readonly CurrentObject?: System.Object;

			/** Gets the error context. */
			readonly ErrorContext: Newtonsoft.Json.Serialization.ErrorContext;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Get and set values for a {@link System.Reflection.MemberInfo} using dynamic methods.
		 */
		export class ExpressionValueProvider implements Newtonsoft.Json.Serialization.IValueProvider {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.ExpressionValueProvider} class.
			 */
			constructor(memberInfo: System.Reflection.MemberInfo);

			/** Sets the value. */
			SetValue(
				target: System.Object,
				value: System.Object | undefined,
			): void;

			/** Gets the value. */
			GetValue(target: System.Object): System.Object | undefined;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Provides methods to get attributes. */
		export interface IAttributeProvider {
			/**
			 * Returns a collection of all of the attributes, or an empty collection if there are no
			 * attributes.
			 */
			GetAttributes(inherit: boolean): System.Attribute[];

			/**
			 * Returns a collection of attributes, identified by type, or an empty collection if
			 * there are no attributes.
			 */
			GetAttributes(
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute[];
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Used by {@link Newtonsoft.Json.JsonSerializer} to resolve a
		 * {@link Newtonsoft.Json.Serialization.JsonContract} for a given {@link System.Type}.
		 */
		export interface IContractResolver {
			/** Resolves the contract for a given type. */
			ResolveContract(type: System.Type): Newtonsoft.Json.Serialization.JsonContract;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Used to resolve references when serializing and deserializing JSON by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export interface IReferenceResolver {
			/** Resolves a reference to its object. */
			ResolveReference(
				context: System.Object,
				reference: string,
			): System.Object;

			/** Gets the reference for the specified object. */
			GetReference(
				context: System.Object,
				value: System.Object,
			): string;

			/** Determines whether the specified object is referenced. */
			IsReferenced(
				context: System.Object,
				value: System.Object,
			): boolean;

			/** Adds a reference to the specified object. */
			AddReference(
				context: System.Object,
				reference: string,
				value: System.Object,
			): void;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Allows users to control class loading and mandate what class to load. */
		export interface ISerializationBinder {
			/** When implemented, controls the binding of a serialized object to a type. */
			BindToType(
				assemblyName: string | undefined,
				typeName: string,
			): System.Type;

			BindToName(serializedType: System.Type): { assemblyName?: string, typeName?: string };
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Represents a trace writer. */
		export interface ITraceWriter {
			/**
			 * Gets the {@link System.Diagnostics.TraceLevel} that will be used to filter the trace
			 * messages passed to the writer. For example a filter level of
			 * {@link System.Diagnostics.TraceLevel.Info} will exclude
			 * {@link System.Diagnostics.TraceLevel.Verbose} messages and include
			 * {@link System.Diagnostics.TraceLevel.Info},
			 * {@link System.Diagnostics.TraceLevel.Warning} and
			 * {@link System.Diagnostics.TraceLevel.Error} messages.
			 */
			readonly LevelFilter: unknown;

			/** Writes the specified trace level, message and optional exception. */
			Trace(
				level: unknown,
				message: string,
				ex: System.Exception | undefined,
			): void;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Provides methods to get and set values. */
		export interface IValueProvider {
			/** Sets the value. */
			SetValue(
				target: System.Object,
				value: System.Object | undefined,
			): void;

			/** Gets the value. */
			GetValue(target: System.Object): System.Object | undefined;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Contract details for a {@link System.Type} used by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export class JsonArrayContract extends Newtonsoft.Json.Serialization.JsonContainerContract {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.JsonArrayContract} class.
			 */
			constructor(underlyingType: System.Type);

			/** Gets the {@link System.Type} of the collection items. */
			readonly CollectionItemType?: System.Type;

			/** Gets a value indicating whether the collection type is a multidimensional array. */
			readonly IsMultidimensionalArray: boolean;

			/**
			 * Gets or sets the function used to create the object. When set this function will
			 * override {@link Newtonsoft.Json.Serialization.JsonContract.DefaultCreator}.
			 */
			OverrideCreator?: Newtonsoft.Json.Serialization.ObjectConstructor$1<System.Object>;

			/**
			 * Gets a value indicating whether the creator has a parameter with the collection
			 * values.
			 */
			HasParameterizedCreator: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Contract details for a {@link System.Type} used by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export class JsonContainerContract extends Newtonsoft.Json.Serialization.JsonContract {
			/** Gets or sets the default collection items {@link Newtonsoft.Json.JsonConverter}. */
			ItemConverter?: Newtonsoft.Json.JsonConverter;

			/**
			 * Gets or sets a value indicating whether the collection items preserve object
			 * references.
			 */
			ItemIsReference?: boolean;

			/** Gets or sets the collection item reference loop handling. */
			ItemReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			/** Gets or sets the collection item type name handling. */
			ItemTypeNameHandling?: Newtonsoft.Json.TypeNameHandling;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Handles {@link Newtonsoft.Json.JsonSerializer} serialization callback events. */
		export interface SerializationCallback { (
			o: System.Object,
			context: System.Runtime.Serialization.StreamingContext,
		): void; }
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Handles {@link Newtonsoft.Json.JsonSerializer} serialization error callback events.
		 */
		export interface SerializationErrorCallback { (
			o: System.Object,
			context: System.Runtime.Serialization.StreamingContext,
			errorContext: Newtonsoft.Json.Serialization.ErrorContext,
		): void; }
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Sets extension data for an object during deserialization. */
		export interface ExtensionDataSetter { (
			o: System.Object,
			key: string,
			value: System.Object | undefined,
		): void; }
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Gets extension data for an object during serialization. */
		export interface ExtensionDataGetter { (o: System.Object): Iterable<[System.Object, System.Object]>; }
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Contract details for a {@link System.Type} used by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export class JsonContract {
			/** Gets the underlying type for the contract. */
			readonly UnderlyingType: System.Type;

			/** Gets or sets the type created during deserialization. */
			CreatedType: System.Type;

			/** Gets or sets whether this type contract is serialized as a reference. */
			IsReference?: boolean;

			/** Gets or sets the default {@link Newtonsoft.Json.JsonConverter} for this contract. */
			Converter?: Newtonsoft.Json.JsonConverter;

			/**
			 * Gets the internally resolved {@link Newtonsoft.Json.JsonConverter} for the contract's
			 * type. This converter is used as a fallback converter when no other converter is
			 * resolved. Setting {@link Newtonsoft.Json.Serialization.JsonContract.Converter} will
			 * always override this converter.
			 */
			InternalConverter?: Newtonsoft.Json.JsonConverter;

			/** Gets or sets all methods called immediately after deserialization of the object. */
			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			/** Gets or sets all methods called during deserialization of the object. */
			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			/** Gets or sets all methods called after serialization of the object graph. */
			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			/** Gets or sets all methods called before serialization of the object. */
			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			/**
			 * Gets or sets all method called when an error is thrown during the serialization of the
			 * object.
			 */
			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			/** Gets or sets the default creator method used to create the object. */
			DefaultCreator?: System.Func$1<System.Object>;

			/** Gets or sets a value indicating whether the default creator is non-public. */
			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Contract details for a {@link System.Type} used by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export class JsonDictionaryContract extends Newtonsoft.Json.Serialization.JsonContainerContract {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.JsonDictionaryContract} class.
			 */
			constructor(underlyingType: System.Type);

			/** Gets or sets the dictionary key resolver. */
			DictionaryKeyResolver?: System.Func$2<string, string>;

			/** Gets the {@link System.Type} of the dictionary keys. */
			readonly DictionaryKeyType?: System.Type;

			/** Gets the {@link System.Type} of the dictionary values. */
			readonly DictionaryValueType?: System.Type;

			/**
			 * Gets or sets the function used to create the object. When set this function will
			 * override {@link Newtonsoft.Json.Serialization.JsonContract.DefaultCreator}.
			 */
			OverrideCreator?: Newtonsoft.Json.Serialization.ObjectConstructor$1<System.Object>;

			/**
			 * Gets a value indicating whether the creator has a parameter with the dictionary
			 * values.
			 */
			HasParameterizedCreator: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Contract details for a {@link System.Type} used by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export class JsonDynamicContract extends Newtonsoft.Json.Serialization.JsonContainerContract {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.JsonDynamicContract} class.
			 */
			constructor(underlyingType: System.Type);

			/** Gets the object's properties. */
			readonly Properties: Newtonsoft.Json.Serialization.JsonPropertyCollection;

			/** Gets or sets the property name resolver. */
			PropertyNameResolver?: System.Func$2<string, string>;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Contract details for a {@link System.Type} used by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export class JsonISerializableContract extends Newtonsoft.Json.Serialization.JsonContainerContract {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.JsonISerializableContract} class.
			 */
			constructor(underlyingType: System.Type);

			/**
			 * Gets or sets the {@link System.Runtime.Serialization.ISerializable} object
			 * constructor.
			 */
			ISerializableCreator?: Newtonsoft.Json.Serialization.ObjectConstructor$1<System.Object>;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Contract details for a {@link System.Type} used by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export class JsonLinqContract extends Newtonsoft.Json.Serialization.JsonContract {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.JsonLinqContract} class.
			 */
			constructor(underlyingType: System.Type);
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Contract details for a {@link System.Type} used by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export class JsonObjectContract extends Newtonsoft.Json.Serialization.JsonContainerContract {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.JsonObjectContract} class.
			 */
			constructor(underlyingType: System.Type);

			/** Gets or sets the object member serialization. */
			MemberSerialization: Newtonsoft.Json.MemberSerialization;

			/** Gets or sets the missing member handling used when deserializing this object. */
			MissingMemberHandling?: Newtonsoft.Json.MissingMemberHandling;

			/** Gets or sets a value that indicates whether the object's properties are required. */
			ItemRequired?: Newtonsoft.Json.Required;

			/**
			 * Gets or sets how the object's properties with null values are handled during
			 * serialization and deserialization.
			 */
			ItemNullValueHandling?: Newtonsoft.Json.NullValueHandling;

			/** Gets the object's properties. */
			readonly Properties: Newtonsoft.Json.Serialization.JsonPropertyCollection;

			/**
			 * Gets a collection of {@link Newtonsoft.Json.Serialization.JsonProperty} instances that
			 * define the parameters used with
			 * {@link Newtonsoft.Json.Serialization.JsonObjectContract.OverrideCreator}.
			 */
			readonly CreatorParameters: Newtonsoft.Json.Serialization.JsonPropertyCollection;

			/**
			 * Gets or sets the function used to create the object. When set this function will
			 * override {@link Newtonsoft.Json.Serialization.JsonContract.DefaultCreator}. This
			 * function is called with a collection of arguments which are defined by the
			 * {@link Newtonsoft.Json.Serialization.JsonObjectContract.CreatorParameters} collection.
			 */
			OverrideCreator?: Newtonsoft.Json.Serialization.ObjectConstructor$1<System.Object>;

			/** Gets or sets the extension data setter. */
			ExtensionDataSetter?: Newtonsoft.Json.Serialization.ExtensionDataSetter;

			/** Gets or sets the extension data getter. */
			ExtensionDataGetter?: Newtonsoft.Json.Serialization.ExtensionDataGetter;

			/** Gets or sets the extension data value type. */
			ExtensionDataValueType?: System.Type;

			/** Gets or sets the extension data name resolver. */
			ExtensionDataNameResolver?: System.Func$2<string, string>;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Contract details for a {@link System.Type} used by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export class JsonPrimitiveContract extends Newtonsoft.Json.Serialization.JsonContract {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.JsonPrimitiveContract} class.
			 */
			constructor(underlyingType: System.Type);
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Maps a JSON property to a .NET member or constructor parameter. */
		export class JsonProperty {
			constructor();

			/** Gets or sets the name of the property. */
			PropertyName?: string;

			/** Gets or sets the type that declared this property. */
			DeclaringType?: System.Type;

			/** Gets or sets the order of serialization of a member. */
			Order?: number;

			/** Gets or sets the name of the underlying member or parameter. */
			UnderlyingName?: string;

			/**
			 * Gets the {@link Newtonsoft.Json.Serialization.IValueProvider} that will get and set
			 * the {@link Newtonsoft.Json.Serialization.JsonProperty} during serialization.
			 */
			ValueProvider?: Newtonsoft.Json.Serialization.IValueProvider;

			/**
			 * Gets or sets the {@link Newtonsoft.Json.Serialization.IAttributeProvider} for this
			 * property.
			 */
			AttributeProvider?: Newtonsoft.Json.Serialization.IAttributeProvider;

			/** Gets or sets the type of the property. */
			PropertyType?: System.Type;

			/**
			 * Gets or sets the {@link Newtonsoft.Json.JsonConverter} for the property. If set this
			 * converter takes precedence over the contract converter for the property type.
			 */
			Converter?: Newtonsoft.Json.JsonConverter;

			/** Gets or sets the member converter. */
			MemberConverter?: Newtonsoft.Json.JsonConverter;

			/**
			 * Gets or sets a value indicating whether this
			 * {@link Newtonsoft.Json.Serialization.JsonProperty} is ignored.
			 */
			Ignored: boolean;

			/**
			 * Gets or sets a value indicating whether this
			 * {@link Newtonsoft.Json.Serialization.JsonProperty} is readable.
			 */
			Readable: boolean;

			/**
			 * Gets or sets a value indicating whether this
			 * {@link Newtonsoft.Json.Serialization.JsonProperty} is writable.
			 */
			Writable: boolean;

			/**
			 * Gets or sets a value indicating whether this
			 * {@link Newtonsoft.Json.Serialization.JsonProperty} has a member attribute.
			 */
			HasMemberAttribute: boolean;

			/** Gets the default value. */
			DefaultValue?: System.Object;

			/**
			 * Gets or sets a value indicating whether this
			 * {@link Newtonsoft.Json.Serialization.JsonProperty} is required.
			 */
			Required: Newtonsoft.Json.Required;

			/**
			 * Gets a value indicating whether
			 * {@link Newtonsoft.Json.Serialization.JsonProperty.Required} has a value specified.
			 */
			readonly IsRequiredSpecified: boolean;

			/** Gets or sets a value indicating whether this property preserves object references. */
			IsReference?: boolean;

			/** Gets or sets the property null value handling. */
			NullValueHandling?: Newtonsoft.Json.NullValueHandling;

			/** Gets or sets the property default value handling. */
			DefaultValueHandling?: Newtonsoft.Json.DefaultValueHandling;

			/** Gets or sets the property reference loop handling. */
			ReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			/** Gets or sets the property object creation handling. */
			ObjectCreationHandling?: Newtonsoft.Json.ObjectCreationHandling;

			/** Gets or sets or sets the type name handling. */
			TypeNameHandling?: Newtonsoft.Json.TypeNameHandling;

			/**
			 * Gets or sets a predicate used to determine whether the property should be serialized.
			 */
			ShouldSerialize?: System.Predicate$1<System.Object>;

			/**
			 * Gets or sets a predicate used to determine whether the property should be
			 * deserialized.
			 */
			ShouldDeserialize?: System.Predicate$1<System.Object>;

			/**
			 * Gets or sets a predicate used to determine whether the property should be serialized.
			 */
			GetIsSpecified?: System.Predicate$1<System.Object>;

			/** Gets or sets an action used to set whether the property has been deserialized. */
			SetIsSpecified?: System.Action$2<System.Object, System.Object | undefined>;

			/** Gets or sets the converter used when serializing the property's collection items. */
			ItemConverter?: Newtonsoft.Json.JsonConverter;

			/**
			 * Gets or sets whether this property's collection items are serialized as a reference.
			 */
			ItemIsReference?: boolean;

			/**
			 * Gets or sets the type name handling used when serializing the property's collection
			 * items.
			 */
			ItemTypeNameHandling?: Newtonsoft.Json.TypeNameHandling;

			/**
			 * Gets or sets the reference loop handling used when serializing the property's
			 * collection items.
			 */
			ItemReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			/** Returns a {@link System.String} that represents this instance. */
			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** A collection of {@link Newtonsoft.Json.Serialization.JsonProperty} objects. */
		export class JsonPropertyCollection extends System.Collections.ObjectModel.KeyedCollection$2<string, Newtonsoft.Json.Serialization.JsonProperty> {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.JsonPropertyCollection} class.
			 */
			constructor(type: System.Type);

			/** Adds a {@link Newtonsoft.Json.Serialization.JsonProperty} object. */
			AddProperty(property: Newtonsoft.Json.Serialization.JsonProperty): void;

			/**
			 * Gets the closest matching {@link Newtonsoft.Json.Serialization.JsonProperty} object.
			 * First attempts to get an exact case match of `propertyName` and then a case
			 * insensitive match.
			 */
			GetClosestMatchProperty(propertyName: string): Newtonsoft.Json.Serialization.JsonProperty | undefined;

			/** Gets a property by property name. */
			GetProperty(
				propertyName: string,
				comparisonType: System.StringComparison,
			): Newtonsoft.Json.Serialization.JsonProperty | undefined;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Contract details for a {@link System.Type} used by the
		 * {@link Newtonsoft.Json.JsonSerializer}.
		 */
		export class JsonStringContract extends Newtonsoft.Json.Serialization.JsonPrimitiveContract {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.JsonStringContract} class.
			 */
			constructor(underlyingType: System.Type);
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** A kebab case naming strategy. */
		export class KebabCaseNamingStrategy extends Newtonsoft.Json.Serialization.NamingStrategy {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.KebabCaseNamingStrategy} class.
			 */
			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
			);

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.KebabCaseNamingStrategy} class.
			 */
			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
				processExtensionDataNames: boolean,
			);

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.KebabCaseNamingStrategy} class.
			 */
			constructor();
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Represents a trace writer that writes to memory. When the trace message limit is
		 * reached then old trace messages will be removed as new messages are added.
		 */
		export class MemoryTraceWriter implements Newtonsoft.Json.Serialization.ITraceWriter {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.MemoryTraceWriter} class.
			 */
			constructor();

			/**
			 * Gets the {@link System.Diagnostics.TraceLevel} that will be used to filter the trace
			 * messages passed to the writer. For example a filter level of
			 * {@link System.Diagnostics.TraceLevel.Info} will exclude
			 * {@link System.Diagnostics.TraceLevel.Verbose} messages and include
			 * {@link System.Diagnostics.TraceLevel.Info},
			 * {@link System.Diagnostics.TraceLevel.Warning} and
			 * {@link System.Diagnostics.TraceLevel.Error} messages.
			 */
			LevelFilter: unknown;

			/** Writes the specified trace level, message and optional exception. */
			Trace(
				level: unknown,
				message: string,
				ex: System.Exception | undefined,
			): void;

			/** Returns an enumeration of the most recent trace messages. */
			GetTraceMessages(): Iterable<string>;

			/** Returns a {@link System.String} of the most recent trace messages. */
			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** A base class for resolving how property names and dictionary keys are serialized. */
		export class NamingStrategy {
			/** A flag indicating whether dictionary keys should be processed. Defaults to false . */
			ProcessDictionaryKeys: boolean;

			/**
			 * A flag indicating whether extension data names should be processed. Defaults to false
			 * .
			 */
			ProcessExtensionDataNames: boolean;

			/**
			 * A flag indicating whether explicitly specified property names, e.g. a property name
			 * customized with a {@link Newtonsoft.Json.JsonPropertyAttribute}, should be processed.
			 * Defaults to false .
			 */
			OverrideSpecifiedNames: boolean;

			/** Gets the serialized name for a given property name. */
			GetPropertyName(
				name: string,
				hasSpecifiedName: boolean,
			): string;

			/** Gets the serialized name for a given extension data name. */
			GetExtensionDataName(name: string): string;

			/** Gets the serialized key for a given dictionary key. */
			GetDictionaryKey(key: string): string;

			/** Hash code calculation */
			GetHashCode(): number;

			/** Object equality implementation */
			Equals(obj: System.Object | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** [Generic type factory] Represents a method that constructs an object. */
		export function ObjectConstructor$(T: IType): IType;

		/** Represents a method that constructs an object. */
		export interface ObjectConstructor$1<T> { (args: System.Object | undefined[]): System.Object; }
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * When applied to a method, specifies that the method is called when an error occurs
		 * serializing an object.
		 */
		export class OnErrorAttribute extends System.Attribute {
			constructor();
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/**
		 * Provides methods to get attributes from a {@link System.Type},
		 * {@link System.Reflection.MemberInfo}, {@link System.Reflection.ParameterInfo} or
		 * {@link System.Reflection.Assembly}.
		 */
		export class ReflectionAttributeProvider implements Newtonsoft.Json.Serialization.IAttributeProvider {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.ReflectionAttributeProvider} class.
			 */
			constructor(attributeProvider: System.Object);

			/**
			 * Returns a collection of all of the attributes, or an empty collection if there are no
			 * attributes.
			 */
			GetAttributes(inherit: boolean): System.Attribute[];

			/**
			 * Returns a collection of attributes, identified by type, or an empty collection if
			 * there are no attributes.
			 */
			GetAttributes(
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute[];
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** Get and set values for a {@link System.Reflection.MemberInfo} using reflection. */
		export class ReflectionValueProvider implements Newtonsoft.Json.Serialization.IValueProvider {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.ReflectionValueProvider} class.
			 */
			constructor(memberInfo: System.Reflection.MemberInfo);

			/** Sets the value. */
			SetValue(
				target: System.Object,
				value: System.Object | undefined,
			): void;

			/** Gets the value. */
			GetValue(target: System.Object): System.Object | undefined;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		/** A snake case naming strategy. */
		export class SnakeCaseNamingStrategy extends Newtonsoft.Json.Serialization.NamingStrategy {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.SnakeCaseNamingStrategy} class.
			 */
			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
			);

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.SnakeCaseNamingStrategy} class.
			 */
			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
				processExtensionDataNames: boolean,
			);

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Serialization.SnakeCaseNamingStrategy} class.
			 */
			constructor();
		}
	}

	export namespace Newtonsoft.Json.Schema {
		/**
		 * Contains the JSON schema extension methods. JSON Schema validation has been moved to
		 * its own package. See https://www.newtonsoft.com/jsonschema for more details.
		 */
		export namespace Extensions {
			/**
			 * Determines whether the {@link Newtonsoft.Json.Linq.JToken} is valid. JSON Schema
			 * validation has been moved to its own package. See
			 * https://www.newtonsoft.com/jsonschema for more details.
			 */
			export function IsValid(
				source: Newtonsoft.Json.Linq.JToken,
				schema: Newtonsoft.Json.Schema.JsonSchema,
			): boolean;

			export function IsValid(
				source: Newtonsoft.Json.Linq.JToken,
				schema: Newtonsoft.Json.Schema.JsonSchema,
			): { result: boolean, errorMessages: string[] };

			/**
			 * Validates the specified {@link Newtonsoft.Json.Linq.JToken}. JSON Schema validation
			 * has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more
			 * details.
			 */
			export function Validate(
				source: Newtonsoft.Json.Linq.JToken,
				schema: Newtonsoft.Json.Schema.JsonSchema,
			): void;

			/**
			 * Validates the specified {@link Newtonsoft.Json.Linq.JToken}. JSON Schema validation
			 * has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more
			 * details.
			 */
			export function Validate(
				source: Newtonsoft.Json.Linq.JToken,
				schema: Newtonsoft.Json.Schema.JsonSchema,
				validationEventHandler: Newtonsoft.Json.Schema.ValidationEventHandler,
			): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Extension methods from {@link Newtonsoft.Json.Schema.Extensions} */
		export interface JToken {
			/**
			 * Determines whether the {@link Newtonsoft.Json.Linq.JToken} is valid. JSON Schema
			 * validation has been moved to its own package. See
			 * https://www.newtonsoft.com/jsonschema for more details.
			 */
			IsValid(schema: Newtonsoft.Json.Schema.JsonSchema): boolean;

			IsValid(schema: Newtonsoft.Json.Schema.JsonSchema): { result: boolean, errorMessages: string[] };

			/**
			 * Validates the specified {@link Newtonsoft.Json.Linq.JToken}. JSON Schema validation
			 * has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more
			 * details.
			 */
			Validate(schema: Newtonsoft.Json.Schema.JsonSchema): void;

			/**
			 * Validates the specified {@link Newtonsoft.Json.Linq.JToken}. JSON Schema validation
			 * has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more
			 * details.
			 */
			Validate(
				schema: Newtonsoft.Json.Schema.JsonSchema,
				validationEventHandler: Newtonsoft.Json.Schema.ValidationEventHandler,
			): void;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		/**
		 * An in-memory representation of a JSON Schema. JSON Schema validation has been moved to
		 * its own package. See https://www.newtonsoft.com/jsonschema for more details.
		 */
		export class JsonSchema {
			/** Initializes a new instance of the {@link Newtonsoft.Json.Schema.JsonSchema} class. */
			constructor();

			/** Gets or sets the id. */
			Id: string;

			/** Gets or sets the title. */
			Title: string;

			/** Gets or sets whether the object is required. */
			Required?: boolean;

			/** Gets or sets whether the object is read-only. */
			ReadOnly?: boolean;

			/** Gets or sets whether the object is visible to users. */
			Hidden?: boolean;

			/** Gets or sets whether the object is transient. */
			Transient?: boolean;

			/** Gets or sets the description of the object. */
			Description: string;

			/** Gets or sets the types of values allowed by the object. */
			Type?: Newtonsoft.Json.Schema.JsonSchemaType;

			/** Gets or sets the pattern. */
			Pattern: string;

			/** Gets or sets the minimum length. */
			MinimumLength?: number;

			/** Gets or sets the maximum length. */
			MaximumLength?: number;

			/** Gets or sets a number that the value should be divisible by. */
			DivisibleBy?: number;

			/** Gets or sets the minimum. */
			Minimum?: number;

			/** Gets or sets the maximum. */
			Maximum?: number;

			/**
			 * Gets or sets a flag indicating whether the value can not equal the number defined by
			 * the minimum attribute ( {@link Newtonsoft.Json.Schema.JsonSchema.Minimum} ).
			 */
			ExclusiveMinimum?: boolean;

			/**
			 * Gets or sets a flag indicating whether the value can not equal the number defined by
			 * the maximum attribute ( {@link Newtonsoft.Json.Schema.JsonSchema.Maximum} ).
			 */
			ExclusiveMaximum?: boolean;

			/** Gets or sets the minimum number of items. */
			MinimumItems?: number;

			/** Gets or sets the maximum number of items. */
			MaximumItems?: number;

			/** Gets or sets the {@link Newtonsoft.Json.Schema.JsonSchema} of items. */
			Items: Newtonsoft.Json.Schema.JsonSchema[];

			/**
			 * Gets or sets a value indicating whether items in an array are validated using the
			 * {@link Newtonsoft.Json.Schema.JsonSchema} instance at their array position from
			 * {@link Newtonsoft.Json.Schema.JsonSchema.Items}.
			 */
			PositionalItemsValidation: boolean;

			/** Gets or sets the {@link Newtonsoft.Json.Schema.JsonSchema} of additional items. */
			AdditionalItems: Newtonsoft.Json.Schema.JsonSchema;

			/** Gets or sets a value indicating whether additional items are allowed. */
			AllowAdditionalItems: boolean;

			/** Gets or sets whether the array items must be unique. */
			UniqueItems: boolean;

			/** Gets or sets the {@link Newtonsoft.Json.Schema.JsonSchema} of properties. */
			Properties: Map<string, Newtonsoft.Json.Schema.JsonSchema>;

			/**
			 * Gets or sets the {@link Newtonsoft.Json.Schema.JsonSchema} of additional properties.
			 */
			AdditionalProperties: Newtonsoft.Json.Schema.JsonSchema;

			/** Gets or sets the pattern properties. */
			PatternProperties: Map<string, Newtonsoft.Json.Schema.JsonSchema>;

			/** Gets or sets a value indicating whether additional properties are allowed. */
			AllowAdditionalProperties: boolean;

			/** Gets or sets the required property if this property is present. */
			Requires: string;

			/** Gets or sets the a collection of valid enum values allowed. */
			Enum: Newtonsoft.Json.Linq.JToken[];

			/** Gets or sets disallowed types. */
			Disallow?: Newtonsoft.Json.Schema.JsonSchemaType;

			/** Gets or sets the default value. */
			Default: Newtonsoft.Json.Linq.JToken;

			/**
			 * Gets or sets the collection of {@link Newtonsoft.Json.Schema.JsonSchema} that this
			 * schema extends.
			 */
			Extends: Newtonsoft.Json.Schema.JsonSchema[];

			/** Gets or sets the format. */
			Format: string;

			/**
			 * Reads a {@link Newtonsoft.Json.Schema.JsonSchema} from the specified
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Read(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Schema.JsonSchema;

			/**
			 * Reads a {@link Newtonsoft.Json.Schema.JsonSchema} from the specified
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Read(
				reader: Newtonsoft.Json.JsonReader,
				resolver: Newtonsoft.Json.Schema.JsonSchemaResolver,
			): Newtonsoft.Json.Schema.JsonSchema;

			/**
			 * Load a {@link Newtonsoft.Json.Schema.JsonSchema} from a string that contains JSON
			 * Schema.
			 */
			static Parse(json: string): Newtonsoft.Json.Schema.JsonSchema;

			/**
			 * Load a {@link Newtonsoft.Json.Schema.JsonSchema} from a string that contains JSON
			 * Schema using the specified {@link Newtonsoft.Json.Schema.JsonSchemaResolver}.
			 */
			static Parse(
				json: string,
				resolver: Newtonsoft.Json.Schema.JsonSchemaResolver,
			): Newtonsoft.Json.Schema.JsonSchema;

			/** Writes this schema to a {@link Newtonsoft.Json.JsonWriter}. */
			WriteTo(writer: Newtonsoft.Json.JsonWriter): void;

			/**
			 * Writes this schema to a {@link Newtonsoft.Json.JsonWriter} using the specified
			 * {@link Newtonsoft.Json.Schema.JsonSchemaResolver}.
			 */
			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				resolver: Newtonsoft.Json.Schema.JsonSchemaResolver,
			): void;

			/** Returns a {@link System.String} that represents the current {@link System.Object}. */
			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		/**
		 * Returns detailed information about the schema exception. JSON Schema validation has
		 * been moved to its own package. See https://www.newtonsoft.com/jsonschema for more
		 * details.
		 */
		export class JsonSchemaException extends Newtonsoft.Json.JsonException {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Schema.JsonSchemaException}
			 * class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Schema.JsonSchemaException}
			 * class with a specified error message.
			 */
			constructor(message: string);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Schema.JsonSchemaException}
			 * class with a specified error message and a reference to the inner exception that is
			 * the cause of this exception.
			 */
			constructor(
				message: string,
				innerException: System.Exception,
			);

			/** Gets the line number indicating where the error occurred. */
			readonly LineNumber: number;

			/** Gets the line position indicating where the error occurred. */
			readonly LinePosition: number;

			/** Gets the path to the JSON where the error occurred. */
			readonly Path: string;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		/**
		 * Generates a {@link Newtonsoft.Json.Schema.JsonSchema} from a specified
		 * {@link System.Type}. JSON Schema validation has been moved to its own package. See
		 * https://www.newtonsoft.com/jsonschema for more details.
		 */
		export class JsonSchemaGenerator {
			constructor();

			/** Gets or sets how undefined schemas are handled by the serializer. */
			UndefinedSchemaIdHandling: Newtonsoft.Json.Schema.UndefinedSchemaIdHandling;

			/** Gets or sets the contract resolver. */
			ContractResolver: Newtonsoft.Json.Serialization.IContractResolver;

			/** Generate a {@link Newtonsoft.Json.Schema.JsonSchema} from the specified type. */
			Generate(type: System.Type): Newtonsoft.Json.Schema.JsonSchema;

			/** Generate a {@link Newtonsoft.Json.Schema.JsonSchema} from the specified type. */
			Generate(
				type: System.Type,
				resolver: Newtonsoft.Json.Schema.JsonSchemaResolver,
			): Newtonsoft.Json.Schema.JsonSchema;

			/** Generate a {@link Newtonsoft.Json.Schema.JsonSchema} from the specified type. */
			Generate(
				type: System.Type,
				rootSchemaNullable: boolean,
			): Newtonsoft.Json.Schema.JsonSchema;

			/** Generate a {@link Newtonsoft.Json.Schema.JsonSchema} from the specified type. */
			Generate(
				type: System.Type,
				resolver: Newtonsoft.Json.Schema.JsonSchemaResolver,
				rootSchemaNullable: boolean,
			): Newtonsoft.Json.Schema.JsonSchema;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		/**
		 * Resolves {@link Newtonsoft.Json.Schema.JsonSchema} from an id. JSON Schema validation
		 * has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more
		 * details.
		 */
		export class JsonSchemaResolver {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Schema.JsonSchemaResolver}
			 * class.
			 */
			constructor();

			/** Gets or sets the loaded schemas. */
			LoadedSchemas: Newtonsoft.Json.Schema.JsonSchema[];

			/** Gets a {@link Newtonsoft.Json.Schema.JsonSchema} for the specified reference. */
			GetSchema(reference: string): Newtonsoft.Json.Schema.JsonSchema;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		/**
		 * The value types allowed by the {@link Newtonsoft.Json.Schema.JsonSchema}. JSON Schema
		 * validation has been moved to its own package. See
		 * https://www.newtonsoft.com/jsonschema for more details.
		 */
		export enum JsonSchemaType {
			/** No type specified. */
			None = 0,

			/** String type. */
			String = 1,

			/** Float type. */
			Float = 2,

			/** Integer type. */
			Integer = 4,

			/** Boolean type. */
			Boolean = 8,

			/** Object type. */
			Object = 16,

			/** Array type. */
			Array = 32,

			/** Null type. */
			Null = 64,

			/** Any type. */
			Any = 127,
		}
	}

	export namespace Newtonsoft.Json.Schema {
		/**
		 * Specifies undefined schema Id handling options for the
		 * {@link Newtonsoft.Json.Schema.JsonSchemaGenerator}. JSON Schema validation has been
		 * moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.
		 */
		export enum UndefinedSchemaIdHandling {
			/** Do not infer a schema Id. */
			None = 0,

			/** Use the .NET type name as the schema Id. */
			UseTypeName = 1,

			/** Use the assembly qualified .NET type name as the schema Id. */
			UseAssemblyQualifiedName = 2,
		}
	}

	export namespace Newtonsoft.Json.Schema {
		/**
		 * Returns detailed information related to the
		 * {@link Newtonsoft.Json.Schema.ValidationEventHandler}. JSON Schema validation has been
		 * moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.
		 */
		export class ValidationEventArgs extends System.EventArgs {
			/**
			 * Gets the {@link Newtonsoft.Json.Schema.JsonSchemaException} associated with the
			 * validation error.
			 */
			readonly Exception: Newtonsoft.Json.Schema.JsonSchemaException;

			/** Gets the path of the JSON location where the validation error occurred. */
			readonly Path: string;

			/** Gets the text description corresponding to the validation error. */
			readonly Message: string;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		/**
		 * Represents the callback method that will handle JSON schema validation events and the
		 * {@link Newtonsoft.Json.Schema.ValidationEventArgs}. JSON Schema validation has been
		 * moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.
		 */
		export interface ValidationEventHandler { (
			sender: System.Object,
			e: Newtonsoft.Json.Schema.ValidationEventArgs,
		): void; }
	}

	export namespace Newtonsoft.Json.Linq {
		/** Specifies how JSON comments are handled when loading JSON. */
		export enum CommentHandling {
			/** Ignore comments. */
			Ignore = 0,

			/**
			 * Load comments as a {@link Newtonsoft.Json.Linq.JValue} with type
			 * {@link Newtonsoft.Json.Linq.JTokenType.Comment}.
			 */
			Load = 1,
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Specifies how duplicate property names are handled when loading JSON. */
		export enum DuplicatePropertyNameHandling {
			/**
			 * Replace the existing value when there is a duplicate property. The value of the last
			 * property in the JSON object will be used.
			 */
			Replace = 0,

			/**
			 * Ignore the new value when there is a duplicate property. The value of the first
			 * property in the JSON object will be used.
			 */
			Ignore = 1,

			/**
			 * Throw a {@link Newtonsoft.Json.JsonReaderException} when a duplicate property is
			 * encountered.
			 */
			Error = 2,
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Contains the LINQ to JSON extension methods. */
		export namespace Extensions {
			/**
			 * Returns a collection of tokens that contains the ancestors of every token in the
			 * source collection.
			 */
			export function Ancestors<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Returns a collection of tokens that contains every token in the source collection, and
			 * the ancestors of every token in the source collection.
			 */
			export function AncestorsAndSelf<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Returns a collection of tokens that contains the descendants of every token in the
			 * source collection.
			 */
			export function Descendants<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Returns a collection of tokens that contains every token in the source collection, and
			 * the descendants of every token in the source collection.
			 */
			export function DescendantsAndSelf<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/** Returns a collection of child properties of every object in the source collection. */
			export function Properties(source: Iterable<Newtonsoft.Json.Linq.JObject>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JProperty>;

			/**
			 * Returns a collection of child values of every object in the source collection with the
			 * given key.
			 */
			export function Values(
				source: Iterable<Newtonsoft.Json.Linq.JToken>,
				key: System.Object | undefined,
			): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/** Returns a collection of child values of every object in the source collection. */
			export function Values(source: Iterable<Newtonsoft.Json.Linq.JToken>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Returns a collection of converted child values of every object in the source
			 * collection with the given key.
			 */
			export function Values<U>(
				source: Iterable<Newtonsoft.Json.Linq.JToken>,
				key: System.Object,
			): Iterable<U>;

			/**
			 * Returns a collection of converted child values of every object in the source
			 * collection.
			 */
			export function Values<U>(source: Iterable<Newtonsoft.Json.Linq.JToken>): Iterable<U>;

			/** Converts the value. */
			export function Value<U>(value: Iterable<Newtonsoft.Json.Linq.JToken>): U;

			/** Converts the value. */
			export function Value<T, U>(value: Iterable<T>): U;

			/** Returns a collection of child tokens of every array in the source collection. */
			export function Children<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Returns a collection of converted child tokens of every array in the source
			 * collection.
			 */
			export function Children<T, U>(source: Iterable<T>): Iterable<U>;

			/** Returns the input typed as {@link Newtonsoft.Json.Linq.IJEnumerable<>}. */
			export function AsJEnumerable(source: Iterable<Newtonsoft.Json.Linq.JToken>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/** Returns the input typed as {@link Newtonsoft.Json.Linq.IJEnumerable<>}. */
			export function AsJEnumerable<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<T>;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/**
		 * [Generic type factory] Represents a collection of {@link Newtonsoft.Json.Linq.JToken}
		 * objects.
		 */
		export function IJEnumerable$(T: IType): IType;

		/** Represents a collection of {@link Newtonsoft.Json.Linq.JToken} objects. */
		export interface IJEnumerable$1<T> {
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Represents a JSON array. */
		export class JArray extends Newtonsoft.Json.Linq.JContainer {
			/** Initializes a new instance of the {@link Newtonsoft.Json.Linq.JArray} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JArray} class from
			 * another {@link Newtonsoft.Json.Linq.JArray} object.
			 */
			constructor(other: Newtonsoft.Json.Linq.JArray);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JArray} class with the
			 * specified content.
			 */
			constructor(content: System.Object[]);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JArray} class with the
			 * specified content.
			 */
			constructor(content: System.Object);

			/** Gets the node type for this {@link Newtonsoft.Json.Linq.JToken}. */
			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			/**
			 * Gets a value indicating whether the {@link Newtonsoft.Json.Linq.JArray} is read-only.
			 */
			readonly IsReadOnly: boolean;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			/**
			 * Asynchronously loads a {@link Newtonsoft.Json.Linq.JArray} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JArray>;

			/**
			 * Asynchronously loads a {@link Newtonsoft.Json.Linq.JArray} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JArray>;

			/**
			 * Loads an {@link Newtonsoft.Json.Linq.JArray} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Load(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JArray;

			/**
			 * Loads an {@link Newtonsoft.Json.Linq.JArray} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Load(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JArray;

			/** Load a {@link Newtonsoft.Json.Linq.JArray} from a string that contains JSON. */
			static Parse(json: string): Newtonsoft.Json.Linq.JArray;

			/** Load a {@link Newtonsoft.Json.Linq.JArray} from a string that contains JSON. */
			static Parse(
				json: string,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JArray;

			/** Creates a {@link Newtonsoft.Json.Linq.JArray} from an object. */
			static FromObject(o: System.Object): Newtonsoft.Json.Linq.JArray;

			/** Creates a {@link Newtonsoft.Json.Linq.JArray} from an object. */
			static FromObject(
				o: System.Object,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): Newtonsoft.Json.Linq.JArray;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter}. */
			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			/**
			 * Determines the index of a specific item in the {@link Newtonsoft.Json.Linq.JArray}.
			 */
			IndexOf(item: Newtonsoft.Json.Linq.JToken): number;

			/** Inserts an item to the {@link Newtonsoft.Json.Linq.JArray} at the specified index. */
			Insert(
				index: number,
				item: Newtonsoft.Json.Linq.JToken,
			): void;

			/** Removes the {@link Newtonsoft.Json.Linq.JArray} item at the specified index. */
			RemoveAt(index: number): void;

			/** Returns an enumerator that iterates through the collection. */
			GetEnumerator(): System.Collections.Generic.IEnumerator$1<Newtonsoft.Json.Linq.JToken>;

			/** Adds an item to the {@link Newtonsoft.Json.Linq.JArray}. */
			Add(item: Newtonsoft.Json.Linq.JToken): void;

			/** Removes all items from the {@link Newtonsoft.Json.Linq.JArray}. */
			Clear(): void;

			/**
			 * Determines whether the {@link Newtonsoft.Json.Linq.JArray} contains a specific value.
			 */
			Contains(item: Newtonsoft.Json.Linq.JToken): boolean;

			/**
			 * Copies the elements of the {@link Newtonsoft.Json.Linq.JArray} to an array, starting
			 * at a particular array index.
			 */
			CopyTo(
				array: Newtonsoft.Json.Linq.JToken[],
				arrayIndex: number,
			): void;

			/**
			 * Removes the first occurrence of a specific object from the
			 * {@link Newtonsoft.Json.Linq.JArray}.
			 */
			Remove(item: Newtonsoft.Json.Linq.JToken): boolean;

			/**
			 * Adds the specified content as children of this {@link Newtonsoft.Json.Linq.JToken}.
			 */
			Add(content: System.Object | undefined): void;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			/** Removes this token from its parent. */
			Remove(): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Represents a JSON constructor. */
		export class JConstructor extends Newtonsoft.Json.Linq.JContainer {
			/** Initializes a new instance of the {@link Newtonsoft.Json.Linq.JConstructor} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JConstructor} class from
			 * another {@link Newtonsoft.Json.Linq.JConstructor} object.
			 */
			constructor(other: Newtonsoft.Json.Linq.JConstructor);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JConstructor} class with
			 * the specified name and content.
			 */
			constructor(
				name: string,
				content: System.Object[],
			);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JConstructor} class with
			 * the specified name and content.
			 */
			constructor(
				name: string,
				content: System.Object,
			);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JConstructor} class with
			 * the specified name.
			 */
			constructor(name: string);

			/** Gets or sets the name of this constructor. */
			Name?: string;

			/** Gets the node type for this {@link Newtonsoft.Json.Linq.JToken}. */
			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			/**
			 * Asynchronously loads a {@link Newtonsoft.Json.Linq.JConstructor} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JConstructor>;

			/**
			 * Asynchronously loads a {@link Newtonsoft.Json.Linq.JConstructor} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JConstructor>;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter}. */
			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			/**
			 * Loads a {@link Newtonsoft.Json.Linq.JConstructor} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Load(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JConstructor;

			/**
			 * Loads a {@link Newtonsoft.Json.Linq.JConstructor} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Load(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JConstructor;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Represents a token that can contain other tokens. */
		export class JContainer extends Newtonsoft.Json.Linq.JToken {
			/** Gets a value indicating whether this token has child tokens. */
			readonly HasValues: boolean;

			/** Get the first child token of this token. */
			readonly First?: Newtonsoft.Json.Linq.JToken;

			/** Get the last child token of this token. */
			readonly Last?: Newtonsoft.Json.Linq.JToken;

			/** Gets the count of child JSON tokens. */
			readonly Count: number;

			/** Returns a collection of the child tokens of this token, in document order. */
			Children(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/** Returns a collection of the child values of this token, in document order. */
			Values<T>(): Iterable<T>;

			/** Returns a collection of the descendant tokens for this token in document order. */
			Descendants(): Iterable<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Returns a collection of the tokens that contain this token, and all descendant tokens
			 * of this token, in document order.
			 */
			DescendantsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Adds the specified content as children of this {@link Newtonsoft.Json.Linq.JToken}.
			 */
			Add(content: System.Object | undefined): void;

			/**
			 * Adds the specified content as the first children of this
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			AddFirst(content: System.Object | undefined): void;

			/**
			 * Creates a {@link Newtonsoft.Json.JsonWriter} that can be used to add tokens to the
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			CreateWriter(): Newtonsoft.Json.JsonWriter;

			/** Replaces the child nodes of this token with the specified content. */
			ReplaceAll(content: System.Object): void;

			/** Removes the child nodes from this token. */
			RemoveAll(): void;

			/** Merge the specified content into this {@link Newtonsoft.Json.Linq.JToken}. */
			Merge(content: System.Object | undefined): void;

			/**
			 * Merge the specified content into this {@link Newtonsoft.Json.Linq.JToken} using
			 * {@link Newtonsoft.Json.Linq.JsonMergeSettings}.
			 */
			Merge(
				content: System.Object | undefined,
				settings: Newtonsoft.Json.Linq.JsonMergeSettings | undefined,
			): void;

			/**
			 * Returns a collection of the child tokens of this token, in document order, filtered by
			 * the specified type.
			 */
			Children<T>(): Newtonsoft.Json.Linq.JEnumerable$1<T>;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/**
		 * [Generic type factory] Represents a collection of {@link Newtonsoft.Json.Linq.JToken}
		 * objects.
		 */
		export function JEnumerable$(T: IType): typeof JEnumerable$1<any>;

		/** Represents a collection of {@link Newtonsoft.Json.Linq.JToken} objects. */
		export class JEnumerable$1<T> extends System.ValueType {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JEnumerable<>} struct.
			 */
			constructor(enumerable: Iterable<T>);

			/** Returns an enumerator that can be used to iterate through the collection. */
			GetEnumerator(): System.Collections.Generic.IEnumerator$1<T>;

			/**
			 * Determines whether the specified {@link Newtonsoft.Json.Linq.JEnumerable<>} is equal
			 * to this instance.
			 */
			Equals(other: Newtonsoft.Json.Linq.JEnumerable$1<T>): boolean;

			/** Determines whether the specified {@link System.Object} is equal to this instance. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns a hash code for this instance. */
			GetHashCode(): number;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Represents a JSON object. */
		export class JObject extends Newtonsoft.Json.Linq.JContainer {
			/** Initializes a new instance of the {@link Newtonsoft.Json.Linq.JObject} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JObject} class from
			 * another {@link Newtonsoft.Json.Linq.JObject} object.
			 */
			constructor(other: Newtonsoft.Json.Linq.JObject);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JObject} class with the
			 * specified content.
			 */
			constructor(content: System.Object[]);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JObject} class with the
			 * specified content.
			 */
			constructor(content: System.Object);

			/** Gets the node type for this {@link Newtonsoft.Json.Linq.JToken}. */
			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			/**
			 * Asynchronously loads a {@link Newtonsoft.Json.Linq.JObject} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JObject>;

			/**
			 * Asynchronously loads a {@link Newtonsoft.Json.Linq.JObject} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JObject>;

			/**
			 * Gets an {@link System.Collections.Generic.IEnumerable<>} of
			 * {@link Newtonsoft.Json.Linq.JProperty} of this object's properties.
			 */
			Properties(): Iterable<Newtonsoft.Json.Linq.JProperty>;

			/** Gets a {@link Newtonsoft.Json.Linq.JProperty} with the specified name. */
			Property(name: string): Newtonsoft.Json.Linq.JProperty | undefined;

			/**
			 * Gets the {@link Newtonsoft.Json.Linq.JProperty} with the specified name. The exact
			 * name will be searched for first and if no matching property is found then the
			 * {@link System.StringComparison} will be used to match a property.
			 */
			Property(
				name: string,
				comparison: System.StringComparison,
			): Newtonsoft.Json.Linq.JProperty | undefined;

			/**
			 * Gets a {@link Newtonsoft.Json.Linq.JEnumerable<>} of
			 * {@link Newtonsoft.Json.Linq.JToken} of this object's property values.
			 */
			PropertyValues(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Loads a {@link Newtonsoft.Json.Linq.JObject} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Load(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JObject;

			/**
			 * Loads a {@link Newtonsoft.Json.Linq.JObject} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Load(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JObject;

			/** Load a {@link Newtonsoft.Json.Linq.JObject} from a string that contains JSON. */
			static Parse(json: string): Newtonsoft.Json.Linq.JObject;

			/** Load a {@link Newtonsoft.Json.Linq.JObject} from a string that contains JSON. */
			static Parse(
				json: string,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JObject;

			/** Creates a {@link Newtonsoft.Json.Linq.JObject} from an object. */
			static FromObject(o: System.Object): Newtonsoft.Json.Linq.JObject;

			/** Creates a {@link Newtonsoft.Json.Linq.JObject} from an object. */
			static FromObject(
				o: System.Object,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): Newtonsoft.Json.Linq.JObject;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter}. */
			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			/** Gets the {@link Newtonsoft.Json.Linq.JToken} with the specified property name. */
			GetValue(propertyName: string | undefined): Newtonsoft.Json.Linq.JToken | undefined;

			/**
			 * Gets the {@link Newtonsoft.Json.Linq.JToken} with the specified property name. The
			 * exact property name will be searched for first and if no matching property is found
			 * then the {@link System.StringComparison} will be used to match a property.
			 */
			GetValue(
				propertyName: string | undefined,
				comparison: System.StringComparison,
			): Newtonsoft.Json.Linq.JToken | undefined;

			TryGetValue(
				propertyName: string,
				comparison: System.StringComparison,
			): Newtonsoft.Json.Linq.JToken | undefined;

			/** Adds the specified property name. */
			Add(
				propertyName: string,
				value: Newtonsoft.Json.Linq.JToken | undefined,
			): void;

			/** Determines whether the JSON object has the specified property name. */
			ContainsKey(propertyName: string): boolean;

			/** Removes the property with the specified name. */
			Remove(propertyName: string): boolean;

			TryGetValue(propertyName: string): Newtonsoft.Json.Linq.JToken | undefined;

			/** Returns an enumerator that can be used to iterate through the collection. */
			GetEnumerator(): System.Collections.Generic.IEnumerator$1<[string, Newtonsoft.Json.Linq.JToken | undefined]>;

			/**
			 * Adds the specified content as children of this {@link Newtonsoft.Json.Linq.JToken}.
			 */
			Add(content: System.Object | undefined): void;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			/** Removes this token from its parent. */
			Remove(): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Represents a JSON property. */
		export class JProperty extends Newtonsoft.Json.Linq.JContainer {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JProperty} class from
			 * another {@link Newtonsoft.Json.Linq.JProperty} object.
			 */
			constructor(other: Newtonsoft.Json.Linq.JProperty);

			/** Initializes a new instance of the {@link Newtonsoft.Json.Linq.JProperty} class. */
			constructor(
				name: string,
				content: System.Object[],
			);

			/** Initializes a new instance of the {@link Newtonsoft.Json.Linq.JProperty} class. */
			constructor(
				name: string,
				content: System.Object | undefined,
			);

			/** Gets the property name. */
			readonly Name: string;

			/** Gets or sets the property value. */
			Value: Newtonsoft.Json.Linq.JToken;

			/** Gets the node type for this {@link Newtonsoft.Json.Linq.JToken}. */
			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			/**
			 * Asynchronously loads a {@link Newtonsoft.Json.Linq.JProperty} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JProperty>;

			/**
			 * Asynchronously loads a {@link Newtonsoft.Json.Linq.JProperty} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JProperty>;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter}. */
			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			/**
			 * Loads a {@link Newtonsoft.Json.Linq.JProperty} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Load(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JProperty;

			/**
			 * Loads a {@link Newtonsoft.Json.Linq.JProperty} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Load(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JProperty;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Represents a view of a {@link Newtonsoft.Json.Linq.JProperty}. */
		export class JPropertyDescriptor extends System.ComponentModel.PropertyDescriptor {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JPropertyDescriptor}
			 * class.
			 */
			constructor(name: string);

			/**
			 * When overridden in a derived class, gets the type of the component this property is
			 * bound to.
			 */
			readonly ComponentType: System.Type;

			/**
			 * When overridden in a derived class, gets a value indicating whether this property is
			 * read-only.
			 */
			readonly IsReadOnly: boolean;

			/** When overridden in a derived class, gets the type of the property. */
			readonly PropertyType: System.Type;

			/**
			 * When overridden in a derived class, returns whether resetting an object changes its
			 * value.
			 */
			CanResetValue(component: System.Object): boolean;

			/**
			 * When overridden in a derived class, gets the current value of the property on a
			 * component.
			 */
			GetValue(component: System.Object | undefined): System.Object | undefined;

			/**
			 * When overridden in a derived class, resets the value for this property of the
			 * component to the default value.
			 */
			ResetValue(component: System.Object): void;

			/**
			 * When overridden in a derived class, sets the value of the component to a different
			 * value.
			 */
			SetValue(
				component: System.Object | undefined,
				value: System.Object | undefined,
			): void;

			/**
			 * When overridden in a derived class, determines a value indicating whether the value of
			 * this property needs to be persisted.
			 */
			ShouldSerializeValue(component: System.Object): boolean;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Represents a raw JSON string. */
		export class JRaw extends Newtonsoft.Json.Linq.JValue {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JRaw} class from another
			 * {@link Newtonsoft.Json.Linq.JRaw} object.
			 */
			constructor(other: Newtonsoft.Json.Linq.JRaw);

			/** Initializes a new instance of the {@link Newtonsoft.Json.Linq.JRaw} class. */
			constructor(rawJson: System.Object | undefined);

			/**
			 * Asynchronously creates an instance of {@link Newtonsoft.Json.Linq.JRaw} with the
			 * content of the reader's current token.
			 */
			static CreateAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JRaw>;

			/**
			 * Creates an instance of {@link Newtonsoft.Json.Linq.JRaw} with the content of the
			 * reader's current token.
			 */
			static Create(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JRaw;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Specifies the settings used when cloning JSON. */
		export class JsonCloneSettings {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JsonCloneSettings}
			 * class.
			 */
			constructor();

			/**
			 * Gets or sets a flag that indicates whether to copy annotations when cloning a
			 * {@link Newtonsoft.Json.Linq.JToken}. The default value is true .
			 */
			CopyAnnotations: boolean;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Specifies the settings used when loading JSON. */
		export class JsonLoadSettings {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JsonLoadSettings} class.
			 */
			constructor();

			/**
			 * Gets or sets how JSON comments are handled when loading JSON. The default value is
			 * {@link Newtonsoft.Json.Linq.CommentHandling.Ignore}.
			 */
			CommentHandling: Newtonsoft.Json.Linq.CommentHandling;

			/**
			 * Gets or sets how JSON line info is handled when loading JSON. The default value is
			 * {@link Newtonsoft.Json.Linq.LineInfoHandling.Load}.
			 */
			LineInfoHandling: Newtonsoft.Json.Linq.LineInfoHandling;

			/**
			 * Gets or sets how duplicate property names in JSON objects are handled when loading
			 * JSON. The default value is
			 * {@link Newtonsoft.Json.Linq.DuplicatePropertyNameHandling.Replace}.
			 */
			DuplicatePropertyNameHandling: Newtonsoft.Json.Linq.DuplicatePropertyNameHandling;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Specifies the settings used when merging JSON. */
		export class JsonMergeSettings {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JsonMergeSettings}
			 * class.
			 */
			constructor();

			/** Gets or sets the method used when merging JSON arrays. */
			MergeArrayHandling: Newtonsoft.Json.Linq.MergeArrayHandling;

			/** Gets or sets how null value properties are merged. */
			MergeNullValueHandling: Newtonsoft.Json.Linq.MergeNullValueHandling;

			/**
			 * Gets or sets the comparison used to match property names while merging. The exact
			 * property name will be searched for first and if no matching property is found then the
			 * {@link System.StringComparison} will be used to match a property.
			 */
			PropertyNameComparison: System.StringComparison;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Specifies the settings used when selecting JSON. */
		export class JsonSelectSettings {
			constructor();

			/** Gets or sets a timeout that will be used when executing regular expressions. */
			RegexMatchTimeout?: number;

			/**
			 * Gets or sets a flag that indicates whether an error should be thrown if no tokens are
			 * found when evaluating part of the expression.
			 */
			ErrorWhenNoMatch: boolean;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Represents an abstract JSON token. */
		export class JToken {
			/** Gets a comparer that can compare two tokens for value equality. */
			static readonly EqualityComparer: Newtonsoft.Json.Linq.JTokenEqualityComparer;

			/** Gets or sets the parent. */
			Parent?: Newtonsoft.Json.Linq.JContainer;

			/**
			 * Gets the root {@link Newtonsoft.Json.Linq.JToken} of this
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			readonly Root: Newtonsoft.Json.Linq.JToken;

			/** Gets the node type for this {@link Newtonsoft.Json.Linq.JToken}. */
			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			/** Gets a value indicating whether this token has child tokens. */
			readonly HasValues: boolean;

			/** Gets the next sibling token of this node. */
			Next?: Newtonsoft.Json.Linq.JToken;

			/** Gets the previous sibling token of this node. */
			Previous?: Newtonsoft.Json.Linq.JToken;

			/** Gets the path of the JSON token. */
			readonly Path: string;

			/** Get the first child token of this token. */
			readonly First?: Newtonsoft.Json.Linq.JToken;

			/** Get the last child token of this token. */
			readonly Last?: Newtonsoft.Json.Linq.JToken;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			/**
			 * Asynchronously creates a {@link Newtonsoft.Json.Linq.JToken} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static ReadFromAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Asynchronously creates a {@link Newtonsoft.Json.Linq.JToken} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static ReadFromAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Asynchronously creates a {@link Newtonsoft.Json.Linq.JToken} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Asynchronously creates a {@link Newtonsoft.Json.Linq.JToken} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JToken>;

			/** Compares the values of two tokens, including the values of all descendant tokens. */
			static DeepEquals(
				t1: Newtonsoft.Json.Linq.JToken | undefined,
				t2: Newtonsoft.Json.Linq.JToken | undefined,
			): boolean;

			/** Adds the specified content immediately after this token. */
			AddAfterSelf(content: System.Object | undefined): void;

			/** Adds the specified content immediately before this token. */
			AddBeforeSelf(content: System.Object | undefined): void;

			/** Returns a collection of the ancestor tokens of this token. */
			Ancestors(): Iterable<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Returns a collection of tokens that contain this token, and the ancestors of this
			 * token.
			 */
			AncestorsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			/** Returns a collection of the sibling tokens after this token, in document order. */
			AfterSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			/** Returns a collection of the sibling tokens before this token, in document order. */
			BeforeSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Gets the {@link Newtonsoft.Json.Linq.JToken} with the specified key converted to the
			 * specified type.
			 */
			Value<T>(key: System.Object): T;

			/** Returns a collection of the child tokens of this token, in document order. */
			Children(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Returns a collection of the child tokens of this token, in document order, filtered by
			 * the specified type.
			 */
			Children<T>(): Newtonsoft.Json.Linq.JEnumerable$1<T>;

			/** Returns a collection of the child values of this token, in document order. */
			Values<T>(): Iterable<T>;

			/** Removes this token from its parent. */
			Remove(): void;

			/** Replaces this token with the specified token. */
			Replace(value: Newtonsoft.Json.Linq.JToken): void;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter}. */
			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			/**
			 * Returns the indented JSON for this token.
			 *
			 * ToString() returns a non-JSON string value for tokens with a type of
			 * {@link Newtonsoft.Json.Linq.JTokenType.String}. If you want the JSON for all token
			 * types then you should use
			 * {@link Newtonsoft.Json.Linq.JToken.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])}.
			 */
			ToString(): string;

			/** Returns the JSON for this token using the given formatting and converters. */
			ToString(
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			/** Creates a {@link Newtonsoft.Json.JsonReader} for this token. */
			CreateReader(): Newtonsoft.Json.JsonReader;

			/** Creates a {@link Newtonsoft.Json.Linq.JToken} from an object. */
			static FromObject(o: System.Object): Newtonsoft.Json.Linq.JToken;

			/**
			 * Creates a {@link Newtonsoft.Json.Linq.JToken} from an object using the specified
			 * {@link Newtonsoft.Json.JsonSerializer}.
			 */
			static FromObject(
				o: System.Object,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): Newtonsoft.Json.Linq.JToken;

			/**
			 * Creates an instance of the specified .NET type from the
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			ToObject<T>(): T;

			/**
			 * Creates an instance of the specified .NET type from the
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			ToObject(objectType: System.Type): System.Object | undefined;

			/**
			 * Creates an instance of the specified .NET type from the
			 * {@link Newtonsoft.Json.Linq.JToken} using the specified
			 * {@link Newtonsoft.Json.JsonSerializer}.
			 */
			ToObject<T>(jsonSerializer: Newtonsoft.Json.JsonSerializer): T;

			/**
			 * Creates an instance of the specified .NET type from the
			 * {@link Newtonsoft.Json.Linq.JToken} using the specified
			 * {@link Newtonsoft.Json.JsonSerializer}.
			 */
			ToObject(
				objectType: System.Type | undefined,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/**
			 * Creates a {@link Newtonsoft.Json.Linq.JToken} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static ReadFrom(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JToken;

			/**
			 * Creates a {@link Newtonsoft.Json.Linq.JToken} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static ReadFrom(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JToken;

			/** Load a {@link Newtonsoft.Json.Linq.JToken} from a string that contains JSON. */
			static Parse(json: string): Newtonsoft.Json.Linq.JToken;

			/** Load a {@link Newtonsoft.Json.Linq.JToken} from a string that contains JSON. */
			static Parse(
				json: string,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JToken;

			/**
			 * Creates a {@link Newtonsoft.Json.Linq.JToken} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Load(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JToken;

			/**
			 * Creates a {@link Newtonsoft.Json.Linq.JToken} from a
			 * {@link Newtonsoft.Json.JsonReader}.
			 */
			static Load(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JToken;

			/**
			 * Selects a {@link Newtonsoft.Json.Linq.JToken} using a JSONPath expression. Selects the
			 * token that matches the object path.
			 */
			SelectToken(path: string): Newtonsoft.Json.Linq.JToken | undefined;

			/**
			 * Selects a {@link Newtonsoft.Json.Linq.JToken} using a JSONPath expression. Selects the
			 * token that matches the object path.
			 */
			SelectToken(
				path: string,
				errorWhenNoMatch: boolean,
			): Newtonsoft.Json.Linq.JToken | undefined;

			/**
			 * Selects a {@link Newtonsoft.Json.Linq.JToken} using a JSONPath expression. Selects the
			 * token that matches the object path.
			 */
			SelectToken(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Newtonsoft.Json.Linq.JToken | undefined;

			/** Selects a collection of elements using a JSONPath expression. */
			SelectTokens(path: string): Iterable<Newtonsoft.Json.Linq.JToken>;

			/** Selects a collection of elements using a JSONPath expression. */
			SelectTokens(
				path: string,
				errorWhenNoMatch: boolean,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			/** Selects a collection of elements using a JSONPath expression. */
			SelectTokens(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			/**
			 * Creates a new instance of the {@link Newtonsoft.Json.Linq.JToken}. All child tokens
			 * are recursively cloned.
			 */
			DeepClone(): Newtonsoft.Json.Linq.JToken;

			/**
			 * Creates a new instance of the {@link Newtonsoft.Json.Linq.JToken}. All child tokens
			 * are recursively cloned.
			 */
			DeepClone(settings: Newtonsoft.Json.Linq.JsonCloneSettings): Newtonsoft.Json.Linq.JToken;

			/** Adds an object to the annotation list of this {@link Newtonsoft.Json.Linq.JToken}. */
			AddAnnotation(annotation: System.Object): void;

			/**
			 * Get the first annotation object of the specified type from this
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			Annotation<T>(): T;

			/**
			 * Gets the first annotation object of the specified type from this
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			Annotation(type: System.Type): System.Object | undefined;

			/**
			 * Gets a collection of annotations of the specified type for this
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			Annotations<T>(): Iterable<T>;

			/**
			 * Gets a collection of annotations of the specified type for this
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			Annotations(type: System.Type): Iterable<System.Object>;

			/**
			 * Removes the annotations of the specified type from this
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			RemoveAnnotations<T>(): void;

			/**
			 * Removes the annotations of the specified type from this
			 * {@link Newtonsoft.Json.Linq.JToken}.
			 */
			RemoveAnnotations(type: System.Type): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Compares tokens to determine whether they are equal. */
		export class JTokenEqualityComparer {
			constructor();

			/** Determines whether the specified objects are equal. */
			Equals(
				x: Newtonsoft.Json.Linq.JToken | undefined,
				y: Newtonsoft.Json.Linq.JToken | undefined,
			): boolean;

			/** Returns a hash code for the specified object. */
			GetHashCode(obj: Newtonsoft.Json.Linq.JToken): number;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/**
		 * Represents a reader that provides fast, non-cached, forward-only access to serialized
		 * JSON data.
		 */
		export class JTokenReader extends Newtonsoft.Json.JsonReader {
			/** Initializes a new instance of the {@link Newtonsoft.Json.Linq.JTokenReader} class. */
			constructor(token: Newtonsoft.Json.Linq.JToken);

			/** Initializes a new instance of the {@link Newtonsoft.Json.Linq.JTokenReader} class. */
			constructor(
				token: Newtonsoft.Json.Linq.JToken,
				initialPath: string,
			);

			/** Gets the {@link Newtonsoft.Json.Linq.JToken} at the reader's current position. */
			readonly CurrentToken?: Newtonsoft.Json.Linq.JToken;

			/** Gets the path of the current JSON token. */
			readonly Path: string;

			/** Reads the next JSON token from the underlying {@link Newtonsoft.Json.Linq.JToken}. */
			Read(): boolean;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Specifies the type of token. */
		export enum JTokenType {
			/** No token type has been set. */
			None = 0,

			/** A JSON object. */
			Object = 1,

			/** A JSON array. */
			Array = 2,

			/** A JSON constructor. */
			Constructor = 3,

			/** A JSON object property. */
			Property = 4,

			/** A comment. */
			Comment = 5,

			/** An integer value. */
			Integer = 6,

			/** A float value. */
			Float = 7,

			/** A string value. */
			String = 8,

			/** A boolean value. */
			Boolean = 9,

			/** A null value. */
			Null = 10,

			/** An undefined value. */
			Undefined = 11,

			/** A date value. */
			Date = 12,

			/** A raw JSON value. */
			Raw = 13,

			/** A collection of bytes value. */
			Bytes = 14,

			/** A Guid value. */
			Guid = 15,

			/** A Uri value. */
			Uri = 16,

			/** A TimeSpan value. */
			TimeSpan = 17,
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/**
		 * Represents a writer that provides a fast, non-cached, forward-only way of generating
		 * JSON data.
		 */
		export class JTokenWriter extends Newtonsoft.Json.JsonWriter {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JTokenWriter} class
			 * writing to the given {@link Newtonsoft.Json.Linq.JContainer}.
			 */
			constructor(container: Newtonsoft.Json.Linq.JContainer);

			/** Initializes a new instance of the {@link Newtonsoft.Json.Linq.JTokenWriter} class. */
			constructor();

			/** Gets the {@link Newtonsoft.Json.Linq.JToken} at the writer's current position. */
			readonly CurrentToken?: Newtonsoft.Json.Linq.JToken;

			/** Gets the token being written. */
			readonly Token?: Newtonsoft.Json.Linq.JToken;

			/**
			 * Flushes whatever is in the buffer to the underlying
			 * {@link Newtonsoft.Json.Linq.JContainer}.
			 */
			Flush(): void;

			/**
			 * Closes this writer. If {@link Newtonsoft.Json.JsonWriter.AutoCompleteOnClose} is set
			 * to true , the JSON is auto-completed.
			 *
			 * Setting {@link Newtonsoft.Json.JsonWriter.CloseOutput} to true has no additional
			 * effect, since the underlying {@link Newtonsoft.Json.Linq.JContainer} is a type that
			 * cannot be closed.
			 */
			Close(): void;

			/** Writes the beginning of a JSON object. */
			WriteStartObject(): void;

			/** Writes the beginning of a JSON array. */
			WriteStartArray(): void;

			/** Writes the start of a constructor with the given name. */
			WriteStartConstructor(name: string): void;

			/** Writes the property name of a name/value pair on a JSON object. */
			WritePropertyName(name: string): void;

			/**
			 * Writes a {@link System.Object} value. An error will be raised if the value cannot be
			 * written as a single JSON token.
			 */
			WriteValue(value: System.Object | undefined): void;

			/** Writes a null value. */
			WriteNull(): void;

			/** Writes an undefined value. */
			WriteUndefined(): void;

			/** Writes raw JSON. */
			WriteRaw(json: string | undefined): void;

			/** Writes a comment /*... containing the specified text. */
			WriteComment(text: string | undefined): void;

			/** Writes a {@link System.String} value. */
			WriteValue(value: string | undefined): void;

			/** Writes a {@link System.Int32} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt32} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Int64} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt64} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Single} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Double} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Boolean} value. */
			WriteValue(value: boolean): void;

			/** Writes a {@link System.Int16} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt16} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Char} value. */
			WriteValue(value: System.Char): void;

			/** Writes a {@link System.Byte} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.SByte} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Decimal} value. */
			WriteValue(value: System.Decimal): void;

			/** Writes a {@link System.DateTime} value. */
			WriteValue(value: DateTime): void;

			/** Writes a {@link System.DateTimeOffset} value. */
			WriteValue(value: DateTimeOffset): void;

			/** Writes a {@link System.Byte} [] value. */
			WriteValue(value: number[] | undefined): void;

			/** Writes a {@link System.TimeSpan} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Guid} value. */
			WriteValue(value: string): void;

			/** Writes a {@link System.Uri} value. */
			WriteValue(value: System.Uri | undefined): void;

			/** Writes the property name of a name/value pair of a JSON object. */
			WritePropertyName(
				name: string,
				escape: boolean,
			): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int32} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt32} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int64} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt64} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Single} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Double} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Boolean} value. */
			WriteValue(value: boolean | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int16} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt16} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Char} value. */
			WriteValue(value: System.Char | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Byte} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.SByte} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Decimal} value. */
			WriteValue(value: System.Decimal | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.DateTime} value. */
			WriteValue(value: DateTime | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.DateTimeOffset} value. */
			WriteValue(value: DateTimeOffset | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Guid} value. */
			WriteValue(value: string | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.TimeSpan} value. */
			WriteValue(value: number | undefined): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Represents a value in JSON (string, integer, date, etc). */
		export class JValue extends Newtonsoft.Json.Linq.JToken {
			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class from
			 * another {@link Newtonsoft.Json.Linq.JValue} object.
			 */
			constructor(other: Newtonsoft.Json.Linq.JValue);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: System.Decimal);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: System.Char);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: DateTime);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: DateTimeOffset);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: boolean);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: string | undefined);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: string);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: System.Uri | undefined);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link Newtonsoft.Json.Linq.JValue} class with the
			 * given value.
			 */
			constructor(value: System.Object | undefined);

			/** Gets a value indicating whether this token has child tokens. */
			readonly HasValues: boolean;

			/** Gets the node type for this {@link Newtonsoft.Json.Linq.JToken}. */
			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			/** Gets or sets the underlying token value. */
			Value?: System.Object;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			/** Creates a {@link Newtonsoft.Json.Linq.JValue} comment with the given value. */
			static CreateComment(value: string | undefined): Newtonsoft.Json.Linq.JValue;

			/** Creates a {@link Newtonsoft.Json.Linq.JValue} string with the given value. */
			static CreateString(value: string | undefined): Newtonsoft.Json.Linq.JValue;

			/** Creates a {@link Newtonsoft.Json.Linq.JValue} null value. */
			static CreateNull(): Newtonsoft.Json.Linq.JValue;

			/** Creates a {@link Newtonsoft.Json.Linq.JValue} undefined value. */
			static CreateUndefined(): Newtonsoft.Json.Linq.JValue;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter}. */
			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			/** Indicates whether the current object is equal to another object of the same type. */
			Equals(other: Newtonsoft.Json.Linq.JValue | undefined): boolean;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link System.Object}.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Serves as a hash function for a particular type. */
			GetHashCode(): number;

			/**
			 * Returns a {@link System.String} that represents this instance.
			 *
			 * ToString() returns a non-JSON string value for tokens with a type of
			 * {@link Newtonsoft.Json.Linq.JTokenType.String}. If you want the JSON for all token
			 * types then you should use
			 * {@link Newtonsoft.Json.Linq.JValue.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])}.
			 */
			ToString(): string;

			/** Returns a {@link System.String} that represents this instance. */
			ToString(format: string): string;

			/** Returns a {@link System.String} that represents this instance. */
			ToString(formatProvider: System.IFormatProvider | undefined): string;

			/** Returns a {@link System.String} that represents this instance. */
			ToString(
				format: string | undefined,
				formatProvider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(obj: Newtonsoft.Json.Linq.JValue | undefined): number;

			/** Writes this token to a {@link Newtonsoft.Json.JsonWriter} asynchronously. */
			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			/** Returns the JSON for this token using the given formatting and converters. */
			ToString(
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Specifies how line information is handled when loading JSON. */
		export enum LineInfoHandling {
			/** Ignore line information. */
			Ignore = 0,

			/** Load line information. */
			Load = 1,
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Specifies how JSON arrays are merged together. */
		export enum MergeArrayHandling {
			/** Concatenate arrays. */
			Concat = 0,

			/** Union arrays, skipping items that already exist. */
			Union = 1,

			/** Replace all array items. */
			Replace = 2,

			/** Merge array items together, matched by index. */
			Merge = 3,
		}
	}

	export namespace Newtonsoft.Json.Linq {
		/** Specifies how null value properties are merged. */
		export enum MergeNullValueHandling {
			/** The content's null value properties will be ignored during merging. */
			Ignore = 0,

			/** The content's null value properties will be merged. */
			Merge = 1,
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts a binary value to and from a base 64 string value. */
		export class BinaryConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts a {@link Newtonsoft.Json.Bson.BsonObjectId} to and from JSON and BSON. */
		export class BsonObjectIdConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** [Generic type factory] Creates a custom object. */
		export function CustomCreationConverter$(T: IType): typeof CustomCreationConverter$1<any>;

		/** Creates a custom object. */
		export class CustomCreationConverter$1<T> extends Newtonsoft.Json.JsonConverter {
			/**
			 * Gets a value indicating whether this {@link Newtonsoft.Json.JsonConverter} can write
			 * JSON.
			 */
			readonly CanWrite: boolean;

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Creates an object which will then be populated by the serializer. */
			Create(objectType: System.Type): T;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts a {@link System.Data.DataSet} to and from JSON. */
		export class DataSetConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified value type. */
			CanConvert(valueType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts a {@link System.Data.DataTable} to and from JSON. */
		export class DataTableConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified value type. */
			CanConvert(valueType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Provides a base class for converting a {@link System.DateTime} to and from JSON. */
		export class DateTimeConverterBase extends Newtonsoft.Json.JsonConverter {
			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts a F# discriminated union type to and from JSON. */
		export class DiscriminatedUnionConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts an Entity Framework {@link System.Data.EntityKeyMember} to and from JSON. */
		export class EntityKeyMemberConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts an {@link System.Dynamic.ExpandoObject} to and from JSON. */
		export class ExpandoObjectConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/**
			 * Gets a value indicating whether this {@link Newtonsoft.Json.JsonConverter} can write
			 * JSON.
			 */
			readonly CanWrite: boolean;

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/**
		 * Converts a {@link System.DateTime} to and from the ISO 8601 date format (e.g.
		 * "2008-04-12T12:53Z" ).
		 */
		export class IsoDateTimeConverter extends Newtonsoft.Json.Converters.DateTimeConverterBase {
			constructor();

			/** Gets or sets the date time styles used when converting a date to and from JSON. */
			DateTimeStyles: System.Globalization.DateTimeStyles;

			/** Gets or sets the date time format used when converting a date to and from JSON. */
			DateTimeFormat?: string;

			/** Gets or sets the culture used when converting a date to and from JSON. */
			Culture: System.Globalization.CultureInfo;

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/**
		 * Converts a {@link System.DateTime} to and from a JavaScript Date constructor (e.g. new
		 * Date(52231943) ).
		 */
		export class JavaScriptDateTimeConverter extends Newtonsoft.Json.Converters.DateTimeConverterBase {
			constructor();

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts a {@link System.Collections.Generic.KeyValuePair<,>} to and from JSON. */
		export class KeyValuePairConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts a {@link System.Text.RegularExpressions.Regex} to and from JSON and BSON. */
		export class RegexConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts an {@link System.Enum} to and from its name string value. */
		export class StringEnumConverter extends Newtonsoft.Json.JsonConverter {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Converters.StringEnumConverter} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Converters.StringEnumConverter} class.
			 */
			constructor(camelCaseText: boolean);

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Converters.StringEnumConverter} class.
			 */
			constructor(
				namingStrategy: Newtonsoft.Json.Serialization.NamingStrategy,
				allowIntegerValues?: boolean,
			);

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Converters.StringEnumConverter} class.
			 */
			constructor(namingStrategyType: System.Type);

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Converters.StringEnumConverter} class.
			 */
			constructor(
				namingStrategyType: System.Type,
				namingStrategyParameters: System.Object[],
			);

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Converters.StringEnumConverter} class.
			 */
			constructor(
				namingStrategyType: System.Type,
				namingStrategyParameters: System.Object[],
				allowIntegerValues: boolean,
			);

			/**
			 * Gets or sets a value indicating whether the written enum text should be camel case.
			 * The default value is false .
			 */
			CamelCaseText: boolean;

			/** Gets or sets the naming strategy used to resolve how enum text is written. */
			NamingStrategy?: Newtonsoft.Json.Serialization.NamingStrategy;

			/**
			 * Gets or sets a value indicating whether integer values are allowed when serializing
			 * and deserializing. The default value is true .
			 */
			AllowIntegerValues: boolean;

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts a {@link System.DateTime} to and from Unix epoch time */
		export class UnixDateTimeConverter extends Newtonsoft.Json.Converters.DateTimeConverterBase {
			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Converters.UnixDateTimeConverter} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link Newtonsoft.Json.Converters.UnixDateTimeConverter} class.
			 */
			constructor(allowPreEpoch: boolean);

			/**
			 * Gets or sets a value indicating whether the dates before Unix epoch should converted
			 * to and from JSON.
			 */
			AllowPreEpoch: boolean;

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts a {@link System.Version} to and from a string (e.g. "1.2.3.4" ). */
		export class VersionConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified object type. */
			CanConvert(objectType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		/** Converts XML to and from JSON. */
		export class XmlNodeConverter extends Newtonsoft.Json.JsonConverter {
			constructor();

			/**
			 * Gets or sets the name of the root element to insert when deserializing to XML if the
			 * JSON structure has produced multiple root elements.
			 */
			DeserializeRootElementName?: string;

			/**
			 * Gets or sets a value to indicate whether to write the Json.NET array attribute. This
			 * attribute helps preserve arrays when converting the written XML back to JSON.
			 */
			WriteArrayAttribute: boolean;

			/** Gets or sets a value indicating whether to write the root JSON object. */
			OmitRootObject: boolean;

			/**
			 * Gets or sets a value indicating whether to encode special characters when converting
			 * JSON to XML. If true , special characters like ':', '@', '?', '#' and '$' in JSON
			 * property names aren't used to specify XML namespaces, attributes or processing
			 * directives. Instead special characters are encoded and written as part of the XML
			 * element name.
			 */
			EncodeSpecialCharacters: boolean;

			/** Writes the JSON representation of the object. */
			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			/** Reads the JSON representation of the object. */
			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: System.Type,
				existingValue: System.Object | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): System.Object | undefined;

			/** Determines whether this instance can convert the specified value type. */
			CanConvert(valueType: System.Type): boolean;
		}
	}

	export namespace Newtonsoft.Json.Bson {
		/** Represents a BSON Oid (object id). */
		export class BsonObjectId {
			/** Initializes a new instance of the {@link Newtonsoft.Json.Bson.BsonObjectId} class. */
			constructor(value: number[]);

			/** Gets or sets the value of the Oid. */
			readonly Value: number[];
		}
	}

	export namespace Newtonsoft.Json.Bson {
		/**
		 * Represents a reader that provides fast, non-cached, forward-only access to serialized
		 * BSON data.
		 */
		export class BsonReader extends Newtonsoft.Json.JsonReader {
			/** Initializes a new instance of the {@link Newtonsoft.Json.Bson.BsonReader} class. */
			constructor(stream: Duplex);

			/** Initializes a new instance of the {@link Newtonsoft.Json.Bson.BsonReader} class. */
			constructor(reader: System.IO.BinaryReader);

			/** Initializes a new instance of the {@link Newtonsoft.Json.Bson.BsonReader} class. */
			constructor(
				stream: Duplex,
				readRootValueAsArray: boolean,
				dateTimeKindHandling: System.DateTimeKind,
			);

			/** Initializes a new instance of the {@link Newtonsoft.Json.Bson.BsonReader} class. */
			constructor(
				reader: System.IO.BinaryReader,
				readRootValueAsArray: boolean,
				dateTimeKindHandling: System.DateTimeKind,
			);

			/**
			 * Gets or sets a value indicating whether binary data reading should be compatible with
			 * incorrect Json.NET 3.5 written binary.
			 */
			JsonNet35BinaryCompatibility: boolean;

			/**
			 * Gets or sets a value indicating whether the root object will be read as a JSON array.
			 */
			ReadRootValueAsArray: boolean;

			/**
			 * Gets or sets the {@link System.DateTimeKind} used when reading {@link System.DateTime}
			 * values from BSON.
			 */
			DateTimeKindHandling: System.DateTimeKind;

			/** Reads the next JSON token from the underlying {@link System.IO.Stream}. */
			Read(): boolean;

			/**
			 * Changes the reader's state to {@link Newtonsoft.Json.JsonReader.State.Closed}. If
			 * {@link Newtonsoft.Json.JsonReader.CloseInput} is set to true , the underlying
			 * {@link System.IO.Stream} is also closed.
			 */
			Close(): void;
		}
	}

	export namespace Newtonsoft.Json.Bson {
		/**
		 * Represents a writer that provides a fast, non-cached, forward-only way of generating
		 * BSON data.
		 */
		export class BsonWriter extends Newtonsoft.Json.JsonWriter {
			/** Initializes a new instance of the {@link Newtonsoft.Json.Bson.BsonWriter} class. */
			constructor(stream: Duplex);

			/** Initializes a new instance of the {@link Newtonsoft.Json.Bson.BsonWriter} class. */
			constructor(writer: System.IO.BinaryWriter);

			/**
			 * Gets or sets the {@link System.DateTimeKind} used when writing {@link System.DateTime}
			 * values to BSON. When set to {@link System.DateTimeKind.Unspecified} no conversion will
			 * occur.
			 */
			DateTimeKindHandling: System.DateTimeKind;

			/**
			 * Flushes whatever is in the buffer to the underlying {@link System.IO.Stream} and also
			 * flushes the underlying stream.
			 */
			Flush(): void;

			/** Writes a comment /*... containing the specified text. */
			WriteComment(text: string): void;

			/** Writes the start of a constructor with the given name. */
			WriteStartConstructor(name: string): void;

			/** Writes raw JSON. */
			WriteRaw(json: string): void;

			/** Writes raw JSON where a value is expected and updates the writer's state. */
			WriteRawValue(json: string): void;

			/** Writes the beginning of a JSON array. */
			WriteStartArray(): void;

			/** Writes the beginning of a JSON object. */
			WriteStartObject(): void;

			/** Writes the property name of a name/value pair on a JSON object. */
			WritePropertyName(name: string): void;

			/**
			 * Closes this writer. If {@link Newtonsoft.Json.JsonWriter.CloseOutput} is set to true ,
			 * the underlying {@link System.IO.Stream} is also closed. If
			 * {@link Newtonsoft.Json.JsonWriter.AutoCompleteOnClose} is set to true , the JSON is
			 * auto-completed.
			 */
			Close(): void;

			/**
			 * Writes a {@link System.Object} value. An error will raised if the value cannot be
			 * written as a single JSON token.
			 */
			WriteValue(value: System.Object): void;

			/** Writes a null value. */
			WriteNull(): void;

			/** Writes an undefined value. */
			WriteUndefined(): void;

			/** Writes a {@link System.String} value. */
			WriteValue(value: string): void;

			/** Writes a {@link System.Int32} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt32} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Int64} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt64} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Single} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Double} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Boolean} value. */
			WriteValue(value: boolean): void;

			/** Writes a {@link System.Int16} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.UInt16} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Char} value. */
			WriteValue(value: System.Char): void;

			/** Writes a {@link System.Byte} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.SByte} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Decimal} value. */
			WriteValue(value: System.Decimal): void;

			/** Writes a {@link System.DateTime} value. */
			WriteValue(value: DateTime): void;

			/** Writes a {@link System.DateTimeOffset} value. */
			WriteValue(value: DateTimeOffset): void;

			/** Writes a {@link System.Byte} [] value. */
			WriteValue(value: number[]): void;

			/** Writes a {@link System.Guid} value. */
			WriteValue(value: string): void;

			/** Writes a {@link System.TimeSpan} value. */
			WriteValue(value: number): void;

			/** Writes a {@link System.Uri} value. */
			WriteValue(value: System.Uri): void;

			/** Writes a {@link System.Byte} [] value that represents a BSON object id. */
			WriteObjectId(value: number[]): void;

			/** Writes a BSON regex. */
			WriteRegex(
				pattern: string,
				options: string,
			): void;

			/** Writes the property name of a name/value pair of a JSON object. */
			WritePropertyName(
				name: string,
				escape: boolean,
			): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int32} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt32} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int64} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt64} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Single} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Double} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Boolean} value. */
			WriteValue(value: boolean | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Int16} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.UInt16} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Char} value. */
			WriteValue(value: System.Char | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Byte} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.SByte} value. */
			WriteValue(value: number | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Decimal} value. */
			WriteValue(value: System.Decimal | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.DateTime} value. */
			WriteValue(value: DateTime | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.DateTimeOffset} value. */
			WriteValue(value: DateTimeOffset | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.Guid} value. */
			WriteValue(value: string | undefined): void;

			/** Writes a {@link System.Nullable<>} of {@link System.TimeSpan} value. */
			WriteValue(value: number | undefined): void;
		}
	}
}
