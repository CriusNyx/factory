// Generated for: GenParse 1.0.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.8.0.0
/* eslint-disable */

import './System.Runtime';

/** A JavaScript projection of a .NET type. */
interface IType {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): IType;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace ASTNodeExtensions {
		export function SourceCode<LexonType>(astNode: GenParse.Parsing.ASTNode$1<LexonType>): string;
	}

	export function CustomParser$(LexonType: IType): IType;

	export interface CustomParser$1<LexonType> {
		Parse(
			context: GenParse.Parsing.ParseContext$1<LexonType>,
			lexons: GenParse.Lexing.Lexon$1<LexonType>[],
			index: number,
		): GenParse.Parsing.ParseResult$1<LexonType> | undefined;
	}

	export class EmptyProgramException extends System.Exception {
		constructor();
	}

	export function ParseException$(LexonType: IType): typeof ParseException$1<any>;

	export class ParseException$1<LexonType> extends System.Exception {
		constructor(lexon: GenParse.Lexing.Lexon$1<LexonType>);
	}

	export class ASTAttribute extends System.Attribute {
		constructor();
	}

	export class ASTClassAttribute extends System.Attribute {
		constructor(nodeName: string);
	}

	export class ASTFieldAttribute extends System.Attribute {
		constructor(grammarElementName: string);
	}

	export interface ASTTransformer {
		Transform(): System.Object;
	}

	export namespace Transformer {
		export function Transform<T>(root: GenParse.Parsing.ASTNode$1<T>): System.Object;
	}

	export namespace GenParse.Functional {
		export namespace Functional {
			export function Range(value: number): number[];

			export function Map<T, U>(
				arr: T[],
				func: System.Func$2<T, U>,
			): U[];

			export function Map<T, U>(
				arr: T[],
				func: System.Func$3<T, number, U>,
			): U[];

			export function MapReduce<T, U, V>(
				arr: T[],
				initialContext: V,
				func: System.Func$3<T, V, [U, V]>,
			): [U[], V];

			export function FlatMap<T, U>(
				arr: T[],
				func: System.Func$2<T, U[]>,
			): U[];

			export function Reduce<T, U>(
				arr: T[],
				initialValue: U,
				func: System.Func$3<T, U, U>,
			): U;

			export function FilterNull<T>(arr: T[]): T[];

			export function Collapse<U>(arr: U[][]): U[];

			export function Map<T, U, V>(
				dict: Map<T, U>,
				func: System.Func$2<U, V>,
			): Map<T, V>;

			export function TryMap<T, U>(
				arr: T[],
				tryFunc: System.Func$2<T, U>,
			): U[] | undefined;

			export function Filter<T>(
				arr: T[],
				func: System.Func$2<T, boolean>,
			): T[];

			export function FilterByType<T, U>(arr: T[]): U[];

			export function FindByType<T, U>(arr: T[]): U;

			export function UntilNull<T>(func: System.Func$1<T>): Iterable<T>;

			export function FirstNotNull<T>(arr: T[]): T;

			export function FirstNotNull<T, U>(
				arr: T[],
				func: System.Func$2<T, U>,
			): U;

			export function TryGet<T>(
				arr: T[],
				index: number,
			): T | undefined;

			export function SafeGet<T>(
				arr: T[],
				index: number,
			): T;

			export function Safe<T, U>(
				dict: ReadonlyMap<T, U>,
				key: T,
			): U;

			export function SafeGet<T, U>(
				dict: ReadonlyMap<T, U>,
				key: T,
				defaultValue: U,
			): U;

			export function AddOrGet<T, U>(
				dict: Map<T, U>,
				key: T,
				constructor: System.Func$1<U>,
			): U;

			export function AddOrGet<T, U>(
				dict: Map<T, U[]>,
				key: T,
			): U[];

			export function With<T, U>(
				value: T,
				other: U,
			): [T, U];

			export function Push<T>(
				arr: T[],
				other: T[],
			): T[];

			export function Push<T>(
				arr: T[],
				other: T,
			): T[];

			export function PushOrReplace<T>(
				arr: T[],
				other: T,
				evaluate?: System.Func$2<T, boolean>,
			): T[];

			export function ToTypedArray<T>(o: System.Object): T[];

			export function ToTypedArray<T>(
				arr: T[],
				t: System.Type,
			): System.Object;

			export function Spread<T>(
				arr: T[],
				startIndex: number,
				endIndex?: number,
			): T[];

			export function Crawl<T>(
				root: T,
				getChildren: System.Func$2<T, Iterable<T>>,
				visit: System.Action$1<T>,
			): void;

			export function Crawl<T, U>(
				root: T,
				initialContext: U,
				traversalFunc: System.Func$3<T, U, [Iterable<T>, U]>,
				visitorFunc: System.Action$2<T, U>,
			): void;

			export function FilterDefined<T>(arr: T[]): T[];

			export function NotNull<T>(val: T): T;

			export function ReplaceOrAdd<T>(
				list: T[],
				func: System.Func$2<T, boolean>,
				replace: System.Func$2<T, T>,
			): T[];

			export function ReplaceAt(
				source: string,
				index: number,
				len: number,
				newString: string,
			): string;
		}
	}

	export namespace GenParse.Functional.Functional {
		/** Extension methods from {@link GenParse.Functional.Functional} */
		export interface T {
			With<T, U>(other: U): [T, U];
		}
	}

	export namespace System {
		/** Extension methods from {@link GenParse.Functional.Functional} */
		export interface Object {
			ToTypedArray<T>(): T[];
		}
	}

	export namespace GenParse.Functional.Functional {
		/** Extension methods from {@link GenParse.Functional.Functional} */
		export interface T {
			Crawl<T>(
				getChildren: System.Func$2<T, Iterable<T>>,
				visit: System.Action$1<T>,
			): void;
		}
	}

	export namespace GenParse.Functional.Functional {
		/** Extension methods from {@link GenParse.Functional.Functional} */
		export interface T {
			Crawl<T, U>(
				initialContext: U,
				traversalFunc: System.Func$3<T, U, [Iterable<T>, U]>,
				visitorFunc: System.Action$2<T, U>,
			): void;
		}
	}

	export namespace GenParse.Functional.Functional {
		/** Extension methods from {@link GenParse.Functional.Functional} */
		export interface T {
			NotNull<T>(): T;
		}
	}

	export namespace System {
		/** Extension methods from {@link GenParse.Functional.Functional} */
		export interface String {
			ReplaceAt(
				index: number,
				len: number,
				newString: string,
			): string;
		}
	}

	export namespace GenParse.Util {
		export enum CColor {
			Red = 0,
		}
	}

	export namespace GenParse.Util {
		export namespace Formatting {
			export function TreeIndent(indent: number): string;

			export function PrintTree<T>(
				root: T,
				elementName: System.Func$2<T, string>,
				getChildren: System.Func$2<T, Iterable<T>>,
			): string;

			export function PrintTree<T>(
				root: GenParse.Util.Formatting.ITree$1<T>,
				elementName: System.Func$2<GenParse.Util.Formatting.ITree$1<T>, string>,
			): string;

			export function PrintTree<T>(
				root: T,
				elementName: System.Func$2<T, string>,
				getChildren: System.Func$2<T, Iterable<T>>,
				builder: System.Text.StringBuilder,
				indent: number,
			): void;

			export function PrintGrid(
				lines: string[][],
				columnSeparator?: string,
				alignRight?: boolean[],
				eol?: string,
			): string;

			export function Colorize(
				source: string,
				color: GenParse.Util.CColor,
			): string;
		}
	}

	export namespace GenParse.Util.Formatting {
		export function ITree$(T: IType): IType;

		export interface ITree$1<T> {
			GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<T>>;
		}
	}

	export namespace System {
		/** Extension methods from {@link GenParse.Util.Formatting} */
		export interface String {
			Colorize(color: GenParse.Util.CColor): string;
		}
	}

	export namespace GenParse.Util {
		export function Thunk$(T: IType): typeof Thunk$1<any>;

		export class Thunk$1<T> {
			constructor(generator: System.Func$1<T>);
		}
	}

	export namespace GenParse.Parsing {
		export function ASTNode$(LexonType: IType): typeof ASTNode$1<any>;

		export class ASTNode$1<LexonType> {
			constructor(
				name: string,
				productionRule: GenParse.Parsing.ProductionRule$1<LexonType> | undefined,
				children: GenParse.Parsing.ASTNode$1<LexonType>[],
				lexons: GenParse.Lexing.Lexon$1<LexonType>[],
			);

			PrintProgram(): string;

			ToString(): string;
		}
	}

	export namespace GenParse.Parsing {
		export namespace ASTNodeSearchExtensions {
			export function MatchPath<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType> | undefined,
				search: string,
			): GenParse.Parsing.ASTNode$1<LexonType> | undefined;

			export function MatchPath<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType> | undefined,
				search: string[],
			): GenParse.Parsing.ASTNode$1<LexonType> | undefined;

			export function Match<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType> | undefined,
				search: string,
			): GenParse.Parsing.ASTNode$1<LexonType> | undefined;

			export function Match<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType> | undefined,
				search: [string, string],
			): [GenParse.Parsing.ASTNode$1<LexonType> | undefined, GenParse.Parsing.ASTNode$1<LexonType> | undefined];

			export function Match<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType> | undefined,
				search: [string, string, string],
			): [GenParse.Parsing.ASTNode$1<LexonType> | undefined, GenParse.Parsing.ASTNode$1<LexonType> | undefined, GenParse.Parsing.ASTNode$1<LexonType> | undefined];

			export function TryMatch<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType> | undefined,
				search: string,
			): GenParse.Parsing.ASTNode$1<LexonType> | undefined;

			export function TryMatch<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType> | undefined,
				search: [string, string],
			): [GenParse.Parsing.ASTNode$1<LexonType>, GenParse.Parsing.ASTNode$1<LexonType>] | undefined;

			export function TryMatch<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType> | undefined,
				search: [string, string, string],
			): [GenParse.Parsing.ASTNode$1<LexonType>, GenParse.Parsing.ASTNode$1<LexonType>, GenParse.Parsing.ASTNode$1<LexonType>] | undefined;

			export function TryMatch<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType> | undefined,
				search: [string, string, string, string],
			): [GenParse.Parsing.ASTNode$1<LexonType>, GenParse.Parsing.ASTNode$1<LexonType>, GenParse.Parsing.ASTNode$1<LexonType>, GenParse.Parsing.ASTNode$1<LexonType>] | undefined;

			export function TryMatch<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType> | undefined,
				search: string[],
			): GenParse.Parsing.ASTNode$1<LexonType>[] | undefined;

			export function MatchAll<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType>,
				search: string,
			): GenParse.Parsing.ASTNode$1<LexonType>[];

			export function MatchAll<LexonType>(
				node: GenParse.Parsing.ASTNode$1<LexonType>,
				search: string[],
			): GenParse.Parsing.ASTNode$1<LexonType>[];
		}
	}

	export namespace GenParse.Parsing {
		export function ParseContext$(LexonType: IType): typeof ParseContext$1<any>;

		export class ParseContext$1<LexonType> {
			constructor(productionSets: ReadonlyMap<string, GenParse.Parsing.ProductionSet$1<LexonType>>);

			ToString(): string;
		}
	}

	export namespace GenParse.Parsing {
		export function Parser$(LexonType: IType): typeof Parser$1<any>;

		export class Parser$1<LexonType> {
			constructor(context: GenParse.Parsing.ParseContext$1<LexonType>);

			Parse(
				rootSymbol: string,
				lexons: GenParse.Lexing.Lexon$1<LexonType>[],
				forgiving?: boolean,
			): GenParse.Parsing.ASTNode$1<LexonType> | undefined;

			ToString(): string;

			ComputeHead(grammarElementName: string): LexonType[];
		}
	}

	export namespace GenParse.Parsing {
		export function ParseResult$(LexonType: IType): typeof ParseResult$1<any>;

		export class ParseResult$1<LexonType> {
			constructor(
				astNode: GenParse.Parsing.ASTNode$1<LexonType>,
				lexonsConsumed: number,
			);
		}
	}

	export namespace GenParse.Parsing {
		export function ProductionRule$(LexonType: IType): typeof ProductionRule$1<any>;

		export class ProductionRule$1<LexonType> {
			constructor(
				name: string,
				symbols: GenParse.Parsing.ProductionSymbol$1<LexonType>[],
			);

			ToString(): string;
		}
	}

	export namespace GenParse.Parsing {
		export function ProductionSet$(LexonType: IType): typeof ProductionSet$1<any>;

		export class ProductionSet$1<LexonType> {
			constructor(rules: GenParse.Parsing.ProductionRule$1<LexonType>[]);

			ToString(): string;
		}
	}

	export namespace GenParse.Parsing {
		export function ProductionSymbol$(LexonType: IType): typeof ProductionSymbol$1<any>;

		export class ProductionSymbol$1<LexonType> {
			constructor(
				name: string,
				lexonType: LexonType,
				modifier: System.Char | undefined,
			);

			readonly NameWithMod: string;

			readonly isLexon: boolean;

			ToString(): string;
		}
	}

	export namespace GenParse.Lexing {
		export namespace Lexer {
			export function Lex<TLexon, TLexonType>(
				code: string,
				rules: [TLexonType, unknown][],
				lexonConstructor: System.Func$4<TLexonType, string, number, TLexon>,
			): TLexon[];
		}
	}

	export namespace GenParse.Lexing {
		export function Lexon$(LexonType: IType): typeof Lexon$1<any>;

		export class Lexon$1<LexonType> {
			constructor(
				lexonType: LexonType,
				sourceCode: string,
				isSemantic: boolean,
				index: number,
			);

			readonly length: number;

			ToString(): string;
		}
	}

	export namespace GenParse.Grammar {
		export enum GrammarLexonType {
			comment = 0,

			whitespace = 1,

			name = 2,

			equalSign = 3,

			semicolon = 4,

			modifierCharacter = 5,
		}
	}

	export namespace GenParse.Grammar {
		export class GrammarParser {
			constructor();

			static ParseGrammar<LanguageLexonType>(
				sourceFiles: string[],
				stringToLexon: System.Func$2<string, LanguageLexonType>,
			): GenParse.Parsing.ParseContext$1<LanguageLexonType>;
		}
	}
}
