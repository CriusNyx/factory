// Generated for: System.Runtime 8.0.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.8.0.0
/* eslint-disable */

declare namespace js { type DateTime = Date & { kind?: 'utc' | 'local' | 'unspecified' } }

declare namespace js { type DateTimeOffset = Date & { offset?: number } }

import { Duplex } from 'stream';

interface IDisposable { dispose(): void; }

/** A JavaScript projection of a .NET type. */
interface IType {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): IType;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace System {
		/**
		 * The exception that is thrown when there is an attempt to read or write protected
		 * memory.
		 */
		export class AccessViolationException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.AccessViolationException} class with a
			 * system-supplied message that describes the error.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.AccessViolationException} class with a
			 * specified message that describes the error.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.AccessViolationException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Encapsulates a method that has no parameters and does not return a value. */
		export interface Action { (): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has a single parameter and does not
		 * return a value.
		 */
		export function Action$(T: IType): IType;

		/** Encapsulates a method that has a single parameter and does not return a value. */
		export interface Action$1<T> { (obj: T): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 10 parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType): IType;

		/** Encapsulates a method that has 10 parameters and does not return a value. */
		export interface Action$10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 11 parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType): IType;

		/** Encapsulates a method that has 11 parameters and does not return a value. */
		export interface Action$11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 12 parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, T12: IType): IType;

		/** Encapsulates a method that has 12 parameters and does not return a value. */
		export interface Action$12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
			arg12: T12,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 13 parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, T12: IType, T13: IType): IType;

		/** Encapsulates a method that has 13 parameters and does not return a value. */
		export interface Action$13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
			arg12: T12,
			arg13: T13,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 14 parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, T12: IType, T13: IType, T14: IType): IType;

		/** Encapsulates a method that has 14 parameters and does not return a value. */
		export interface Action$14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
			arg12: T12,
			arg13: T13,
			arg14: T14,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 15 parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, T12: IType, T13: IType, T14: IType, T15: IType): IType;

		/** Encapsulates a method that has 15 parameters and does not return a value. */
		export interface Action$15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
			arg12: T12,
			arg13: T13,
			arg14: T14,
			arg15: T15,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 16 parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, T12: IType, T13: IType, T14: IType, T15: IType, T16: IType): IType;

		/** Encapsulates a method that has 16 parameters and does not return a value. */
		export interface Action$16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
			arg12: T12,
			arg13: T13,
			arg14: T14,
			arg15: T15,
			arg16: T16,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has two parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType): IType;

		/** Encapsulates a method that has two parameters and does not return a value. */
		export interface Action$2<T1, T2> { (
			arg1: T1,
			arg2: T2,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has three parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType): IType;

		/** Encapsulates a method that has three parameters and does not return a value. */
		export interface Action$3<T1, T2, T3> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has four parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType): IType;

		/** Encapsulates a method that has four parameters and does not return a value. */
		export interface Action$4<T1, T2, T3, T4> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has five parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType): IType;

		/** Encapsulates a method that has five parameters and does not return a value. */
		export interface Action$5<T1, T2, T3, T4, T5> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has six parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType): IType;

		/** Encapsulates a method that has six parameters and does not return a value. */
		export interface Action$6<T1, T2, T3, T4, T5, T6> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has seven parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType): IType;

		/** Encapsulates a method that has seven parameters and does not return a value. */
		export interface Action$7<T1, T2, T3, T4, T5, T6, T7> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has eight parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType): IType;

		/** Encapsulates a method that has eight parameters and does not return a value. */
		export interface Action$8<T1, T2, T3, T4, T5, T6, T7, T8> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has nine parameters and does not
		 * return a value.
		 */
		export function Action$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType): IType;

		/** Encapsulates a method that has nine parameters and does not return a value. */
		export interface Action$9<T1, T2, T3, T4, T5, T6, T7, T8, T9> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
		): void; }
	}

	export namespace System {
		/**
		 * Contains methods to create types of objects locally or remotely, or obtain references
		 * to existing remote objects. This class cannot be inherited.
		 */
		export namespace Activator {
			/**
			 * Creates an instance of the type whose name is specified, using the named assembly and
			 * parameterless constructor.
			 */
			export function CreateInstance(
				assemblyName: string,
				typeName: string,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates an instance of the type whose name is specified, using the named assembly and
			 * the constructor that best matches the specified parameters.
			 */
			export function CreateInstance(
				assemblyName: string,
				typeName: string,
				ignoreCase: boolean,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				args: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates an instance of the type whose name is specified, using the named assembly and
			 * parameterless constructor.
			 */
			export function CreateInstance(
				assemblyName: string,
				typeName: string,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates an instance of the specified type using that type's parameterless constructor.
			 */
			export function CreateInstance(type: System.Type): System.Object | undefined;

			/**
			 * Creates an instance of the specified type using that type's parameterless constructor.
			 */
			export function CreateInstance(
				type: System.Type,
				nonPublic: boolean,
			): System.Object | undefined;

			/**
			 * Creates an instance of the specified type using the constructor that best matches the
			 * specified parameters.
			 */
			export function CreateInstance(
				type: System.Type,
				args: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * Creates an instance of the specified type using the constructor that best matches the
			 * specified parameters.
			 */
			export function CreateInstance(
				type: System.Type,
				args: System.Object | undefined[] | undefined,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * Creates an instance of the specified type using the constructor that best matches the
			 * specified parameters.
			 */
			export function CreateInstance(
				type: System.Type,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				args: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
			): System.Object | undefined;

			/**
			 * Creates an instance of the specified type using the constructor that best matches the
			 * specified parameters.
			 */
			export function CreateInstance(
				type: System.Type,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				args: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * Creates an instance of the type whose name is specified, using the named assembly file
			 * and parameterless constructor.
			 */
			export function CreateInstanceFrom(
				assemblyFile: string,
				typeName: string,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates an instance of the type whose name is specified, using the named assembly file
			 * and the constructor that best matches the specified parameters.
			 */
			export function CreateInstanceFrom(
				assemblyFile: string,
				typeName: string,
				ignoreCase: boolean,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				args: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates an instance of the type whose name is specified, using the named assembly file
			 * and parameterless constructor.
			 */
			export function CreateInstanceFrom(
				assemblyFile: string,
				typeName: string,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates an instance of the type designated by the specified generic type parameter,
			 * using the parameterless constructor.
			 */
			export function CreateInstance<T>(): T;
		}
	}

	export namespace System {
		/** Represents one or more errors that occur during application execution. */
		export class AggregateException extends System.Exception {
			/**
			 * Initializes a new instance of the {@link System.AggregateException} class with a
			 * system-supplied message that describes the error.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.AggregateException} class with
			 * references to the inner exceptions that are the cause of this exception.
			 */
			constructor(innerExceptions: Iterable<System.Exception>);

			/**
			 * Initializes a new instance of the {@link System.AggregateException} class with
			 * references to the inner exceptions that are the cause of this exception.
			 */
			constructor(innerExceptions: System.Exception[]);

			/**
			 * Initializes a new instance of the {@link System.AggregateException} class with a
			 * specified message that describes the error.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.AggregateException} class with a
			 * specified error message and references to the inner exceptions that are the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerExceptions: Iterable<System.Exception>,
			);

			/**
			 * Initializes a new instance of the {@link System.AggregateException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception,
			);

			/**
			 * Initializes a new instance of the {@link System.AggregateException} class with a
			 * specified error message and references to the inner exceptions that are the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerExceptions: System.Exception[],
			);

			/**
			 * Gets a read-only collection of the {@link System.Exception} instances that caused the
			 * current exception.
			 */
			readonly InnerExceptions: readonly System.Exception[];

			/** Gets a message that describes the exception. */
			readonly Message: string;

			/**
			 * Flattens an {@link System.AggregateException} instances into a single, new instance.
			 */
			Flatten(): System.AggregateException;

			/**
			 * Returns the {@link System.AggregateException} that is the root cause of this
			 * exception.
			 */
			GetBaseException(): System.Exception;

			/**
			 * Invokes a handler on each {@link System.Exception} contained by this
			 * {@link System.AggregateException}.
			 */
			Handle(predicate: System.Func$2<System.Exception, boolean>): void;

			/**
			 * Creates and returns a string representation of the current
			 * {@link System.AggregateException}.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** Provides members for setting and retrieving data about an application's context. */
		export namespace AppContext {
			/**
			 * Gets the file path of the base directory that the assembly resolver uses to probe for
			 * assemblies.
			 */
			export const BaseDirectory: string;

			/** Gets the name of the framework version targeted by the current application. */
			export const TargetFrameworkName: string | undefined;

			/**
			 * Returns the value of the named data element assigned to the current application
			 * domain.
			 */
			export function GetData(name: string): System.Object | undefined;

			/**
			 * Sets the value of the named data element assigned to the current application domain.
			 */
			export function SetData(
				name: string,
				data: System.Object | undefined,
			): void;

			/** Sets the value of a switch. */
			export function SetSwitch(
				switchName: string,
				isEnabled: boolean,
			): void;

			export function TryGetSwitch(switchName: string): boolean | undefined;
		}
	}

	export namespace System {
		/**
		 * Represents an application domain, which is an isolated environment where applications
		 * execute. This class cannot be inherited.
		 */
		export class AppDomain extends System.MarshalByRefObject {
			/** Gets the base directory that the assembly resolver uses to probe for assemblies. */
			readonly BaseDirectory: string;

			/**
			 * Gets the current application domain for the current {@link System.Threading.Thread}.
			 */
			static readonly CurrentDomain: System.AppDomain;

			/**
			 * Gets the directory that the assembly resolver uses to probe for dynamically created
			 * assemblies.
			 */
			readonly DynamicDirectory?: string;

			/** Gets the friendly name of this application domain. */
			readonly FriendlyName: string;

			/**
			 * Gets an integer that uniquely identifies the application domain within the process.
			 */
			readonly Id: number;

			/**
			 * Gets a value that indicates whether assemblies that are loaded into the current
			 * application domain execute with full trust.
			 */
			readonly IsFullyTrusted: boolean;

			/**
			 * Gets a value that indicates whether the current application domain has a set of
			 * permissions that is granted to all assemblies that are loaded into the application
			 * domain.
			 */
			readonly IsHomogenous: boolean;

			/**
			 * Gets or sets a value that indicates whether CPU and memory monitoring of application
			 * domains is enabled for the current process. Once monitoring is enabled for a process,
			 * it cannot be disabled.
			 */
			static MonitoringIsEnabled: boolean;

			/**
			 * Gets the number of bytes that survived the last collection and that are known to be
			 * referenced by the current application domain.
			 */
			readonly MonitoringSurvivedMemorySize: number;

			/**
			 * Gets the total bytes that survived from the last collection for all application
			 * domains in the process.
			 */
			static readonly MonitoringSurvivedProcessMemorySize: number;

			/**
			 * Gets the total size, in bytes, of all memory allocations that have been made by the
			 * application domain since it was created, without subtracting memory that has been
			 * collected.
			 */
			readonly MonitoringTotalAllocatedMemorySize: number;

			/**
			 * Gets the total processor time that has been used by all threads while executing in the
			 * current application domain, since the process started.
			 */
			readonly MonitoringTotalProcessorTime: number;

			/** Gets the permission set of a sandboxed application domain. */
			readonly PermissionSet: System.Security.PermissionSet;

			/**
			 * Gets the path under the base directory where the assembly resolver should probe for
			 * private assemblies.
			 */
			readonly RelativeSearchPath?: string;

			/** Gets the application domain configuration information for this instance. */
			readonly SetupInformation: System.AppDomainSetup;

			/**
			 * Gets an indication whether the application domain is configured to shadow copy files.
			 */
			readonly ShadowCopyFiles: boolean;

			/** Appends the specified directory name to the private path list. */
			AppendPrivatePath(path: string | undefined): void;

			/** Returns the assembly display name after policy has been applied. */
			ApplyPolicy(assemblyName: string): string;

			/**
			 * Resets the path that specifies the location of private assemblies to the empty string
			 * ("").
			 */
			ClearPrivatePath(): void;

			/**
			 * Resets the list of directories containing shadow copied assemblies to the empty string
			 * ("").
			 */
			ClearShadowCopyPath(): void;

			/** Creates a new application domain with the specified name. */
			static CreateDomain(friendlyName: string): System.AppDomain;

			/** Creates a new instance of the specified type defined in the specified assembly. */
			CreateInstance(
				assemblyName: string,
				typeName: string,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates a new instance of the specified type defined in the specified assembly.
			 * Parameters specify a binder, binding flags, constructor arguments, culture-specific
			 * information used to interpret arguments, and optional activation attributes.
			 */
			CreateInstance(
				assemblyName: string,
				typeName: string,
				ignoreCase: boolean,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				args: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates a new instance of the specified type defined in the specified assembly. A
			 * parameter specifies an array of activation attributes.
			 */
			CreateInstance(
				assemblyName: string,
				typeName: string,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates a new instance of the specified type. Parameters specify the assembly where
			 * the type is defined, and the name of the type.
			 */
			CreateInstanceAndUnwrap(
				assemblyName: string,
				typeName: string,
			): System.Object | undefined;

			/**
			 * Creates a new instance of the specified type defined in the specified assembly,
			 * specifying whether the case of the type name is ignored; the binding attributes and
			 * the binder that are used to select the type to be created; the arguments of the
			 * constructor; the culture; and the activation attributes.
			 */
			CreateInstanceAndUnwrap(
				assemblyName: string,
				typeName: string,
				ignoreCase: boolean,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				args: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * Creates a new instance of the specified type. Parameters specify the assembly where
			 * the type is defined, the name of the type, and an array of activation attributes.
			 */
			CreateInstanceAndUnwrap(
				assemblyName: string,
				typeName: string,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * Creates a new instance of the specified type defined in the specified assembly file.
			 */
			CreateInstanceFrom(
				assemblyFile: string,
				typeName: string,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates a new instance of the specified type defined in the specified assembly file.
			 */
			CreateInstanceFrom(
				assemblyFile: string,
				typeName: string,
				ignoreCase: boolean,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				args: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates a new instance of the specified type defined in the specified assembly file.
			 */
			CreateInstanceFrom(
				assemblyFile: string,
				typeName: string,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Runtime.Remoting.ObjectHandle | undefined;

			/**
			 * Creates a new instance of the specified type defined in the specified assembly file.
			 */
			CreateInstanceFromAndUnwrap(
				assemblyFile: string,
				typeName: string,
			): System.Object | undefined;

			/**
			 * Creates a new instance of the specified type defined in the specified assembly file,
			 * specifying whether the case of the type name is ignored; the binding attributes and
			 * the binder that are used to select the type to be created; the arguments of the
			 * constructor; the culture; and the activation attributes.
			 */
			CreateInstanceFromAndUnwrap(
				assemblyFile: string,
				typeName: string,
				ignoreCase: boolean,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				args: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * Creates a new instance of the specified type defined in the specified assembly file.
			 */
			CreateInstanceFromAndUnwrap(
				assemblyFile: string,
				typeName: string,
				activationAttributes: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/** Executes the assembly contained in the specified file. */
			ExecuteAssembly(assemblyFile: string): number;

			/**
			 * Executes the assembly contained in the specified file, using the specified arguments.
			 */
			ExecuteAssembly(
				assemblyFile: string,
				args: string | undefined[] | undefined,
			): number;

			/**
			 * Executes the assembly contained in the specified file, using the specified arguments,
			 * hash value, and hash algorithm.
			 */
			ExecuteAssembly(
				assemblyFile: string,
				args: string | undefined[] | undefined,
				hashValue: number[] | undefined,
				hashAlgorithm: System.Configuration.Assemblies.AssemblyHashAlgorithm,
			): number;

			/**
			 * Executes the assembly given an {@link System.Reflection.AssemblyName}, using the
			 * specified arguments.
			 */
			ExecuteAssemblyByName(
				assemblyName: System.Reflection.AssemblyName,
				args: string | undefined[] | undefined,
			): number;

			/** Executes an assembly given its display name. */
			ExecuteAssemblyByName(assemblyName: string): number;

			/** Executes the assembly given its display name, using the specified arguments. */
			ExecuteAssemblyByName(
				assemblyName: string,
				args: string | undefined[] | undefined,
			): number;

			/**
			 * Gets the assemblies that have been loaded into the execution context of this
			 * application domain.
			 */
			GetAssemblies(): System.Reflection.Assembly[];

			/** Gets the current thread identifier. */
			static GetCurrentThreadId(): number;

			/** Gets the value stored in the current application domain for the specified name. */
			GetData(name: string): System.Object | undefined;

			/**
			 * Gets a nullable Boolean value that indicates whether any compatibility switches are
			 * set, and if so, whether the specified compatibility switch is set.
			 */
			IsCompatibilitySwitchSet(value: string): boolean | undefined;

			/**
			 * Returns a value that indicates whether the application domain is the default
			 * application domain for the process.
			 */
			IsDefaultAppDomain(): boolean;

			/**
			 * Indicates whether this application domain is unloading, and the objects it contains
			 * are being finalized by the common language runtime.
			 */
			IsFinalizingForUnload(): boolean;

			/**
			 * Loads the {@link System.Reflection.Assembly} with a common object file format (COFF)
			 * based image containing an emitted {@link System.Reflection.Assembly}.
			 */
			Load(rawAssembly: number[]): System.Reflection.Assembly;

			/**
			 * Loads the {@link System.Reflection.Assembly} with a common object file format (COFF)
			 * based image containing an emitted {@link System.Reflection.Assembly}. The raw bytes
			 * representing the symbols for the {@link System.Reflection.Assembly} are also loaded.
			 */
			Load(
				rawAssembly: number[],
				rawSymbolStore: number[] | undefined,
			): System.Reflection.Assembly;

			/**
			 * Loads an {@link System.Reflection.Assembly} given its
			 * {@link System.Reflection.AssemblyName}.
			 */
			Load(assemblyRef: System.Reflection.AssemblyName): System.Reflection.Assembly;

			/** Loads an {@link System.Reflection.Assembly} given its display name. */
			Load(assemblyString: string): System.Reflection.Assembly;

			/**
			 * Returns the assemblies that have been loaded into the reflection-only context of the
			 * application domain.
			 */
			ReflectionOnlyGetAssemblies(): System.Reflection.Assembly[];

			/**
			 * Establishes the specified directory path as the location where assemblies are shadow
			 * copied.
			 */
			SetCachePath(path: string | undefined): void;

			/** Assigns the specified value to the specified application domain property. */
			SetData(
				name: string,
				data: System.Object | undefined,
			): void;

			/**
			 * Establishes the specified directory path as the base directory for subdirectories
			 * where dynamically generated files are stored and accessed.
			 */
			SetDynamicBase(path: string | undefined): void;

			/**
			 * Specifies how principal and identity objects should be attached to a thread if the
			 * thread attempts to bind to a principal while executing in this application domain.
			 */
			SetPrincipalPolicy(policy: System.Security.Principal.PrincipalPolicy): void;

			/** Turns on shadow copying. */
			SetShadowCopyFiles(): void;

			/**
			 * Establishes the specified directory path as the location of assemblies to be shadow
			 * copied.
			 */
			SetShadowCopyPath(path: string | undefined): void;

			/**
			 * Sets the default principal object to be attached to threads if they attempt to bind to
			 * a principal while executing in this application domain.
			 */
			SetThreadPrincipal(principal: System.Security.Principal.IPrincipal): void;

			/**
			 * Obtains a string representation that includes the friendly name of the application
			 * domain and any context policies.
			 */
			ToString(): string;

			/** Unloads the specified application domain. */
			static Unload(domain: System.AppDomain): void;
		}
	}

	export namespace System {
		/**
		 * Represents assembly binding information that can be added to an instance of
		 * {@link System.AppDomain}.
		 */
		export class AppDomainSetup {
			/** Gets the name of the directory containing the application. */
			readonly ApplicationBase?: string;

			/**
			 * Gets (or, in .NET Framework, sets) a string that specifies the target framework in a
			 * format that can be parsed by the
			 * {@link System.Runtime.Versioning.FrameworkName.#ctor(System.String)} constructor.
			 */
			readonly TargetFrameworkName?: string;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an attempt is made to access an unloaded application
		 * domain.
		 */
		export class AppDomainUnloadedException extends System.SystemException {
			/** Initializes a new instance of the {@link System.AppDomainUnloadedException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.AppDomainUnloadedException} class with
			 * a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.AppDomainUnloadedException} class with
			 * a specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Serves as the base class for application-defined exceptions. */
		export class ApplicationException extends System.Exception {
			/** Initializes a new instance of the {@link System.ApplicationException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.ApplicationException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ApplicationException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * Contains information used to uniquely identify a manifest-based application. This
		 * class cannot be inherited.
		 */
		export class ApplicationId {
			/** Initializes a new instance of the {@link System.ApplicationId} class. */
			constructor(
				publicKeyToken: number[],
				name: string,
				version: System.Version,
				processorArchitecture: string | undefined,
				culture: string | undefined,
			);

			/** Gets a string representing the culture information for the application. */
			readonly Culture?: string;

			/** Gets the name of the application. */
			readonly Name: string;

			/** Gets the target processor architecture for the application. */
			readonly ProcessorArchitecture?: string;

			/** Gets the public key token for the application. */
			readonly PublicKeyToken: number[];

			/** Gets the version of the application. */
			readonly Version: System.Version;

			/** Creates and returns an identical copy of the current application identity. */
			Copy(): System.ApplicationId;

			/**
			 * Determines whether the specified {@link System.ApplicationId} object is equivalent to
			 * the current {@link System.ApplicationId}.
			 */
			Equals(o: System.Object | undefined): boolean;

			/** Gets the hash code for the current application identity. */
			GetHashCode(): number;

			/** Creates and returns a string representation of the application identity. */
			ToString(): string;
		}
	}

	export namespace System {
		/**
		 * Represents a variable-length argument list; that is, the parameters of a function that
		 * takes a variable number of arguments.
		 */
		export class ArgIterator extends System.ValueType {
			/**
			 * Initializes a new instance of the {@link System.ArgIterator} structure using the
			 * specified argument list.
			 */
			constructor(arglist: System.RuntimeArgumentHandle);

			/**
			 * Concludes processing of the variable-length argument list represented by this
			 * instance.
			 */
			End(): void;

			/**
			 * This method is not supported, and always throws {@link System.NotSupportedException}.
			 */
			Equals(o: System.Object | undefined): boolean;

			/** Returns the hash code of this object. */
			GetHashCode(): number;

			/** Returns the next argument in a variable-length argument list. */
			GetNextArg(): System.TypedReference;

			/**
			 * Returns the next argument in a variable-length argument list that has a specified
			 * type.
			 */
			GetNextArg(rth: System.RuntimeTypeHandle): System.TypedReference;

			/** Returns the type of the next argument. */
			GetNextArgType(): System.RuntimeTypeHandle;

			/** Returns the number of arguments remaining in the argument list. */
			GetRemainingCount(): number;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when one of the arguments provided to a method is not
		 * valid.
		 */
		export class ArgumentException extends System.SystemException {
			/** Initializes a new instance of the {@link System.ArgumentException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.ArgumentException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ArgumentException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.ArgumentException} class with a
			 * specified error message and the name of the parameter that causes this exception.
			 */
			constructor(
				message: string | undefined,
				paramName: string | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.ArgumentException} class with a
			 * specified error message, the parameter name, and a reference to the inner exception
			 * that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				paramName: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Gets the error message and the parameter name, or only the error message if no
			 * parameter name is set.
			 */
			readonly Message: string;

			/** Gets the name of the parameter that causes this exception. */
			readonly ParamName?: string;

			/** Throws an exception if `argument` is `null` or empty. */
			static ThrowIfNullOrEmpty(
				argument: string,
				paramName?: string,
			): void;

			/**
			 * Throws an exception if `argument` is `null`, empty, or consists only of white-space
			 * characters.
			 */
			static ThrowIfNullOrWhiteSpace(
				argument: string,
				paramName?: string,
			): void;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when a null reference ( `Nothing` in Visual Basic) is
		 * passed to a method that does not accept it as a valid argument.
		 */
		export class ArgumentNullException extends System.ArgumentException {
			/** Initializes a new instance of the {@link System.ArgumentNullException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.ArgumentNullException} class with the
			 * name of the parameter that causes this exception.
			 */
			constructor(paramName: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ArgumentNullException} class with a
			 * specified error message and the exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes an instance of the {@link System.ArgumentNullException} class with a
			 * specified error message and the name of the parameter that causes this exception.
			 */
			constructor(
				paramName: string | undefined,
				message: string | undefined,
			);

			/** Throws an {@link System.ArgumentNullException} if `argument` is `null`. */
			static ThrowIfNull(
				argument: System.Object,
				paramName?: string,
			): void;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when the value of an argument is outside the allowable
		 * range of values as defined by the invoked method.
		 */
		export class ArgumentOutOfRangeException extends System.ArgumentException {
			/**
			 * Initializes a new instance of the {@link System.ArgumentOutOfRangeException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.ArgumentOutOfRangeException} class
			 * with the name of the parameter that causes this exception.
			 */
			constructor(paramName: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ArgumentOutOfRangeException} class
			 * with a specified error message and the exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.ArgumentOutOfRangeException} class
			 * with the parameter name, the value of the argument, and a specified error message.
			 */
			constructor(
				paramName: string | undefined,
				actualValue: System.Object | undefined,
				message: string | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.ArgumentOutOfRangeException} class
			 * with the name of the parameter that causes this exception and a specified error
			 * message.
			 */
			constructor(
				paramName: string | undefined,
				message: string | undefined,
			);

			/** Gets the argument value that causes this exception. */
			readonly ActualValue?: System.Object;

			/**
			 * Gets the error message and the string representation of the invalid argument value, or
			 * only the error message if the argument value is null.
			 */
			readonly Message: string;

			/**
			 * Throws an {@link System.ArgumentOutOfRangeException} if `value` is equal to `other`.
			 */
			static ThrowIfEqual<T>(
				value: T,
				other: T,
				paramName?: string,
			): void;

			/**
			 * Throws an {@link System.ArgumentOutOfRangeException} if `value` is greater than
			 * `other`.
			 */
			static ThrowIfGreaterThan<T>(
				value: T,
				other: T,
				paramName?: string,
			): void;

			/**
			 * Throws an {@link System.ArgumentOutOfRangeException} if `value` is greater than or
			 * equal to `other`.
			 */
			static ThrowIfGreaterThanOrEqual<T>(
				value: T,
				other: T,
				paramName?: string,
			): void;

			/**
			 * Throws an {@link System.ArgumentOutOfRangeException} if `value` is less than `other`.
			 */
			static ThrowIfLessThan<T>(
				value: T,
				other: T,
				paramName?: string,
			): void;

			/**
			 * Throws an {@link System.ArgumentOutOfRangeException} if `value` is less than or equal
			 * to `other`.
			 */
			static ThrowIfLessThanOrEqual<T>(
				value: T,
				other: T,
				paramName?: string,
			): void;

			/** Throws an {@link System.ArgumentOutOfRangeException} if `value` is negative. */
			static ThrowIfNegative<T>(
				value: T,
				paramName?: string,
			): void;

			/**
			 * Throws an {@link System.ArgumentOutOfRangeException} if `value` is negative or zero.
			 */
			static ThrowIfNegativeOrZero<T>(
				value: T,
				paramName?: string,
			): void;

			/**
			 * Throws an {@link System.ArgumentOutOfRangeException} if `value` is not equal to
			 * `other`.
			 */
			static ThrowIfNotEqual<T>(
				value: T,
				other: T,
				paramName?: string,
			): void;

			/** Throws an {@link System.ArgumentOutOfRangeException} if `value` is zero. */
			static ThrowIfZero<T>(
				value: T,
				paramName?: string,
			): void;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown for errors in an arithmetic, casting, or conversion
		 * operation.
		 */
		export class ArithmeticException extends System.SystemException {
			/** Initializes a new instance of the {@link System.ArithmeticException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.ArithmeticException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ArithmeticException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * Provides methods for creating, manipulating, searching, and sorting arrays, thereby
		 * serving as the base class for all arrays in the common language runtime.
		 */
		export class Array implements
			System.Collections.IEnumerable,
			System.ICloneable {
			/** Gets a value indicating whether the {@link System.Array} has a fixed size. */
			readonly IsFixedSize: boolean;

			/** Gets a value indicating whether the {@link System.Array} is read-only. */
			readonly IsReadOnly: boolean;

			/**
			 * Gets a value indicating whether access to the {@link System.Array} is synchronized
			 * (thread safe).
			 */
			readonly IsSynchronized: boolean;

			/**
			 * Gets the total number of elements in all the dimensions of the {@link System.Array}.
			 */
			readonly Length: number;

			/**
			 * Gets a 64-bit integer that represents the total number of elements in all the
			 * dimensions of the {@link System.Array}.
			 */
			readonly LongLength: number;

			/** Gets the maximum number of elements that may be contained in an array. */
			static readonly MaxLength: number;

			/**
			 * Gets the rank (number of dimensions) of the {@link System.Array}. For example, a
			 * one-dimensional array returns 1, a two-dimensional array returns 2, and so on.
			 */
			readonly Rank: number;

			/** Gets an object that can be used to synchronize access to the {@link System.Array}. */
			readonly SyncRoot: System.Object;

			static AsReadOnly<T>(array: T[]): readonly T[];

			/**
			 * Searches a range of elements in a one-dimensional sorted array for a value, using the
			 * {@link System.IComparable} interface implemented by each element of the array and by
			 * the specified value.
			 */
			static BinarySearch(
				array: System.Array,
				index: number,
				length: number,
				value: System.Object | undefined,
			): number;

			/**
			 * Searches a range of elements in a one-dimensional sorted array for a value, using the
			 * specified {@link System.Collections.IComparer} interface.
			 */
			static BinarySearch(
				array: System.Array,
				index: number,
				length: number,
				value: System.Object | undefined,
				comparer: System.Collections.IComparer | undefined,
			): number;

			/**
			 * Searches an entire one-dimensional sorted array for a specific element, using the
			 * {@link System.IComparable} interface implemented by each element of the array and by
			 * the specified object.
			 */
			static BinarySearch(
				array: System.Array,
				value: System.Object | undefined,
			): number;

			/**
			 * Searches an entire one-dimensional sorted array for a value using the specified
			 * {@link System.Collections.IComparer} interface.
			 */
			static BinarySearch(
				array: System.Array,
				value: System.Object | undefined,
				comparer: System.Collections.IComparer | undefined,
			): number;

			static BinarySearch<T>(
				array: T[],
				index: number,
				length: number,
				value: T,
			): number;

			static BinarySearch<T>(
				array: T[],
				index: number,
				length: number,
				value: T,
				comparer: System.Collections.Generic.IComparer$1<T> | undefined,
			): number;

			static BinarySearch<T>(
				array: T[],
				value: T,
			): number;

			static BinarySearch<T>(
				array: T[],
				value: T,
				comparer: System.Collections.Generic.IComparer$1<T> | undefined,
			): number;

			/** Clears the contents of an array. */
			static Clear(array: System.Array): void;

			/** Sets a range of elements in an array to the default value of each element type. */
			static Clear(
				array: System.Array,
				index: number,
				length: number,
			): void;

			/** Creates a shallow copy of the {@link System.Array}. */
			Clone(): System.Object;

			/**
			 * Copies a range of elements from an {@link System.Array} starting at the specified
			 * source index and pastes them to another {@link System.Array} starting at the specified
			 * destination index.  Guarantees that all changes are undone if the copy does not
			 * succeed completely.
			 */
			static ConstrainedCopy(
				sourceArray: System.Array,
				sourceIndex: number,
				destinationArray: System.Array,
				destinationIndex: number,
				length: number,
			): void;

			static ConvertAll<TInput, TOutput>(
				array: TInput[],
				converter: System.Converter$2<TInput, TOutput>,
			): TOutput[];

			/**
			 * Copies a range of elements from an {@link System.Array} starting at the first element
			 * and pastes them into another {@link System.Array} starting at the first element. The
			 * length is specified as a 32-bit integer.
			 */
			static Copy(
				sourceArray: System.Array,
				destinationArray: System.Array,
				length: number,
			): void;

			/**
			 * Copies a range of elements from an {@link System.Array} starting at the first element
			 * and pastes them into another {@link System.Array} starting at the first element. The
			 * length is specified as a 64-bit integer.
			 */
			static Copy(
				sourceArray: System.Array,
				destinationArray: System.Array,
				length: number,
			): void;

			/**
			 * Copies a range of elements from an {@link System.Array} starting at the specified
			 * source index and pastes them to another {@link System.Array} starting at the specified
			 * destination index. The length and the indexes are specified as 32-bit integers.
			 */
			static Copy(
				sourceArray: System.Array,
				sourceIndex: number,
				destinationArray: System.Array,
				destinationIndex: number,
				length: number,
			): void;

			/**
			 * Copies a range of elements from an {@link System.Array} starting at the specified
			 * source index and pastes them to another {@link System.Array} starting at the specified
			 * destination index. The length and the indexes are specified as 64-bit integers.
			 */
			static Copy(
				sourceArray: System.Array,
				sourceIndex: number,
				destinationArray: System.Array,
				destinationIndex: number,
				length: number,
			): void;

			/**
			 * Copies all the elements of the current one-dimensional array to the specified
			 * one-dimensional array starting at the specified destination array index. The index is
			 * specified as a 32-bit integer.
			 */
			CopyTo(
				array: System.Array,
				index: number,
			): void;

			/**
			 * Copies all the elements of the current one-dimensional array to the specified
			 * one-dimensional array starting at the specified destination array index. The index is
			 * specified as a 64-bit integer.
			 */
			CopyTo(
				array: System.Array,
				index: number,
			): void;

			/**
			 * Creates a one-dimensional {@link System.Array} of the specified {@link System.Type}
			 * and length, with zero-based indexing.
			 */
			static CreateInstance(
				elementType: System.Type,
				length: number,
			): System.Array;

			/**
			 * Creates a two-dimensional {@link System.Array} of the specified {@link System.Type}
			 * and dimension lengths, with zero-based indexing.
			 */
			static CreateInstance(
				elementType: System.Type,
				length1: number,
				length2: number,
			): System.Array;

			/**
			 * Creates a three-dimensional {@link System.Array} of the specified {@link System.Type}
			 * and dimension lengths, with zero-based indexing.
			 */
			static CreateInstance(
				elementType: System.Type,
				length1: number,
				length2: number,
				length3: number,
			): System.Array;

			/**
			 * Creates a multidimensional {@link System.Array} of the specified {@link System.Type}
			 * and dimension lengths, with zero-based indexing. The dimension lengths are specified
			 * in an array of 32-bit integers.
			 */
			static CreateInstance(
				elementType: System.Type,
				lengths: number[],
			): System.Array;

			/**
			 * Creates a multidimensional {@link System.Array} of the specified {@link System.Type}
			 * and dimension lengths, with the specified lower bounds.
			 */
			static CreateInstance(
				elementType: System.Type,
				lengths: number[],
				lowerBounds: number[],
			): System.Array;

			/**
			 * Creates a multidimensional {@link System.Array} of the specified {@link System.Type}
			 * and dimension lengths, with zero-based indexing. The dimension lengths are specified
			 * in an array of 64-bit integers.
			 */
			static CreateInstance(
				elementType: System.Type,
				lengths: number[],
			): System.Array;

			/** Returns an empty array. */
			static Empty<T>(): T[];

			static Exists<T>(
				array: T[],
				match: System.Predicate$1<T>,
			): boolean;

			static Fill<T>(
				array: T[],
				value: T,
			): void;

			static Fill<T>(
				array: T[],
				value: T,
				startIndex: number,
				count: number,
			): void;

			static FindAll<T>(
				array: T[],
				match: System.Predicate$1<T>,
			): T[];

			static FindIndex<T>(
				array: T[],
				startIndex: number,
				count: number,
				match: System.Predicate$1<T>,
			): number;

			static FindIndex<T>(
				array: T[],
				startIndex: number,
				match: System.Predicate$1<T>,
			): number;

			static FindIndex<T>(
				array: T[],
				match: System.Predicate$1<T>,
			): number;

			static FindLastIndex<T>(
				array: T[],
				startIndex: number,
				count: number,
				match: System.Predicate$1<T>,
			): number;

			static FindLastIndex<T>(
				array: T[],
				startIndex: number,
				match: System.Predicate$1<T>,
			): number;

			static FindLastIndex<T>(
				array: T[],
				match: System.Predicate$1<T>,
			): number;

			static FindLast<T>(
				array: T[],
				match: System.Predicate$1<T>,
			): T;

			static Find<T>(
				array: T[],
				match: System.Predicate$1<T>,
			): T;

			static ForEach<T>(
				array: T[],
				action: System.Action$1<T>,
			): void;

			/** Returns an {@link System.Collections.IEnumerator} for the {@link System.Array}. */
			GetEnumerator(): System.Collections.IEnumerator;

			/**
			 * Gets a 32-bit integer that represents the number of elements in the specified
			 * dimension of the {@link System.Array}.
			 */
			GetLength(dimension: number): number;

			/**
			 * Gets a 64-bit integer that represents the number of elements in the specified
			 * dimension of the {@link System.Array}.
			 */
			GetLongLength(dimension: number): number;

			/** Gets the index of the first element of the specified dimension in the array. */
			GetLowerBound(dimension: number): number;

			/** Gets the index of the last element of the specified dimension in the array. */
			GetUpperBound(dimension: number): number;

			/**
			 * Gets the value at the specified position in the one-dimensional {@link System.Array}.
			 * The index is specified as a 32-bit integer.
			 */
			GetValue(index: number): System.Object | undefined;

			/**
			 * Gets the value at the specified position in the two-dimensional {@link System.Array}.
			 * The indexes are specified as 32-bit integers.
			 */
			GetValue(
				index1: number,
				index2: number,
			): System.Object | undefined;

			/**
			 * Gets the value at the specified position in the three-dimensional
			 * {@link System.Array}. The indexes are specified as 32-bit integers.
			 */
			GetValue(
				index1: number,
				index2: number,
				index3: number,
			): System.Object | undefined;

			/**
			 * Gets the value at the specified position in the multidimensional {@link System.Array}.
			 * The indexes are specified as an array of 32-bit integers.
			 */
			GetValue(indices: number[]): System.Object | undefined;

			/**
			 * Gets the value at the specified position in the one-dimensional {@link System.Array}.
			 * The index is specified as a 64-bit integer.
			 */
			GetValue(index: number): System.Object | undefined;

			/**
			 * Gets the value at the specified position in the two-dimensional {@link System.Array}.
			 * The indexes are specified as 64-bit integers.
			 */
			GetValue(
				index1: number,
				index2: number,
			): System.Object | undefined;

			/**
			 * Gets the value at the specified position in the three-dimensional
			 * {@link System.Array}. The indexes are specified as 64-bit integers.
			 */
			GetValue(
				index1: number,
				index2: number,
				index3: number,
			): System.Object | undefined;

			/**
			 * Gets the value at the specified position in the multidimensional {@link System.Array}.
			 * The indexes are specified as an array of 64-bit integers.
			 */
			GetValue(indices: number[]): System.Object | undefined;

			/**
			 * Searches for the specified object and returns the index of its first occurrence in a
			 * one-dimensional array.
			 */
			static IndexOf(
				array: System.Array,
				value: System.Object | undefined,
			): number;

			/**
			 * Searches for the specified object in a range of elements of a one-dimensional array,
			 * and returns the index of its first occurrence. The range extends from a specified
			 * index to the end of the array.
			 */
			static IndexOf(
				array: System.Array,
				value: System.Object | undefined,
				startIndex: number,
			): number;

			/**
			 * Searches for the specified object in a range of elements of a one-dimensional array,
			 * and returns the index of ifs first occurrence. The range extends from a specified
			 * index for a specified number of elements.
			 */
			static IndexOf(
				array: System.Array,
				value: System.Object | undefined,
				startIndex: number,
				count: number,
			): number;

			static IndexOf<T>(
				array: T[],
				value: T,
			): number;

			static IndexOf<T>(
				array: T[],
				value: T,
				startIndex: number,
			): number;

			static IndexOf<T>(
				array: T[],
				value: T,
				startIndex: number,
				count: number,
			): number;

			/**
			 * Initializes every element of the value-type {@link System.Array} by calling the
			 * parameterless constructor of the value type.
			 */
			Initialize(): void;

			/**
			 * Searches for the specified object and returns the index of the last occurrence within
			 * the entire one-dimensional {@link System.Array}.
			 */
			static LastIndexOf(
				array: System.Array,
				value: System.Object | undefined,
			): number;

			/**
			 * Searches for the specified object and returns the index of the last occurrence within
			 * the range of elements in the one-dimensional {@link System.Array} that extends from
			 * the first element to the specified index.
			 */
			static LastIndexOf(
				array: System.Array,
				value: System.Object | undefined,
				startIndex: number,
			): number;

			/**
			 * Searches for the specified object and returns the index of the last occurrence within
			 * the range of elements in the one-dimensional {@link System.Array} that contains the
			 * specified number of elements and ends at the specified index.
			 */
			static LastIndexOf(
				array: System.Array,
				value: System.Object | undefined,
				startIndex: number,
				count: number,
			): number;

			static LastIndexOf<T>(
				array: T[],
				value: T,
			): number;

			static LastIndexOf<T>(
				array: T[],
				value: T,
				startIndex: number,
			): number;

			static LastIndexOf<T>(
				array: T[],
				value: T,
				startIndex: number,
				count: number,
			): number;

			static Resize<T>(
				array: T[],
				newSize: number,
			): void;

			/**
			 * Reverses the sequence of the elements in the entire one-dimensional
			 * {@link System.Array}.
			 */
			static Reverse(array: System.Array): void;

			/**
			 * Reverses the sequence of a subset of the elements in the one-dimensional
			 * {@link System.Array}.
			 */
			static Reverse(
				array: System.Array,
				index: number,
				length: number,
			): void;

			static Reverse<T>(array: T[]): void;

			static Reverse<T>(
				array: T[],
				index: number,
				length: number,
			): void;

			/**
			 * Sets a value to the element at the specified position in the one-dimensional
			 * {@link System.Array}. The index is specified as a 32-bit integer.
			 */
			SetValue(
				value: System.Object | undefined,
				index: number,
			): void;

			/**
			 * Sets a value to the element at the specified position in the two-dimensional
			 * {@link System.Array}. The indexes are specified as 32-bit integers.
			 */
			SetValue(
				value: System.Object | undefined,
				index1: number,
				index2: number,
			): void;

			/**
			 * Sets a value to the element at the specified position in the three-dimensional
			 * {@link System.Array}. The indexes are specified as 32-bit integers.
			 */
			SetValue(
				value: System.Object | undefined,
				index1: number,
				index2: number,
				index3: number,
			): void;

			/**
			 * Sets a value to the element at the specified position in the multidimensional
			 * {@link System.Array}. The indexes are specified as an array of 32-bit integers.
			 */
			SetValue(
				value: System.Object | undefined,
				indices: number[],
			): void;

			/**
			 * Sets a value to the element at the specified position in the one-dimensional
			 * {@link System.Array}. The index is specified as a 64-bit integer.
			 */
			SetValue(
				value: System.Object | undefined,
				index: number,
			): void;

			/**
			 * Sets a value to the element at the specified position in the two-dimensional
			 * {@link System.Array}. The indexes are specified as 64-bit integers.
			 */
			SetValue(
				value: System.Object | undefined,
				index1: number,
				index2: number,
			): void;

			/**
			 * Sets a value to the element at the specified position in the three-dimensional
			 * {@link System.Array}. The indexes are specified as 64-bit integers.
			 */
			SetValue(
				value: System.Object | undefined,
				index1: number,
				index2: number,
				index3: number,
			): void;

			/**
			 * Sets a value to the element at the specified position in the multidimensional
			 * {@link System.Array}. The indexes are specified as an array of 64-bit integers.
			 */
			SetValue(
				value: System.Object | undefined,
				indices: number[],
			): void;

			/**
			 * Sorts the elements in an entire one-dimensional {@link System.Array} using the
			 * {@link System.IComparable} implementation of each element of the {@link System.Array}.
			 */
			static Sort(array: System.Array): void;

			/**
			 * Sorts a pair of one-dimensional {@link System.Array} objects (one contains the keys
			 * and the other contains the corresponding items) based on the keys in the first
			 * {@link System.Array} using the {@link System.IComparable} implementation of each key.
			 */
			static Sort(
				keys: System.Array,
				items: System.Array | undefined,
			): void;

			/**
			 * Sorts a pair of one-dimensional {@link System.Array} objects (one contains the keys
			 * and the other contains the corresponding items) based on the keys in the first
			 * {@link System.Array} using the specified {@link System.Collections.IComparer}.
			 */
			static Sort(
				keys: System.Array,
				items: System.Array | undefined,
				comparer: System.Collections.IComparer | undefined,
			): void;

			/**
			 * Sorts a range of elements in a pair of one-dimensional {@link System.Array} objects
			 * (one contains the keys and the other contains the corresponding items) based on the
			 * keys in the first {@link System.Array} using the {@link System.IComparable}
			 * implementation of each key.
			 */
			static Sort(
				keys: System.Array,
				items: System.Array | undefined,
				index: number,
				length: number,
			): void;

			/**
			 * Sorts a range of elements in a pair of one-dimensional {@link System.Array} objects
			 * (one contains the keys and the other contains the corresponding items) based on the
			 * keys in the first {@link System.Array} using the specified
			 * {@link System.Collections.IComparer}.
			 */
			static Sort(
				keys: System.Array,
				items: System.Array | undefined,
				index: number,
				length: number,
				comparer: System.Collections.IComparer | undefined,
			): void;

			/**
			 * Sorts the elements in a one-dimensional {@link System.Array} using the specified
			 * {@link System.Collections.IComparer}.
			 */
			static Sort(
				array: System.Array,
				comparer: System.Collections.IComparer | undefined,
			): void;

			/**
			 * Sorts the elements in a range of elements in a one-dimensional {@link System.Array}
			 * using the {@link System.IComparable} implementation of each element of the
			 * {@link System.Array}.
			 */
			static Sort(
				array: System.Array,
				index: number,
				length: number,
			): void;

			/**
			 * Sorts the elements in a range of elements in a one-dimensional {@link System.Array}
			 * using the specified {@link System.Collections.IComparer}.
			 */
			static Sort(
				array: System.Array,
				index: number,
				length: number,
				comparer: System.Collections.IComparer | undefined,
			): void;

			static Sort<T>(array: T[]): void;

			static Sort<T>(
				array: T[],
				comparer: System.Collections.Generic.IComparer$1<T> | undefined,
			): void;

			static Sort<T>(
				array: T[],
				comparison: System.Comparison$1<T>,
			): void;

			static Sort<T>(
				array: T[],
				index: number,
				length: number,
			): void;

			static Sort<T>(
				array: T[],
				index: number,
				length: number,
				comparer: System.Collections.Generic.IComparer$1<T> | undefined,
			): void;

			static Sort<TKey, TValue>(
				keys: TKey[],
				items: TValue[] | undefined,
			): void;

			static Sort<TKey, TValue>(
				keys: TKey[],
				items: TValue[] | undefined,
				comparer: System.Collections.Generic.IComparer$1<TKey> | undefined,
			): void;

			static Sort<TKey, TValue>(
				keys: TKey[],
				items: TValue[] | undefined,
				index: number,
				length: number,
			): void;

			static Sort<TKey, TValue>(
				keys: TKey[],
				items: TValue[] | undefined,
				index: number,
				length: number,
				comparer: System.Collections.Generic.IComparer$1<TKey> | undefined,
			): void;

			static TrueForAll<T>(
				array: T[],
				match: System.Predicate$1<T>,
			): boolean;
		}
	}

	export namespace System {
		/** [Generic type factory] Delimits a section of a one-dimensional array. */
		export function ArraySegment$(T: IType): typeof ArraySegment$1<any>;

		/** Delimits a section of a one-dimensional array. */
		export class ArraySegment$1<T> extends System.ValueType {
			constructor(array: T[]);

			constructor(
				array: T[],
				offset: number,
				count: number,
			);

			/**
			 * Gets the original array containing the range of elements that the array segment
			 * delimits.
			 */
			readonly Array?: T[];

			/** Gets the number of elements in the range delimited by the array segment. */
			readonly Count: number;

			/** Represents the empty array segment. This field is read-only. */
			static readonly Empty: System.ArraySegment$1<any>;

			/**
			 * Gets the position of the first element in the range delimited by the array segment,
			 * relative to the start of the original array.
			 */
			readonly Offset: number;

			/**
			 * Copies the contents of this instance into the specified destination array segment of
			 * the same type  .
			 */
			CopyTo(destination: System.ArraySegment$1<T>): void;

			CopyTo(destination: T[]): void;

			CopyTo(
				destination: T[],
				destinationIndex: number,
			): void;

			/**
			 * Determines whether the specified {@link System.ArraySegment<>} structure is equal to
			 * the current instance.
			 */
			Equals(obj: System.ArraySegment$1<T>): boolean;

			/** Determines whether the specified object is equal to the current instance. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns an enumerator that can be used to iterate through the array segment. */
			GetEnumerator(): System.Collections.Generic.IEnumerator$1<T>;

			/** Returns the hash code for the current instance. */
			GetHashCode(): number;

			/** Forms a slice out of the current array segment starting at the specified index. */
			Slice(index: number): System.ArraySegment$1<T>;

			/**
			 * Forms a slice of the specified length out of the current array segment starting at the
			 * specified index.
			 */
			Slice(
				index: number,
				count: number,
			): System.ArraySegment$1<T>;

			/** Copies the contents of this array segment into a new array. */
			ToArray(): T[];
		}
	}

	export namespace System.ArraySegment {
		export function Enumerator$(T: IType): typeof Enumerator$1<any>;

		export class Enumerator$1<T> extends System.ValueType implements
			IDisposable {
			readonly Current: T;

			dispose(): void;

			MoveNext(): boolean;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an attempt is made to store an element of the wrong
		 * type within an array.
		 */
		export class ArrayTypeMismatchException extends System.SystemException {
			/** Initializes a new instance of the {@link System.ArrayTypeMismatchException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.ArrayTypeMismatchException} class with
			 * a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ArrayTypeMismatchException} class with
			 * a specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Provides data for the {@link System.AppDomain.AssemblyLoad} event. */
		export class AssemblyLoadEventArgs extends System.EventArgs {
			/**
			 * Initializes a new instance of the {@link System.AssemblyLoadEventArgs} class using the
			 * specified {@link System.Reflection.Assembly}.
			 */
			constructor(loadedAssembly: System.Reflection.Assembly);

			/**
			 * Gets an {@link System.Reflection.Assembly} that represents the currently loaded
			 * assembly.
			 */
			readonly LoadedAssembly: System.Reflection.Assembly;
		}
	}

	export namespace System {
		/**
		 * Represents the method that handles the {@link System.AppDomain.AssemblyLoad} event of
		 * an {@link System.AppDomain}.
		 */
		export interface AssemblyLoadEventHandler { (
			sender: System.Object | undefined,
			args: System.AssemblyLoadEventArgs,
		): void; }
	}

	export namespace System {
		/**
		 * References a method to be called when a corresponding asynchronous operation
		 * completes.
		 */
		export interface AsyncCallback { (ar: System.IAsyncResult): void; }
	}

	export namespace System {
		/** Represents the base class for custom attributes. */
		export class Attribute {
			/**
			 * When implemented in a derived class, gets a unique identifier for this
			 * {@link System.Attribute}.
			 */
			readonly TypeId: System.Object;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Retrieves a custom attribute applied to a specified assembly. Parameters specify the
			 * assembly and the type of the custom attribute to search for.
			 */
			static GetCustomAttribute(
				element: System.Reflection.Assembly,
				attributeType: System.Type,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute applied to an assembly. Parameters specify the assembly,
			 * the type of the custom attribute to search for, and an ignored search option.
			 */
			static GetCustomAttribute(
				element: System.Reflection.Assembly,
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute applied to a member of a type. Parameters specify the
			 * member, and the type of the custom attribute to search for.
			 */
			static GetCustomAttribute(
				element: System.Reflection.MemberInfo,
				attributeType: System.Type,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute applied to a member of a type. Parameters specify the
			 * member, the type of the custom attribute to search for, and whether to search
			 * ancestors of the member.
			 */
			static GetCustomAttribute(
				element: System.Reflection.MemberInfo,
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute applied to a module. Parameters specify the module, and
			 * the type of the custom attribute to search for.
			 */
			static GetCustomAttribute(
				element: System.Reflection.Module,
				attributeType: System.Type,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute applied to a module. Parameters specify the module, the
			 * type of the custom attribute to search for, and an ignored search option.
			 */
			static GetCustomAttribute(
				element: System.Reflection.Module,
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute applied to a method parameter. Parameters specify the
			 * method parameter, and the type of the custom attribute to search for.
			 */
			static GetCustomAttribute(
				element: System.Reflection.ParameterInfo,
				attributeType: System.Type,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute applied to a method parameter. Parameters specify the
			 * method parameter, the type of the custom attribute to search for, and whether to
			 * search ancestors of the method parameter.
			 */
			static GetCustomAttribute(
				element: System.Reflection.ParameterInfo,
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute | undefined;

			/**
			 * Retrieves an array of the custom attributes applied to an assembly. A parameter
			 * specifies the assembly.
			 */
			static GetCustomAttributes(element: System.Reflection.Assembly): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to an assembly. Parameters specify
			 * the assembly, and an ignored search option.
			 */
			static GetCustomAttributes(
				element: System.Reflection.Assembly,
				inherit: boolean,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to an assembly. Parameters specify
			 * the assembly, and the type of the custom attribute to search for.
			 */
			static GetCustomAttributes(
				element: System.Reflection.Assembly,
				attributeType: System.Type,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to an assembly. Parameters specify
			 * the assembly, the type of the custom attribute to search for, and an ignored search
			 * option.
			 */
			static GetCustomAttributes(
				element: System.Reflection.Assembly,
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a member of a type. A parameter
			 * specifies the member.
			 */
			static GetCustomAttributes(element: System.Reflection.MemberInfo): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a member of a type. Parameters
			 * specify the member, the type of the custom attribute to search for, and whether to
			 * search ancestors of the member.
			 */
			static GetCustomAttributes(
				element: System.Reflection.MemberInfo,
				inherit: boolean,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a member of a type. Parameters
			 * specify the member, and the type of the custom attribute to search for.
			 */
			static GetCustomAttributes(
				element: System.Reflection.MemberInfo,
				attributeType: System.Type,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a member of a type. Parameters
			 * specify the member, the type of the custom attribute to search for, and whether to
			 * search ancestors of the member.
			 */
			static GetCustomAttributes(
				element: System.Reflection.MemberInfo,
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a module. A parameter specifies
			 * the module.
			 */
			static GetCustomAttributes(element: System.Reflection.Module): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a module. Parameters specify
			 * the module, and an ignored search option.
			 */
			static GetCustomAttributes(
				element: System.Reflection.Module,
				inherit: boolean,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a module. Parameters specify
			 * the module, and the type of the custom attribute to search for.
			 */
			static GetCustomAttributes(
				element: System.Reflection.Module,
				attributeType: System.Type,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a module. Parameters specify
			 * the module, the type of the custom attribute to search for, and an ignored search
			 * option.
			 */
			static GetCustomAttributes(
				element: System.Reflection.Module,
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a method parameter. A parameter
			 * specifies the method parameter.
			 */
			static GetCustomAttributes(element: System.Reflection.ParameterInfo): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a method parameter. Parameters
			 * specify the method parameter, and whether to search ancestors of the method parameter.
			 */
			static GetCustomAttributes(
				element: System.Reflection.ParameterInfo,
				inherit: boolean,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a method parameter. Parameters
			 * specify the method parameter, and the type of the custom attribute to search for.
			 */
			static GetCustomAttributes(
				element: System.Reflection.ParameterInfo,
				attributeType: System.Type,
			): System.Attribute[];

			/**
			 * Retrieves an array of the custom attributes applied to a method parameter. Parameters
			 * specify the method parameter, the type of the custom attribute to search for, and
			 * whether to search ancestors of the method parameter.
			 */
			static GetCustomAttributes(
				element: System.Reflection.ParameterInfo,
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute[];

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * When overridden in a derived class, indicates whether the value of this instance is
			 * the default value for the derived class.
			 */
			IsDefaultAttribute(): boolean;

			/**
			 * Determines whether any custom attributes are applied to an assembly. Parameters
			 * specify the assembly, and the type of the custom attribute to search for.
			 */
			static IsDefined(
				element: System.Reflection.Assembly,
				attributeType: System.Type,
			): boolean;

			/**
			 * Determines whether any custom attributes are applied to an assembly. Parameters
			 * specify the assembly, the type of the custom attribute to search for, and an ignored
			 * search option.
			 */
			static IsDefined(
				element: System.Reflection.Assembly,
				attributeType: System.Type,
				inherit: boolean,
			): boolean;

			/**
			 * Determines whether any custom attributes are applied to a member of a type. Parameters
			 * specify the member, and the type of the custom attribute to search for.
			 */
			static IsDefined(
				element: System.Reflection.MemberInfo,
				attributeType: System.Type,
			): boolean;

			/**
			 * Determines whether any custom attributes are applied to a member of a type. Parameters
			 * specify the member, the type of the custom attribute to search for, and whether to
			 * search ancestors of the member.
			 */
			static IsDefined(
				element: System.Reflection.MemberInfo,
				attributeType: System.Type,
				inherit: boolean,
			): boolean;

			/**
			 * Determines whether any custom attributes of a specified type are applied to a module.
			 * Parameters specify the module, and the type of the custom attribute to search for.
			 */
			static IsDefined(
				element: System.Reflection.Module,
				attributeType: System.Type,
			): boolean;

			/**
			 * Determines whether any custom attributes are applied to a module. Parameters specify
			 * the module, the type of the custom attribute to search for, and an ignored search
			 * option.
			 */
			static IsDefined(
				element: System.Reflection.Module,
				attributeType: System.Type,
				inherit: boolean,
			): boolean;

			/**
			 * Determines whether any custom attributes are applied to a method parameter. Parameters
			 * specify the method parameter, and the type of the custom attribute to search for.
			 */
			static IsDefined(
				element: System.Reflection.ParameterInfo,
				attributeType: System.Type,
			): boolean;

			/**
			 * Determines whether any custom attributes are applied to a method parameter. Parameters
			 * specify the method parameter, the type of the custom attribute to search for, and
			 * whether to search ancestors of the method parameter.
			 */
			static IsDefined(
				element: System.Reflection.ParameterInfo,
				attributeType: System.Type,
				inherit: boolean,
			): boolean;

			/**
			 * When overridden in a derived class, returns a value that indicates whether this
			 * instance equals a specified object.
			 */
			Match(obj: System.Object | undefined): boolean;
		}
	}

	export namespace System {
		/** Specifies the application elements on which it is valid to apply an attribute. */
		export enum AttributeTargets {
			/** Attribute can be applied to an assembly. */
			Assembly = 1,

			/**
			 * Attribute can be applied to a module. `Module` refers to a portable executable file
			 * (.dll or.exe) and not a Visual Basic standard module.
			 */
			Module = 2,

			/** Attribute can be applied to a class. */
			Class = 4,

			/** Attribute can be applied to a structure; that is, a value type. */
			Struct = 8,

			/** Attribute can be applied to an enumeration. */
			Enum = 16,

			/** Attribute can be applied to a constructor. */
			Constructor = 32,

			/** Attribute can be applied to a method. */
			Method = 64,

			/** Attribute can be applied to a property. */
			Property = 128,

			/** Attribute can be applied to a field. */
			Field = 256,

			/** Attribute can be applied to an event. */
			Event = 512,

			/** Attribute can be applied to an interface. */
			Interface = 1024,

			/** Attribute can be applied to a parameter. */
			Parameter = 2048,

			/** Attribute can be applied to a delegate. */
			Delegate = 4096,

			/** Attribute can be applied to a return value. */
			ReturnValue = 8192,

			/**
			 * Attribute can be applied to a generic parameter. Currently, this attribute can be
			 * applied only in C#, Microsoft intermediate language (MSIL), and emitted code.
			 */
			GenericParameter = 16384,

			/** Attribute can be applied to any application element. */
			All = 32767,
		}
	}

	export namespace System {
		/** Specifies the usage of another attribute class. This class cannot be inherited. */
		export class AttributeUsageAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.AttributeUsageAttribute} class with
			 * the specified list of {@link System.AttributeTargets}, the
			 * {@link System.AttributeUsageAttribute.AllowMultiple} value, and the
			 * {@link System.AttributeUsageAttribute.Inherited} value.
			 */
			constructor(validOn: System.AttributeTargets);

			/**
			 * Gets or sets a Boolean value indicating whether more than one instance of the
			 * indicated attribute can be specified for a single program element.
			 */
			AllowMultiple: boolean;

			/**
			 * Gets or sets a {@link System.Boolean} value that determines whether the indicated
			 * attribute is inherited by derived classes and overriding members.
			 */
			Inherited: boolean;

			/**
			 * Gets a set of values identifying which program elements that the indicated attribute
			 * can be applied to.
			 */
			readonly ValidOn: System.AttributeTargets;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when the file image of a dynamic link library (DLL) or an
		 * executable program is invalid.
		 */
		export class BadImageFormatException extends System.SystemException {
			/** Initializes a new instance of the {@link System.BadImageFormatException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.BadImageFormatException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.BadImageFormatException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.BadImageFormatException} class with a
			 * specified error message and file name.
			 */
			constructor(
				message: string | undefined,
				fileName: string | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.BadImageFormatException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				fileName: string | undefined,
				inner: System.Exception | undefined,
			);

			/** Gets the name of the file that causes this exception. */
			readonly FileName?: string;

			/** Gets the log file that describes why an assembly load failed. */
			readonly FusionLog?: string;

			/** Gets the error message and the name of the file that caused this exception. */
			readonly Message: string;

			/**
			 * Returns the fully qualified name of this exception and possibly the error message, the
			 * name of the inner exception, and the stack trace.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/**
		 * Specifies whether relevant {@link System.Convert.ToBase64CharArray} and
		 * {@link System.Convert.ToBase64String} methods insert line breaks in their output.
		 */
		export enum Base64FormattingOptions {
			/**
			 * Does not insert line breaks after every 76 characters in the string representation.
			 */
			None = 0,

			/** Inserts line breaks after every 76 characters in the string representation. */
			InsertLineBreaks = 1,
		}
	}

	export namespace System {
		/**
		 * Converts base data types to an array of bytes, and an array of bytes to base data
		 * types.
		 */
		export namespace BitConverter {
			/**
			 * Converts the specified double-precision floating point number to a 64-bit signed
			 * integer.
			 */
			export function DoubleToInt64Bits(value: number): number;

			/**
			 * Converts the specified double-precision floating point number to a 64-bit unsigned
			 * integer.
			 */
			export function DoubleToUInt64Bits(value: number): number;

			/** Returns the specified Boolean value as a byte array. */
			export function GetBytes(value: boolean): number[];

			/** Returns the specified Unicode character value as an array of bytes. */
			export function GetBytes(value: System.Char): number[];

			/** Returns the specified double-precision floating-point value as an array of bytes. */
			export function GetBytes(value: number): number[];

			/** Returns the specified half-precision floating-point value as an array of bytes. */
			export function GetBytes(value: System.Half): number[];

			/** Returns the specified 16-bit signed integer value as an array of bytes. */
			export function GetBytes(value: number): number[];

			/** Returns the specified 32-bit signed integer value as an array of bytes. */
			export function GetBytes(value: number): number[];

			/** Returns the specified 64-bit signed integer value as an array of bytes. */
			export function GetBytes(value: number): number[];

			/** Returns the specified single-precision floating point value as an array of bytes. */
			export function GetBytes(value: number): number[];

			/** Returns the specified 16-bit unsigned integer value as an array of bytes. */
			export function GetBytes(value: number): number[];

			/** Returns the specified 32-bit unsigned integer value as an array of bytes. */
			export function GetBytes(value: number): number[];

			/** Returns the specified 64-bit unsigned integer value as an array of bytes. */
			export function GetBytes(value: number): number[];

			/** Converts a half-precision floating-point value into a 16-bit integer. */
			export function HalfToInt16Bits(value: System.Half): number;

			/**
			 * Converts the specified half-precision floating point number to a 16-bit unsigned
			 * integer.
			 */
			export function HalfToUInt16Bits(value: System.Half): number;

			/**
			 * Reinterprets the specified 16-bit signed integer value as a half-precision
			 * floating-point value.
			 */
			export function Int16BitsToHalf(value: number): System.Half;

			/**
			 * Reinterprets the specified 32-bit integer as a single-precision floating-point value.
			 */
			export function Int32BitsToSingle(value: number): number;

			/**
			 * Reinterprets the specified 64-bit signed integer to a double-precision floating point
			 * number.
			 */
			export function Int64BitsToDouble(value: number): number;

			/** Converts a single-precision floating-point value into an integer. */
			export function SingleToInt32Bits(value: number): number;

			/**
			 * Converts the specified single-precision floating point number to a 32-bit unsigned
			 * integer.
			 */
			export function SingleToUInt32Bits(value: number): number;

			/**
			 * Returns a Boolean value converted from the byte at a specified position in a byte
			 * array.
			 */
			export function ToBoolean(
				value: number[],
				startIndex: number,
			): boolean;

			/** Converts a read-only byte span to a Boolean value. */
			export function ToBoolean(value: System.ReadOnlySpan$1<number>): boolean;

			/**
			 * Returns a Unicode character converted from two bytes at a specified position in a byte
			 * array.
			 */
			export function ToChar(
				value: number[],
				startIndex: number,
			): System.Char;

			/** Converts a read-only byte span into a character. */
			export function ToChar(value: System.ReadOnlySpan$1<number>): System.Char;

			/**
			 * Returns a double-precision floating point number converted from eight bytes at a
			 * specified position in a byte array.
			 */
			export function ToDouble(
				value: number[],
				startIndex: number,
			): number;

			/** Converts a read-only byte span into a double-precision floating-point value. */
			export function ToDouble(value: System.ReadOnlySpan$1<number>): number;

			/**
			 * Returns a laft-precision floating point number converted from two bytes at a specified
			 * position in a byte array.
			 */
			export function ToHalf(
				value: number[],
				startIndex: number,
			): System.Half;

			/** Converts a read-only byte span into a half-precision floating-point value. */
			export function ToHalf(value: System.ReadOnlySpan$1<number>): System.Half;

			/**
			 * Returns a 16-bit signed integer converted from two bytes at a specified position in a
			 * byte array.
			 */
			export function ToInt16(
				value: number[],
				startIndex: number,
			): number;

			/** Converts a read-only byte span into a 16-bit signed integer. */
			export function ToInt16(value: System.ReadOnlySpan$1<number>): number;

			/**
			 * Returns a 32-bit signed integer converted from four bytes at a specified position in a
			 * byte array.
			 */
			export function ToInt32(
				value: number[],
				startIndex: number,
			): number;

			/** Converts a read-only byte span into a 32-bit signed integer. */
			export function ToInt32(value: System.ReadOnlySpan$1<number>): number;

			/**
			 * Returns a 64-bit signed integer converted from eight bytes at a specified position in
			 * a byte array.
			 */
			export function ToInt64(
				value: number[],
				startIndex: number,
			): number;

			/** Converts a read-only byte span into a 64-bit signed integer. */
			export function ToInt64(value: System.ReadOnlySpan$1<number>): number;

			/**
			 * Returns a single-precision floating point number converted from four bytes at a
			 * specified position in a byte array.
			 */
			export function ToSingle(
				value: number[],
				startIndex: number,
			): number;

			/** Converts a read-only byte span into a single-precision floating-point value. */
			export function ToSingle(value: System.ReadOnlySpan$1<number>): number;

			/**
			 * Converts the numeric value of each element of a specified array of bytes to its
			 * equivalent hexadecimal string representation.
			 */
			export function ToString(value: number[]): string;

			/**
			 * Converts the numeric value of each element of a specified subarray of bytes to its
			 * equivalent hexadecimal string representation.
			 */
			export function ToString(
				value: number[],
				startIndex: number,
			): string;

			/**
			 * Converts the numeric value of each element of a specified subarray of bytes to its
			 * equivalent hexadecimal string representation.
			 */
			export function ToString(
				value: number[],
				startIndex: number,
				length: number,
			): string;

			/**
			 * Returns a 16-bit unsigned integer converted from two bytes at a specified position in
			 * a byte array.
			 */
			export function ToUInt16(
				value: number[],
				startIndex: number,
			): number;

			/** Converts a read-only byte-span into a 16-bit unsigned integer. */
			export function ToUInt16(value: System.ReadOnlySpan$1<number>): number;

			/**
			 * Returns a 32-bit unsigned integer converted from four bytes at a specified position in
			 * a byte array.
			 */
			export function ToUInt32(
				value: number[],
				startIndex: number,
			): number;

			/** Converts a read-only byte span into a 32-bit unsigned integer. */
			export function ToUInt32(value: System.ReadOnlySpan$1<number>): number;

			/**
			 * Returns a 64-bit unsigned integer converted from eight bytes at a specified position
			 * in a byte array.
			 */
			export function ToUInt64(
				value: number[],
				startIndex: number,
			): number;

			/** Converts bytes into an unsigned long. */
			export function ToUInt64(value: System.ReadOnlySpan$1<number>): number;

			/** Converts a Boolean into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: boolean,
			): boolean;

			/** Converts a character into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: System.Char,
			): boolean;

			/** Converts a double-precision floating-point value into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: number,
			): boolean;

			/** Converts a half-precision floating-point value into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: System.Half,
			): boolean;

			/** Converts a 16-bit signed integer into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: number,
			): boolean;

			/** Converts a 32-bit signed integer into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: number,
			): boolean;

			/** Converts a 64-bit signed integer into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: number,
			): boolean;

			/** Converts a single-precision floating-point value into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: number,
			): boolean;

			/** Converts an unsigned 16-bit integer into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: number,
			): boolean;

			/** Converts a 32-bit unsigned integer into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: number,
			): boolean;

			/** Converts an unsigned 64-bit integer into a span of bytes. */
			export function TryWriteBytes(
				destination: System.Span$1<number>,
				value: number,
			): boolean;

			/**
			 * Converts the specified 16-bit unsigned integer to a half-precision floating point
			 * number.
			 */
			export function UInt16BitsToHalf(value: number): System.Half;

			/**
			 * Converts the specified 32-bit unsigned integer to a single-precision floating point
			 * number.
			 */
			export function UInt32BitsToSingle(value: number): number;

			/**
			 * Converts the specified 64-bit unsigned integer to a double-precision floating point
			 * number.
			 */
			export function UInt64BitsToDouble(value: number): number;
		}
	}

	export namespace System {
		/** Represents a Boolean ( `true` or `false` ) value. */
		export class Boolean extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<boolean>,
			System.IEquatable$1<boolean>,
			System.IParsable$1<boolean>,
			System.ISpanParsable$1<boolean> {
			/**
			 * Compares this instance to a specified {@link System.Boolean} object and returns an
			 * integer that indicates their relationship to one another.
			 */
			CompareTo(value: boolean): number;

			/**
			 * Compares this instance to a specified object and returns an integer that indicates
			 * their relationship to one another.
			 */
			CompareTo(obj: System.Object | undefined): number;

			/**
			 * Returns a value indicating whether this instance is equal to a specified
			 * {@link System.Boolean} object.
			 */
			Equals(obj: boolean): boolean;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the type code for the {@link System.Boolean} value type. */
			GetTypeCode(): System.TypeCode;

			/**
			 * Converts the specified span representation of a logical value to its
			 * {@link System.Boolean} equivalent.
			 */
			static Parse(value: System.ReadOnlySpan$1<System.Char>): boolean;

			/**
			 * Converts the specified string representation of a logical value to its
			 * {@link System.Boolean} equivalent.
			 */
			static Parse(value: string): boolean;

			/**
			 * Converts the value of this instance to its equivalent string representation (either
			 * "True" or "False").
			 */
			ToString(): string;

			/**
			 * Converts the value of this instance to its equivalent string representation (either
			 * "True" or "False").
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			TryFormat(destination: System.Span$1<System.Char>): number | undefined;

			static TryParse(value: System.ReadOnlySpan$1<System.Char>): boolean | undefined;

			static TryParse(value: string | undefined): boolean | undefined;
		}
	}

	export namespace System {
		/** Manipulates arrays of primitive types. */
		export namespace Buffer {
			/**
			 * Copies a specified number of bytes from a source array starting at a particular offset
			 * to a destination array starting at a particular offset.
			 */
			export function BlockCopy(
				src: System.Array,
				srcOffset: number,
				dst: System.Array,
				dstOffset: number,
				count: number,
			): void;

			/** Returns the number of bytes in the specified array. */
			export function ByteLength(array: System.Array): number;

			/** Retrieves the byte at the specified location in the specified array. */
			export function GetByte(
				array: System.Array,
				index: number,
			): number;

			/** Assigns a specified value to a byte at a particular location in a specified array. */
			export function SetByte(
				array: System.Array,
				index: number,
				value: number,
			): void;
		}
	}

	export namespace System {
		/** Represents an 8-bit unsigned integer. */
		export class Byte extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.Numerics.IAdditionOperators$3<number, number, number>,
			System.Numerics.IAdditiveIdentity$2<number, number>,
			System.Numerics.IBinaryNumber$1<number>,
			System.Numerics.IBitwiseOperators$3<number, number, number>,
			System.Numerics.IComparisonOperators$3<number, number, boolean>,
			System.Numerics.IEqualityOperators$3<number, number, boolean>,
			System.Numerics.IDecrementOperators$1<number>,
			System.Numerics.IDivisionOperators$3<number, number, number>,
			System.Numerics.IIncrementOperators$1<number>,
			System.Numerics.IModulusOperators$3<number, number, number>,
			System.Numerics.IMultiplicativeIdentity$2<number, number>,
			System.Numerics.IMultiplyOperators$3<number, number, number>,
			System.Numerics.INumber$1<number>,
			System.Numerics.INumberBase$1<number>,
			System.Numerics.ISubtractionOperators$3<number, number, number>,
			System.Numerics.IUnaryNegationOperators$2<number, number>,
			System.Numerics.IUnaryPlusOperators$2<number, number>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<number>,
			System.Numerics.IShiftOperators$3<number, number, number>,
			System.Numerics.IMinMaxValue$1<number>,
			System.Numerics.IUnsignedNumber$1<number> {
			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/**
			 * Compares this instance to a specified 8-bit unsigned integer and returns an indication
			 * of their relative values.
			 */
			CompareTo(value: number): number;

			/**
			 * Compares this instance to a specified object and returns an indication of their
			 * relative values.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): number;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: number,
				right: number,
			): [number, number];

			/**
			 * Returns a value indicating whether this instance and a specified {@link System.Byte}
			 * object represent the same value.
			 */
			Equals(obj: number): boolean;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.Byte}. */
			GetTypeCode(): System.TypeCode;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: number): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: number): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: number): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: number): number;

			/** Computes the log2 of a value. */
			static Log2(value: number): number;

			/** Compares two values to compute which is greater. */
			static Max(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: number,
				y: number,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the span representation of a number in a specified style and culture-specific
			 * format to its {@link System.Byte} equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number to its {@link System.Byte} equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a number in a specified style to its
			 * {@link System.Byte} equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): number;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its {@link System.Byte} equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its {@link System.Byte} equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: number): number;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: number,
				rotateAmount: number,
			): number;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: number,
				rotateAmount: number,
			): number;

			/** Computes the sign of a value. */
			static Sign(value: number): number;

			/**
			 * Converts the value of the current {@link System.Byte} object to its equivalent string
			 * representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of the current {@link System.Byte} object to its equivalent
			 * string representation using the specified culture-specific formatting information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the value of the current {@link System.Byte} object to its equivalent string
			 * representation using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the value of the current {@link System.Byte} object to its equivalent string
			 * representation using the specified format and culture-specific formatting information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: number): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number | undefined;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an attempt to unload an application domain fails.
		 */
		export class CannotUnloadAppDomainException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.CannotUnloadAppDomainException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.CannotUnloadAppDomainException} class
			 * with a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.CannotUnloadAppDomainException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Represents a character as a UTF-16 code unit. */
		export class Char extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<System.Char>,
			System.IEquatable$1<System.Char>,
			System.IParsable$1<System.Char>,
			System.ISpanParsable$1<System.Char>,
			System.Numerics.IAdditionOperators$3<System.Char, System.Char, System.Char>,
			System.Numerics.IAdditiveIdentity$2<System.Char, System.Char>,
			System.Numerics.IBitwiseOperators$3<System.Char, System.Char, System.Char>,
			System.Numerics.IComparisonOperators$3<System.Char, System.Char, boolean>,
			System.Numerics.IEqualityOperators$3<System.Char, System.Char, boolean>,
			System.Numerics.IDecrementOperators$1<System.Char>,
			System.Numerics.IDivisionOperators$3<System.Char, System.Char, System.Char>,
			System.Numerics.IIncrementOperators$1<System.Char>,
			System.Numerics.IModulusOperators$3<System.Char, System.Char, System.Char>,
			System.Numerics.IMultiplicativeIdentity$2<System.Char, System.Char>,
			System.Numerics.IMultiplyOperators$3<System.Char, System.Char, System.Char>,
			System.Numerics.ISubtractionOperators$3<System.Char, System.Char, System.Char>,
			System.Numerics.IUnaryNegationOperators$2<System.Char, System.Char>,
			System.Numerics.IUnaryPlusOperators$2<System.Char, System.Char>,
			System.IUtf8SpanParsable$1<System.Char>,
			System.Numerics.IShiftOperators$3<System.Char, number, System.Char>,
			System.Numerics.IMinMaxValue$1<System.Char> {
			/**
			 * Compares this instance to a specified {@link System.Char} object and indicates whether
			 * this instance precedes, follows, or appears in the same position in the sort order as
			 * the specified {@link System.Char} object.
			 */
			CompareTo(value: System.Char): number;

			/**
			 * Compares this instance to a specified object and indicates whether this instance
			 * precedes, follows, or appears in the same position in the sort order as the specified
			 * {@link System.Object}.
			 */
			CompareTo(value: System.Object | undefined): number;

			/** Converts the specified Unicode code point into a UTF-16 encoded string. */
			static ConvertFromUtf32(utf32: number): string;

			/** Converts the value of a UTF-16 encoded surrogate pair into a Unicode code point. */
			static ConvertToUtf32(
				highSurrogate: System.Char,
				lowSurrogate: System.Char,
			): number;

			/**
			 * Converts the value of a UTF-16 encoded character or surrogate pair at a specified
			 * position in a string into a Unicode code point.
			 */
			static ConvertToUtf32(
				s: string,
				index: number,
			): number;

			/**
			 * Returns a value that indicates whether this instance is equal to the specified
			 * {@link System.Char} object.
			 */
			Equals(obj: System.Char): boolean;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Converts the specified numeric Unicode character to a double-precision floating point
			 * number.
			 */
			static GetNumericValue(c: System.Char): number;

			/**
			 * Converts the numeric Unicode character at the specified position in a specified string
			 * to a double-precision floating point number.
			 */
			static GetNumericValue(
				s: string,
				index: number,
			): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.Char}. */
			GetTypeCode(): System.TypeCode;

			/**
			 * Categorizes a specified Unicode character into a group identified by one of the
			 * {@link System.Globalization.UnicodeCategory} values.
			 */
			static GetUnicodeCategory(c: System.Char): System.Globalization.UnicodeCategory;

			/**
			 * Categorizes the character at the specified position in a specified string into a group
			 * identified by one of the {@link System.Globalization.UnicodeCategory} values.
			 */
			static GetUnicodeCategory(
				s: string,
				index: number,
			): System.Globalization.UnicodeCategory;

			/** Returns `true` if `c` is an ASCII character ([ U+0000..U+007F ]). */
			static IsAscii(c: System.Char): boolean;

			/** Indicates whether a character is categorized as an ASCII digit. */
			static IsAsciiDigit(c: System.Char): boolean;

			/** Indicates whether a character is categorized as an ASCII hexademical digit. */
			static IsAsciiHexDigit(c: System.Char): boolean;

			/**
			 * Indicates whether a character is categorized as an ASCII lower-case hexademical digit.
			 */
			static IsAsciiHexDigitLower(c: System.Char): boolean;

			/**
			 * Indicates whether a character is categorized as an ASCII upper-case hexademical digit.
			 */
			static IsAsciiHexDigitUpper(c: System.Char): boolean;

			/** Indicates whether a character is categorized as an ASCII letter. */
			static IsAsciiLetter(c: System.Char): boolean;

			/** Indicates whether a character is categorized as a lowercase ASCII letter. */
			static IsAsciiLetterLower(c: System.Char): boolean;

			/** Indicates whether a character is categorized as an ASCII letter or digit. */
			static IsAsciiLetterOrDigit(c: System.Char): boolean;

			/** Indicates whether a character is categorized as an uppercase ASCII letter. */
			static IsAsciiLetterUpper(c: System.Char): boolean;

			/** Indicates whether a character is within the specified inclusive range. */
			static IsBetween(
				c: System.Char,
				minInclusive: System.Char,
				maxInclusive: System.Char,
			): boolean;

			/**
			 * Indicates whether the specified Unicode character is categorized as a control
			 * character.
			 */
			static IsControl(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as a control character.
			 */
			static IsControl(
				s: string,
				index: number,
			): boolean;

			/**
			 * Indicates whether the specified Unicode character is categorized as a decimal digit.
			 */
			static IsDigit(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as a decimal digit.
			 */
			static IsDigit(
				s: string,
				index: number,
			): boolean;

			/** Indicates whether the specified {@link System.Char} object is a high surrogate. */
			static IsHighSurrogate(c: System.Char): boolean;

			/**
			 * Indicates whether the {@link System.Char} object at the specified position in a string
			 * is a high surrogate.
			 */
			static IsHighSurrogate(
				s: string,
				index: number,
			): boolean;

			/**
			 * Indicates whether the specified Unicode character is categorized as a Unicode letter.
			 */
			static IsLetter(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as a Unicode letter.
			 */
			static IsLetter(
				s: string,
				index: number,
			): boolean;

			/**
			 * Indicates whether the specified Unicode character is categorized as a letter or a
			 * decimal digit.
			 */
			static IsLetterOrDigit(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as a letter or a decimal digit.
			 */
			static IsLetterOrDigit(
				s: string,
				index: number,
			): boolean;

			/**
			 * Indicates whether the specified Unicode character is categorized as a lowercase
			 * letter.
			 */
			static IsLower(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as a lowercase letter.
			 */
			static IsLower(
				s: string,
				index: number,
			): boolean;

			/** Indicates whether the specified {@link System.Char} object is a low surrogate. */
			static IsLowSurrogate(c: System.Char): boolean;

			/**
			 * Indicates whether the {@link System.Char} object at the specified position in a string
			 * is a low surrogate.
			 */
			static IsLowSurrogate(
				s: string,
				index: number,
			): boolean;

			/** Indicates whether the specified Unicode character is categorized as a number. */
			static IsNumber(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as a number.
			 */
			static IsNumber(
				s: string,
				index: number,
			): boolean;

			/**
			 * Indicates whether the specified Unicode character is categorized as a punctuation
			 * mark.
			 */
			static IsPunctuation(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as a punctuation mark.
			 */
			static IsPunctuation(
				s: string,
				index: number,
			): boolean;

			/**
			 * Indicates whether the specified Unicode character is categorized as a separator
			 * character.
			 */
			static IsSeparator(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as a separator character.
			 */
			static IsSeparator(
				s: string,
				index: number,
			): boolean;

			/** Indicates whether the specified character has a surrogate code unit. */
			static IsSurrogate(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string has a
			 * surrogate code unit.
			 */
			static IsSurrogate(
				s: string,
				index: number,
			): boolean;

			/**
			 * Indicates whether the two specified {@link System.Char} objects form a surrogate pair.
			 */
			static IsSurrogatePair(
				highSurrogate: System.Char,
				lowSurrogate: System.Char,
			): boolean;

			/**
			 * Indicates whether two adjacent {@link System.Char} objects at a specified position in
			 * a string form a surrogate pair.
			 */
			static IsSurrogatePair(
				s: string,
				index: number,
			): boolean;

			/**
			 * Indicates whether the specified Unicode character is categorized as a symbol
			 * character.
			 */
			static IsSymbol(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as a symbol character.
			 */
			static IsSymbol(
				s: string,
				index: number,
			): boolean;

			/**
			 * Indicates whether the specified Unicode character is categorized as an uppercase
			 * letter.
			 */
			static IsUpper(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as an uppercase letter.
			 */
			static IsUpper(
				s: string,
				index: number,
			): boolean;

			/** Indicates whether the specified Unicode character is categorized as white space. */
			static IsWhiteSpace(c: System.Char): boolean;

			/**
			 * Indicates whether the character at the specified position in a specified string is
			 * categorized as white space.
			 */
			static IsWhiteSpace(
				s: string,
				index: number,
			): boolean;

			/** Converts the value of the specified string to its equivalent Unicode character. */
			static Parse(s: string): System.Char;

			/** Converts the value of a Unicode character to its lowercase equivalent. */
			static ToLower(c: System.Char): System.Char;

			/**
			 * Converts the value of a specified Unicode character to its lowercase equivalent using
			 * specified culture-specific formatting information.
			 */
			static ToLower(
				c: System.Char,
				culture: System.Globalization.CultureInfo,
			): System.Char;

			/**
			 * Converts the value of a Unicode character to its lowercase equivalent using the casing
			 * rules of the invariant culture.
			 */
			static ToLowerInvariant(c: System.Char): System.Char;

			/** Converts the value of this instance to its equivalent string representation. */
			ToString(): string;

			/** Converts the specified Unicode character to its equivalent string representation. */
			static ToString(c: System.Char): string;

			/**
			 * Converts the value of this instance to its equivalent string representation using the
			 * specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/** Converts the value of a Unicode character to its uppercase equivalent. */
			static ToUpper(c: System.Char): System.Char;

			/**
			 * Converts the value of a specified Unicode character to its uppercase equivalent using
			 * specified culture-specific formatting information.
			 */
			static ToUpper(
				c: System.Char,
				culture: System.Globalization.CultureInfo,
			): System.Char;

			/**
			 * Converts the value of a Unicode character to its uppercase equivalent using the casing
			 * rules of the invariant culture.
			 */
			static ToUpperInvariant(c: System.Char): System.Char;

			static TryParse(s: string | undefined): System.Char | undefined;
		}
	}

	export namespace System {
		/**
		 * Supports iterating over a {@link System.String} object and reading its individual
		 * characters. This class cannot be inherited.
		 */
		export class CharEnumerator implements
			IDisposable,
			System.ICloneable {
			/**
			 * Gets the currently referenced character in the string enumerated by this
			 * {@link System.CharEnumerator} object.
			 */
			readonly Current: System.Char;

			/** Creates a copy of the current {@link System.CharEnumerator} object. */
			Clone(): System.Object;

			/**
			 * Releases all resources used by the current instance of the
			 * {@link System.CharEnumerator} class.
			 */
			dispose(): void;

			/**
			 * Increments the internal index of the current {@link System.CharEnumerator} object to
			 * the next character of the enumerated string.
			 */
			MoveNext(): boolean;

			/**
			 * Initializes the index to a position logically before the first character of the
			 * enumerated string.
			 */
			Reset(): void;
		}
	}

	export namespace System {
		/**
		 * Indicates whether a program element is compliant with the Common Language
		 * Specification (CLS). This class cannot be inherited.
		 */
		export class CLSCompliantAttribute extends System.Attribute {
			/**
			 * Initializes an instance of the {@link System.CLSCompliantAttribute} class with a
			 * Boolean value indicating whether the indicated program element is CLS-compliant.
			 */
			constructor(isCompliant: boolean);

			/**
			 * Gets the Boolean value indicating whether the indicated program element is
			 * CLS-compliant.
			 */
			readonly IsCompliant: boolean;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Represents the method that compares two objects of the same
		 * type.
		 */
		export function Comparison$(T: IType): IType;

		/** Represents the method that compares two objects of the same type. */
		export interface Comparison$1<T> { (
			x: T,
			y: T,
		): number; }
	}

	export namespace System {
		/** Defines the base class for all context-bound classes. */
		export class ContextBoundObject extends System.MarshalByRefObject {
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an attempt to marshal an object across a context
		 * boundary fails.
		 */
		export class ContextMarshalException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.ContextMarshalException} class with
			 * default properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.ContextMarshalException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ContextMarshalException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Indicates that the value of a static field is unique for a particular context. */
		export class ContextStaticAttribute extends System.Attribute {
			/** Initializes a new instance of the {@link System.ContextStaticAttribute} class. */
			constructor();
		}
	}

	export namespace System {
		/** Converts a base data type to another base data type. */
		export namespace Convert {
			/**
			 * Returns an object of the specified type and whose value is equivalent to the specified
			 * object.
			 */
			export function ChangeType(
				value: System.Object | undefined,
				conversionType: System.Type,
			): System.Object | undefined;

			/**
			 * Returns an object of the specified type whose value is equivalent to the specified
			 * object. A parameter supplies culture-specific formatting information.
			 */
			export function ChangeType(
				value: System.Object | undefined,
				conversionType: System.Type,
				provider: System.IFormatProvider | undefined,
			): System.Object | undefined;

			/**
			 * Returns an object of the specified type whose value is equivalent to the specified
			 * object.
			 */
			export function ChangeType(
				value: System.Object | undefined,
				typeCode: System.TypeCode,
			): System.Object | undefined;

			/**
			 * Returns an object of the specified type whose value is equivalent to the specified
			 * object. A parameter supplies culture-specific formatting information.
			 */
			export function ChangeType(
				value: System.Object | undefined,
				typeCode: System.TypeCode,
				provider: System.IFormatProvider | undefined,
			): System.Object | undefined;

			/**
			 * Converts a subset of a Unicode character array, which encodes binary data as base-64
			 * digits, to an equivalent 8-bit unsigned integer array. Parameters specify the subset
			 * in the input array and the number of elements to convert.
			 */
			export function FromBase64CharArray(
				inArray: System.Char[],
				offset: number,
				length: number,
			): number[];

			/**
			 * Converts the specified string, which encodes binary data as base-64 digits, to an
			 * equivalent 8-bit unsigned integer array.
			 */
			export function FromBase64String(s: string): number[];

			/**
			 * Converts the span, which encodes binary data as hex characters, to an equivalent 8-bit
			 * unsigned integer array.
			 */
			export function FromHexString(chars: System.ReadOnlySpan$1<System.Char>): number[];

			/**
			 * Converts the specified string, which encodes binary data as hex characters, to an
			 * equivalent 8-bit unsigned integer array.
			 */
			export function FromHexString(s: string): number[];

			/** Returns the {@link System.TypeCode} for the specified object. */
			export function GetTypeCode(value: System.Object | undefined): System.TypeCode;

			/**
			 * Returns an indication whether the specified object is of type {@link System.DBNull}.
			 */
			export function IsDBNull(value: System.Object | undefined): boolean;

			/**
			 * Converts a subset of an 8-bit unsigned integer array to an equivalent subset of a
			 * Unicode character array encoded with base-64 digits. Parameters specify the subsets as
			 * offsets in the input and output arrays, and the number of elements in the input array
			 * to convert.
			 */
			export function ToBase64CharArray(
				inArray: number[],
				offsetIn: number,
				length: number,
				outArray: System.Char[],
				offsetOut: number,
			): number;

			/**
			 * Converts a subset of an 8-bit unsigned integer array to an equivalent subset of a
			 * Unicode character array encoded with base-64 digits. Parameters specify the subsets as
			 * offsets in the input and output arrays, the number of elements in the input array to
			 * convert, and whether line breaks are inserted in the output array.
			 */
			export function ToBase64CharArray(
				inArray: number[],
				offsetIn: number,
				length: number,
				outArray: System.Char[],
				offsetOut: number,
				options: System.Base64FormattingOptions,
			): number;

			/**
			 * Converts an array of 8-bit unsigned integers to its equivalent string representation
			 * that is encoded with base-64 digits.
			 */
			export function ToBase64String(inArray: number[]): string;

			/**
			 * Converts an array of 8-bit unsigned integers to its equivalent string representation
			 * that is encoded with base-64 digits. You can specify whether to insert line breaks in
			 * the return value.
			 */
			export function ToBase64String(
				inArray: number[],
				options: System.Base64FormattingOptions,
			): string;

			/**
			 * Converts a subset of an array of 8-bit unsigned integers to its equivalent string
			 * representation that is encoded with base-64 digits. Parameters specify the subset as
			 * an offset in the input array, and the number of elements in the array to convert.
			 */
			export function ToBase64String(
				inArray: number[],
				offset: number,
				length: number,
			): string;

			/**
			 * Converts a subset of an array of 8-bit unsigned integers to its equivalent string
			 * representation that is encoded with base-64 digits. Parameters specify the subset as
			 * an offset in the input array, the number of elements in the array to convert, and
			 * whether to insert line breaks in the return value.
			 */
			export function ToBase64String(
				inArray: number[],
				offset: number,
				length: number,
				options: System.Base64FormattingOptions,
			): string;

			/**
			 * Converts the 8-bit unsigned integers inside the specified read-only span into their
			 * equivalent string representation that is encoded with base-64 digits. You can
			 * optionally specify whether to insert line breaks in the return value.
			 */
			export function ToBase64String(
				bytes: System.ReadOnlySpan$1<number>,
				options?: System.Base64FormattingOptions,
			): string;

			/** Returns the specified Boolean value; no actual conversion is performed. */
			export function ToBoolean(value: boolean): boolean;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to an equivalent Boolean
			 * value.
			 */
			export function ToBoolean(value: number): boolean;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToBoolean(value: System.Char): boolean;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToBoolean(value: js.DateTime): boolean;

			/** Converts the value of the specified decimal number to an equivalent Boolean value. */
			export function ToBoolean(value: System.Decimal): boolean;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent Boolean value.
			 */
			export function ToBoolean(value: number): boolean;

			/**
			 * Converts the value of the specified 16-bit signed integer to an equivalent Boolean
			 * value.
			 */
			export function ToBoolean(value: number): boolean;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent Boolean
			 * value.
			 */
			export function ToBoolean(value: number): boolean;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent Boolean
			 * value.
			 */
			export function ToBoolean(value: number): boolean;

			/** Converts the value of a specified object to an equivalent Boolean value. */
			export function ToBoolean(value: System.Object | undefined): boolean;

			/**
			 * Converts the value of the specified object to an equivalent Boolean value, using the
			 * specified culture-specific formatting information.
			 */
			export function ToBoolean(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): boolean;

			/**
			 * Converts the value of the specified 8-bit signed integer to an equivalent Boolean
			 * value.
			 */
			export function ToBoolean(value: number): boolean;

			/**
			 * Converts the value of the specified single-precision floating-point number to an
			 * equivalent Boolean value.
			 */
			export function ToBoolean(value: number): boolean;

			/**
			 * Converts the specified string representation of a logical value to its Boolean
			 * equivalent.
			 */
			export function ToBoolean(value: string | undefined): boolean;

			/**
			 * Converts the specified string representation of a logical value to its Boolean
			 * equivalent, using the specified culture-specific formatting information.
			 */
			export function ToBoolean(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): boolean;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to an equivalent Boolean
			 * value.
			 */
			export function ToBoolean(value: number): boolean;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent Boolean
			 * value.
			 */
			export function ToBoolean(value: number): boolean;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent Boolean
			 * value.
			 */
			export function ToBoolean(value: number): boolean;

			/** Converts the specified Boolean value to the equivalent 8-bit unsigned integer. */
			export function ToByte(value: boolean): number;

			/** Returns the specified 8-bit unsigned integer; no actual conversion is performed. */
			export function ToByte(value: number): number;

			/**
			 * Converts the value of the specified Unicode character to the equivalent 8-bit unsigned
			 * integer.
			 */
			export function ToByte(value: System.Char): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToByte(value: js.DateTime): number;

			/**
			 * Converts the value of the specified decimal number to an equivalent 8-bit unsigned
			 * integer.
			 */
			export function ToByte(value: System.Decimal): number;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent 8-bit unsigned integer.
			 */
			export function ToByte(value: number): number;

			/**
			 * Converts the value of the specified 16-bit signed integer to an equivalent 8-bit
			 * unsigned integer.
			 */
			export function ToByte(value: number): number;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent 8-bit
			 * unsigned integer.
			 */
			export function ToByte(value: number): number;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent 8-bit
			 * unsigned integer.
			 */
			export function ToByte(value: number): number;

			/** Converts the value of the specified object to an 8-bit unsigned integer. */
			export function ToByte(value: System.Object | undefined): number;

			/**
			 * Converts the value of the specified object to an 8-bit unsigned integer, using the
			 * specified culture-specific formatting information.
			 */
			export function ToByte(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 8-bit signed integer to an equivalent 8-bit
			 * unsigned integer.
			 */
			export function ToByte(value: number): number;

			/**
			 * Converts the value of the specified single-precision floating-point number to an
			 * equivalent 8-bit unsigned integer.
			 */
			export function ToByte(value: number): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 8-bit
			 * unsigned integer.
			 */
			export function ToByte(value: string | undefined): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 8-bit
			 * unsigned integer, using specified culture-specific formatting information.
			 */
			export function ToByte(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified base to an equivalent
			 * 8-bit unsigned integer.
			 */
			export function ToByte(
				value: string | undefined,
				fromBase: number,
			): number;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to an equivalent 8-bit
			 * unsigned integer.
			 */
			export function ToByte(value: number): number;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent 8-bit
			 * unsigned integer.
			 */
			export function ToByte(value: number): number;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent 8-bit
			 * unsigned integer.
			 */
			export function ToByte(value: number): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToChar(value: boolean): System.Char;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to its equivalent Unicode
			 * character.
			 */
			export function ToChar(value: number): System.Char;

			/** Returns the specified Unicode character value; no actual conversion is performed. */
			export function ToChar(value: System.Char): System.Char;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToChar(value: js.DateTime): System.Char;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToChar(value: System.Decimal): System.Char;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToChar(value: number): System.Char;

			/**
			 * Converts the value of the specified 16-bit signed integer to its equivalent Unicode
			 * character.
			 */
			export function ToChar(value: number): System.Char;

			/**
			 * Converts the value of the specified 32-bit signed integer to its equivalent Unicode
			 * character.
			 */
			export function ToChar(value: number): System.Char;

			/**
			 * Converts the value of the specified 64-bit signed integer to its equivalent Unicode
			 * character.
			 */
			export function ToChar(value: number): System.Char;

			/** Converts the value of the specified object to a Unicode character. */
			export function ToChar(value: System.Object | undefined): System.Char;

			/**
			 * Converts the value of the specified object to its equivalent Unicode character, using
			 * the specified culture-specific formatting information.
			 */
			export function ToChar(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): System.Char;

			/**
			 * Converts the value of the specified 8-bit signed integer to its equivalent Unicode
			 * character.
			 */
			export function ToChar(value: number): System.Char;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToChar(value: number): System.Char;

			/** Converts the first character of a specified string to a Unicode character. */
			export function ToChar(value: string): System.Char;

			/**
			 * Converts the first character of a specified string to a Unicode character, using
			 * specified culture-specific formatting information.
			 */
			export function ToChar(
				value: string,
				provider: System.IFormatProvider | undefined,
			): System.Char;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to its equivalent Unicode
			 * character.
			 */
			export function ToChar(value: number): System.Char;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to its equivalent Unicode
			 * character.
			 */
			export function ToChar(value: number): System.Char;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to its equivalent Unicode
			 * character.
			 */
			export function ToChar(value: number): System.Char;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: boolean): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: number): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: System.Char): js.DateTime;

			/**
			 * Returns the specified {@link System.DateTime} object; no actual conversion is
			 * performed.
			 */
			export function ToDateTime(value: js.DateTime): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: System.Decimal): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: number): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: number): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: number): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: number): js.DateTime;

			/** Converts the value of the specified object to a {@link System.DateTime} object. */
			export function ToDateTime(value: System.Object | undefined): js.DateTime;

			/**
			 * Converts the value of the specified object to a {@link System.DateTime} object, using
			 * the specified culture-specific formatting information.
			 */
			export function ToDateTime(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: number): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: number): js.DateTime;

			/**
			 * Converts the specified string representation of a date and time to an equivalent date
			 * and time value.
			 */
			export function ToDateTime(value: string | undefined): js.DateTime;

			/**
			 * Converts the specified string representation of a number to an equivalent date and
			 * time, using the specified culture-specific formatting information.
			 */
			export function ToDateTime(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: number): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: number): js.DateTime;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDateTime(value: number): js.DateTime;

			/** Converts the specified Boolean value to the equivalent decimal number. */
			export function ToDecimal(value: boolean): System.Decimal;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to the equivalent decimal
			 * number.
			 */
			export function ToDecimal(value: number): System.Decimal;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDecimal(value: System.Char): System.Decimal;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDecimal(value: js.DateTime): System.Decimal;

			/** Returns the specified decimal number; no actual conversion is performed. */
			export function ToDecimal(value: System.Decimal): System.Decimal;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent decimal number.
			 */
			export function ToDecimal(value: number): System.Decimal;

			/**
			 * Converts the value of the specified 16-bit signed integer to an equivalent decimal
			 * number.
			 */
			export function ToDecimal(value: number): System.Decimal;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent decimal
			 * number.
			 */
			export function ToDecimal(value: number): System.Decimal;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent decimal
			 * number.
			 */
			export function ToDecimal(value: number): System.Decimal;

			/** Converts the value of the specified object to an equivalent decimal number. */
			export function ToDecimal(value: System.Object | undefined): System.Decimal;

			/**
			 * Converts the value of the specified object to an equivalent decimal number, using the
			 * specified culture-specific formatting information.
			 */
			export function ToDecimal(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): System.Decimal;

			/**
			 * Converts the value of the specified 8-bit signed integer to the equivalent decimal
			 * number.
			 */
			export function ToDecimal(value: number): System.Decimal;

			/**
			 * Converts the value of the specified single-precision floating-point number to the
			 * equivalent decimal number.
			 */
			export function ToDecimal(value: number): System.Decimal;

			/**
			 * Converts the specified string representation of a number to an equivalent decimal
			 * number.
			 */
			export function ToDecimal(value: string | undefined): System.Decimal;

			/**
			 * Converts the specified string representation of a number to an equivalent decimal
			 * number, using the specified culture-specific formatting information.
			 */
			export function ToDecimal(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): System.Decimal;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to an equivalent decimal
			 * number.
			 */
			export function ToDecimal(value: number): System.Decimal;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent decimal
			 * number.
			 */
			export function ToDecimal(value: number): System.Decimal;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent decimal
			 * number.
			 */
			export function ToDecimal(value: number): System.Decimal;

			/**
			 * Converts the specified Boolean value to the equivalent double-precision floating-point
			 * number.
			 */
			export function ToDouble(value: boolean): number;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to the equivalent
			 * double-precision floating-point number.
			 */
			export function ToDouble(value: number): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDouble(value: System.Char): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToDouble(value: js.DateTime): number;

			/**
			 * Converts the value of the specified decimal number to an equivalent double-precision
			 * floating-point number.
			 */
			export function ToDouble(value: System.Decimal): number;

			/**
			 * Returns the specified double-precision floating-point number; no actual conversion is
			 * performed.
			 */
			export function ToDouble(value: number): number;

			/**
			 * Converts the value of the specified 16-bit signed integer to an equivalent
			 * double-precision floating-point number.
			 */
			export function ToDouble(value: number): number;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent
			 * double-precision floating-point number.
			 */
			export function ToDouble(value: number): number;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent
			 * double-precision floating-point number.
			 */
			export function ToDouble(value: number): number;

			/**
			 * Converts the value of the specified object to a double-precision floating-point
			 * number.
			 */
			export function ToDouble(value: System.Object | undefined): number;

			/**
			 * Converts the value of the specified object to an double-precision floating-point
			 * number, using the specified culture-specific formatting information.
			 */
			export function ToDouble(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 8-bit signed integer to the equivalent
			 * double-precision floating-point number.
			 */
			export function ToDouble(value: number): number;

			/**
			 * Converts the value of the specified single-precision floating-point number to an
			 * equivalent double-precision floating-point number.
			 */
			export function ToDouble(value: number): number;

			/**
			 * Converts the specified string representation of a number to an equivalent
			 * double-precision floating-point number.
			 */
			export function ToDouble(value: string | undefined): number;

			/**
			 * Converts the specified string representation of a number to an equivalent
			 * double-precision floating-point number, using the specified culture-specific
			 * formatting information.
			 */
			export function ToDouble(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to the equivalent
			 * double-precision floating-point number.
			 */
			export function ToDouble(value: number): number;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent
			 * double-precision floating-point number.
			 */
			export function ToDouble(value: number): number;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent
			 * double-precision floating-point number.
			 */
			export function ToDouble(value: number): number;

			/**
			 * Converts an array of 8-bit unsigned integers to its equivalent string representation
			 * that is encoded with uppercase hex characters.
			 */
			export function ToHexString(inArray: number[]): string;

			/**
			 * Converts a subset of an array of 8-bit unsigned integers to its equivalent string
			 * representation that is encoded with uppercase hex characters. Parameters specify the
			 * subset as an offset in the input array and the number of elements in the array to
			 * convert.
			 */
			export function ToHexString(
				inArray: number[],
				offset: number,
				length: number,
			): string;

			/**
			 * Converts a span of 8-bit unsigned integers to its equivalent string representation
			 * that is encoded with uppercase hex characters.
			 */
			export function ToHexString(bytes: System.ReadOnlySpan$1<number>): string;

			/** Converts the specified Boolean value to the equivalent 16-bit signed integer. */
			export function ToInt16(value: boolean): number;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to the equivalent 16-bit
			 * signed integer.
			 */
			export function ToInt16(value: number): number;

			/**
			 * Converts the value of the specified Unicode character to the equivalent 16-bit signed
			 * integer.
			 */
			export function ToInt16(value: System.Char): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToInt16(value: js.DateTime): number;

			/**
			 * Converts the value of the specified decimal number to an equivalent 16-bit signed
			 * integer.
			 */
			export function ToInt16(value: System.Decimal): number;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent 16-bit signed integer.
			 */
			export function ToInt16(value: number): number;

			/** Returns the specified 16-bit signed integer; no actual conversion is performed. */
			export function ToInt16(value: number): number;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent 16-bit
			 * signed integer.
			 */
			export function ToInt16(value: number): number;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent 16-bit
			 * signed integer.
			 */
			export function ToInt16(value: number): number;

			/** Converts the value of the specified object to a 16-bit signed integer. */
			export function ToInt16(value: System.Object | undefined): number;

			/**
			 * Converts the value of the specified object to a 16-bit signed integer, using the
			 * specified culture-specific formatting information.
			 */
			export function ToInt16(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 8-bit signed integer to the equivalent 16-bit
			 * signed integer.
			 */
			export function ToInt16(value: number): number;

			/**
			 * Converts the value of the specified single-precision floating-point number to an
			 * equivalent 16-bit signed integer.
			 */
			export function ToInt16(value: number): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 16-bit
			 * signed integer.
			 */
			export function ToInt16(value: string | undefined): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 16-bit
			 * signed integer, using the specified culture-specific formatting information.
			 */
			export function ToInt16(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified base to an equivalent
			 * 16-bit signed integer.
			 */
			export function ToInt16(
				value: string | undefined,
				fromBase: number,
			): number;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to the equivalent 16-bit
			 * signed integer.
			 */
			export function ToInt16(value: number): number;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent 16-bit
			 * signed integer.
			 */
			export function ToInt16(value: number): number;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent 16-bit
			 * signed integer.
			 */
			export function ToInt16(value: number): number;

			/** Converts the specified Boolean value to the equivalent 32-bit signed integer. */
			export function ToInt32(value: boolean): number;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to the equivalent 32-bit
			 * signed integer.
			 */
			export function ToInt32(value: number): number;

			/**
			 * Converts the value of the specified Unicode character to the equivalent 32-bit signed
			 * integer.
			 */
			export function ToInt32(value: System.Char): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToInt32(value: js.DateTime): number;

			/**
			 * Converts the value of the specified decimal number to an equivalent 32-bit signed
			 * integer.
			 */
			export function ToInt32(value: System.Decimal): number;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent 32-bit signed integer.
			 */
			export function ToInt32(value: number): number;

			/**
			 * Converts the value of the specified 16-bit signed integer to an equivalent 32-bit
			 * signed integer.
			 */
			export function ToInt32(value: number): number;

			/** Returns the specified 32-bit signed integer; no actual conversion is performed. */
			export function ToInt32(value: number): number;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent 32-bit
			 * signed integer.
			 */
			export function ToInt32(value: number): number;

			/** Converts the value of the specified object to a 32-bit signed integer. */
			export function ToInt32(value: System.Object | undefined): number;

			/**
			 * Converts the value of the specified object to a 32-bit signed integer, using the
			 * specified culture-specific formatting information.
			 */
			export function ToInt32(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 8-bit signed integer to the equivalent 32-bit
			 * signed integer.
			 */
			export function ToInt32(value: number): number;

			/**
			 * Converts the value of the specified single-precision floating-point number to an
			 * equivalent 32-bit signed integer.
			 */
			export function ToInt32(value: number): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 32-bit
			 * signed integer.
			 */
			export function ToInt32(value: string | undefined): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 32-bit
			 * signed integer, using the specified culture-specific formatting information.
			 */
			export function ToInt32(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified base to an equivalent
			 * 32-bit signed integer.
			 */
			export function ToInt32(
				value: string | undefined,
				fromBase: number,
			): number;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to the equivalent 32-bit
			 * signed integer.
			 */
			export function ToInt32(value: number): number;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent 32-bit
			 * signed integer.
			 */
			export function ToInt32(value: number): number;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent 32-bit
			 * signed integer.
			 */
			export function ToInt32(value: number): number;

			/** Converts the specified Boolean value to the equivalent 64-bit signed integer. */
			export function ToInt64(value: boolean): number;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to the equivalent 64-bit
			 * signed integer.
			 */
			export function ToInt64(value: number): number;

			/**
			 * Converts the value of the specified Unicode character to the equivalent 64-bit signed
			 * integer.
			 */
			export function ToInt64(value: System.Char): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToInt64(value: js.DateTime): number;

			/**
			 * Converts the value of the specified decimal number to an equivalent 64-bit signed
			 * integer.
			 */
			export function ToInt64(value: System.Decimal): number;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent 64-bit signed integer.
			 */
			export function ToInt64(value: number): number;

			/**
			 * Converts the value of the specified 16-bit signed integer to an equivalent 64-bit
			 * signed integer.
			 */
			export function ToInt64(value: number): number;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent 64-bit
			 * signed integer.
			 */
			export function ToInt64(value: number): number;

			/** Returns the specified 64-bit signed integer; no actual conversion is performed. */
			export function ToInt64(value: number): number;

			/** Converts the value of the specified object to a 64-bit signed integer. */
			export function ToInt64(value: System.Object | undefined): number;

			/**
			 * Converts the value of the specified object to a 64-bit signed integer, using the
			 * specified culture-specific formatting information.
			 */
			export function ToInt64(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 8-bit signed integer to the equivalent 64-bit
			 * signed integer.
			 */
			export function ToInt64(value: number): number;

			/**
			 * Converts the value of the specified single-precision floating-point number to an
			 * equivalent 64-bit signed integer.
			 */
			export function ToInt64(value: number): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 64-bit
			 * signed integer.
			 */
			export function ToInt64(value: string | undefined): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 64-bit
			 * signed integer, using the specified culture-specific formatting information.
			 */
			export function ToInt64(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified base to an equivalent
			 * 64-bit signed integer.
			 */
			export function ToInt64(
				value: string | undefined,
				fromBase: number,
			): number;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to the equivalent 64-bit
			 * signed integer.
			 */
			export function ToInt64(value: number): number;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent 64-bit
			 * signed integer.
			 */
			export function ToInt64(value: number): number;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent 64-bit
			 * signed integer.
			 */
			export function ToInt64(value: number): number;

			/** Converts the specified Boolean value to the equivalent 8-bit signed integer. */
			export function ToSByte(value: boolean): number;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to the equivalent 8-bit
			 * signed integer.
			 */
			export function ToSByte(value: number): number;

			/**
			 * Converts the value of the specified Unicode character to the equivalent 8-bit signed
			 * integer.
			 */
			export function ToSByte(value: System.Char): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToSByte(value: js.DateTime): number;

			/**
			 * Converts the value of the specified decimal number to an equivalent 8-bit signed
			 * integer.
			 */
			export function ToSByte(value: System.Decimal): number;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent 8-bit signed integer.
			 */
			export function ToSByte(value: number): number;

			/**
			 * Converts the value of the specified 16-bit signed integer to the equivalent 8-bit
			 * signed integer.
			 */
			export function ToSByte(value: number): number;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent 8-bit
			 * signed integer.
			 */
			export function ToSByte(value: number): number;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent 8-bit
			 * signed integer.
			 */
			export function ToSByte(value: number): number;

			/** Converts the value of the specified object to an 8-bit signed integer. */
			export function ToSByte(value: System.Object | undefined): number;

			/**
			 * Converts the value of the specified object to an 8-bit signed integer, using the
			 * specified culture-specific formatting information.
			 */
			export function ToSByte(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Returns the specified 8-bit signed integer; no actual conversion is performed. */
			export function ToSByte(value: number): number;

			/**
			 * Converts the value of the specified single-precision floating-point number to an
			 * equivalent 8-bit signed integer.
			 */
			export function ToSByte(value: number): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 8-bit signed
			 * integer.
			 */
			export function ToSByte(value: string | undefined): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 8-bit signed
			 * integer, using the specified culture-specific formatting information.
			 */
			export function ToSByte(
				value: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified base to an equivalent
			 * 8-bit signed integer.
			 */
			export function ToSByte(
				value: string | undefined,
				fromBase: number,
			): number;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to the equivalent 8-bit
			 * signed integer.
			 */
			export function ToSByte(value: number): number;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent 8-bit
			 * signed integer.
			 */
			export function ToSByte(value: number): number;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent 8-bit
			 * signed integer.
			 */
			export function ToSByte(value: number): number;

			/**
			 * Converts the specified Boolean value to the equivalent single-precision floating-point
			 * number.
			 */
			export function ToSingle(value: boolean): number;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to the equivalent
			 * single-precision floating-point number.
			 */
			export function ToSingle(value: number): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToSingle(value: System.Char): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToSingle(value: js.DateTime): number;

			/**
			 * Converts the value of the specified decimal number to an equivalent single-precision
			 * floating-point number.
			 */
			export function ToSingle(value: System.Decimal): number;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent single-precision floating-point number.
			 */
			export function ToSingle(value: number): number;

			/**
			 * Converts the value of the specified 16-bit signed integer to an equivalent
			 * single-precision floating-point number.
			 */
			export function ToSingle(value: number): number;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent
			 * single-precision floating-point number.
			 */
			export function ToSingle(value: number): number;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent
			 * single-precision floating-point number.
			 */
			export function ToSingle(value: number): number;

			/**
			 * Converts the value of the specified object to a single-precision floating-point
			 * number.
			 */
			export function ToSingle(value: System.Object | undefined): number;

			/**
			 * Converts the value of the specified object to an single-precision floating-point
			 * number, using the specified culture-specific formatting information.
			 */
			export function ToSingle(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 8-bit signed integer to the equivalent
			 * single-precision floating-point number.
			 */
			export function ToSingle(value: number): number;

			/**
			 * Returns the specified single-precision floating-point number; no actual conversion is
			 * performed.
			 */
			export function ToSingle(value: number): number;

			/**
			 * Converts the specified string representation of a number to an equivalent
			 * single-precision floating-point number.
			 */
			export function ToSingle(value: string | undefined): number;

			/**
			 * Converts the specified string representation of a number to an equivalent
			 * single-precision floating-point number, using the specified culture-specific
			 * formatting information.
			 */
			export function ToSingle(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to the equivalent
			 * single-precision floating-point number.
			 */
			export function ToSingle(value: number): number;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent
			 * single-precision floating-point number.
			 */
			export function ToSingle(value: number): number;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent
			 * single-precision floating-point number.
			 */
			export function ToSingle(value: number): number;

			/** Converts the specified Boolean value to its equivalent string representation. */
			export function ToString(value: boolean): string;

			/** Converts the specified Boolean value to its equivalent string representation. */
			export function ToString(
				value: boolean,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to its equivalent string
			 * representation.
			 */
			export function ToString(value: number): string;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: number,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of an 8-bit unsigned integer to its equivalent string
			 * representation in a specified base.
			 */
			export function ToString(
				value: number,
				toBase: number,
			): string;

			/**
			 * Converts the value of the specified Unicode character to its equivalent string
			 * representation.
			 */
			export function ToString(value: System.Char): string;

			/**
			 * Converts the value of the specified Unicode character to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: System.Char,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of the specified {@link System.DateTime} to its equivalent string
			 * representation.
			 */
			export function ToString(value: js.DateTime): string;

			/**
			 * Converts the value of the specified {@link System.DateTime} to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: js.DateTime,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of the specified decimal number to its equivalent string
			 * representation.
			 */
			export function ToString(value: System.Decimal): string;

			/**
			 * Converts the value of the specified decimal number to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: System.Decimal,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of the specified double-precision floating-point number to its
			 * equivalent string representation.
			 */
			export function ToString(value: number): string;

			/**
			 * Converts the value of the specified double-precision floating-point number to its
			 * equivalent string representation.
			 */
			export function ToString(
				value: number,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of the specified 16-bit signed integer to its equivalent string
			 * representation.
			 */
			export function ToString(value: number): string;

			/**
			 * Converts the value of the specified 16-bit signed integer to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: number,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of a 16-bit signed integer to its equivalent string representation
			 * in a specified base.
			 */
			export function ToString(
				value: number,
				toBase: number,
			): string;

			/**
			 * Converts the value of the specified 32-bit signed integer to its equivalent string
			 * representation.
			 */
			export function ToString(value: number): string;

			/**
			 * Converts the value of the specified 32-bit signed integer to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: number,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of a 32-bit signed integer to its equivalent string representation
			 * in a specified base.
			 */
			export function ToString(
				value: number,
				toBase: number,
			): string;

			/**
			 * Converts the value of the specified 64-bit signed integer to its equivalent string
			 * representation.
			 */
			export function ToString(value: number): string;

			/**
			 * Converts the value of the specified 64-bit signed integer to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: number,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of a 64-bit signed integer to its equivalent string representation
			 * in a specified base.
			 */
			export function ToString(
				value: number,
				toBase: number,
			): string;

			/**
			 * Converts the value of the specified object to its equivalent string representation.
			 */
			export function ToString(value: System.Object | undefined): string | undefined;

			/**
			 * Converts the value of the specified object to its equivalent string representation
			 * using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): string | undefined;

			/**
			 * Converts the value of the specified 8-bit signed integer to its equivalent string
			 * representation.
			 */
			export function ToString(value: number): string;

			/**
			 * Converts the value of the specified 8-bit signed integer to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: number,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of the specified single-precision floating-point number to its
			 * equivalent string representation.
			 */
			export function ToString(value: number): string;

			/**
			 * Converts the value of the specified single-precision floating-point number to its
			 * equivalent string representation, using the specified culture-specific formatting
			 * information.
			 */
			export function ToString(
				value: number,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Returns the specified string instance; no actual conversion is performed. */
			export function ToString(value: string | undefined): string | undefined;

			/** Returns the specified string instance; no actual conversion is performed. */
			export function ToString(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string | undefined;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to its equivalent string
			 * representation.
			 */
			export function ToString(value: number): string;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: number,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to its equivalent string
			 * representation.
			 */
			export function ToString(value: number): string;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: number,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to its equivalent string
			 * representation.
			 */
			export function ToString(value: number): string;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to its equivalent string
			 * representation, using the specified culture-specific formatting information.
			 */
			export function ToString(
				value: number,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Converts the specified Boolean value to the equivalent 16-bit unsigned integer. */
			export function ToUInt16(value: boolean): number;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to the equivalent 16-bit
			 * unsigned integer.
			 */
			export function ToUInt16(value: number): number;

			/**
			 * Converts the value of the specified Unicode character to the equivalent 16-bit
			 * unsigned integer.
			 */
			export function ToUInt16(value: System.Char): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToUInt16(value: js.DateTime): number;

			/**
			 * Converts the value of the specified decimal number to an equivalent 16-bit unsigned
			 * integer.
			 */
			export function ToUInt16(value: System.Decimal): number;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent 16-bit unsigned integer.
			 */
			export function ToUInt16(value: number): number;

			/**
			 * Converts the value of the specified 16-bit signed integer to the equivalent 16-bit
			 * unsigned integer.
			 */
			export function ToUInt16(value: number): number;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent 16-bit
			 * unsigned integer.
			 */
			export function ToUInt16(value: number): number;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent 16-bit
			 * unsigned integer.
			 */
			export function ToUInt16(value: number): number;

			/** Converts the value of the specified object to a 16-bit unsigned integer. */
			export function ToUInt16(value: System.Object | undefined): number;

			/**
			 * Converts the value of the specified object to a 16-bit unsigned integer, using the
			 * specified culture-specific formatting information.
			 */
			export function ToUInt16(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 8-bit signed integer to the equivalent 16-bit
			 * unsigned integer.
			 */
			export function ToUInt16(value: number): number;

			/**
			 * Converts the value of the specified single-precision floating-point number to an
			 * equivalent 16-bit unsigned integer.
			 */
			export function ToUInt16(value: number): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 16-bit
			 * unsigned integer.
			 */
			export function ToUInt16(value: string | undefined): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 16-bit
			 * unsigned integer, using the specified culture-specific formatting information.
			 */
			export function ToUInt16(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified base to an equivalent
			 * 16-bit unsigned integer.
			 */
			export function ToUInt16(
				value: string | undefined,
				fromBase: number,
			): number;

			/** Returns the specified 16-bit unsigned integer; no actual conversion is performed. */
			export function ToUInt16(value: number): number;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent 16-bit
			 * unsigned integer.
			 */
			export function ToUInt16(value: number): number;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent 16-bit
			 * unsigned integer.
			 */
			export function ToUInt16(value: number): number;

			/** Converts the specified Boolean value to the equivalent 32-bit unsigned integer. */
			export function ToUInt32(value: boolean): number;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to the equivalent 32-bit
			 * unsigned integer.
			 */
			export function ToUInt32(value: number): number;

			/**
			 * Converts the value of the specified Unicode character to the equivalent 32-bit
			 * unsigned integer.
			 */
			export function ToUInt32(value: System.Char): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToUInt32(value: js.DateTime): number;

			/**
			 * Converts the value of the specified decimal number to an equivalent 32-bit unsigned
			 * integer.
			 */
			export function ToUInt32(value: System.Decimal): number;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent 32-bit unsigned integer.
			 */
			export function ToUInt32(value: number): number;

			/**
			 * Converts the value of the specified 16-bit signed integer to the equivalent 32-bit
			 * unsigned integer.
			 */
			export function ToUInt32(value: number): number;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent 32-bit
			 * unsigned integer.
			 */
			export function ToUInt32(value: number): number;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent 32-bit
			 * unsigned integer.
			 */
			export function ToUInt32(value: number): number;

			/** Converts the value of the specified object to a 32-bit unsigned integer. */
			export function ToUInt32(value: System.Object | undefined): number;

			/**
			 * Converts the value of the specified object to a 32-bit unsigned integer, using the
			 * specified culture-specific formatting information.
			 */
			export function ToUInt32(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 8-bit signed integer to the equivalent 32-bit
			 * unsigned integer.
			 */
			export function ToUInt32(value: number): number;

			/**
			 * Converts the value of the specified single-precision floating-point number to an
			 * equivalent 32-bit unsigned integer.
			 */
			export function ToUInt32(value: number): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 32-bit
			 * unsigned integer.
			 */
			export function ToUInt32(value: string | undefined): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 32-bit
			 * unsigned integer, using the specified culture-specific formatting information.
			 */
			export function ToUInt32(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified base to an equivalent
			 * 32-bit unsigned integer.
			 */
			export function ToUInt32(
				value: string | undefined,
				fromBase: number,
			): number;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to the equivalent 32-bit
			 * unsigned integer.
			 */
			export function ToUInt32(value: number): number;

			/** Returns the specified 32-bit unsigned integer; no actual conversion is performed. */
			export function ToUInt32(value: number): number;

			/**
			 * Converts the value of the specified 64-bit unsigned integer to an equivalent 32-bit
			 * unsigned integer.
			 */
			export function ToUInt32(value: number): number;

			/** Converts the specified Boolean value to the equivalent 64-bit unsigned integer. */
			export function ToUInt64(value: boolean): number;

			/**
			 * Converts the value of the specified 8-bit unsigned integer to the equivalent 64-bit
			 * unsigned integer.
			 */
			export function ToUInt64(value: number): number;

			/**
			 * Converts the value of the specified Unicode character to the equivalent 64-bit
			 * unsigned integer.
			 */
			export function ToUInt64(value: System.Char): number;

			/** Calling this method always throws {@link System.InvalidCastException}. */
			export function ToUInt64(value: js.DateTime): number;

			/**
			 * Converts the value of the specified decimal number to an equivalent 64-bit unsigned
			 * integer.
			 */
			export function ToUInt64(value: System.Decimal): number;

			/**
			 * Converts the value of the specified double-precision floating-point number to an
			 * equivalent 64-bit unsigned integer.
			 */
			export function ToUInt64(value: number): number;

			/**
			 * Converts the value of the specified 16-bit signed integer to the equivalent 64-bit
			 * unsigned integer.
			 */
			export function ToUInt64(value: number): number;

			/**
			 * Converts the value of the specified 32-bit signed integer to an equivalent 64-bit
			 * unsigned integer.
			 */
			export function ToUInt64(value: number): number;

			/**
			 * Converts the value of the specified 64-bit signed integer to an equivalent 64-bit
			 * unsigned integer.
			 */
			export function ToUInt64(value: number): number;

			/** Converts the value of the specified object to a 64-bit unsigned integer. */
			export function ToUInt64(value: System.Object | undefined): number;

			/**
			 * Converts the value of the specified object to a 64-bit unsigned integer, using the
			 * specified culture-specific formatting information.
			 */
			export function ToUInt64(
				value: System.Object | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the value of the specified 8-bit signed integer to the equivalent 64-bit
			 * unsigned integer.
			 */
			export function ToUInt64(value: number): number;

			/**
			 * Converts the value of the specified single-precision floating-point number to an
			 * equivalent 64-bit unsigned integer.
			 */
			export function ToUInt64(value: number): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 64-bit
			 * unsigned integer.
			 */
			export function ToUInt64(value: string | undefined): number;

			/**
			 * Converts the specified string representation of a number to an equivalent 64-bit
			 * unsigned integer, using the specified culture-specific formatting information.
			 */
			export function ToUInt64(
				value: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified base to an equivalent
			 * 64-bit unsigned integer.
			 */
			export function ToUInt64(
				value: string | undefined,
				fromBase: number,
			): number;

			/**
			 * Converts the value of the specified 16-bit unsigned integer to the equivalent 64-bit
			 * unsigned integer.
			 */
			export function ToUInt64(value: number): number;

			/**
			 * Converts the value of the specified 32-bit unsigned integer to an equivalent 64-bit
			 * unsigned integer.
			 */
			export function ToUInt64(value: number): number;

			/** Returns the specified 64-bit unsigned integer; no actual conversion is performed. */
			export function ToUInt64(value: number): number;

			export function TryFromBase64Chars(
				chars: System.ReadOnlySpan$1<System.Char>,
				bytes: System.Span$1<number>,
			): number | undefined;

			export function TryFromBase64String(
				s: string,
				bytes: System.Span$1<number>,
			): number | undefined;

			export function TryToBase64Chars(
				bytes: System.ReadOnlySpan$1<number>,
				chars: System.Span$1<System.Char>,
				options?: System.Base64FormattingOptions,
			): System.Base64FormattingOptions | undefined;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Represents a method that converts an object from one type to
		 * another type.
		 */
		export function Converter$(TInput: IType, TOutput: IType): IType;

		/** Represents a method that converts an object from one type to another type. */
		export interface Converter$2<TInput, TOutput> { (input: TInput): TOutput; }
	}

	export namespace System {
		/**
		 * Represents dates with values ranging from January 1, 0001 Anno Domini (Common Era)
		 * through December 31, 9999 A.D. (C.E.) in the Gregorian calendar.
		 */
		export class DateOnly extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<System.DateOnly>,
			System.IEquatable$1<System.DateOnly>,
			System.IFormattable,
			System.IParsable$1<System.DateOnly>,
			System.ISpanFormattable,
			System.ISpanParsable$1<System.DateOnly>,
			System.IUtf8SpanFormattable {
			/**
			 * Creates a new instance of the {@link System.DateOnly} structure to the specified year,
			 * month, and day.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
			);

			/**
			 * Creates a new instance of the {@link System.DateOnly} structure to the specified year,
			 * month, and day for the specified calendar.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				calendar: System.Globalization.Calendar,
			);

			/** Gets the day component of the date represented by this instance. */
			readonly Day: number;

			/**
			 * Gets the number of days since January 1, 0001 in the Proleptic Gregorian calendar
			 * represented by this instance.
			 */
			readonly DayNumber: number;

			/** Gets the day of the week represented by this instance. */
			readonly DayOfWeek: System.DayOfWeek;

			/** Gets the day of the year represented by this instance. */
			readonly DayOfYear: number;

			/** Gets the latest possible date that can be created. */
			static readonly MaxValue: System.DateOnly;

			/** Gets the earliest possible date that can be created. */
			static readonly MinValue: System.DateOnly;

			/** Gets the month component of the date represented by this instance. */
			readonly Month: number;

			/** Gets the year component of the date represented by this instance. */
			readonly Year: number;

			/** Adds the specified number of days to the value of this instance. */
			AddDays(value: number): System.DateOnly;

			/** Adds the specified number of months to the value of this instance. */
			AddMonths(value: number): System.DateOnly;

			/** Adds the specified number of years to the value of this instance. */
			AddYears(value: number): System.DateOnly;

			/**
			 * Compares the value of this instance to a specified {@link System.DateOnly} value and
			 * returns an integer that indicates whether this instance is earlier than, the same as,
			 * or later than the specified {@link System.DateOnly} value.
			 */
			CompareTo(value: System.DateOnly): number;

			/**
			 * Compares the value of this instance to a specified object that contains a specified
			 * {@link System.DateOnly} value, and returns an integer that indicates whether this
			 * instance is earlier than, the same as, or later than the specified
			 * {@link System.DateOnly} value.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Returns a value indicating whether the value of this instance is equal to the value of
			 * the specified {@link System.DateOnly} instance.
			 */
			Equals(value: System.DateOnly): boolean;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Returns a {@link System.DateOnly} instance that is set to the date part of the
			 * specified `dateTime`.
			 */
			static FromDateTime(dateTime: js.DateTime): System.DateOnly;

			/**
			 * Creates a new instance of the {@link System.DateOnly} structure to the specified
			 * number of days.
			 */
			static FromDayNumber(dayNumber: number): System.DateOnly;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			Deconstruct(): { year: number, month: number, day: number };

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.DateOnly;

			/**
			 * Converts a memory span that contains string representation of a date to its
			 * {@link System.DateOnly} equivalent by using culture-specific format information and a
			 * formatting style.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
				style?: System.Globalization.DateTimeStyles,
			): System.DateOnly;

			/**
			 * Converts a string that contains string representation of a date to its
			 * {@link System.DateOnly} equivalent by using the conventions of the current culture.
			 */
			static Parse(s: string): System.DateOnly;

			/** Parses a string into a value. */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): System.DateOnly;

			/**
			 * Converts a string that contains string representation of a date to its
			 * {@link System.DateOnly} equivalent by using culture-specific format information and a
			 * formatting style.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
				style?: System.Globalization.DateTimeStyles,
			): System.DateOnly;

			/**
			 * Converts the specified span representation of a date to its {@link System.DateOnly}
			 * equivalent using the specified format, culture-specific format information, and style.
			 * The format of the string representation must match the specified format exactly or an
			 * exception is thrown.
			 */
			static ParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
				style?: System.Globalization.DateTimeStyles,
			): System.DateOnly;

			/**
			 * Converts the specified span representation of a date to its {@link System.DateOnly}
			 * equivalent using the specified array of formats. The format of the string
			 * representation must match at least one of the specified formats exactly or an
			 * exception is thrown.
			 */
			static ParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				formats: string[],
			): System.DateOnly;

			/**
			 * Converts the specified span representation of a date to its {@link System.DateOnly}
			 * equivalent using the specified array of formats, culture-specific format information,
			 * and style. The format of the string representation must match at least one of the
			 * specified formats exactly or an exception is thrown.
			 */
			static ParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				formats: string[],
				provider: System.IFormatProvider | undefined,
				style?: System.Globalization.DateTimeStyles,
			): System.DateOnly;

			/**
			 * Converts the specified string representation of a date to its {@link System.DateOnly}
			 * equivalent using the specified format. The format of the string representation must
			 * match the specified format exactly or an exception is thrown.
			 */
			static ParseExact(
				s: string,
				format: string,
			): System.DateOnly;

			/**
			 * Converts the specified string representation of a date to its {@link System.DateOnly}
			 * equivalent using the specified format, culture-specific format information, and style.
			 * The format of the string representation must match the specified format exactly or an
			 * exception is thrown.
			 */
			static ParseExact(
				s: string,
				format: string,
				provider: System.IFormatProvider | undefined,
				style?: System.Globalization.DateTimeStyles,
			): System.DateOnly;

			/**
			 * Converts the specified span representation of a date to its {@link System.DateOnly}
			 * equivalent using the specified array of formats. The format of the string
			 * representation must match at least one of the specified formats exactly or an
			 * exception is thrown.
			 */
			static ParseExact(
				s: string,
				formats: string[],
			): System.DateOnly;

			/**
			 * Converts the specified string representation of a date to its {@link System.DateOnly}
			 * equivalent using the specified array of formats, culture-specific format information,
			 * and style. The format of the string representation must match at least one of the
			 * specified formats exactly or an exception is thrown.
			 */
			static ParseExact(
				s: string,
				formats: string[],
				provider: System.IFormatProvider | undefined,
				style?: System.Globalization.DateTimeStyles,
			): System.DateOnly;

			/**
			 * Returns a {@link System.DateTime} that is set to the date of this
			 * {@link System.DateOnly} instance and the time of specified input time.
			 */
			ToDateTime(time: System.TimeOnly): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} instance with the specified input kind that is set
			 * to the date of this {@link System.DateOnly} instance and the time of specified input
			 * time.
			 */
			ToDateTime(
				time: System.TimeOnly,
				kind: System.DateTimeKind,
			): js.DateTime;

			/**
			 * Converts the value of the current {@link System.DateOnly} object to its equivalent
			 * long date string representation.
			 */
			ToLongDateString(): string;

			/**
			 * Converts the value of the current {@link System.DateOnly} object to its equivalent
			 * short date string representation.
			 */
			ToShortDateString(): string;

			/**
			 * Converts the value of the current {@link System.DateOnly} object to its equivalent
			 * string representation using the formatting conventions of the current culture. The
			 * {@link System.DateOnly} object will be formatted in short form.
			 */
			ToString(): string;

			/**
			 * Converts the value of the current {@link System.DateOnly} object to its equivalent
			 * string representation using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the value of the current {@link System.DateOnly} object to its equivalent
			 * string representation using the specified format and the formatting conventions of the
			 * current culture.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the value of the current {@link System.DateOnly} object to its equivalent
			 * string representation using the specified culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): System.DateOnly | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.DateOnly | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.DateOnly | undefined;

			static TryParse(s: string | undefined): System.DateOnly | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): System.DateOnly | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.DateOnly | undefined;

			static TryParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
			): System.DateOnly | undefined;

			static TryParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.DateOnly | undefined;

			static TryParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				formats: string | undefined[] | undefined,
			): System.DateOnly | undefined;

			static TryParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				formats: string | undefined[] | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.DateOnly | undefined;

			static TryParseExact(
				s: string | undefined,
				format: string | undefined,
			): System.DateOnly | undefined;

			static TryParseExact(
				s: string | undefined,
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.DateOnly | undefined;

			static TryParseExact(
				s: string | undefined,
				formats: string | undefined[] | undefined,
			): System.DateOnly | undefined;

			static TryParseExact(
				s: string | undefined,
				formats: string | undefined[] | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.DateOnly | undefined;
		}
	}

	export namespace System {
		/** Represents an instant in time, typically expressed as a date and time of day. */
		export class DateTime extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<js.DateTime>,
			System.IEquatable$1<js.DateTime>,
			System.IFormattable,
			System.IParsable$1<js.DateTime>,
			System.ISpanFormattable,
			System.ISpanParsable$1<js.DateTime>,
			System.IUtf8SpanFormattable {
			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, and day.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, and day for the specified calendar.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				calendar: System.Globalization.Calendar,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, and second.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, second, and Coordinated Universal Time (UTC) or local
			 * time.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				kind: System.DateTimeKind,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, and second for the specified calendar.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				calendar: System.Globalization.Calendar,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, second, and millisecond.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, second, millisecond, and Coordinated Universal Time
			 * (UTC) or local time.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				kind: System.DateTimeKind,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, second, and millisecond for the specified calendar.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				calendar: System.Globalization.Calendar,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, second, millisecond, and Coordinated Universal Time
			 * (UTC) or local time for the specified calendar.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				calendar: System.Globalization.Calendar,
				kind: System.DateTimeKind,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, second, millisecond, and Coordinated Universal Time
			 * (UTC) or local time for the specified calendar.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				microsecond: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, second, millisecond, and Coordinated Universal Time
			 * (UTC) or local time for the specified calendar.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				microsecond: number,
				kind: System.DateTimeKind,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, second, millisecond, and Coordinated Universal Time
			 * (UTC) or local time for the specified calendar.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				microsecond: number,
				calendar: System.Globalization.Calendar,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * year, month, day, hour, minute, second, millisecond, and Coordinated Universal Time
			 * (UTC) or local time for the specified calendar.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				microsecond: number,
				calendar: System.Globalization.Calendar,
				kind: System.DateTimeKind,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to a specified
			 * number of ticks.
			 */
			constructor(ticks: number);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to a specified
			 * number of ticks and to Coordinated Universal Time (UTC) or local time.
			 */
			constructor(
				ticks: number,
				kind: System.DateTimeKind,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * {@link System.DateOnly} and {@link System.TimeOnly}. The new instance will have the
			 * {@link System.DateTimeKind.Unspecified} kind.
			 */
			constructor(
				date: System.DateOnly,
				time: System.TimeOnly,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTime} structure to the specified
			 * {@link System.DateOnly} and {@link System.TimeOnly} and respecting the specified
			 * {@link System.DateTimeKind}.
			 */
			constructor(
				date: System.DateOnly,
				time: System.TimeOnly,
				kind: System.DateTimeKind,
			);

			/** Gets the date component of this instance. */
			readonly Date: js.DateTime;

			/** Gets the day of the month represented by this instance. */
			readonly Day: number;

			/** Gets the day of the week represented by this instance. */
			readonly DayOfWeek: System.DayOfWeek;

			/** Gets the day of the year represented by this instance. */
			readonly DayOfYear: number;

			/** Gets the hour component of the date represented by this instance. */
			readonly Hour: number;

			/**
			 * Gets a value that indicates whether the time represented by this instance is based on
			 * local time, Coordinated Universal Time (UTC), or neither.
			 */
			readonly Kind: System.DateTimeKind;

			/** The microseconds component, expressed as a value between 0 and 999. */
			readonly Microsecond: number;

			/** Gets the milliseconds component of the date represented by this instance. */
			readonly Millisecond: number;

			/** Gets the minute component of the date represented by this instance. */
			readonly Minute: number;

			/** Gets the month component of the date represented by this instance. */
			readonly Month: number;

			/**
			 * The nanoseconds component, expressed as a value between 0 and 900 (in increments of
			 * 100 nanoseconds).
			 */
			readonly Nanosecond: number;

			/**
			 * Gets a {@link System.DateTime} object that is set to the current date and time on this
			 * computer, expressed as the local time.
			 */
			static readonly Now: js.DateTime;

			/** Gets the seconds component of the date represented by this instance. */
			readonly Second: number;

			/** Gets the number of ticks that represent the date and time of this instance. */
			readonly Ticks: number;

			/** Gets the time of day for this instance. */
			readonly TimeOfDay: number;

			/** Gets the current date. */
			static readonly Today: js.DateTime;

			/**
			 * Gets a {@link System.DateTime} object that is set to the current date and time on this
			 * computer, expressed as the Coordinated Universal Time (UTC).
			 */
			static readonly UtcNow: js.DateTime;

			/** Gets the year component of the date represented by this instance. */
			readonly Year: number;

			/**
			 * Returns a new {@link System.DateTime} that adds the value of the specified
			 * {@link System.TimeSpan} to the value of this instance.
			 */
			Add(value: number): js.DateTime;

			/**
			 * Returns a new {@link System.DateTime} that adds the specified number of days to the
			 * value of this instance.
			 */
			AddDays(value: number): js.DateTime;

			/**
			 * Returns a new {@link System.DateTime} that adds the specified number of hours to the
			 * value of this instance.
			 */
			AddHours(value: number): js.DateTime;

			/**
			 * Returns a new {@link System.DateTime} that adds the specified number of microseconds
			 * to the value of this instance.
			 */
			AddMicroseconds(value: number): js.DateTime;

			/**
			 * Returns a new {@link System.DateTime} that adds the specified number of milliseconds
			 * to the value of this instance.
			 */
			AddMilliseconds(value: number): js.DateTime;

			/**
			 * Returns a new {@link System.DateTime} that adds the specified number of minutes to the
			 * value of this instance.
			 */
			AddMinutes(value: number): js.DateTime;

			/**
			 * Returns a new {@link System.DateTime} that adds the specified number of months to the
			 * value of this instance.
			 */
			AddMonths(months: number): js.DateTime;

			/**
			 * Returns a new {@link System.DateTime} that adds the specified number of seconds to the
			 * value of this instance.
			 */
			AddSeconds(value: number): js.DateTime;

			/**
			 * Returns a new {@link System.DateTime} that adds the specified number of ticks to the
			 * value of this instance.
			 */
			AddTicks(value: number): js.DateTime;

			/**
			 * Returns a new {@link System.DateTime} that adds the specified number of years to the
			 * value of this instance.
			 */
			AddYears(value: number): js.DateTime;

			/**
			 * Compares two instances of {@link System.DateTime} and returns an integer that
			 * indicates whether the first instance is earlier than, the same as, or later than the
			 * second instance.
			 */
			static Compare(
				t1: js.DateTime,
				t2: js.DateTime,
			): number;

			/**
			 * Compares the value of this instance to a specified {@link System.DateTime} value and
			 * returns an integer that indicates whether this instance is earlier than, the same as,
			 * or later than the specified {@link System.DateTime} value.
			 */
			CompareTo(value: js.DateTime): number;

			/**
			 * Compares the value of this instance to a specified object that contains a specified
			 * {@link System.DateTime} value, and returns an integer that indicates whether this
			 * instance is earlier than, the same as, or later than the specified
			 * {@link System.DateTime} value.
			 */
			CompareTo(value: System.Object | undefined): number;

			/** Returns the number of days in the specified month and year. */
			static DaysInMonth(
				year: number,
				month: number,
			): number;

			/**
			 * Returns a value indicating whether the value of this instance is equal to the value of
			 * the specified {@link System.DateTime} instance.
			 */
			Equals(value: js.DateTime): boolean;

			/**
			 * Returns a value indicating whether two {@link System.DateTime} instances  have the
			 * same date and time value.
			 */
			static Equals(
				t1: js.DateTime,
				t2: js.DateTime,
			): boolean;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Deserializes a 64-bit binary value and recreates an original serialized
			 * {@link System.DateTime} object.
			 */
			static FromBinary(dateData: number): js.DateTime;

			/** Converts the specified Windows file time to an equivalent local time. */
			static FromFileTime(fileTime: number): js.DateTime;

			/** Converts the specified Windows file time to an equivalent UTC time. */
			static FromFileTimeUtc(fileTime: number): js.DateTime;

			/** Returns a {@link System.DateTime} equivalent to the specified OLE Automation Date. */
			static FromOADate(d: number): js.DateTime;

			/**
			 * Converts the value of this instance to all the string representations supported by the
			 * standard date and time format specifiers.
			 */
			GetDateTimeFormats(): string[];

			/**
			 * Converts the value of this instance to all the string representations supported by the
			 * specified standard date and time format specifier.
			 */
			GetDateTimeFormats(format: System.Char): string[];

			/**
			 * Converts the value of this instance to all the string representations supported by the
			 * specified standard date and time format specifier and culture-specific formatting
			 * information.
			 */
			GetDateTimeFormats(
				format: System.Char,
				provider: System.IFormatProvider | undefined,
			): string[];

			/**
			 * Converts the value of this instance to all the string representations supported by the
			 * standard date and time format specifiers and the specified culture-specific formatting
			 * information.
			 */
			GetDateTimeFormats(provider: System.IFormatProvider | undefined): string[];

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.DateTime}. */
			GetTypeCode(): System.TypeCode;

			/**
			 * Indicates whether this instance of {@link System.DateTime} is within the daylight
			 * saving time range for the current time zone.
			 */
			IsDaylightSavingTime(): boolean;

			/** Returns an indication whether the specified year is a leap year. */
			static IsLeapYear(year: number): boolean;

			Deconstruct(): { date: System.DateOnly, time: System.TimeOnly };

			Deconstruct(): { year: number, month: number, day: number };

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): js.DateTime;

			/**
			 * Converts a memory span that contains string representation of a date and time to its
			 * {@link System.DateTime} equivalent by using culture-specific format information and a
			 * formatting style.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
				styles?: System.Globalization.DateTimeStyles,
			): js.DateTime;

			/**
			 * Converts the string representation of a date and time to its {@link System.DateTime}
			 * equivalent by using the conventions of the current culture.
			 */
			static Parse(s: string): js.DateTime;

			/**
			 * Converts the string representation of a date and time to its {@link System.DateTime}
			 * equivalent by using culture-specific format information.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): js.DateTime;

			/**
			 * Converts the string representation of a date and time to its {@link System.DateTime}
			 * equivalent by using culture-specific format information and a formatting style.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTime;

			/**
			 * Converts the specified span representation of a date and time to its
			 * {@link System.DateTime} equivalent using the specified format, culture-specific format
			 * information, and style. The format of the string representation must match the
			 * specified format exactly or an exception is thrown.
			 */
			static ParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
				style?: System.Globalization.DateTimeStyles,
			): js.DateTime;

			/**
			 * Converts the specified span representation of a date and time to its
			 * {@link System.DateTime} equivalent using the specified array of formats,
			 * culture-specific format information, and style. The format of the string
			 * representation must match at least one of the specified formats exactly or an
			 * exception is thrown.
			 */
			static ParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				formats: string[],
				provider: System.IFormatProvider | undefined,
				style?: System.Globalization.DateTimeStyles,
			): js.DateTime;

			/**
			 * Converts the specified string representation of a date and time to its
			 * {@link System.DateTime} equivalent using the specified format and culture-specific
			 * format information. The format of the string representation must match the specified
			 * format exactly.
			 */
			static ParseExact(
				s: string,
				format: string,
				provider: System.IFormatProvider | undefined,
			): js.DateTime;

			/**
			 * Converts the specified string representation of a date and time to its
			 * {@link System.DateTime} equivalent using the specified format, culture-specific format
			 * information, and style. The format of the string representation must match the
			 * specified format exactly or an exception is thrown.
			 */
			static ParseExact(
				s: string,
				format: string,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): js.DateTime;

			/**
			 * Converts the specified string representation of a date and time to its
			 * {@link System.DateTime} equivalent using the specified array of formats,
			 * culture-specific format information, and style. The format of the string
			 * representation must match at least one of the specified formats exactly or an
			 * exception is thrown.
			 */
			static ParseExact(
				s: string,
				formats: string[],
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): js.DateTime;

			/**
			 * Creates a new {@link System.DateTime} object that has the same number of ticks as the
			 * specified {@link System.DateTime}, but is designated as either local time, Coordinated
			 * Universal Time (UTC), or neither, as indicated by the specified
			 * {@link System.DateTimeKind} value.
			 */
			static SpecifyKind(
				value: js.DateTime,
				kind: System.DateTimeKind,
			): js.DateTime;

			/**
			 * Returns a new {@link System.TimeSpan} that subtracts the specified date and time from
			 * the value of this instance.
			 */
			Subtract(value: js.DateTime): number;

			/**
			 * Returns a new {@link System.DateTime} that subtracts the specified duration from the
			 * value of this instance.
			 */
			Subtract(value: number): js.DateTime;

			/**
			 * Serializes the current {@link System.DateTime} object to a 64-bit binary value that
			 * subsequently can be used to recreate the {@link System.DateTime} object.
			 */
			ToBinary(): number;

			/**
			 * Converts the value of the current {@link System.DateTime} object to a Windows file
			 * time.
			 */
			ToFileTime(): number;

			/**
			 * Converts the value of the current {@link System.DateTime} object to a Windows file
			 * time.
			 */
			ToFileTimeUtc(): number;

			/** Converts the value of the current {@link System.DateTime} object to local time. */
			ToLocalTime(): js.DateTime;

			/**
			 * Converts the value of the current {@link System.DateTime} object to its equivalent
			 * long date string representation.
			 */
			ToLongDateString(): string;

			/**
			 * Converts the value of the current {@link System.DateTime} object to its equivalent
			 * long time string representation.
			 */
			ToLongTimeString(): string;

			/** Converts the value of this instance to the equivalent OLE Automation date. */
			ToOADate(): number;

			/**
			 * Converts the value of the current {@link System.DateTime} object to its equivalent
			 * short date string representation.
			 */
			ToShortDateString(): string;

			/**
			 * Converts the value of the current {@link System.DateTime} object to its equivalent
			 * short time string representation.
			 */
			ToShortTimeString(): string;

			/**
			 * Converts the value of the current {@link System.DateTime} object to its equivalent
			 * string representation using the formatting conventions of the current culture.
			 */
			ToString(): string;

			/**
			 * Converts the value of the current {@link System.DateTime} object to its equivalent
			 * string representation using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the value of the current {@link System.DateTime} object to its equivalent
			 * string representation using the specified format and the formatting conventions of the
			 * current culture.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the value of the current {@link System.DateTime} object to its equivalent
			 * string representation using the specified format and culture-specific format
			 * information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of the current {@link System.DateTime} object to Coordinated
			 * Universal Time (UTC).
			 */
			ToUniversalTime(): js.DateTime;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): js.DateTime | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): js.DateTime | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTime | undefined;

			static TryParse(s: string | undefined): js.DateTime | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): js.DateTime | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTime | undefined;

			static TryParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): js.DateTime | undefined;

			static TryParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				formats: string | undefined[] | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): js.DateTime | undefined;

			static TryParseExact(
				s: string | undefined,
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): js.DateTime | undefined;

			static TryParseExact(
				s: string | undefined,
				formats: string | undefined[] | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): js.DateTime | undefined;
		}
	}

	export namespace System {
		/**
		 * Specifies whether a {@link System.DateTime} object represents a local time, a
		 * Coordinated Universal Time (UTC), or is not specified as either local time or UTC.
		 */
		export enum DateTimeKind {
			/**
			 * The time represented is not specified as either local time or Coordinated Universal
			 * Time (UTC).
			 */
			Unspecified = 0,

			/** The time represented is UTC. */
			Utc = 1,

			/** The time represented is local time. */
			Local = 2,
		}
	}

	export namespace System {
		/**
		 * Represents a point in time, typically expressed as a date and time of day, relative to
		 * Coordinated Universal Time (UTC).
		 */
		export class DateTimeOffset extends System.ValueType implements
			System.IComparable$1<js.DateTimeOffset>,
			System.IEquatable$1<js.DateTimeOffset>,
			System.IFormattable,
			System.IParsable$1<js.DateTimeOffset>,
			System.ISpanFormattable,
			System.ISpanParsable$1<js.DateTimeOffset>,
			System.IUtf8SpanFormattable {
			/**
			 * Initializes a new instance of the {@link System.DateTimeOffset} structure using the
			 * specified {@link System.DateTime} value.
			 */
			constructor(dateTime: js.DateTime);

			/**
			 * Initializes a new instance of the {@link System.DateTimeOffset} structure using the
			 * specified {@link System.DateTime} value and offset.
			 */
			constructor(
				dateTime: js.DateTime,
				offset: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTimeOffset} structure using the
			 * specified year, month, day, hour, minute, second, millisecond, and offset of a
			 * specified calendar.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				calendar: System.Globalization.Calendar,
				offset: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTimeOffset} structure using the
			 * specified `year`, `month`, `day`, `hour`, `minute`, `second`, `millisecond`,
			 * `microsecond` and `offset`.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				microsecond: number,
				calendar: System.Globalization.Calendar,
				offset: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTimeOffset} structure using the
			 * specified `year`, `month`, `day`, `hour`, `minute`, `second`, `millisecond`,
			 * `microsecond` and `offset`.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				microsecond: number,
				offset: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTimeOffset} structure using the
			 * specified year, month, day, hour, minute, second, millisecond, and offset.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				offset: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTimeOffset} structure using the
			 * specified `date`, `time`, and `offset`.
			 */
			constructor(
				date: System.DateOnly,
				time: System.TimeOnly,
				offset: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTimeOffset} structure using the
			 * specified year, month, day, hour, minute, second, and offset.
			 */
			constructor(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				offset: number,
			);

			/**
			 * Initializes a new instance of the {@link System.DateTimeOffset} structure using the
			 * specified number of ticks and offset.
			 */
			constructor(
				ticks: number,
				offset: number,
			);

			/**
			 * Gets a {@link System.DateTime} value that represents the date component of the current
			 * {@link System.DateTimeOffset} object.
			 */
			readonly Date: js.DateTime;

			/**
			 * Gets a {@link System.DateTime} value that represents the date and time of the current
			 * {@link System.DateTimeOffset} object.
			 */
			readonly DateTime: js.DateTime;

			/**
			 * Gets the day of the month represented by the current {@link System.DateTimeOffset}
			 * object.
			 */
			readonly Day: number;

			/**
			 * Gets the day of the week represented by the current {@link System.DateTimeOffset}
			 * object.
			 */
			readonly DayOfWeek: System.DayOfWeek;

			/**
			 * Gets the day of the year represented by the current {@link System.DateTimeOffset}
			 * object.
			 */
			readonly DayOfYear: number;

			/**
			 * Gets the hour component of the time represented by the current
			 * {@link System.DateTimeOffset} object.
			 */
			readonly Hour: number;

			/**
			 * Gets a {@link System.DateTime} value that represents the local date and time of the
			 * current {@link System.DateTimeOffset} object.
			 */
			readonly LocalDateTime: js.DateTime;

			/**
			 * Gets the microsecond component of the time represented by the current
			 * {@link System.DateTimeOffset} object.
			 */
			readonly Microsecond: number;

			/**
			 * Gets the millisecond component of the time represented by the current
			 * {@link System.DateTimeOffset} object.
			 */
			readonly Millisecond: number;

			/**
			 * Gets the minute component of the time represented by the current
			 * {@link System.DateTimeOffset} object.
			 */
			readonly Minute: number;

			/**
			 * Gets the month component of the date represented by the current
			 * {@link System.DateTimeOffset} object.
			 */
			readonly Month: number;

			/**
			 * Gets the nanosecond component of the time represented by the current
			 * {@link System.DateTimeOffset} object.
			 */
			readonly Nanosecond: number;

			/**
			 * Gets a {@link System.DateTimeOffset} object that is set to the current date and time
			 * on the current computer, with the offset set to the local time's offset from
			 * Coordinated Universal Time (UTC).
			 */
			static readonly Now: js.DateTimeOffset;

			/** Gets the time's offset from Coordinated Universal Time (UTC). */
			readonly Offset: number;

			/**
			 * Gets the second component of the clock time represented by the current
			 * {@link System.DateTimeOffset} object.
			 */
			readonly Second: number;

			/**
			 * Gets the number of ticks that represents the date and time of the current
			 * {@link System.DateTimeOffset} object in clock time.
			 */
			readonly Ticks: number;

			/** Gets the time of day for the current {@link System.DateTimeOffset} object. */
			readonly TimeOfDay: number;

			/** Gets the time's offset from Coordinated Universal Time (UTC) in minutes. */
			readonly TotalOffsetMinutes: number;

			/**
			 * Gets a {@link System.DateTime} value that represents the Coordinated Universal Time
			 * (UTC) date and time of the current {@link System.DateTimeOffset} object.
			 */
			readonly UtcDateTime: js.DateTime;

			/**
			 * Gets a {@link System.DateTimeOffset} object whose date and time are set to the current
			 * Coordinated Universal Time (UTC) date and time and whose offset is
			 * {@link System.TimeSpan.Zero}.
			 */
			static readonly UtcNow: js.DateTimeOffset;

			/**
			 * Gets the number of ticks that represents the date and time of the current
			 * {@link System.DateTimeOffset} object in Coordinated Universal Time (UTC).
			 */
			readonly UtcTicks: number;

			/**
			 * Gets the year component of the date represented by the current
			 * {@link System.DateTimeOffset} object.
			 */
			readonly Year: number;

			/**
			 * Returns a new {@link System.DateTimeOffset} object that adds a specified time interval
			 * to the value of this instance.
			 */
			Add(timeSpan: number): js.DateTimeOffset;

			/**
			 * Returns a new {@link System.DateTimeOffset} object that adds a specified number of
			 * whole and fractional days to the value of this instance.
			 */
			AddDays(days: number): js.DateTimeOffset;

			/**
			 * Returns a new {@link System.DateTimeOffset} object that adds a specified number of
			 * whole and fractional hours to the value of this instance.
			 */
			AddHours(hours: number): js.DateTimeOffset;

			/**
			 * Returns a new {@link System.DateTimeOffset} object that adds a specified number of
			 * microseconds to the value of this instance.
			 */
			AddMicroseconds(microseconds: number): js.DateTimeOffset;

			/**
			 * Returns a new {@link System.DateTimeOffset} object that adds a specified number of
			 * milliseconds to the value of this instance.
			 */
			AddMilliseconds(milliseconds: number): js.DateTimeOffset;

			/**
			 * Returns a new {@link System.DateTimeOffset} object that adds a specified number of
			 * whole and fractional minutes to the value of this instance.
			 */
			AddMinutes(minutes: number): js.DateTimeOffset;

			/**
			 * Returns a new {@link System.DateTimeOffset} object that adds a specified number of
			 * months to the value of this instance.
			 */
			AddMonths(months: number): js.DateTimeOffset;

			/**
			 * Returns a new {@link System.DateTimeOffset} object that adds a specified number of
			 * whole and fractional seconds to the value of this instance.
			 */
			AddSeconds(seconds: number): js.DateTimeOffset;

			/**
			 * Returns a new {@link System.DateTimeOffset} object that adds a specified number of
			 * ticks to the value of this instance.
			 */
			AddTicks(ticks: number): js.DateTimeOffset;

			/**
			 * Returns a new {@link System.DateTimeOffset} object that adds a specified number of
			 * years to the value of this instance.
			 */
			AddYears(years: number): js.DateTimeOffset;

			/**
			 * Compares two {@link System.DateTimeOffset} objects and indicates whether the first is
			 * earlier than the second, equal to the second, or later than the second.
			 */
			static Compare(
				first: js.DateTimeOffset,
				second: js.DateTimeOffset,
			): number;

			/**
			 * Compares the current {@link System.DateTimeOffset} object to a specified
			 * {@link System.DateTimeOffset} object and indicates whether the current object is
			 * earlier than, the same as, or later than the second {@link System.DateTimeOffset}
			 * object.
			 */
			CompareTo(other: js.DateTimeOffset): number;

			/**
			 * Determines whether the current {@link System.DateTimeOffset} object represents the
			 * same point in time as a specified {@link System.DateTimeOffset} object.
			 */
			Equals(other: js.DateTimeOffset): boolean;

			/**
			 * Determines whether two specified {@link System.DateTimeOffset} objects represent the
			 * same point in time.
			 */
			static Equals(
				first: js.DateTimeOffset,
				second: js.DateTimeOffset,
			): boolean;

			/**
			 * Determines whether a {@link System.DateTimeOffset} object represents the same point in
			 * time as a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Determines whether the current {@link System.DateTimeOffset} object represents the
			 * same time and has the same offset as a specified {@link System.DateTimeOffset} object.
			 */
			EqualsExact(other: js.DateTimeOffset): boolean;

			/** Converts the specified Windows file time to an equivalent local time. */
			static FromFileTime(fileTime: number): js.DateTimeOffset;

			/**
			 * Converts a Unix time expressed as the number of milliseconds that have elapsed since
			 * 1970-01-01T00:00:00Z to a {@link System.DateTimeOffset} value.
			 */
			static FromUnixTimeMilliseconds(milliseconds: number): js.DateTimeOffset;

			/**
			 * Converts a Unix time expressed as the number of seconds that have elapsed since
			 * 1970-01-01T00:00:00Z to a {@link System.DateTimeOffset} value.
			 */
			static FromUnixTimeSeconds(seconds: number): js.DateTimeOffset;

			/** Returns the hash code for the current {@link System.DateTimeOffset} object. */
			GetHashCode(): number;

			Deconstruct(): { date: System.DateOnly, time: System.TimeOnly, offset: number };

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): js.DateTimeOffset;

			/**
			 * Converts the specified span representation of a date and time to its
			 * {@link System.DateTimeOffset} equivalent using the specified culture-specific format
			 * information and formatting style.
			 */
			static Parse(
				input: System.ReadOnlySpan$1<System.Char>,
				formatProvider?: System.IFormatProvider,
				styles?: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset;

			/**
			 * Converts the specified string representation of a date, time, and offset to its
			 * {@link System.DateTimeOffset} equivalent.
			 */
			static Parse(input: string): js.DateTimeOffset;

			/**
			 * Converts the specified string representation of a date and time to its
			 * {@link System.DateTimeOffset} equivalent using the specified culture-specific format
			 * information.
			 */
			static Parse(
				input: string,
				formatProvider: System.IFormatProvider | undefined,
			): js.DateTimeOffset;

			/**
			 * Converts the specified string representation of a date and time to its
			 * {@link System.DateTimeOffset} equivalent using the specified culture-specific format
			 * information and formatting style.
			 */
			static Parse(
				input: string,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset;

			/**
			 * Converts a character span that represents a date and time to its
			 * {@link System.DateTimeOffset} equivalent using the specified format, culture-specific
			 * format information, and style. The format of the date and time representation must
			 * match the specified format exactly.
			 */
			static ParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				formatProvider: System.IFormatProvider | undefined,
				styles?: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset;

			/**
			 * Converts a character span that contains the string representation of a date and time
			 * to its {@link System.DateTimeOffset} equivalent using the specified formats,
			 * culture-specific format information, and style. The format of the date and time
			 * representation must match one of the specified formats exactly.
			 */
			static ParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				formats: string[],
				formatProvider: System.IFormatProvider | undefined,
				styles?: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset;

			/**
			 * Converts the specified string representation of a date and time to its
			 * {@link System.DateTimeOffset} equivalent using the specified format and
			 * culture-specific format information. The format of the string representation must
			 * match the specified format exactly.
			 */
			static ParseExact(
				input: string,
				format: string,
				formatProvider: System.IFormatProvider | undefined,
			): js.DateTimeOffset;

			/**
			 * Converts the specified string representation of a date and time to its
			 * {@link System.DateTimeOffset} equivalent using the specified format, culture-specific
			 * format information, and style. The format of the string representation must match the
			 * specified format exactly.
			 */
			static ParseExact(
				input: string,
				format: string,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset;

			/**
			 * Converts the specified string representation of a date and time to its
			 * {@link System.DateTimeOffset} equivalent using the specified formats, culture-specific
			 * format information, and style. The format of the string representation must match one
			 * of the specified formats exactly.
			 */
			static ParseExact(
				input: string,
				formats: string[],
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset;

			/**
			 * Subtracts a {@link System.DateTimeOffset} value that represents a specific date and
			 * time from the current {@link System.DateTimeOffset} object.
			 */
			Subtract(value: js.DateTimeOffset): number;

			/**
			 * Subtracts a specified time interval from the current {@link System.DateTimeOffset}
			 * object.
			 */
			Subtract(value: number): js.DateTimeOffset;

			/**
			 * Converts the value of the current {@link System.DateTimeOffset} object to a Windows
			 * file time.
			 */
			ToFileTime(): number;

			/**
			 * Converts the current {@link System.DateTimeOffset} object to a
			 * {@link System.DateTimeOffset} object that represents the local time.
			 */
			ToLocalTime(): js.DateTimeOffset;

			/**
			 * Converts the value of the current {@link System.DateTimeOffset} object to the date and
			 * time specified by an offset value.
			 */
			ToOffset(offset: number): js.DateTimeOffset;

			/**
			 * Converts the value of the current {@link System.DateTimeOffset} object to its
			 * equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the value of the current {@link System.DateTimeOffset} object to its
			 * equivalent string representation using the specified culture-specific formatting
			 * information.
			 */
			ToString(formatProvider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the value of the current {@link System.DateTimeOffset} object to its
			 * equivalent string representation using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the value of the current {@link System.DateTimeOffset} object to its
			 * equivalent string representation using the specified format and culture-specific
			 * format information.
			 */
			ToString(
				format: string | undefined,
				formatProvider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the current {@link System.DateTimeOffset} object to a
			 * {@link System.DateTimeOffset} value that represents the Coordinated Universal Time
			 * (UTC).
			 */
			ToUniversalTime(): js.DateTimeOffset;

			/**
			 * Returns the number of milliseconds that have elapsed since 1970-01-01T00:00:00.000Z.
			 */
			ToUnixTimeMilliseconds(): number;

			/** Returns the number of seconds that have elapsed since 1970-01-01T00:00:00Z. */
			ToUnixTimeSeconds(): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				formatProvider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				formatProvider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(input: System.ReadOnlySpan$1<System.Char>): js.DateTimeOffset | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): js.DateTimeOffset | undefined;

			static TryParse(
				input: System.ReadOnlySpan$1<System.Char>,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset | undefined;

			static TryParse(input: string | undefined): js.DateTimeOffset | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): js.DateTimeOffset | undefined;

			static TryParse(
				input: string | undefined,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset | undefined;

			static TryParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset | undefined;

			static TryParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				formats: string | undefined[] | undefined,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset | undefined;

			static TryParseExact(
				input: string | undefined,
				format: string | undefined,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset | undefined;

			static TryParseExact(
				input: string | undefined,
				formats: string | undefined[] | undefined,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.DateTimeStyles,
			): js.DateTimeOffset | undefined;
		}
	}

	export namespace System {
		/** Specifies the day of the week. */
		export enum DayOfWeek {
			/** Indicates Sunday. */
			Sunday = 0,

			/** Indicates Monday. */
			Monday = 1,

			/** Indicates Tuesday. */
			Tuesday = 2,

			/** Indicates Wednesday. */
			Wednesday = 3,

			/** Indicates Thursday. */
			Thursday = 4,

			/** Indicates Friday. */
			Friday = 5,

			/** Indicates Saturday. */
			Saturday = 6,
		}
	}

	export namespace System {
		/** Provides an abstraction for time. */
		export class TimeProvider {
			/**
			 * Gets a {@link System.TimeProvider} that provides a clock based on
			 * {@link System.DateTimeOffset.UtcNow}, a time zone based on
			 * {@link System.TimeZoneInfo.Local}, a high-performance time stamp based on
			 * {@link System.Diagnostics.Stopwatch}, and a timer based on
			 * {@link System.Threading.Timer}.
			 */
			static readonly System: System.TimeProvider;

			/**
			 * Gets the local time zone according to this {@link System.TimeProvider} 's notion of
			 * time.
			 */
			readonly LocalTimeZone: System.TimeZoneInfo;

			/**
			 * Gets the frequency of {@link System.TimeProvider.GetTimestamp} as the number of ticks
			 * per second.
			 */
			readonly TimestampFrequency: number;

			/**
			 * Gets the current Coordinated Universal Time (UTC) date and time with an offset of
			 * zero, according to this {@link System.TimeProvider} 's notion of time.
			 */
			GetUtcNow(): js.DateTimeOffset;

			/**
			 * Gets the current date and time according to this {@link System.TimeProvider} 's notion
			 * of time based on {@link System.TimeProvider.GetUtcNow}, with the offset set to the
			 * {@link System.TimeProvider.LocalTimeZone} 's offset from Coordinated Universal Time
			 * (UTC).
			 */
			GetLocalNow(): js.DateTimeOffset;

			/**
			 * Gets the current high-frequency value designed to measure small time intervals with
			 * high accuracy in the timer mechanism.
			 */
			GetTimestamp(): number;

			/**
			 * Gets the elapsed time since the `startingTimestamp` value was retrieved using
			 * {@link System.TimeProvider.GetTimestamp}.
			 */
			GetElapsedTime(startingTimestamp: number): number;

			/**
			 * Gets the elapsed time between two timestamps retrieved using
			 * {@link System.TimeProvider.GetTimestamp}.
			 */
			GetElapsedTime(
				startingTimestamp: number,
				endingTimestamp: number,
			): number;

			/**
			 * Creates a new {@link System.Threading.ITimer} instance, using {@link System.TimeSpan}
			 * values to measure time intervals.
			 */
			CreateTimer(
				callback: System.Threading.TimerCallback,
				state: System.Object | undefined,
				dueTime: number,
				period: number,
			): System.Threading.ITimer;
		}
	}

	export namespace System {
		/** Represents a nonexistent value. This class cannot be inherited. */
		export class DBNull {
			/** Gets the {@link System.TypeCode} value for {@link System.DBNull}. */
			GetTypeCode(): System.TypeCode;

			/** Returns an empty string ( {@link System.String.Empty} ). */
			ToString(): string;

			/** Returns an empty string using the specified {@link System.IFormatProvider}. */
			ToString(provider: System.IFormatProvider | undefined): string;
		}
	}

	export namespace System {
		/** Represents a decimal floating-point number. */
		export class Decimal extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<System.Decimal>,
			System.IEquatable$1<System.Decimal>,
			System.IFormattable,
			System.IParsable$1<System.Decimal>,
			System.ISpanFormattable,
			System.ISpanParsable$1<System.Decimal>,
			System.Numerics.IAdditionOperators$3<System.Decimal, System.Decimal, System.Decimal>,
			System.Numerics.IAdditiveIdentity$2<System.Decimal, System.Decimal>,
			System.Numerics.IComparisonOperators$3<System.Decimal, System.Decimal, boolean>,
			System.Numerics.IEqualityOperators$3<System.Decimal, System.Decimal, boolean>,
			System.Numerics.IDecrementOperators$1<System.Decimal>,
			System.Numerics.IDivisionOperators$3<System.Decimal, System.Decimal, System.Decimal>,
			System.Numerics.IFloatingPointConstants$1<System.Decimal>,
			System.Numerics.INumberBase$1<System.Decimal>,
			System.Numerics.IIncrementOperators$1<System.Decimal>,
			System.Numerics.IMultiplicativeIdentity$2<System.Decimal, System.Decimal>,
			System.Numerics.IMultiplyOperators$3<System.Decimal, System.Decimal, System.Decimal>,
			System.Numerics.ISubtractionOperators$3<System.Decimal, System.Decimal, System.Decimal>,
			System.Numerics.IUnaryNegationOperators$2<System.Decimal, System.Decimal>,
			System.Numerics.IUnaryPlusOperators$2<System.Decimal, System.Decimal>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<System.Decimal>,
			System.Numerics.IModulusOperators$3<System.Decimal, System.Decimal, System.Decimal>,
			System.Numerics.INumber$1<System.Decimal>,
			System.Numerics.ISignedNumber$1<System.Decimal>,
			System.Numerics.IMinMaxValue$1<System.Decimal> {
			/**
			 * Initializes a new instance of {@link System.Decimal} to the value of the specified
			 * double-precision floating-point number.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of {@link System.Decimal} to the value of the specified
			 * 32-bit signed integer.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of {@link System.Decimal} from parameters specifying the
			 * instance's constituent parts.
			 */
			constructor(
				lo: number,
				mid: number,
				hi: number,
				isNegative: boolean,
				scale: number,
			);

			/**
			 * Initializes a new instance of {@link System.Decimal} to a decimal value represented in
			 * binary and contained in a specified array.
			 */
			constructor(bits: number[]);

			/**
			 * Initializes a new instance of {@link System.Decimal} to the value of the specified
			 * 64-bit signed integer.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of {@link System.Decimal} to a decimal value represented in
			 * binary and contained in the specified span.
			 */
			constructor(bits: System.ReadOnlySpan$1<number>);

			/**
			 * Initializes a new instance of {@link System.Decimal} to the value of the specified
			 * single-precision floating-point number.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of {@link System.Decimal} to the value of the specified
			 * 32-bit unsigned integer.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of {@link System.Decimal} to the value of the specified
			 * 64-bit unsigned integer.
			 */
			constructor(value: number);

			/**
			 * Gets the scaling factor of the decimal, which is a number from 0 to 28 that represents
			 * the number of decimal digits.
			 */
			readonly Scale: number;

			/** Computes the absolute of a value. */
			static Abs(value: System.Decimal): System.Decimal;

			/** Adds two specified {@link System.Decimal} values. */
			static Add(
				d1: System.Decimal,
				d2: System.Decimal,
			): System.Decimal;

			/**
			 * Returns the smallest integral value that is greater than or equal to the specified
			 * decimal number.
			 */
			static Ceiling(d: System.Decimal): System.Decimal;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: System.Decimal,
				min: System.Decimal,
				max: System.Decimal,
			): System.Decimal;

			/** Compares two specified {@link System.Decimal} values. */
			static Compare(
				d1: System.Decimal,
				d2: System.Decimal,
			): number;

			/**
			 * Compares this instance to a specified {@link System.Decimal} object and returns a
			 * comparison of their relative values.
			 */
			CompareTo(value: System.Decimal): number;

			/**
			 * Compares this instance to a specified object and returns a comparison of their
			 * relative values.
			 */
			CompareTo(value: System.Object | undefined): number;

			/** Copies the sign of a value to the sign of another value. */
			static CopySign(
				value: System.Decimal,
				sign: System.Decimal,
			): System.Decimal;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): System.Decimal;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): System.Decimal;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): System.Decimal;

			/** Divides two specified {@link System.Decimal} values. */
			static Divide(
				d1: System.Decimal,
				d2: System.Decimal,
			): System.Decimal;

			/**
			 * Returns a value indicating whether this instance and a specified
			 * {@link System.Decimal} object represent the same value.
			 */
			Equals(value: System.Decimal): boolean;

			/**
			 * Returns a value indicating whether two specified instances of {@link System.Decimal}
			 * represent the same value.
			 */
			static Equals(
				d1: System.Decimal,
				d2: System.Decimal,
			): boolean;

			/**
			 * Returns a value indicating whether this instance and a specified {@link System.Object}
			 * represent the same type and value.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Rounds a specified {@link System.Decimal} number to the closest integer toward
			 * negative infinity.
			 */
			static Floor(d: System.Decimal): System.Decimal;

			/**
			 * Converts the specified 64-bit signed integer, which contains an OLE Automation
			 * Currency value, to the equivalent {@link System.Decimal} value.
			 */
			static FromOACurrency(cy: number): System.Decimal;

			/**
			 * Converts the value of a specified instance of {@link System.Decimal} to its equivalent
			 * binary representation.
			 */
			static GetBits(d: System.Decimal): number[];

			/**
			 * Converts the value of a specified instance of {@link System.Decimal} to its equivalent
			 * binary representation.
			 */
			static GetBits(
				d: System.Decimal,
				destination: System.Span$1<number>,
			): number;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.Decimal}. */
			GetTypeCode(): System.TypeCode;

			/** Determines if a value is in its canonical representation. */
			static IsCanonical(value: System.Decimal): boolean;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: System.Decimal): boolean;

			/** Determines if a value represents an integral number. */
			static IsInteger(value: System.Decimal): boolean;

			/** Determines if a value is negative. */
			static IsNegative(value: System.Decimal): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: System.Decimal): boolean;

			/** Determines if a value is positive. */
			static IsPositive(value: System.Decimal): boolean;

			/** Compares two values to compute which is greater. */
			static Max(
				x: System.Decimal,
				y: System.Decimal,
			): System.Decimal;

			/** Compares two values to compute which is greater. */
			static MaxMagnitude(
				x: System.Decimal,
				y: System.Decimal,
			): System.Decimal;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: System.Decimal,
				y: System.Decimal,
			): System.Decimal;

			/** Compares two values to compute which is lesser. */
			static MinMagnitude(
				x: System.Decimal,
				y: System.Decimal,
			): System.Decimal;

			/** Multiplies two specified {@link System.Decimal} values. */
			static Multiply(
				d1: System.Decimal,
				d2: System.Decimal,
			): System.Decimal;

			/**
			 * Returns the result of multiplying the specified {@link System.Decimal} value by
			 * negative one.
			 */
			static Negate(d: System.Decimal): System.Decimal;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.Decimal;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.Decimal;

			/**
			 * Converts the span representation of a number to its {@link System.Decimal} equivalent
			 * using the specified style and culture-specific format.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.Decimal;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.Decimal;

			/**
			 * Converts the string representation of a number to its {@link System.Decimal}
			 * equivalent.
			 */
			static Parse(s: string): System.Decimal;

			/**
			 * Converts the string representation of a number in a specified style to its
			 * {@link System.Decimal} equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): System.Decimal;

			/**
			 * Converts the string representation of a number to its {@link System.Decimal}
			 * equivalent using the specified style and culture-specific format.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Decimal;

			/**
			 * Converts the string representation of a number to its {@link System.Decimal}
			 * equivalent using the specified culture-specific format information.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): System.Decimal;

			/** Computes the remainder after dividing two {@link System.Decimal} values. */
			static Remainder(
				d1: System.Decimal,
				d2: System.Decimal,
			): System.Decimal;

			/** Rounds a decimal value to the nearest integer. */
			static Round(d: System.Decimal): System.Decimal;

			/** Rounds a {@link System.Decimal} value to a specified number of decimal places. */
			static Round(
				d: System.Decimal,
				decimals: number,
			): System.Decimal;

			/**
			 * Rounds a decimal value to the specified precision using the specified rounding
			 * strategy.
			 */
			static Round(
				d: System.Decimal,
				decimals: number,
				mode: System.MidpointRounding,
			): System.Decimal;

			/** Rounds a decimal value to an integer using the specified rounding strategy. */
			static Round(
				d: System.Decimal,
				mode: System.MidpointRounding,
			): System.Decimal;

			/** Computes the sign of a value. */
			static Sign(d: System.Decimal): number;

			/** Subtracts one specified {@link System.Decimal} value from another. */
			static Subtract(
				d1: System.Decimal,
				d2: System.Decimal,
			): System.Decimal;

			/**
			 * Converts the value of the specified {@link System.Decimal} to the equivalent 8-bit
			 * unsigned integer.
			 */
			static ToByte(value: System.Decimal): number;

			/**
			 * Converts the value of the specified {@link System.Decimal} to the equivalent
			 * double-precision floating-point number.
			 */
			static ToDouble(d: System.Decimal): number;

			/**
			 * Converts the value of the specified {@link System.Decimal} to the equivalent 16-bit
			 * signed integer.
			 */
			static ToInt16(value: System.Decimal): number;

			/**
			 * Converts the value of the specified {@link System.Decimal} to the equivalent 32-bit
			 * signed integer.
			 */
			static ToInt32(d: System.Decimal): number;

			/**
			 * Converts the value of the specified {@link System.Decimal} to the equivalent 64-bit
			 * signed integer.
			 */
			static ToInt64(d: System.Decimal): number;

			/**
			 * Converts the specified {@link System.Decimal} value to the equivalent OLE Automation
			 * Currency value, which is contained in a 64-bit signed integer.
			 */
			static ToOACurrency(value: System.Decimal): number;

			/**
			 * Converts the value of the specified {@link System.Decimal} to the equivalent 8-bit
			 * signed integer.
			 */
			static ToSByte(value: System.Decimal): number;

			/**
			 * Converts the value of the specified {@link System.Decimal} to the equivalent
			 * single-precision floating-point number.
			 */
			static ToSingle(d: System.Decimal): number;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the value of the specified {@link System.Decimal} to the equivalent 16-bit
			 * unsigned integer.
			 */
			static ToUInt16(value: System.Decimal): number;

			/**
			 * Converts the value of the specified {@link System.Decimal} to the equivalent 32-bit
			 * unsigned integer.
			 */
			static ToUInt32(d: System.Decimal): number;

			/**
			 * Converts the value of the specified {@link System.Decimal} to the equivalent 64-bit
			 * unsigned integer.
			 */
			static ToUInt64(d: System.Decimal): number;

			/**
			 * Returns the integral digits of the specified {@link System.Decimal} ; any fractional
			 * digits are discarded.
			 */
			static Truncate(d: System.Decimal): System.Decimal;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryGetBits(
				d: System.Decimal,
				destination: System.Span$1<number>,
			): number | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): System.Decimal | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Decimal | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.Decimal | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): System.Decimal | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Decimal | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.Decimal | undefined;

			static TryParse(s: string | undefined): System.Decimal | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Decimal | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): System.Decimal | undefined;
		}
	}

	export namespace System {
		/**
		 * Represents a delegate, which is a data structure that refers to a static method or to
		 * a class instance and an instance method of that class.
		 */
		export class Delegate implements System.ICloneable {
			/** Gets the method represented by the delegate. */
			readonly Method: System.Reflection.MethodInfo;

			/** Gets the class instance on which the current delegate invokes the instance method. */
			readonly Target?: System.Object;

			/** Creates a shallow copy of the delegate. */
			Clone(): System.Object;

			/** Concatenates the invocation lists of two delegates. */
			static Combine(
				a: System.Delegate | undefined,
				b: System.Delegate | undefined,
			): System.Delegate | undefined;

			/** Concatenates the invocation lists of an array of delegates. */
			static Combine(delegates: System.Delegate | undefined[] | undefined): System.Delegate | undefined;

			/**
			 * Creates a delegate of the specified type that represents the specified static or
			 * instance method, with the specified first argument.
			 */
			static CreateDelegate(
				type: System.Type,
				firstArgument: System.Object | undefined,
				method: System.Reflection.MethodInfo,
			): System.Delegate;

			/**
			 * Creates a delegate of the specified type that represents the specified static or
			 * instance method, with the specified first argument and the specified behavior on
			 * failure to bind.
			 */
			static CreateDelegate(
				type: System.Type,
				firstArgument: System.Object | undefined,
				method: System.Reflection.MethodInfo,
				throwOnBindFailure: boolean,
			): System.Delegate | undefined;

			/**
			 * Creates a delegate of the specified type that represents the specified instance method
			 * to invoke on the specified class instance.
			 */
			static CreateDelegate(
				type: System.Type,
				target: System.Object,
				method: string,
			): System.Delegate;

			/**
			 * Creates a delegate of the specified type that represents the specified instance method
			 * to invoke on the specified class instance with the specified case-sensitivity.
			 */
			static CreateDelegate(
				type: System.Type,
				target: System.Object,
				method: string,
				ignoreCase: boolean,
			): System.Delegate;

			/**
			 * Creates a delegate of the specified type that represents the specified instance method
			 * to invoke on the specified class instance, with the specified case-sensitivity and the
			 * specified behavior on failure to bind.
			 */
			static CreateDelegate(
				type: System.Type,
				target: System.Object,
				method: string,
				ignoreCase: boolean,
				throwOnBindFailure: boolean,
			): System.Delegate | undefined;

			/** Creates a delegate of the specified type to represent the specified method. */
			static CreateDelegate(
				type: System.Type,
				method: System.Reflection.MethodInfo,
			): System.Delegate;

			/**
			 * Creates a delegate of the specified type to represent the specified static method,
			 * with the specified behavior on failure to bind.
			 */
			static CreateDelegate(
				type: System.Type,
				method: System.Reflection.MethodInfo,
				throwOnBindFailure: boolean,
			): System.Delegate | undefined;

			/**
			 * Creates a delegate of the specified type that represents the specified static method
			 * of the specified class.
			 */
			static CreateDelegate(
				type: System.Type,
				target: System.Type,
				method: string,
			): System.Delegate;

			/**
			 * Creates a delegate of the specified type that represents the specified static method
			 * of the specified class, with the specified case-sensitivity.
			 */
			static CreateDelegate(
				type: System.Type,
				target: System.Type,
				method: string,
				ignoreCase: boolean,
			): System.Delegate;

			/**
			 * Creates a delegate of the specified type that represents the specified static method
			 * of the specified class, with the specified case-sensitivity and the specified behavior
			 * on failure to bind.
			 */
			static CreateDelegate(
				type: System.Type,
				target: System.Type,
				method: string,
				ignoreCase: boolean,
				throwOnBindFailure: boolean,
			): System.Delegate | undefined;

			/** Dynamically invokes (late-bound) the method represented by the current delegate. */
			DynamicInvoke(args: System.Object | undefined[] | undefined): System.Object | undefined;

			/**
			 * Determines whether the specified object and the current delegate are of the same type
			 * and share the same targets, methods, and invocation list.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns a hash code for the delegate. */
			GetHashCode(): number;

			/** Returns the invocation list of the delegate. */
			GetInvocationList(): System.Delegate[];

			/**
			 * Removes the last occurrence of the invocation list of a delegate from the invocation
			 * list of another delegate.
			 */
			static Remove(
				source: System.Delegate | undefined,
				value: System.Delegate | undefined,
			): System.Delegate | undefined;

			/**
			 * Removes all occurrences of the invocation list of a delegate from the invocation list
			 * of another delegate.
			 */
			static RemoveAll(
				source: System.Delegate | undefined,
				value: System.Delegate | undefined,
			): System.Delegate | undefined;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is an attempt to divide an integral or
		 * {@link System.Decimal} value by zero.
		 */
		export class DivideByZeroException extends System.ArithmeticException {
			/** Initializes a new instance of the {@link System.DivideByZeroException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.DivideByZeroException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.DivideByZeroException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Represents a double-precision floating-point number. */
		export class Double extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.Numerics.IAdditionOperators$3<number, number, number>,
			System.Numerics.IAdditiveIdentity$2<number, number>,
			System.Numerics.IBinaryNumber$1<number>,
			System.Numerics.IBitwiseOperators$3<number, number, number>,
			System.Numerics.IComparisonOperators$3<number, number, boolean>,
			System.Numerics.IEqualityOperators$3<number, number, boolean>,
			System.Numerics.IDecrementOperators$1<number>,
			System.Numerics.IDivisionOperators$3<number, number, number>,
			System.Numerics.IIncrementOperators$1<number>,
			System.Numerics.IModulusOperators$3<number, number, number>,
			System.Numerics.IMultiplicativeIdentity$2<number, number>,
			System.Numerics.IMultiplyOperators$3<number, number, number>,
			System.Numerics.INumber$1<number>,
			System.Numerics.INumberBase$1<number>,
			System.Numerics.ISubtractionOperators$3<number, number, number>,
			System.Numerics.IUnaryNegationOperators$2<number, number>,
			System.Numerics.IUnaryPlusOperators$2<number, number>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<number>,
			System.Numerics.IExponentialFunctions$1<number>,
			System.Numerics.IFloatingPointConstants$1<number>,
			System.Numerics.ISignedNumber$1<number>,
			System.Numerics.IHyperbolicFunctions$1<number>,
			System.Numerics.ILogarithmicFunctions$1<number>,
			System.Numerics.IPowerFunctions$1<number>,
			System.Numerics.IRootFunctions$1<number>,
			System.Numerics.ITrigonometricFunctions$1<number>,
			System.Numerics.IMinMaxValue$1<number> {
			/** Computes the absolute of a value. */
			static Abs(value: number): number;

			/** Computes the arc-cosine of a value. */
			static Acos(x: number): number;

			/** Computes the hyperbolic arc-cosine of a value. */
			static Acosh(x: number): number;

			/** Computes the arc-cosine of a value and divides the result by pi . */
			static AcosPi(x: number): number;

			/** Computes the arc-sine of a value. */
			static Asin(x: number): number;

			/** Computes the hyperbolic arc-sine of a value. */
			static Asinh(x: number): number;

			/** Computes the arc-sine of a value and divides the result by pi . */
			static AsinPi(x: number): number;

			/** Computes the arc-tangent of a value. */
			static Atan(x: number): number;

			/** Computes the arc-tangent of the quotient of two values. */
			static Atan2(
				y: number,
				x: number,
			): number;

			/**
			 * Computes the arc-tangent for the quotient of two values and divides the result by pi .
			 */
			static Atan2Pi(
				y: number,
				x: number,
			): number;

			/** Computes the hyperbolic arc-tangent of a value. */
			static Atanh(x: number): number;

			/** Computes the arc-tangent of a value and divides the result by pi. */
			static AtanPi(x: number): number;

			/** Decrements a value to the smallest value that compares less than a given value. */
			static BitDecrement(x: number): number;

			/** Increments a value to the smallest value that compares greater than a given value. */
			static BitIncrement(x: number): number;

			/** Computes the cube-root of a value. */
			static Cbrt(x: number): number;

			/** Computes the ceiling of a value. */
			static Ceiling(x: number): number;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/**
			 * Compares this instance to a specified double-precision floating-point number and
			 * returns an integer that indicates whether the value of this instance is less than,
			 * equal to, or greater than the value of the specified double-precision floating-point
			 * number.
			 */
			CompareTo(value: number): number;

			/**
			 * Compares this instance to a specified object and returns an integer that indicates
			 * whether the value of this instance is less than, equal to, or greater than the value
			 * of the specified object.
			 */
			CompareTo(value: System.Object | undefined): number;

			/** Copies the sign of a value to the sign of another value. */
			static CopySign(
				value: number,
				sign: number,
			): number;

			/** Computes the cosine of a value. */
			static Cos(x: number): number;

			/** Computes the hyperbolic cosine of a value. */
			static Cosh(x: number): number;

			/** Computes the cosine of a value that has been multipled by pi . */
			static CosPi(x: number): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): number;

			/** Converts a given value from degrees to radians. */
			static DegreesToRadians(degrees: number): number;

			/**
			 * Returns a value indicating whether this instance and a specified {@link System.Double}
			 * object represent the same value.
			 */
			Equals(obj: number): boolean;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Computes E raised to a given power. */
			static Exp(x: number): number;

			/** Computes 10 raised to a given power. */
			static Exp10(x: number): number;

			/** Computes 10 raised to a given power and subtracts one. */
			static Exp10M1(x: number): number;

			/** Computes 2 raised to a given power. */
			static Exp2(x: number): number;

			/** Computes 2 raised to a given power and subtracts one. */
			static Exp2M1(x: number): number;

			/** Computes E raised to a given power and subtracts one. */
			static ExpM1(x: number): number;

			/** Computes the floor of a value. */
			static Floor(x: number): number;

			/** Computes the fused multiply-add of three values. */
			static FusedMultiplyAdd(
				left: number,
				right: number,
				addend: number,
			): number;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.Double}. */
			GetTypeCode(): System.TypeCode;

			/**
			 * Computes the hypotenuse given two values representing the lengths of the shorter sides
			 * in a right-angled triangle.
			 */
			static Hypot(
				x: number,
				y: number,
			): number;

			/** Computes the remainder of two values as specified by IEEE 754. */
			static Ieee754Remainder(
				left: number,
				right: number,
			): number;

			/** Computes the integer logarithm of a value. */
			static ILogB(x: number): number;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: number): boolean;

			/** Determines whether the specified value is finite (zero, subnormal, or normal). */
			static IsFinite(d: number): boolean;

			/**
			 * Returns a value indicating whether the specified number evaluates to negative or
			 * positive infinity.
			 */
			static IsInfinity(d: number): boolean;

			/** Determines if a value represents an integral value. */
			static IsInteger(value: number): boolean;

			/**
			 * Returns a value that indicates whether the specified value is not a number (
				 * {@link System.Double.NaN} ).
				 */
				static IsNaN(d: number): boolean;

			/** Determines whether the specified value is negative. */
			static IsNegative(d: number): boolean;

			/**
			 * Returns a value indicating whether the specified number evaluates to negative
			 * infinity.
			 */
			static IsNegativeInfinity(d: number): boolean;

			/** Determines whether the specified value is normal. */
			static IsNormal(d: number): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: number): boolean;

			/** Determines if a value is positive. */
			static IsPositive(value: number): boolean;

			/**
			 * Returns a value indicating whether the specified number evaluates to positive
			 * infinity.
			 */
			static IsPositiveInfinity(d: number): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: number): boolean;

			/** Determines if a value represents a real number. */
			static IsRealNumber(value: number): boolean;

			/** Determines whether the specified value is subnormal. */
			static IsSubnormal(d: number): boolean;

			/** Performs a linear interpolation between two values based on the given weight. */
			static Lerp(
				value1: number,
				value2: number,
				amount: number,
			): number;

			/** Computes the natural ( base-E logarithm of a value. */
			static Log(x: number): number;

			/** Computes the logarithm of a value in the specified base. */
			static Log(
				x: number,
				newBase: number,
			): number;

			/** Computes the base-10 logarithm of a value. */
			static Log10(x: number): number;

			/** Computes the base-10 logarithm of a value plus one. */
			static Log10P1(x: number): number;

			/** Computes the log2 of a value. */
			static Log2(value: number): number;

			/** Computes the base-2 logarithm of a value plus one. */
			static Log2P1(x: number): number;

			/** Computes the natural ( base-E ) logarithm of a value plus one. */
			static LogP1(x: number): number;

			/** Compares two values to compute which is greater. */
			static Max(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is greater. */
			static MaxMagnitude(
				x: number,
				y: number,
			): number;

			/**
			 * Compares two values to compute which has the greater magnitude and returning the other
			 * value if an input is NaN .
			 */
			static MaxMagnitudeNumber(
				x: number,
				y: number,
			): number;

			/**
			 * Compares two values to compute which is greater and returning the other value if an
			 * input is NaN .
			 */
			static MaxNumber(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static MinMagnitude(
				x: number,
				y: number,
			): number;

			/**
			 * Compares two values to compute which has the lesser magnitude and returning the other
			 * value if an input is NaN .
			 */
			static MinMagnitudeNumber(
				x: number,
				y: number,
			): number;

			/**
			 * Compares two values to compute which is lesser and returning the other value if an
			 * input is NaN .
			 */
			static MinNumber(
				x: number,
				y: number,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts a character span that contains the string representation of a number in a
			 * specified style and culture-specific format to its double-precision floating-point
			 * number equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number to its double-precision floating-point
			 * number equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a number in a specified style to its
			 * double-precision floating-point number equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): number;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its double-precision floating-point number equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its double-precision floating-point number equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Computes a value raised to a given power. */
			static Pow(
				x: number,
				y: number,
			): number;

			/** Converts a given value from radians to degrees. */
			static RadiansToDegrees(radians: number): number;

			/** Computes an estimate of the reciprocal of a value. */
			static ReciprocalEstimate(x: number): number;

			/** Computes an estimate of the reciprocal square root of a value. */
			static ReciprocalSqrtEstimate(x: number): number;

			/** Computes the n-th root of a value. */
			static RootN(
				x: number,
				n: number,
			): number;

			/** Rounds a value to the nearest integer using the default rounding mode (  ). */
			static Round(x: number): number;

			/**
			 * Rounds a value to a specified number of fractional-digits using the default rounding
			 * mode (  ).
			 */
			static Round(
				x: number,
				digits: number,
			): number;

			/**
			 * Rounds a value to a specified number of fractional-digits using the default rounding
			 * mode (  ).
			 */
			static Round(
				x: number,
				digits: number,
				mode: System.MidpointRounding,
			): number;

			/** Rounds a value to the nearest integer using the specified rounding mode. */
			static Round(
				x: number,
				mode: System.MidpointRounding,
			): number;

			/** Computes the product of a value and its base-radix raised to the specified power. */
			static ScaleB(
				x: number,
				n: number,
			): number;

			/** Computes the sign of a value. */
			static Sign(value: number): number;

			/** Computes the sine of a value. */
			static Sin(x: number): number;

			/** Computes the sine and cosine of a value. */
			static SinCos(x: number): [number, number];

			/** Computes the sine and cosine of a value. */
			static SinCosPi(x: number): [number, number];

			/** Computes the hyperbolic sine of a value. */
			static Sinh(x: number): number;

			/** Computes the sine of a value that has been multiplied by pi . */
			static SinPi(x: number): number;

			/** Computes the square-root of a value. */
			static Sqrt(x: number): number;

			/** Computes the tangent of a value. */
			static Tan(x: number): number;

			/** Computes the hyperbolic tangent of a value. */
			static Tanh(x: number): number;

			/** Computes the tangent of a value that has been multipled by pi . */
			static TanPi(x: number): number;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Truncates a value. */
			static Truncate(x: number): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number | undefined;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an object appears more than once in an array of
		 * synchronization objects.
		 */
		export class DuplicateWaitObjectException extends System.ArgumentException {
			/**
			 * Initializes a new instance of the {@link System.DuplicateWaitObjectException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.DuplicateWaitObjectException} class
			 * with the name of the parameter that causes this exception.
			 */
			constructor(parameterName: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.DuplicateWaitObjectException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.DuplicateWaitObjectException} class
			 * with a specified error message and the name of the parameter that causes this
			 * exception.
			 */
			constructor(
				parameterName: string | undefined,
				message: string | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an attempt to load a class fails due to the absence
		 * of an entry method.
		 */
		export class EntryPointNotFoundException extends System.TypeLoadException {
			/**
			 * Initializes a new instance of the {@link System.EntryPointNotFoundException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.EntryPointNotFoundException} class
			 * with a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.EntryPointNotFoundException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Provides the base class for enumerations. */
		export class Enum extends System.ValueType implements
			System.IComparable,
			System.IFormattable {
			/**
			 * Compares this instance to a specified object and returns an indication of their
			 * relative values.
			 */
			CompareTo(target: System.Object | undefined): number;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Converts the specified value of a specified enumerated type to its equivalent string
			 * representation according to the specified format.
			 */
			static Format(
				enumType: System.Type,
				value: System.Object,
				format: string,
			): string;

			/** Returns the hash code for the value of this instance. */
			GetHashCode(): number;

			/**
			 * Retrieves the name of the constant in the specified enumeration that has the specified
			 * value.
			 */
			static GetName(
				enumType: System.Type,
				value: System.Object,
			): string | undefined;

			/**
			 * Retrieves the name of the constant in the specified enumeration type that has the
			 * specified value.
			 */
			static GetName<TEnum>(value: TEnum): string | undefined;

			/** Retrieves an array of the names of the constants in a specified enumeration. */
			static GetNames(enumType: System.Type): string[];

			/** Retrieves an array of the names of the constants in a specified enumeration type. */
			static GetNames<TEnum>(): string[];

			/** Returns the type code of the underlying type of this enumeration member. */
			GetTypeCode(): System.TypeCode;

			/** Returns the underlying type of the specified enumeration. */
			static GetUnderlyingType(enumType: System.Type): System.Type;

			/** Retrieves an array of the values of the constants in a specified enumeration. */
			static GetValues(enumType: System.Type): System.Array;

			/** Retrieves an array of the values of the constants in a specified enumeration type. */
			static GetValues<TEnum>(): TEnum[];

			/**
			 * Retrieves an array of the values of the underlying type constants in a specified
			 * enumeration.
			 */
			static GetValuesAsUnderlyingType(enumType: System.Type): System.Array;

			/**
			 * Retrieves an array of the values of the underlying type constants in a specified
			 * enumeration type.
			 */
			static GetValuesAsUnderlyingType<TEnum>(): System.Array;

			/** Determines whether one or more bit fields are set in the current instance. */
			HasFlag(flag: System.Enum): boolean;

			/**
			 * Returns a Boolean telling whether a given integral value, or its name as a string,
			 * exists in a specified enumeration.
			 */
			static IsDefined(
				enumType: System.Type,
				value: System.Object,
			): boolean;

			/**
			 * Returns a boolean telling whether a given integral value, or its name as a string,
			 * exists in a specified enumeration.
			 */
			static IsDefined<TEnum>(value: TEnum): boolean;

			/**
			 * Converts the span of characters representation of the name or numeric value of one or
			 * more enumerated constants to an equivalent enumerated object.
			 */
			static Parse(
				enumType: System.Type,
				value: System.ReadOnlySpan$1<System.Char>,
			): System.Object;

			/**
			 * Converts the span of characters representation of the name or numeric value of one or
			 * more enumerated constants to an equivalent enumerated object. A parameter specifies
			 * whether the operation is case-insensitive.
			 */
			static Parse(
				enumType: System.Type,
				value: System.ReadOnlySpan$1<System.Char>,
				ignoreCase: boolean,
			): System.Object;

			/**
			 * Converts the string representation of the name or numeric value of one or more
			 * enumerated constants to an equivalent enumerated object.
			 */
			static Parse(
				enumType: System.Type,
				value: string,
			): System.Object;

			/**
			 * Converts the string representation of the name or numeric value of one or more
			 * enumerated constants to an equivalent enumerated object. A parameter specifies whether
			 * the operation is case-insensitive.
			 */
			static Parse(
				enumType: System.Type,
				value: string,
				ignoreCase: boolean,
			): System.Object;

			/**
			 * Converts the span of characters representation of the name or numeric value of one or
			 * more enumerated constants specified by  to an equivalent enumerated object.
			 */
			static Parse<TEnum>(value: System.ReadOnlySpan$1<System.Char>): TEnum;

			/**
			 * Converts the span of characters representation of the name or numeric value of one or
			 * more enumerated constants specified by  to an equivalent enumerated object. A
			 * parameter specifies whether the operation is case-insensitive.
			 */
			static Parse<TEnum>(
				value: System.ReadOnlySpan$1<System.Char>,
				ignoreCase: boolean,
			): TEnum;

			/**
			 * Converts the string representation of the name or numeric value of one or more
			 * enumerated constants specified by  to an equivalent enumerated object.
			 */
			static Parse<TEnum>(value: string): TEnum;

			/**
			 * Converts the string representation of the name or numeric value of one or more
			 * enumerated constants specified by  to an equivalent enumerated object. A parameter
			 * specifies whether the operation is case-insensitive.
			 */
			static Parse<TEnum>(
				value: string,
				ignoreCase: boolean,
			): TEnum;

			/** Converts the specified 8-bit unsigned integer to an enumeration member. */
			static ToObject(
				enumType: System.Type,
				value: number,
			): System.Object;

			/** Converts the specified 16-bit signed integer to an enumeration member. */
			static ToObject(
				enumType: System.Type,
				value: number,
			): System.Object;

			/** Converts the specified 32-bit signed integer to an enumeration member. */
			static ToObject(
				enumType: System.Type,
				value: number,
			): System.Object;

			/** Converts the specified 64-bit signed integer to an enumeration member. */
			static ToObject(
				enumType: System.Type,
				value: number,
			): System.Object;

			/** Converts the specified object with an integer value to an enumeration member. */
			static ToObject(
				enumType: System.Type,
				value: System.Object,
			): System.Object;

			/** Converts the specified 8-bit signed integer value to an enumeration member. */
			static ToObject(
				enumType: System.Type,
				value: number,
			): System.Object;

			/** Converts the specified 16-bit unsigned integer value to an enumeration member. */
			static ToObject(
				enumType: System.Type,
				value: number,
			): System.Object;

			/** Converts the specified 32-bit unsigned integer value to an enumeration member. */
			static ToObject(
				enumType: System.Type,
				value: number,
			): System.Object;

			/** Converts the specified 64-bit unsigned integer value to an enumeration member. */
			static ToObject(
				enumType: System.Type,
				value: number,
			): System.Object;

			/** Converts the value of this instance to its equivalent string representation. */
			ToString(): string;

			/** This method overload is obsolete; use {@link System.Enum.ToString}. */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the value of this instance to its equivalent string representation using the
			 * specified format.
			 */
			ToString(format: string | undefined): string;

			/** This method overload is obsolete; use {@link System.Enum.ToString(System.String)}. */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			static TryFormat<TEnum>(
				value: TEnum,
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
			): System.ReadOnlySpan$1<System.Char> | undefined;

			static TryParse(
				enumType: System.Type,
				value: System.ReadOnlySpan$1<System.Char>,
				ignoreCase: boolean,
			): System.Object | undefined;

			static TryParse(
				enumType: System.Type,
				value: System.ReadOnlySpan$1<System.Char>,
			): System.Object | undefined;

			static TryParse(
				enumType: System.Type,
				value: string | undefined,
				ignoreCase: boolean,
			): System.Object | undefined;

			static TryParse(
				enumType: System.Type,
				value: string | undefined,
			): System.Object | undefined;

			static TryParse<TEnum>(
				value: System.ReadOnlySpan$1<System.Char>,
				ignoreCase: boolean,
			): TEnum | undefined;

			static TryParse<TEnum>(value: System.ReadOnlySpan$1<System.Char>): TEnum | undefined;

			static TryParse<TEnum>(
				value: string | undefined,
				ignoreCase: boolean,
			): TEnum | undefined;

			static TryParse<TEnum>(value: string | undefined): TEnum | undefined;
		}
	}

	export namespace System {
		/**
		 * Provides information about, and means to manipulate, the current environment and
		 * platform. This class cannot be inherited.
		 */
		export namespace Environment {
			/** Gets the command line for this process. */
			export const CommandLine: string;

			/** Gets or sets the fully qualified path of the current working directory. */
			export var CurrentDirectory: string;

			/** Gets a unique identifier for the current managed thread. */
			export const CurrentManagedThreadId: number;

			/** Gets or sets the exit code of the process. */
			export var ExitCode: number;

			/**
			 * Gets a value that indicates whether the current application domain is being unloaded
			 * or the common language runtime (CLR) is shutting down.
			 */
			export const HasShutdownStarted: boolean;

			/**
			 * Gets a value that indicates whether the current operating system is a 64-bit operating
			 * system.
			 */
			export const Is64BitOperatingSystem: boolean;

			/** Gets a value that indicates whether the current process is a 64-bit process. */
			export const Is64BitProcess: boolean;

			/**
			 * Gets a value that indicates whether the current process is authorized to perform
			 * security-relevant functions.
			 */
			export const IsPrivilegedProcess: boolean;

			/** Gets the NetBIOS name of this local computer. */
			export const MachineName: string;

			/** Gets the newline string defined for this environment. */
			export const NewLine: string;

			/** Gets the current platform identifier and version number. */
			export const OSVersion: System.OperatingSystem;

			/** Gets the unique identifier for the current process. */
			export const ProcessId: number;

			/** Gets the number of processors available to the current process. */
			export const ProcessorCount: number;

			/**
			 * Returns the path of the executable that started the currently executing process.
			 * Returns `null` when the path is not available.
			 */
			export const ProcessPath: string | undefined;

			/** Gets current stack trace information. */
			export const StackTrace: string;

			/** Gets the fully qualified path of the system directory. */
			export const SystemDirectory: string;

			/** Gets the number of bytes in the operating system's memory page. */
			export const SystemPageSize: number;

			/** Gets the number of milliseconds elapsed since the system started. */
			export const TickCount: number;

			/** Gets the number of milliseconds elapsed since the system started. */
			export const TickCount64: number;

			/** Gets the network domain name associated with the current user. */
			export const UserDomainName: string;

			/**
			 * Gets a value indicating whether the current process is running in user interactive
			 * mode.
			 */
			export const UserInteractive: boolean;

			/** Gets the user name of the person who is associated with the current thread. */
			export const UserName: string;

			/**
			 * Gets a version consisting of the major, minor, build, and revision numbers of the
			 * common language runtime.
			 */
			export const Version: System.Version;

			/** Gets the amount of physical memory mapped to the process context. */
			export const WorkingSet: number;

			/** Terminates this process and returns an exit code to the operating system. */
			export function Exit(exitCode: number): void;

			/**
			 * Replaces the name of each environment variable embedded in the specified string with
			 * the string equivalent of the value of the variable, then returns the resulting string.
			 */
			export function ExpandEnvironmentVariables(name: string): string;

			/**
			 * Immediately terminates a process after writing a message to the Windows Application
			 * event log, and then includes the message in error reporting to Microsoft.
			 */
			export function FailFast(message: string | undefined): void;

			/**
			 * Immediately terminates a process after writing a message to the Windows Application
			 * event log, and then includes the message and exception information in error reporting
			 * to Microsoft.
			 */
			export function FailFast(
				message: string | undefined,
				exception: System.Exception | undefined,
			): void;

			/**
			 * Returns a string array containing the command-line arguments for the current process.
			 */
			export function GetCommandLineArgs(): string[];

			/** Retrieves the value of an environment variable from the current process. */
			export function GetEnvironmentVariable(variable: string): string | undefined;

			/**
			 * Retrieves the value of an environment variable from the current process or from the
			 * Windows operating system registry key for the current user or local machine.
			 */
			export function GetEnvironmentVariable(
				variable: string,
				target: System.EnvironmentVariableTarget,
			): string | undefined;

			/**
			 * Retrieves all environment variable names and their values from the current process.
			 */
			export function GetEnvironmentVariables(): System.Collections.IDictionary;

			/**
			 * Retrieves all environment variable names and their values from the current process, or
			 * from the Windows operating system registry key for the current user or local machine.
			 */
			export function GetEnvironmentVariables(target: System.EnvironmentVariableTarget): System.Collections.IDictionary;

			export function GetFolderPath(folder: System.Environment.SpecialFolder): string;

			export function GetFolderPath(
				folder: System.Environment.SpecialFolder,
				option: System.Environment.SpecialFolderOption,
			): string;

			/**
			 * Returns an array of string containing the names of the logical drives on the current
			 * computer.
			 */
			export function GetLogicalDrives(): string[];

			/**
			 * Creates, modifies, or deletes an environment variable stored in the current process.
			 */
			export function SetEnvironmentVariable(
				variable: string,
				value: string | undefined,
			): void;

			/**
			 * Creates, modifies, or deletes an environment variable stored in the current process or
			 * in the Windows operating system registry key reserved for the current user or local
			 * machine.
			 */
			export function SetEnvironmentVariable(
				variable: string,
				value: string | undefined,
				target: System.EnvironmentVariableTarget,
			): void;
		}
	}

	export namespace System.Environment {
		export enum SpecialFolder {
			Desktop = 0,

			Programs = 2,

			MyDocuments = 5,

			Personal = 5,

			Favorites = 6,

			Startup = 7,

			Recent = 8,

			SendTo = 9,

			StartMenu = 11,

			MyMusic = 13,

			MyVideos = 14,

			DesktopDirectory = 16,

			MyComputer = 17,

			NetworkShortcuts = 19,

			Fonts = 20,

			Templates = 21,

			CommonStartMenu = 22,

			CommonPrograms = 23,

			CommonStartup = 24,

			CommonDesktopDirectory = 25,

			ApplicationData = 26,

			PrinterShortcuts = 27,

			LocalApplicationData = 28,

			InternetCache = 32,

			Cookies = 33,

			History = 34,

			CommonApplicationData = 35,

			Windows = 36,

			System = 37,

			ProgramFiles = 38,

			MyPictures = 39,

			UserProfile = 40,

			SystemX86 = 41,

			ProgramFilesX86 = 42,

			CommonProgramFiles = 43,

			CommonProgramFilesX86 = 44,

			CommonTemplates = 45,

			CommonDocuments = 46,

			CommonAdminTools = 47,

			AdminTools = 48,

			CommonMusic = 53,

			CommonPictures = 54,

			CommonVideos = 55,

			Resources = 56,

			LocalizedResources = 57,

			CommonOemLinks = 58,

			CDBurning = 59,
		}
	}

	export namespace System.Environment {
		export enum SpecialFolderOption {
			None = 0,

			DoNotVerify = 16384,

			Create = 32768,
		}
	}

	export namespace System {
		/**
		 * Specifies the location where an environment variable is stored or retrieved in a set
		 * or get operation.
		 */
		export enum EnvironmentVariableTarget {
			/**
			 * The environment variable is stored or retrieved from the environment block associated
			 * with the current process.
			 */
			Process = 0,

			/**
			 * The environment variable is stored or retrieved from the
			 * `HKEY_CURRENT_USER\Environment` key in the Windows operating system registry. This
			 * value should be used on .NET implementations running on Windows systems only.
			 */
			User = 1,

			/**
			 * The environment variable is stored or retrieved from the
			 * `HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment` key
			 * in the Windows operating system registry. This value should be used on .NET
			 * implementations running on Windows systems only.
			 */
			Machine = 2,
		}
	}

	export namespace System {
		/**
		 * Represents the base class for classes that contain event data, and provides a value to
		 * use for events that do not include event data.
		 */
		export class EventArgs {
			/** Initializes a new instance of the {@link System.EventArgs} class. */
			constructor();
		}
	}

	export namespace System {
		/** Represents the method that will handle an event that has no event data. */
		export interface EventHandler { (
			sender: System.Object | undefined,
			e: System.EventArgs,
		): void; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Represents the method that will handle an event when the event
		 * provides data.
		 */
		export function EventHandler$(TEventArgs: IType): IType;

		/** Represents the method that will handle an event when the event provides data. */
		export interface EventHandler$1<TEventArgs> { (
			sender: System.Object | undefined,
			e: TEventArgs,
		): void; }
	}

	export namespace System {
		/** Represents errors that occur during application execution. */
		export class Exception {
			/** Initializes a new instance of the {@link System.Exception} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Exception} class with a specified
			 * error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.Exception} class with a specified
			 * error message and a reference to the inner exception that is the cause of this
			 * exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Gets a collection of key/value pairs that provide additional user-defined information
			 * about the exception.
			 */
			readonly Data: System.Collections.IDictionary;

			/** Gets or sets a link to the help file associated with this exception. */
			HelpLink?: string;

			/**
			 * Gets or sets HRESULT, a coded numerical value that is assigned to a specific
			 * exception.
			 */
			HResult: number;

			/** Gets the {@link System.Exception} instance that caused the current exception. */
			readonly InnerException?: System.Exception;

			/** Gets a message that describes the current exception. */
			readonly Message: string;

			/** Gets or sets the name of the application or the object that causes the error. */
			Source?: string;

			/** Gets a string representation of the immediate frames on the call stack. */
			readonly StackTrace?: string;

			/** Gets the method that throws the current exception. */
			readonly TargetSite?: System.Reflection.MethodBase;

			/**
			 * When overridden in a derived class, returns the {@link System.Exception} that is the
			 * root cause of one or more subsequent exceptions.
			 */
			GetBaseException(): System.Exception;

			/** Gets the runtime type of the current instance. */
			GetType(): System.Type;

			/** Creates and returns a string representation of the current exception. */
			ToString(): string;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is an internal error in the execution engine
		 * of the common language runtime. This class cannot be inherited.
		 */
		export class ExecutionEngineException extends System.SystemException {
			/** Initializes a new instance of the {@link System.ExecutionEngineException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.ExecutionEngineException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ExecutionEngineException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is an invalid attempt to access a private or
		 * protected field inside a class.
		 */
		export class FieldAccessException extends System.MemberAccessException {
			/** Initializes a new instance of the {@link System.FieldAccessException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.FieldAccessException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.FieldAccessException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * Indicates that an enumeration can be treated as a bit field; that is, a set of flags.
		 */
		export class FlagsAttribute extends System.Attribute {
			/** Initializes a new instance of the {@link System.FlagsAttribute} class. */
			constructor();
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when the format of an argument is invalid, or when a
		 * composite format string is not well formed.
		 */
		export class FormatException extends System.SystemException {
			/** Initializes a new instance of the {@link System.FormatException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.FormatException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.FormatException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Represents a composite format string, along with the arguments to be formatted. */
		export class FormattableString {
			/** Gets the number of arguments to be formatted. */
			readonly ArgumentCount: number;

			/** Returns the composite format string. */
			readonly Format: string;

			/**
			 * Returns a result string in which arguments are formatted by using the conventions of
			 * the current culture.
			 */
			static CurrentCulture(formattable: System.FormattableString): string;

			/** Returns the argument at the specified index position. */
			GetArgument(index: number): System.Object | undefined;

			/** Returns an object array that contains one or more objects to format. */
			GetArguments(): System.Object | undefined[];

			/**
			 * Returns a result string in which arguments are formatted by using the conventions of
			 * the invariant culture.
			 */
			static Invariant(formattable: System.FormattableString): string;

			/**
			 * Returns the string that results from formatting the composite format string along with
			 * its arguments by using the formatting conventions of the current culture.
			 */
			ToString(): string;

			/**
			 * Returns the string that results from formatting the composite format string along with
			 * its arguments by using the formatting conventions of a specified culture.
			 */
			ToString(formatProvider: System.IFormatProvider | undefined): string;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has no parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(TResult: IType): IType;

		/**
		 * Encapsulates a method that has no parameters and returns a value of the type specified
		 * by the  parameter.
		 */
		export interface Func$1<TResult> { (): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has nine parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has nine parameters and returns a value of the type
		 * specified by the  parameter.
		 */
		export interface Func$10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 10 parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has 10 parameters and returns a value of the type specified
		 * by the  parameter.
		 */
		export interface Func$11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 11 parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has 11 parameters and returns a value of the type specified
		 * by the  parameter.
		 */
		export interface Func$12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 12 parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, T12: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has 12 parameters and returns a value of the type specified
		 * by the  parameter.
		 */
		export interface Func$13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
			arg12: T12,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 13 parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, T12: IType, T13: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has 13 parameters and returns a value of the type specified
		 * by the  parameter.
		 */
		export interface Func$14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
			arg12: T12,
			arg13: T13,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 14 parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, T12: IType, T13: IType, T14: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has 14 parameters and returns a value of the type specified
		 * by the  parameter.
		 */
		export interface Func$15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
			arg12: T12,
			arg13: T13,
			arg14: T14,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 15 parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, T12: IType, T13: IType, T14: IType, T15: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has 15 parameters and returns a value of the type specified
		 * by the  parameter.
		 */
		export interface Func$16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
			arg12: T12,
			arg13: T13,
			arg14: T14,
			arg15: T15,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has 16 parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, T9: IType, T10: IType, T11: IType, T12: IType, T13: IType, T14: IType, T15: IType, T16: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has 16 parameters and returns a value of the type specified
		 * by the  parameter.
		 */
		export interface Func$17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
			arg9: T9,
			arg10: T10,
			arg11: T11,
			arg12: T12,
			arg13: T13,
			arg14: T14,
			arg15: T15,
			arg16: T16,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has one parameter and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has one parameter and returns a value of the type specified
		 * by the  parameter.
		 */
		export interface Func$2<T, TResult> { (arg: T): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has two parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has two parameters and returns a value of the type
		 * specified by the  parameter.
		 */
		export interface Func$3<T1, T2, TResult> { (
			arg1: T1,
			arg2: T2,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has three parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has three parameters and returns a value of the type
		 * specified by the  parameter.
		 */
		export interface Func$4<T1, T2, T3, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has four parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has four parameters and returns a value of the type
		 * specified by the  parameter.
		 */
		export interface Func$5<T1, T2, T3, T4, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has five parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has five parameters and returns a value of the type
		 * specified by the  parameter.
		 */
		export interface Func$6<T1, T2, T3, T4, T5, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has six parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has six parameters and returns a value of the type
		 * specified by the  parameter.
		 */
		export interface Func$7<T1, T2, T3, T4, T5, T6, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has seven parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has seven parameters and returns a value of the type
		 * specified by the  parameter.
		 */
		export interface Func$8<T1, T2, T3, T4, T5, T6, T7, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
		): TResult; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Encapsulates a method that has eight parameters and returns a
		 * value of the type specified by the  parameter.
		 */
		export function Func$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, T8: IType, TResult: IType): IType;

		/**
		 * Encapsulates a method that has eight parameters and returns a value of the type
		 * specified by the  parameter.
		 */
		export interface Func$9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> { (
			arg1: T1,
			arg2: T2,
			arg3: T3,
			arg4: T4,
			arg5: T5,
			arg6: T6,
			arg7: T7,
			arg8: T8,
		): TResult; }
	}

	export namespace System {
		/**
		 * Controls the system garbage collector, a service that automatically reclaims unused
		 * memory.
		 */
		export namespace GC {
			/** Gets the maximum number of generations that the system currently supports. */
			export const MaxGeneration: number;

			/**
			 * Informs the runtime of a large allocation of unmanaged memory that should be taken
			 * into account when scheduling garbage collection.
			 */
			export function AddMemoryPressure(bytesAllocated: number): void;

			/** Allocates an array. */
			export function AllocateArray<T>(
				length: number,
				pinned?: boolean,
			): T[];

			/** Allocates an array while skipping zero-initialization, if possible. */
			export function AllocateUninitializedArray<T>(
				length: number,
				pinned?: boolean,
			): T[];

			/** Cancels the registration of a garbage collection notification. */
			export function CancelFullGCNotification(): void;

			/** Forces an immediate garbage collection of all generations. */
			export function Collect(): void;

			/**
			 * Forces an immediate garbage collection from generation 0 through a specified
			 * generation.
			 */
			export function Collect(generation: number): void;

			/**
			 * Forces a garbage collection from generation 0 through a specified generation, at a
			 * time specified by a {@link System.GCCollectionMode} value.
			 */
			export function Collect(
				generation: number,
				mode: System.GCCollectionMode,
			): void;

			/**
			 * Forces a garbage collection from generation 0 through a specified generation, at a
			 * time specified by a {@link System.GCCollectionMode} value, with a value specifying
			 * whether the collection should be blocking.
			 */
			export function Collect(
				generation: number,
				mode: System.GCCollectionMode,
				blocking: boolean,
			): void;

			/**
			 * Forces a garbage collection from generation 0 through a specified generation, at a
			 * time specified by a {@link System.GCCollectionMode} value, with values that specify
			 * whether the collection should be blocking and compacting.
			 */
			export function Collect(
				generation: number,
				mode: System.GCCollectionMode,
				blocking: boolean,
				compacting: boolean,
			): void;

			/**
			 * Returns the number of times garbage collection has occurred for the specified
			 * generation of objects.
			 */
			export function CollectionCount(generation: number): number;

			/** Ends the no GC region latency mode. */
			export function EndNoGCRegion(): void;

			/**
			 * Gets the total number of bytes allocated to the current thread since the beginning of
			 * its lifetime.
			 */
			export function GetAllocatedBytesForCurrentThread(): number;

			/** Gets garbage collection memory information. */
			export function GetGCMemoryInfo(): System.GCMemoryInfo;

			/** Gets garbage collection memory information. */
			export function GetGCMemoryInfo(kind: System.GCKind): System.GCMemoryInfo;

			/** Returns the current generation number of the specified object. */
			export function GetGeneration(obj: System.Object): number;

			/** Returns the current generation number of the target of a specified weak reference. */
			export function GetGeneration(wo: System.WeakReference): number;

			/**
			 * Gets a count of the bytes allocated over the lifetime of the process. The returned
			 * value does not include any native allocations.
			 */
			export function GetTotalAllocatedBytes(precise?: boolean): number;

			/**
			 * Retrieves the heap size excluding fragmentation. For example if the total GC heap size
			 * is 100mb and fragmentation, ie, space taken up by free objects, takes up 40mb, this
			 * API would report 60mb. A parameter indicates whether this method can wait a short
			 * interval before returning, to allow the system to collect garbage and finalize
			 * objects.
			 */
			export function GetTotalMemory(forceFullCollection: boolean): number;

			/**
			 * References the specified object, which makes it ineligible for garbage collection from
			 * the start of the current routine to the point where this method is called.
			 */
			export function KeepAlive(obj: System.Object | undefined): void;

			/**
			 * Specifies that a garbage collection notification should be raised when conditions
			 * favor full garbage collection and when the collection has been completed.
			 */
			export function RegisterForFullGCNotification(
				maxGenerationThreshold: number,
				largeObjectHeapThreshold: number,
			): void;

			/**
			 * Registers a callback to be invoked when a certain amount of memory is allocated in the
			 * no GC region.
			 */
			export function RegisterNoGCRegionCallback(
				totalSize: number,
				callback: () => void,
			): void;

			/**
			 * Informs the runtime that unmanaged memory has been released and no longer needs to be
			 * taken into account when scheduling garbage collection.
			 */
			export function RemoveMemoryPressure(bytesAllocated: number): void;

			/**
			 * Requests that the system call the finalizer for the specified object for which
			 * {@link System.GC.SuppressFinalize(System.Object)} has previously been called.
			 */
			export function ReRegisterForFinalize(obj: System.Object): void;

			/**
			 * Requests that the common language runtime not call the finalizer for the specified
			 * object.
			 */
			export function SuppressFinalize(obj: System.Object): void;

			/**
			 * Attempts to disallow garbage collection during the execution of a critical path if a
			 * specified amount of memory is available.
			 */
			export function TryStartNoGCRegion(totalSize: number): boolean;

			/**
			 * Attempts to disallow garbage collection during the execution of a critical path if a
			 * specified amount of memory is available, and controls whether the garbage collector
			 * does a full blocking garbage collection if not enough memory is initially available.
			 */
			export function TryStartNoGCRegion(
				totalSize: number,
				disallowFullBlockingGC: boolean,
			): boolean;

			/**
			 * Attempts to disallow garbage collection during the execution of a critical path if a
			 * specified amount of memory is available for the large object heap and the small object
			 * heap.
			 */
			export function TryStartNoGCRegion(
				totalSize: number,
				lohSize: number,
			): boolean;

			/**
			 * Attempts to disallow garbage collection during the execution of a critical path if a
			 * specified amount of memory is available for the large object heap and the small object
			 * heap, and controls whether the garbage collector does a full blocking garbage
			 * collection if not enough memory is initially available.
			 */
			export function TryStartNoGCRegion(
				totalSize: number,
				lohSize: number,
				disallowFullBlockingGC: boolean,
			): boolean;

			/**
			 * Returns the status of a registered notification for determining whether a full,
			 * blocking garbage collection by the common language runtime is imminent.
			 */
			export function WaitForFullGCApproach(): System.GCNotificationStatus;

			/**
			 * Returns, in a specified time-out period, the status of a registered notification for
			 * determining whether a full, blocking garbage collection by the common language runtime
			 * is imminent.
			 */
			export function WaitForFullGCApproach(millisecondsTimeout: number): System.GCNotificationStatus;

			/**
			 * Returns, in a specified time-out period, the status of a registered notification for
			 * determining whether a full, blocking garbage collection by the common language runtime
			 * is imminent.
			 */
			export function WaitForFullGCApproach(timeout: number): System.GCNotificationStatus;

			/**
			 * Returns the status of a registered notification for determining whether a full,
			 * blocking garbage collection by the common language runtime has completed.
			 */
			export function WaitForFullGCComplete(): System.GCNotificationStatus;

			/**
			 * Returns, in a specified time-out period, the status of a registered notification for
			 * determining whether a full, blocking garbage collection by common language the runtime
			 * has completed.
			 */
			export function WaitForFullGCComplete(millisecondsTimeout: number): System.GCNotificationStatus;

			/**
			 * Returns the status of a registered notification about whether a blocking garbage
			 * collection has completed. May wait indefinitely for a full collection.
			 */
			export function WaitForFullGCComplete(timeout: number): System.GCNotificationStatus;

			/**
			 * Suspends the current thread until the thread that is processing the queue of
			 * finalizers has emptied that queue.
			 */
			export function WaitForPendingFinalizers(): void;

			/** Gets the total amount of time paused in GC since the beginning of the process. */
			export function GetTotalPauseDuration(): number;

			/** Gets the configurations used by the garbage collector. */
			export function GetConfigurationVariables(): ReadonlyMap<string, System.Object>;

			/**
			 * Instructs the Garbage Collector to reconfigure itself by detecting the various memory
			 * limits on the system.
			 */
			export function RefreshMemoryLimit(): void;
		}
	}

	export namespace System {
		/** Specifies the behavior for a forced garbage collection. */
		export enum GCCollectionMode {
			/**
			 * The default setting for this enumeration, which is currently
			 * {@link System.GCCollectionMode.Forced}.
			 */
			Default = 0,

			/** Forces the garbage collection to occur immediately. */
			Forced = 1,

			/**
			 * Allows the garbage collector to determine whether the current time is optimal to
			 * reclaim objects.
			 */
			Optimized = 2,

			/** Requests that the garbage collector decommit as much memory as possible. */
			Aggressive = 3,
		}
	}

	export namespace System {
		/**
		 * Represents the size and the fragmenation of a generation on entry and on exit of the
		 * GC reported in {@link System.GCMemoryInfo}.
		 */
		export class GCGenerationInfo extends System.ValueType {
			/** Gets the fragmentation in bytes on exit from the reported collection. */
			readonly FragmentationAfterBytes: number;

			/** Gets the fragmentation in bytes on entry to the reported collection. */
			readonly FragmentationBeforeBytes: number;

			/** Gets the size in bytes on exit from the reported collection. */
			readonly SizeAfterBytes: number;

			/** Gets the size in bytes on entry to the reported collection. */
			readonly SizeBeforeBytes: number;
		}
	}

	export namespace System {
		/** Specifies the kind of a garbage collection. */
		export enum GCKind {
			/** Any kind of collection. */
			Any = 0,

			/** A gen0 or gen1 collection. */
			Ephemeral = 1,

			/** A blocking gen2 collection. */
			FullBlocking = 2,

			/** A background collection. This is always a generation 2 collection. */
			Background = 3,
		}
	}

	export namespace System {
		/**
		 * Provides a set of APIs that can be used to retrieve garbage collection information.
		 */
		export class GCMemoryInfo extends System.ValueType {
			/** Gets a value that indicates if this is a compacting GC or not. */
			readonly Compacted: boolean;

			/** Gets a value that indicates if this is a concurrent GC (background GC) or not. */
			readonly Concurrent: boolean;

			/** Gets the number of objects that are ready for finalization that this GC observed. */
			readonly FinalizationPendingCount: number;

			/** Gets the total fragmentation when the last garbage collection occurred. */
			readonly FragmentedBytes: number;

			/**
			 * Gets the generation this GC collected. Collecting a generation also collects younger
			 * generations.
			 */
			readonly Generation: number;

			/** Gets the generation information for all generations. */
			readonly GenerationInfo: System.ReadOnlySpan$1<System.GCGenerationInfo>;

			/** Gets the total heap size when the last garbage collection occurred. */
			readonly HeapSizeBytes: number;

			/** Gets the high memory load threshold when the last garbage collection occurred. */
			readonly HighMemoryLoadThresholdBytes: number;

			/** Gets the index of this GC. */
			readonly Index: number;

			/** Gets the physical memory load when the last garbage collection occurred. */
			readonly MemoryLoadBytes: number;

			/** Gets the durations of the pauses when all managed threads are suspended. */
			readonly PauseDurations: System.ReadOnlySpan$1<number>;

			/**
			 * Gets the pause time percentage in the GC so far. If the pause time is 1.2%, this
			 * property's value is 1.2. The value is calculated by taking the sum of all GC pauses so
			 * far and dividing that by the total elapsed time of the process since the runtime was
			 * loaded. This running counter is updated at the end of each GC. It does not distinguish
			 * between {@link System.GCKind}. That is, at every GC, the calculated value is updated,
			 * and when you access this property, it gets the latest calculated value.
			 */
			readonly PauseTimePercentage: number;

			/** Gets the number of pinned objects this GC observed. */
			readonly PinnedObjectsCount: number;

			/** Gets the promoted bytes for this GC. */
			readonly PromotedBytes: number;

			/**
			 * Gets the total available memory for the garbage collector to use when the last garbage
			 * collection occurred.
			 */
			readonly TotalAvailableMemoryBytes: number;

			/** Gets the total committed bytes of the managed heap. */
			readonly TotalCommittedBytes: number;
		}
	}

	export namespace System {
		/**
		 * Provides information about the current registration for notification of the next full
		 * garbage collection.
		 */
		export enum GCNotificationStatus {
			/** The notification was successful and the registration was not canceled. */
			Succeeded = 0,

			/** The notification failed for any reason. */
			Failed = 1,

			/** The current registration was canceled by the user. */
			Canceled = 2,

			/**
			 * The time specified by the `millisecondsTimeout` parameter for either
			 * {@link System.GC.WaitForFullGCApproach(System.Int32)} or
			 * {@link System.GC.WaitForFullGCComplete(System.Int32)} has elapsed.
			 */
			Timeout = 3,

			/**
			 * This value can result when there's no current registration for a garbage collection
			 * notification, or a full GC has happened but was done as a background GC (that is, a GC
			 * that runs mostly concurrently with user threads) instead of a full blocking GC.
			 * Background GC is enabled by default; disabling it improves the prediction accuracy but
			 * incurs larger GC pauses.
			 */
			NotApplicable = 4,
		}
	}

	export namespace System {
		/** Represents a globally unique identifier (GUID). */
		export class Guid extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<string>,
			System.IEquatable$1<string>,
			System.IFormattable,
			System.IParsable$1<string>,
			System.ISpanParsable$1<string> {
			/**
			 * Initializes a new instance of the {@link System.Guid} structure by using the specified
			 * array of bytes.
			 */
			constructor(b: number[]);

			/**
			 * Initializes a new instance of the {@link System.Guid} structure by using the specified
			 * integers and bytes.
			 */
			constructor(
				a: number,
				b: number,
				c: number,
				d: number,
				e: number,
				f: number,
				g: number,
				h: number,
				i: number,
				j: number,
				k: number,
			);

			/**
			 * Initializes a new instance of the {@link System.Guid} structure by using the specified
			 * integers and byte array.
			 */
			constructor(
				a: number,
				b: number,
				c: number,
				d: number[],
			);

			/**
			 * Initializes a new instance of the {@link System.Guid} structure by using the value
			 * represented by the specified read-only span of bytes.
			 */
			constructor(b: System.ReadOnlySpan$1<number>);

			constructor(
				b: System.ReadOnlySpan$1<number>,
				bigEndian: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.Guid} structure by using the value
			 * represented by the specified string.
			 */
			constructor(g: string);

			/**
			 * Initializes a new instance of the {@link System.Guid} structure by using the specified
			 * unsigned integers and bytes.
			 */
			constructor(
				a: number,
				b: number,
				c: number,
				d: number,
				e: number,
				f: number,
				g: number,
				h: number,
				i: number,
				j: number,
				k: number,
			);

			/**
			 * Compares this instance to a specified {@link System.Guid} object and returns an
			 * indication of their relative values.
			 */
			CompareTo(value: string): number;

			/**
			 * Compares this instance to a specified object and returns an indication of their
			 * relative values.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Returns a value indicating whether this instance and a specified {@link System.Guid}
			 * object represent the same value.
			 */
			Equals(g: string): boolean;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(o: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Initializes a new instance of the {@link System.Guid} structure. */
			static NewGuid(): string;

			/**
			 * Converts a read-only character span that represents a GUID to the equivalent
			 * {@link System.Guid} structure.
			 */
			static Parse(input: System.ReadOnlySpan$1<System.Char>): string;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the string representation of a GUID to the equivalent {@link System.Guid}
			 * structure.
			 */
			static Parse(input: string): string;

			/** Parses a string into a value. */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Converts the character span representation of a GUID to the equivalent
			 * {@link System.Guid} structure, provided that the string is in the specified format.
			 */
			static ParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
			): string;

			/**
			 * Converts the string representation of a GUID to the equivalent {@link System.Guid}
			 * structure, provided that the string is in the specified format.
			 */
			static ParseExact(
				input: string,
				format: string,
			): string;

			/** Returns a 16-element byte array that contains the value of this instance. */
			ToByteArray(): number[];

			ToByteArray(bigEndian: boolean): number[];

			/** Returns a string representation of the value of this instance in registry format. */
			ToString(): string;

			/**
			 * Returns a string representation of the value of this {@link System.Guid} instance,
			 * according to the provided format specifier.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Returns a string representation of the value of this instance of the
			 * {@link System.Guid} class, according to the provided format specifier and
			 * culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
			): System.ReadOnlySpan$1<System.Char> | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
			): System.ReadOnlySpan$1<System.Char> | undefined;

			static TryParse(input: System.ReadOnlySpan$1<System.Char>): string | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): string | undefined;

			static TryParse(input: string | undefined): string | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string | undefined;

			static TryParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
			): string | undefined;

			static TryParseExact(
				input: string | undefined,
				format: string | undefined,
			): string | undefined;

			/** Tries to write the current GUID instance into a span of bytes. */
			TryWriteBytes(destination: System.Span$1<number>): boolean;

			TryWriteBytes(
				destination: System.Span$1<number>,
				bigEndian: boolean,
			): number | undefined;
		}
	}

	export namespace System {
		/** Represents a half-precision floating-point number. */
		export class Half extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<System.Half>,
			System.IEquatable$1<System.Half>,
			System.IFormattable,
			System.IParsable$1<System.Half>,
			System.ISpanFormattable,
			System.ISpanParsable$1<System.Half>,
			System.Numerics.IAdditionOperators$3<System.Half, System.Half, System.Half>,
			System.Numerics.IAdditiveIdentity$2<System.Half, System.Half>,
			System.Numerics.IBinaryNumber$1<System.Half>,
			System.Numerics.IBitwiseOperators$3<System.Half, System.Half, System.Half>,
			System.Numerics.IComparisonOperators$3<System.Half, System.Half, boolean>,
			System.Numerics.IEqualityOperators$3<System.Half, System.Half, boolean>,
			System.Numerics.IDecrementOperators$1<System.Half>,
			System.Numerics.IDivisionOperators$3<System.Half, System.Half, System.Half>,
			System.Numerics.IIncrementOperators$1<System.Half>,
			System.Numerics.IModulusOperators$3<System.Half, System.Half, System.Half>,
			System.Numerics.IMultiplicativeIdentity$2<System.Half, System.Half>,
			System.Numerics.IMultiplyOperators$3<System.Half, System.Half, System.Half>,
			System.Numerics.INumber$1<System.Half>,
			System.Numerics.INumberBase$1<System.Half>,
			System.Numerics.ISubtractionOperators$3<System.Half, System.Half, System.Half>,
			System.Numerics.IUnaryNegationOperators$2<System.Half, System.Half>,
			System.Numerics.IUnaryPlusOperators$2<System.Half, System.Half>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<System.Half>,
			System.Numerics.IExponentialFunctions$1<System.Half>,
			System.Numerics.IFloatingPointConstants$1<System.Half>,
			System.Numerics.ISignedNumber$1<System.Half>,
			System.Numerics.IHyperbolicFunctions$1<System.Half>,
			System.Numerics.ILogarithmicFunctions$1<System.Half>,
			System.Numerics.IPowerFunctions$1<System.Half>,
			System.Numerics.IRootFunctions$1<System.Half>,
			System.Numerics.ITrigonometricFunctions$1<System.Half>,
			System.Numerics.IMinMaxValue$1<System.Half> {
			/** Gets the mathematical constant e . */
			static readonly E: System.Half;

			/**
			 * Represents the smallest positive {@link System.Half} value that is greater than zero.
			 */
			static readonly Epsilon: System.Half;

			/** Represents the largest possible value of  . */
			static readonly MaxValue: System.Half;

			/** Represents the smallest possible value of  . */
			static readonly MinValue: System.Half;

			/** Gets the multiplicative identity of the current type. */
			static readonly MultiplicativeIdentity: System.Half;

			/** Represents not a number. */
			static readonly NaN: System.Half;

			/** Represents negative infinity. */
			static readonly NegativeInfinity: System.Half;

			/** Gets the value -1 for the type. */
			static readonly NegativeOne: System.Half;

			/** Gets a value that represents negative zero . */
			static readonly NegativeZero: System.Half;

			/** Gets the value 1 for the type. */
			static readonly One: System.Half;

			/** Gets the mathematical constant pi . */
			static readonly Pi: System.Half;

			/** Represents positive infinity. */
			static readonly PositiveInfinity: System.Half;

			/** Gets the mathematical constant tau . */
			static readonly Tau: System.Half;

			/** Gets the value 0 for the type. */
			static readonly Zero: System.Half;

			/** Computes the absolute of a value. */
			static Abs(value: System.Half): System.Half;

			/** Computes the arc-cosine of a value. */
			static Acos(x: System.Half): System.Half;

			/** Computes the hyperbolic arc-cosine of a value. */
			static Acosh(x: System.Half): System.Half;

			/** Computes the arc-cosine of a value and divides the result by pi . */
			static AcosPi(x: System.Half): System.Half;

			/** Computes the arc-sine of a value. */
			static Asin(x: System.Half): System.Half;

			/** Computes the hyperbolic arc-sine of a value. */
			static Asinh(x: System.Half): System.Half;

			/** Computes the arc-sine of a value and divides the result by pi . */
			static AsinPi(x: System.Half): System.Half;

			/** Computes the arc-tangent of a value. */
			static Atan(x: System.Half): System.Half;

			/** Computes the arc-tangent of the quotient of two values. */
			static Atan2(
				y: System.Half,
				x: System.Half,
			): System.Half;

			/**
			 * Computes the arc-tangent for the quotient of two values and divides the result by pi .
			 */
			static Atan2Pi(
				y: System.Half,
				x: System.Half,
			): System.Half;

			/** Computes the hyperbolic arc-tangent of a value. */
			static Atanh(x: System.Half): System.Half;

			/** Computes the arc-tangent of a value and divides the result by pi. */
			static AtanPi(x: System.Half): System.Half;

			/** Decrements a value to the smallest value that compares less than a given value. */
			static BitDecrement(x: System.Half): System.Half;

			/** Increments a value to the smallest value that compares greater than a given value. */
			static BitIncrement(x: System.Half): System.Half;

			/** Computes the cube-root of a value. */
			static Cbrt(x: System.Half): System.Half;

			/** Computes the ceiling of a value. */
			static Ceiling(x: System.Half): System.Half;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: System.Half,
				min: System.Half,
				max: System.Half,
			): System.Half;

			/**
			 * Compares this instance to a specified half-precision floating-point number and returns
			 * an integer that indicates whether the value of this instance is less than, equal to,
			 * or greater than the value of the specified half-precision floating-point number.
			 */
			CompareTo(other: System.Half): number;

			/**
			 * Compares this instance to a specified object and returns an integer that indicates
			 * whether the value of this instance is less than, equal to, or greater than the value
			 * of the specified object.
			 */
			CompareTo(obj: System.Object | undefined): number;

			/** Copies the sign of a value to the sign of another value. */
			static CopySign(
				value: System.Half,
				sign: System.Half,
			): System.Half;

			/** Computes the cosine of a value. */
			static Cos(x: System.Half): System.Half;

			/** Computes the hyperbolic cosine of a value. */
			static Cosh(x: System.Half): System.Half;

			/** Computes the cosine of a value that has been multipled by pi . */
			static CosPi(x: System.Half): System.Half;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): System.Half;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): System.Half;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): System.Half;

			/** Converts a given value from degrees to radians. */
			static DegreesToRadians(degrees: System.Half): System.Half;

			/** Compares this instance for equality with `other`. */
			Equals(other: System.Half): boolean;

			/**
			 * Returns a value that indicates whether this instance is equal to the specified `obj`.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Computes E raised to a given power. */
			static Exp(x: System.Half): System.Half;

			/** Computes 10 raised to a given power. */
			static Exp10(x: System.Half): System.Half;

			/** Computes 10 raised to a given power and subtracts one. */
			static Exp10M1(x: System.Half): System.Half;

			/** Computes 2 raised to a given power. */
			static Exp2(x: System.Half): System.Half;

			/** Computes 2 raised to a given power and subtracts one. */
			static Exp2M1(x: System.Half): System.Half;

			/** Computes E raised to a given power and subtracts one. */
			static ExpM1(x: System.Half): System.Half;

			/** Computes the floor of a value. */
			static Floor(x: System.Half): System.Half;

			/** Computes the fused multiply-add of three values. */
			static FusedMultiplyAdd(
				left: System.Half,
				right: System.Half,
				addend: System.Half,
			): System.Half;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Computes the hypotenuse given two values representing the lengths of the shorter sides
			 * in a right-angled triangle.
			 */
			static Hypot(
				x: System.Half,
				y: System.Half,
			): System.Half;

			/** Computes the remainder of two values as specified by IEEE 754. */
			static Ieee754Remainder(
				left: System.Half,
				right: System.Half,
			): System.Half;

			/** Computes the integer logarithm of a value. */
			static ILogB(x: System.Half): number;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: System.Half): boolean;

			/** Determines whether the specified value is finite (zero, subnormal, or normal). */
			static IsFinite(value: System.Half): boolean;

			/**
			 * Returns a value indicating whether the specified number evaluates to positive
			 * infinity.
			 */
			static IsInfinity(value: System.Half): boolean;

			/** Determines if a value represents an integral value. */
			static IsInteger(value: System.Half): boolean;

			/** Determines whether the specified value is not a number. */
			static IsNaN(value: System.Half): boolean;

			/** Determines whether the specified value is negative. */
			static IsNegative(value: System.Half): boolean;

			/** Determines whether the specified value is negative infinity. */
			static IsNegativeInfinity(value: System.Half): boolean;

			/** Determines whether the specified value is normal. */
			static IsNormal(value: System.Half): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: System.Half): boolean;

			/** Determines if a value is positive. */
			static IsPositive(value: System.Half): boolean;

			/** Determines whether the specified value is positive infinity. */
			static IsPositiveInfinity(value: System.Half): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: System.Half): boolean;

			/** Determines if a value represents a real number. */
			static IsRealNumber(value: System.Half): boolean;

			/** Determines whether the specified value is subnormal. */
			static IsSubnormal(value: System.Half): boolean;

			/** Performs a linear interpolation between two values based on the given weight. */
			static Lerp(
				value1: System.Half,
				value2: System.Half,
				amount: System.Half,
			): System.Half;

			/** Computes the natural ( base-E logarithm of a value. */
			static Log(x: System.Half): System.Half;

			/** Computes the logarithm of a value in the specified base. */
			static Log(
				x: System.Half,
				newBase: System.Half,
			): System.Half;

			/** Computes the base-10 logarithm of a value. */
			static Log10(x: System.Half): System.Half;

			/** Computes the base-10 logarithm of a value plus one. */
			static Log10P1(x: System.Half): System.Half;

			/** Computes the log2 of a value. */
			static Log2(value: System.Half): System.Half;

			/** Computes the base-2 logarithm of a value plus one. */
			static Log2P1(x: System.Half): System.Half;

			/** Computes the natural ( base-E ) logarithm of a value plus one. */
			static LogP1(x: System.Half): System.Half;

			/** Compares two values to compute which is greater. */
			static Max(
				x: System.Half,
				y: System.Half,
			): System.Half;

			/** Compares two values to compute which is greater. */
			static MaxMagnitude(
				x: System.Half,
				y: System.Half,
			): System.Half;

			/**
			 * Compares two values to compute which has the greater magnitude and returning the other
			 * value if an input is NaN .
			 */
			static MaxMagnitudeNumber(
				x: System.Half,
				y: System.Half,
			): System.Half;

			/**
			 * Compares two values to compute which is greater and returning the other value if an
			 * input is NaN .
			 */
			static MaxNumber(
				x: System.Half,
				y: System.Half,
			): System.Half;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: System.Half,
				y: System.Half,
			): System.Half;

			/** Compares two values to compute which is lesser. */
			static MinMagnitude(
				x: System.Half,
				y: System.Half,
			): System.Half;

			/**
			 * Compares two values to compute which has the lesser magnitude and returning the other
			 * value if an input is NaN .
			 */
			static MinMagnitudeNumber(
				x: System.Half,
				y: System.Half,
			): System.Half;

			/**
			 * Compares two values to compute which is lesser and returning the other value if an
			 * input is NaN .
			 */
			static MinNumber(
				x: System.Half,
				y: System.Half,
			): System.Half;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.Half;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.Half;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its single-precision floating-point number equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.Half;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.Half;

			/**
			 * Converts the string representation of a number to its half-precision floating-point
			 * number equivalent.
			 */
			static Parse(s: string): System.Half;

			/**
			 * Converts the string representation of a number in a specified style to its
			 * single-precision floating-point number equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): System.Half;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its single-precision floating-point number equivalent.
			 */
			static Parse(
				s: string,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.Half;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its single-precision floating-point number equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): System.Half;

			/** Computes a value raised to a given power. */
			static Pow(
				x: System.Half,
				y: System.Half,
			): System.Half;

			/** Converts a given value from radians to degrees. */
			static RadiansToDegrees(radians: System.Half): System.Half;

			/** Computes an estimate of the reciprocal of a value. */
			static ReciprocalEstimate(x: System.Half): System.Half;

			/** Computes an estimate of the reciprocal square root of a value. */
			static ReciprocalSqrtEstimate(x: System.Half): System.Half;

			/** Computes the n-th root of a value. */
			static RootN(
				x: System.Half,
				n: number,
			): System.Half;

			/** Rounds a value to the nearest integer using the default rounding mode (  ). */
			static Round(x: System.Half): System.Half;

			/**
			 * Rounds a value to a specified number of fractional-digits using the default rounding
			 * mode (  ).
			 */
			static Round(
				x: System.Half,
				digits: number,
			): System.Half;

			/**
			 * Rounds a value to a specified number of fractional-digits using the default rounding
			 * mode (  ).
			 */
			static Round(
				x: System.Half,
				digits: number,
				mode: System.MidpointRounding,
			): System.Half;

			/** Rounds a value to the nearest integer using the specified rounding mode. */
			static Round(
				x: System.Half,
				mode: System.MidpointRounding,
			): System.Half;

			/** Computes the product of a value and its base-radix raised to the specified power. */
			static ScaleB(
				x: System.Half,
				n: number,
			): System.Half;

			/** Computes the sign of a value. */
			static Sign(value: System.Half): number;

			/** Computes the sine of a value. */
			static Sin(x: System.Half): System.Half;

			/** Computes the sine and cosine of a value. */
			static SinCos(x: System.Half): [System.Half, System.Half];

			/** Computes the sine and cosine of a value that has been multiplied by pi . */
			static SinCosPi(x: System.Half): [System.Half, System.Half];

			/** Computes the hyperbolic sine of a value. */
			static Sinh(x: System.Half): System.Half;

			/** Computes the sine of a value that has been multiplied by pi . */
			static SinPi(x: System.Half): System.Half;

			/** Computes the square-root of a value. */
			static Sqrt(x: System.Half): System.Half;

			/** Computes the tangent of a value. */
			static Tan(x: System.Half): System.Half;

			/** Computes the hyperbolic tangent of a value. */
			static Tanh(x: System.Half): System.Half;

			/** Computes the tangent of a value that has been multipled by pi . */
			static TanPi(x: System.Half): System.Half;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Truncates a value. */
			static Truncate(x: System.Half): System.Half;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Half | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): System.Half | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.Half | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Half | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): System.Half | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.Half | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Half | undefined;

			static TryParse(s: string | undefined): System.Half | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): System.Half | undefined;
		}
	}

	export namespace System {
		/** Combines the hash code for multiple values into a single hash code. */
		export class HashCode extends System.ValueType {
			/** Adds a span of bytes to the hash code. */
			AddBytes(value: System.ReadOnlySpan$1<number>): void;

			/** Adds a single value to the hash code. */
			Add<T>(value: T): void;

			/**
			 * Adds a single value to the hash code, specifying the type that provides the hash code
			 * function.
			 */
			Add<T>(
				value: T,
				comparer: System.Collections.Generic.IEqualityComparer$1<T> | undefined,
			): void;

			/** Diffuses the hash code returned by the specified value. */
			static Combine<T1>(value1: T1): number;

			/** Combines two values into a hash code. */
			static Combine<T1, T2>(
				value1: T1,
				value2: T2,
			): number;

			/** Combines three values into a hash code. */
			static Combine<T1, T2, T3>(
				value1: T1,
				value2: T2,
				value3: T3,
			): number;

			/** Combines four values into a hash code. */
			static Combine<T1, T2, T3, T4>(
				value1: T1,
				value2: T2,
				value3: T3,
				value4: T4,
			): number;

			/** Combines five values into a hash code. */
			static Combine<T1, T2, T3, T4, T5>(
				value1: T1,
				value2: T2,
				value3: T3,
				value4: T4,
				value5: T5,
			): number;

			/** Combines six values into a hash code. */
			static Combine<T1, T2, T3, T4, T5, T6>(
				value1: T1,
				value2: T2,
				value3: T3,
				value4: T4,
				value5: T5,
				value6: T6,
			): number;

			/** Combines seven values into a hash code. */
			static Combine<T1, T2, T3, T4, T5, T6, T7>(
				value1: T1,
				value2: T2,
				value3: T3,
				value4: T4,
				value5: T5,
				value6: T6,
				value7: T7,
			): number;

			/** Combines eight values into a hash code. */
			static Combine<T1, T2, T3, T4, T5, T6, T7, T8>(
				value1: T1,
				value2: T2,
				value3: T3,
				value4: T4,
				value5: T5,
				value6: T6,
				value7: T7,
				value8: T8,
			): number;

			/** This method is not supported and should not be called. */
			Equals(obj: System.Object | undefined): boolean;

			/** This method is not supported and should not be called. */
			GetHashCode(): number;

			/**
			 * Calculates the final hash code after consecutive {@link System.HashCode.Add}
			 * invocations.
			 */
			ToHashCode(): number;
		}
	}

	export namespace System {
		/** Provides a mechanism for releasing unmanaged resources asynchronously. */
		export interface IAsyncDisposable {
			/**
			 * Performs application-defined tasks associated with freeing, releasing, or resetting
			 * unmanaged resources asynchronously.
			 */
			DisposeAsync(): Promise<void>;
		}
	}

	export namespace System {
		/** Represents the status of an asynchronous operation. */
		export interface IAsyncResult {
			/**
			 * Gets a user-defined object that qualifies or contains information about an
			 * asynchronous operation.
			 */
			readonly AsyncState?: System.Object;

			/**
			 * Gets a {@link System.Threading.WaitHandle} that is used to wait for an asynchronous
			 * operation to complete.
			 */
			readonly AsyncWaitHandle: System.Threading.WaitHandle;

			/**
			 * Gets a value that indicates whether the asynchronous operation completed
			 * synchronously.
			 */
			readonly CompletedSynchronously: boolean;

			/** Gets a value that indicates whether the asynchronous operation has completed. */
			readonly IsCompleted: boolean;
		}
	}

	export namespace System {
		/**
		 * Supports cloning, which creates a new instance of a class with the same value as an
		 * existing instance.
		 */
		export interface ICloneable {
			/** Creates a new object that is a copy of the current instance. */
			Clone(): System.Object;
		}
	}

	export namespace System {
		/**
		 * Defines a generalized type-specific comparison method that a value type or class
		 * implements to order or sort its instances.
		 */
		export interface IComparable {
			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(obj: System.Object | undefined): number;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Defines a generalized comparison method that a value type or
		 * class implements to create a type-specific comparison method for ordering or sorting
		 * its instances.
		 */
		export function IComparable$(T: IType): IType;

		/**
		 * Defines a generalized comparison method that a value type or class implements to
		 * create a type-specific comparison method for ordering or sorting its instances.
		 */
		export interface IComparable$1<T> {
			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(other: T): number;
		}
	}

	export namespace System {
		/**
		 * Defines methods that convert the value of the implementing reference or value type to
		 * a common language runtime type that has an equivalent value.
		 */
		export interface IConvertible {
			/** Returns the {@link System.TypeCode} for this instance. */
			GetTypeCode(): System.TypeCode;

			/**
			 * Converts the value of this instance to an equivalent Boolean value using the specified
			 * culture-specific formatting information.
			 */
			ToBoolean(provider: System.IFormatProvider | undefined): boolean;

			/**
			 * Converts the value of this instance to an equivalent 8-bit unsigned integer using the
			 * specified culture-specific formatting information.
			 */
			ToByte(provider: System.IFormatProvider | undefined): number;

			/**
			 * Converts the value of this instance to an equivalent Unicode character using the
			 * specified culture-specific formatting information.
			 */
			ToChar(provider: System.IFormatProvider | undefined): System.Char;

			/**
			 * Converts the value of this instance to an equivalent {@link System.DateTime} using the
			 * specified culture-specific formatting information.
			 */
			ToDateTime(provider: System.IFormatProvider | undefined): js.DateTime;

			/**
			 * Converts the value of this instance to an equivalent {@link System.Decimal} number
			 * using the specified culture-specific formatting information.
			 */
			ToDecimal(provider: System.IFormatProvider | undefined): System.Decimal;

			/**
			 * Converts the value of this instance to an equivalent double-precision floating-point
			 * number using the specified culture-specific formatting information.
			 */
			ToDouble(provider: System.IFormatProvider | undefined): number;

			/**
			 * Converts the value of this instance to an equivalent 16-bit signed integer using the
			 * specified culture-specific formatting information.
			 */
			ToInt16(provider: System.IFormatProvider | undefined): number;

			/**
			 * Converts the value of this instance to an equivalent 32-bit signed integer using the
			 * specified culture-specific formatting information.
			 */
			ToInt32(provider: System.IFormatProvider | undefined): number;

			/**
			 * Converts the value of this instance to an equivalent 64-bit signed integer using the
			 * specified culture-specific formatting information.
			 */
			ToInt64(provider: System.IFormatProvider | undefined): number;

			/**
			 * Converts the value of this instance to an equivalent 8-bit signed integer using the
			 * specified culture-specific formatting information.
			 */
			ToSByte(provider: System.IFormatProvider | undefined): number;

			/**
			 * Converts the value of this instance to an equivalent single-precision floating-point
			 * number using the specified culture-specific formatting information.
			 */
			ToSingle(provider: System.IFormatProvider | undefined): number;

			/**
			 * Converts the value of this instance to an equivalent {@link System.String} using the
			 * specified culture-specific formatting information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the value of this instance to an {@link System.Object} of the specified
			 * {@link System.Type} that has an equivalent value, using the specified culture-specific
			 * formatting information.
			 */
			ToType(
				conversionType: System.Type,
				provider: System.IFormatProvider | undefined,
			): System.Object;

			/**
			 * Converts the value of this instance to an equivalent 16-bit unsigned integer using the
			 * specified culture-specific formatting information.
			 */
			ToUInt16(provider: System.IFormatProvider | undefined): number;

			/**
			 * Converts the value of this instance to an equivalent 32-bit unsigned integer using the
			 * specified culture-specific formatting information.
			 */
			ToUInt32(provider: System.IFormatProvider | undefined): number;

			/**
			 * Converts the value of this instance to an equivalent 64-bit unsigned integer using the
			 * specified culture-specific formatting information.
			 */
			ToUInt64(provider: System.IFormatProvider | undefined): number;
		}
	}

	export namespace System {
		/** Defines a method that supports custom formatting of the value of an object. */
		export interface ICustomFormatter {
			/**
			 * Converts the value of a specified object to an equivalent string representation using
			 * specified format and culture-specific formatting information.
			 */
			Format(
				format: string | undefined,
				arg: System.Object | undefined,
				formatProvider: System.IFormatProvider | undefined,
			): string;
		}
	}

	export namespace System {
		/** Provides a mechanism for releasing unmanaged resources. */
		export interface IDisposable {
			/**
			 * Performs application-defined tasks associated with freeing, releasing, or resetting
			 * unmanaged resources.
			 */
			dispose(): void;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Defines a generalized method that a value type or class
		 * implements to create a type-specific method for determining equality of instances.
		 */
		export function IEquatable$(T: IType): IType;

		/**
		 * Defines a generalized method that a value type or class implements to create a
		 * type-specific method for determining equality of instances.
		 */
		export interface IEquatable$1<T> {
			/** Indicates whether the current object is equal to another object of the same type. */
			Equals(other: T): boolean;
		}
	}

	export namespace System {
		/** Provides a mechanism for retrieving an object to control formatting. */
		export interface IFormatProvider {
			/** Returns an object that provides formatting services for the specified type. */
			GetFormat(formatType: System.Type | undefined): System.Object | undefined;
		}
	}

	export namespace System {
		/**
		 * Provides functionality to format the value of an object into a string representation.
		 */
		export interface IFormattable {
			/** Formats the value of the current instance using the specified format. */
			ToString(
				format: string | undefined,
				formatProvider: System.IFormatProvider | undefined,
			): string;
		}
	}

	export namespace System {
		/**
		 * Represents a type that can be used to index a collection either from the beginning or
		 * the end.
		 */
		export class Index extends System.ValueType implements System.IEquatable$1<System.Index> {
			/**
			 * Initializes a new {@link System.Index} with a specified index position and a value
			 * that indicates if the index is from the beginning or the end of a collection.
			 */
			constructor(
				value: number,
				fromEnd?: boolean,
			);

			/** Gets an {@link System.Index} that points beyond the last element. */
			static readonly End: System.Index;

			/** Gets a value that indicates whether the index is from the start or the end. */
			readonly IsFromEnd: boolean;

			/** Gets an {@link System.Index} that points to the first element of a collection. */
			static readonly Start: System.Index;

			/** Gets the index value. */
			readonly Value: number;

			/**
			 * Returns a value that indicates whether the current object is equal to another
			 * {@link System.Index} object.
			 */
			Equals(other: System.Index): boolean;

			/** Indicates whether the current Index object is equal to a specified object. */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Creates an {@link System.Index} from the end of a collection at a specified index
			 * position.
			 */
			static FromEnd(value: number): System.Index;

			/**
			 * Creates an {@link System.Index} from the specified index at the start of a collection.
			 */
			static FromStart(value: number): System.Index;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Calculates the offset from the start of the collection using the specified collection
			 * length.
			 */
			GetOffset(length: number): number;

			/** Returns the string representation of the current {@link System.Index} instance. */
			ToString(): string;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an attempt is made to access an element of an array
		 * or collection with an index that is outside its bounds.
		 */
		export class IndexOutOfRangeException extends System.SystemException {
			/** Initializes a new instance of the {@link System.IndexOutOfRangeException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.IndexOutOfRangeException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.IndexOutOfRangeException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is insufficient execution stack available to
		 * allow most methods to execute.
		 */
		export class InsufficientExecutionStackException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.InsufficientExecutionStackException}
			 * class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.InsufficientExecutionStackException}
			 * class with a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.InsufficientExecutionStackException}
			 * class with a specified error message and a reference to the inner exception that is
			 * the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when a check for sufficient available memory fails. This
		 * class cannot be inherited.
		 */
		export class InsufficientMemoryException extends System.OutOfMemoryException {
			/**
			 * Initializes a new instance of the {@link System.InsufficientMemoryException} class
			 * with a system-supplied message that describes the error.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.InsufficientMemoryException} class
			 * with a specified message that describes the error.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.InsufficientMemoryException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Represents a 128-bit signed integer. */
		export class Int128 extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<System.Int128>,
			System.IEquatable$1<System.Int128>,
			System.IFormattable,
			System.IParsable$1<System.Int128>,
			System.ISpanFormattable,
			System.ISpanParsable$1<System.Int128>,
			System.Numerics.IAdditionOperators$3<System.Int128, System.Int128, System.Int128>,
			System.Numerics.IAdditiveIdentity$2<System.Int128, System.Int128>,
			System.Numerics.IBinaryNumber$1<System.Int128>,
			System.Numerics.IBitwiseOperators$3<System.Int128, System.Int128, System.Int128>,
			System.Numerics.IComparisonOperators$3<System.Int128, System.Int128, boolean>,
			System.Numerics.IEqualityOperators$3<System.Int128, System.Int128, boolean>,
			System.Numerics.IDecrementOperators$1<System.Int128>,
			System.Numerics.IDivisionOperators$3<System.Int128, System.Int128, System.Int128>,
			System.Numerics.IIncrementOperators$1<System.Int128>,
			System.Numerics.IModulusOperators$3<System.Int128, System.Int128, System.Int128>,
			System.Numerics.IMultiplicativeIdentity$2<System.Int128, System.Int128>,
			System.Numerics.IMultiplyOperators$3<System.Int128, System.Int128, System.Int128>,
			System.Numerics.INumber$1<System.Int128>,
			System.Numerics.INumberBase$1<System.Int128>,
			System.Numerics.ISubtractionOperators$3<System.Int128, System.Int128, System.Int128>,
			System.Numerics.IUnaryNegationOperators$2<System.Int128, System.Int128>,
			System.Numerics.IUnaryPlusOperators$2<System.Int128, System.Int128>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<System.Int128>,
			System.Numerics.IShiftOperators$3<System.Int128, number, System.Int128>,
			System.Numerics.IMinMaxValue$1<System.Int128>,
			System.Numerics.ISignedNumber$1<System.Int128> {
			/** Initializes a new instance of the {@link System.Int128} struct. */
			constructor(
				upper: number,
				lower: number,
			);

			/** Gets the maximum value of the current type. */
			static readonly MaxValue: System.Int128;

			/** Gets the minimum value of the current type. */
			static readonly MinValue: System.Int128;

			/** Gets the value -1 for the type. */
			static readonly NegativeOne: System.Int128;

			/** Gets the value 1 for the type. */
			static readonly One: System.Int128;

			/** Gets the value 0 for the type. */
			static readonly Zero: System.Int128;

			/** Computes the absolute of a value. */
			static Abs(value: System.Int128): System.Int128;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: System.Int128,
				min: System.Int128,
				max: System.Int128,
			): System.Int128;

			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(value: System.Int128): number;

			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(value: System.Object | undefined): number;

			/** Copies the sign of a value to the sign of another value. */
			static CopySign(
				value: System.Int128,
				sign: System.Int128,
			): System.Int128;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): System.Int128;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): System.Int128;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): System.Int128;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: System.Int128,
				right: System.Int128,
			): [System.Int128, System.Int128];

			/** Indicates whether the current object is equal to another object of the same type. */
			Equals(other: System.Int128): boolean;

			/** Determines whether the specified object is equal to the current object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Serves as the default hash function. */
			GetHashCode(): number;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: System.Int128): boolean;

			/** Determines if a value is negative. */
			static IsNegative(value: System.Int128): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: System.Int128): boolean;

			/** Determines if a value is positive. */
			static IsPositive(value: System.Int128): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: System.Int128): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: System.Int128): System.Int128;

			/** Computes the log2 of a value. */
			static Log2(value: System.Int128): System.Int128;

			/** Compares two values to compute which is greater. */
			static Max(
				x: System.Int128,
				y: System.Int128,
			): System.Int128;

			/** Compares two values to compute which is greater. */
			static MaxMagnitude(
				x: System.Int128,
				y: System.Int128,
			): System.Int128;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: System.Int128,
				y: System.Int128,
			): System.Int128;

			/** Compares two values to compute which is lesser. */
			static MinMagnitude(
				x: System.Int128,
				y: System.Int128,
			): System.Int128;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.Int128;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.Int128;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.Int128;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.Int128;

			/** Parses a string into a value. */
			static Parse(s: string): System.Int128;

			/** Parses a string into a value. */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): System.Int128;

			/** Parses a string into a value. */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Int128;

			/** Parses a string into a value. */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): System.Int128;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: System.Int128): System.Int128;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: System.Int128,
				rotateAmount: number,
			): System.Int128;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: System.Int128,
				rotateAmount: number,
			): System.Int128;

			/** Computes the sign of a value. */
			static Sign(value: System.Int128): number;

			/** Returns a string that represents the current object. */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/** Formats the value of the current instance using the specified format. */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: System.Int128): System.Int128;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Int128 | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.Int128 | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): System.Int128 | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Int128 | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.Int128 | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): System.Int128 | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.Int128 | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): System.Int128 | undefined;

			static TryParse(s: string | undefined): System.Int128 | undefined;
		}
	}

	export namespace System {
		/** Represents a 16-bit signed integer. */
		export class Int16 extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.Numerics.IAdditionOperators$3<number, number, number>,
			System.Numerics.IAdditiveIdentity$2<number, number>,
			System.Numerics.IBinaryNumber$1<number>,
			System.Numerics.IBitwiseOperators$3<number, number, number>,
			System.Numerics.IComparisonOperators$3<number, number, boolean>,
			System.Numerics.IEqualityOperators$3<number, number, boolean>,
			System.Numerics.IDecrementOperators$1<number>,
			System.Numerics.IDivisionOperators$3<number, number, number>,
			System.Numerics.IIncrementOperators$1<number>,
			System.Numerics.IModulusOperators$3<number, number, number>,
			System.Numerics.IMultiplicativeIdentity$2<number, number>,
			System.Numerics.IMultiplyOperators$3<number, number, number>,
			System.Numerics.INumber$1<number>,
			System.Numerics.INumberBase$1<number>,
			System.Numerics.ISubtractionOperators$3<number, number, number>,
			System.Numerics.IUnaryNegationOperators$2<number, number>,
			System.Numerics.IUnaryPlusOperators$2<number, number>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<number>,
			System.Numerics.IShiftOperators$3<number, number, number>,
			System.Numerics.IMinMaxValue$1<number>,
			System.Numerics.ISignedNumber$1<number> {
			/** Computes the absolute of a value. */
			static Abs(value: number): number;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/**
			 * Compares this instance to a specified 16-bit signed integer and returns an integer
			 * that indicates whether the value of this instance is less than, equal to, or greater
			 * than the value of the specified 16-bit signed integer.
			 */
			CompareTo(value: number): number;

			/**
			 * Compares this instance to a specified object and returns an integer that indicates
			 * whether the value of this instance is less than, equal to, or greater than the value
			 * of the object.
			 */
			CompareTo(value: System.Object | undefined): number;

			/** Copies the sign of a value to the sign of another value. */
			static CopySign(
				value: number,
				sign: number,
			): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): number;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: number,
				right: number,
			): [number, number];

			/**
			 * Returns a value indicating whether this instance is equal to a specified
			 * {@link System.Int16} value.
			 */
			Equals(obj: number): boolean;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.Int16}. */
			GetTypeCode(): System.TypeCode;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: number): boolean;

			/** Determines if a value is negative. */
			static IsNegative(value: number): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: number): boolean;

			/** Determines if a value is positive. */
			static IsPositive(value: number): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: number): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: number): number;

			/** Computes the log2 of a value. */
			static Log2(value: number): number;

			/** Compares two values to compute which is greater. */
			static Max(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is greater. */
			static MaxMagnitude(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static MinMagnitude(
				x: number,
				y: number,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the span representation of a number in a specified style and culture-specific
			 * format to its 16-bit signed integer equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number to its 16-bit signed integer
			 * equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a number in a specified style to its 16-bit
			 * signed integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): number;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its 16-bit signed integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its 16-bit signed integer equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: number): number;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: number,
				rotateAmount: number,
			): number;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: number,
				rotateAmount: number,
			): number;

			/** Computes the sign of a value. */
			static Sign(value: number): number;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific formatting information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: number): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;
		}
	}

	export namespace System {
		/** Represents a 32-bit signed integer. */
		export class Int32 extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.Numerics.IAdditionOperators$3<number, number, number>,
			System.Numerics.IAdditiveIdentity$2<number, number>,
			System.Numerics.IBinaryNumber$1<number>,
			System.Numerics.IBitwiseOperators$3<number, number, number>,
			System.Numerics.IComparisonOperators$3<number, number, boolean>,
			System.Numerics.IEqualityOperators$3<number, number, boolean>,
			System.Numerics.IDecrementOperators$1<number>,
			System.Numerics.IDivisionOperators$3<number, number, number>,
			System.Numerics.IIncrementOperators$1<number>,
			System.Numerics.IModulusOperators$3<number, number, number>,
			System.Numerics.IMultiplicativeIdentity$2<number, number>,
			System.Numerics.IMultiplyOperators$3<number, number, number>,
			System.Numerics.INumber$1<number>,
			System.Numerics.INumberBase$1<number>,
			System.Numerics.ISubtractionOperators$3<number, number, number>,
			System.Numerics.IUnaryNegationOperators$2<number, number>,
			System.Numerics.IUnaryPlusOperators$2<number, number>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<number>,
			System.Numerics.IShiftOperators$3<number, number, number>,
			System.Numerics.IMinMaxValue$1<number>,
			System.Numerics.ISignedNumber$1<number> {
			/** Computes the absolute of a value. */
			static Abs(value: number): number;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/**
			 * Compares this instance to a specified 32-bit signed integer and returns an indication
			 * of their relative values.
			 */
			CompareTo(value: number): number;

			/**
			 * Compares this instance to a specified object and returns an indication of their
			 * relative values.
			 */
			CompareTo(value: System.Object | undefined): number;

			/** Copies the sign of a value to the sign of another value. */
			static CopySign(
				value: number,
				sign: number,
			): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): number;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: number,
				right: number,
			): [number, number];

			/**
			 * Returns a value indicating whether this instance is equal to a specified
			 * {@link System.Int32} value.
			 */
			Equals(obj: number): boolean;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.Int32}. */
			GetTypeCode(): System.TypeCode;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: number): boolean;

			/** Determines if a value is negative. */
			static IsNegative(value: number): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: number): boolean;

			/** Determines if a value is positive. */
			static IsPositive(value: number): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: number): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: number): number;

			/** Computes the log2 of a value. */
			static Log2(value: number): number;

			/** Compares two values to compute which is greater. */
			static Max(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is greater. */
			static MaxMagnitude(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static MinMagnitude(
				x: number,
				y: number,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the span representation of a number in a specified style and culture-specific
			 * format to its 32-bit signed integer equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number to its 32-bit signed integer
			 * equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a number in a specified style to its 32-bit
			 * signed integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): number;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its 32-bit signed integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its 32-bit signed integer equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: number): number;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: number,
				rotateAmount: number,
			): number;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: number,
				rotateAmount: number,
			): number;

			/** Computes the sign of a value. */
			static Sign(value: number): number;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: number): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;
		}
	}

	export namespace System {
		/** Represents a 64-bit signed integer. */
		export class Int64 extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.Numerics.IAdditionOperators$3<number, number, number>,
			System.Numerics.IAdditiveIdentity$2<number, number>,
			System.Numerics.IBinaryNumber$1<number>,
			System.Numerics.IBitwiseOperators$3<number, number, number>,
			System.Numerics.IComparisonOperators$3<number, number, boolean>,
			System.Numerics.IEqualityOperators$3<number, number, boolean>,
			System.Numerics.IDecrementOperators$1<number>,
			System.Numerics.IDivisionOperators$3<number, number, number>,
			System.Numerics.IIncrementOperators$1<number>,
			System.Numerics.IModulusOperators$3<number, number, number>,
			System.Numerics.IMultiplicativeIdentity$2<number, number>,
			System.Numerics.IMultiplyOperators$3<number, number, number>,
			System.Numerics.INumber$1<number>,
			System.Numerics.INumberBase$1<number>,
			System.Numerics.ISubtractionOperators$3<number, number, number>,
			System.Numerics.IUnaryNegationOperators$2<number, number>,
			System.Numerics.IUnaryPlusOperators$2<number, number>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<number>,
			System.Numerics.IShiftOperators$3<number, number, number>,
			System.Numerics.IMinMaxValue$1<number>,
			System.Numerics.ISignedNumber$1<number> {
			/** Computes the absolute of a value. */
			static Abs(value: number): number;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/**
			 * Compares this instance to a specified 64-bit signed integer and returns an indication
			 * of their relative values.
			 */
			CompareTo(value: number): number;

			/**
			 * Compares this instance to a specified object and returns an indication of their
			 * relative values.
			 */
			CompareTo(value: System.Object | undefined): number;

			/** Copies the sign of a value to the sign of another value. */
			static CopySign(
				value: number,
				sign: number,
			): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): number;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: number,
				right: number,
			): [number, number];

			/**
			 * Returns a value indicating whether this instance is equal to a specified
			 * {@link System.Int64} value.
			 */
			Equals(obj: number): boolean;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.Int64}. */
			GetTypeCode(): System.TypeCode;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: number): boolean;

			/** Determines if a value is negative. */
			static IsNegative(value: number): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: number): boolean;

			/** Determines if a value is positive. */
			static IsPositive(value: number): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: number): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: number): number;

			/** Computes the log2 of a value. */
			static Log2(value: number): number;

			/** Compares two values to compute which is greater. */
			static Max(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is greater. */
			static MaxMagnitude(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static MinMagnitude(
				x: number,
				y: number,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the span representation of a number in a specified style and culture-specific
			 * format to its 64-bit signed integer equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number to its 64-bit signed integer
			 * equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a number in a specified style to its 64-bit
			 * signed integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): number;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its 64-bit signed integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its 64-bit signed integer equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: number): number;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: number,
				rotateAmount: number,
			): number;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: number,
				rotateAmount: number,
			): number;

			/** Computes the sign of a value. */
			static Sign(value: number): number;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: number): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;
		}
	}

	export namespace System {
		/** Represents a signed integer where the bit-width is the same as a pointer. */
		export class IntPtr extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<System.IntPtr>,
			System.IEquatable$1<System.IntPtr>,
			System.IFormattable,
			System.IParsable$1<System.IntPtr>,
			System.ISpanFormattable,
			System.ISpanParsable$1<System.IntPtr>,
			System.Numerics.IAdditionOperators$3<System.IntPtr, System.IntPtr, System.IntPtr>,
			System.Numerics.IAdditiveIdentity$2<System.IntPtr, System.IntPtr>,
			System.Numerics.IBinaryNumber$1<System.IntPtr>,
			System.Numerics.IBitwiseOperators$3<System.IntPtr, System.IntPtr, System.IntPtr>,
			System.Numerics.IComparisonOperators$3<System.IntPtr, System.IntPtr, boolean>,
			System.Numerics.IEqualityOperators$3<System.IntPtr, System.IntPtr, boolean>,
			System.Numerics.IDecrementOperators$1<System.IntPtr>,
			System.Numerics.IDivisionOperators$3<System.IntPtr, System.IntPtr, System.IntPtr>,
			System.Numerics.IIncrementOperators$1<System.IntPtr>,
			System.Numerics.IModulusOperators$3<System.IntPtr, System.IntPtr, System.IntPtr>,
			System.Numerics.IMultiplicativeIdentity$2<System.IntPtr, System.IntPtr>,
			System.Numerics.IMultiplyOperators$3<System.IntPtr, System.IntPtr, System.IntPtr>,
			System.Numerics.INumber$1<System.IntPtr>,
			System.Numerics.INumberBase$1<System.IntPtr>,
			System.Numerics.ISubtractionOperators$3<System.IntPtr, System.IntPtr, System.IntPtr>,
			System.Numerics.IUnaryNegationOperators$2<System.IntPtr, System.IntPtr>,
			System.Numerics.IUnaryPlusOperators$2<System.IntPtr, System.IntPtr>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<System.IntPtr>,
			System.Numerics.IShiftOperators$3<System.IntPtr, number, System.IntPtr>,
			System.Numerics.IMinMaxValue$1<System.IntPtr>,
			System.Numerics.ISignedNumber$1<System.IntPtr> {
			/**
			 * Initializes a new instance of {@link System.IntPtr} using the specified 32-bit signed
			 * integer.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of {@link System.IntPtr} using the specified 64-bit signed
			 * integer.
			 */
			constructor(value: number);

			/** Gets the largest possible value of  . */
			static readonly MaxValue: System.IntPtr;

			/** Gets the smallest possible value of  . */
			static readonly MinValue: System.IntPtr;

			/** Gets the size of this instance. */
			static readonly Size: number;

			/** Computes the absolute of a value. */
			static Abs(value: System.IntPtr): System.IntPtr;

			/** Adds an offset to a signed integer. */
			static Add(
				pointer: System.IntPtr,
				offset: number,
			): System.IntPtr;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: System.IntPtr,
				min: System.IntPtr,
				max: System.IntPtr,
			): System.IntPtr;

			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(value: System.IntPtr): number;

			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(value: System.Object | undefined): number;

			/** Copies the sign of a value to the sign of another value. */
			static CopySign(
				value: System.IntPtr,
				sign: System.IntPtr,
			): System.IntPtr;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): System.IntPtr;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): System.IntPtr;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): System.IntPtr;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: System.IntPtr,
				right: System.IntPtr,
			): [System.IntPtr, System.IntPtr];

			/** Indicates whether the current object is equal to another object of the same type. */
			Equals(other: System.IntPtr): boolean;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: System.IntPtr): boolean;

			/** Determines if a value is negative. */
			static IsNegative(value: System.IntPtr): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: System.IntPtr): boolean;

			/** Determines if a value is positive. */
			static IsPositive(value: System.IntPtr): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: System.IntPtr): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: System.IntPtr): System.IntPtr;

			/** Computes the log2 of a value. */
			static Log2(value: System.IntPtr): System.IntPtr;

			/** Compares two values to compute which is greater. */
			static Max(
				x: System.IntPtr,
				y: System.IntPtr,
			): System.IntPtr;

			/** Compares two values to compute which is greater. */
			static MaxMagnitude(
				x: System.IntPtr,
				y: System.IntPtr,
			): System.IntPtr;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: System.IntPtr,
				y: System.IntPtr,
			): System.IntPtr;

			/** Compares two values to compute which is lesser. */
			static MinMagnitude(
				x: System.IntPtr,
				y: System.IntPtr,
			): System.IntPtr;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.IntPtr;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.IntPtr;

			/**
			 * Converts the read-only span of characters representation of a number in a specified
			 * style and culture-specific format to its signed native integer equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.IntPtr;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.IntPtr;

			/**
			 * Converts the string representation of a number to its signed native integer
			 * equivalent.
			 */
			static Parse(s: string): System.IntPtr;

			/**
			 * Converts the string representation of a number in a specified style to its signed
			 * native integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): System.IntPtr;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its signed native integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.IntPtr;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its signed native integer equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): System.IntPtr;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: System.IntPtr): System.IntPtr;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: System.IntPtr,
				rotateAmount: number,
			): System.IntPtr;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: System.IntPtr,
				rotateAmount: number,
			): System.IntPtr;

			/** Computes the sign of a value. */
			static Sign(value: System.IntPtr): number;

			/** Subtracts an offset from a signed integer. */
			static Subtract(
				pointer: System.IntPtr,
				offset: number,
			): System.IntPtr;

			/** Converts the value of this instance to a 32-bit signed integer. */
			ToInt32(): number;

			/** Converts the value of this instance to a 64-bit signed integer. */
			ToInt64(): number;

			/**
			 * Converts the numeric value of the current {@link System.IntPtr} object to its
			 * equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of the current {@link System.IntPtr} object to its
			 * equivalent string representation.
			 */
			ToString(format: string | undefined): string;

			/** Formats the value of the current instance using the specified format. */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: System.IntPtr): System.IntPtr;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.IntPtr | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.IntPtr | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): System.IntPtr | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.IntPtr | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.IntPtr | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): System.IntPtr | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.IntPtr | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): System.IntPtr | undefined;

			static TryParse(s: string | undefined): System.IntPtr | undefined;
		}
	}

	export namespace System {
		/** The exception that is thrown for invalid casting or explicit conversion. */
		export class InvalidCastException extends System.SystemException {
			/** Initializes a new instance of the {@link System.InvalidCastException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.InvalidCastException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.InvalidCastException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.InvalidCastException} class with a
			 * specified message and error code.
			 */
			constructor(
				message: string | undefined,
				errorCode: number,
			);
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when a method call is invalid for the object's current
		 * state.
		 */
		export class InvalidOperationException extends System.SystemException {
			/** Initializes a new instance of the {@link System.InvalidOperationException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.InvalidOperationException} class with
			 * a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.InvalidOperationException} class with
			 * a specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when a program contains invalid Microsoft intermediate
		 * language (MSIL) or metadata. Generally this indicates a bug in the compiler that
		 * generated the program. This exception is also thrown when internal runtime
		 * implementation limits have been exceeded by the program.
		 */
		export class InvalidProgramException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.InvalidProgramException} class with
			 * default properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.InvalidProgramException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.InvalidProgramException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** The exception that is thrown when time zone information is invalid. */
		export class InvalidTimeZoneException extends System.Exception {
			/**
			 * Initializes a new instance of the {@link System.InvalidTimeZoneException} class with a
			 * system-supplied message.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.InvalidTimeZoneException} class with
			 * the specified message string.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.InvalidTimeZoneException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** [Generic type factory] Defines a provider for push-based notification. */
		export function IObservable$(T: IType): IType;

		/** Defines a provider for push-based notification. */
		export interface IObservable$1<T> {
			/** Notifies the provider that an observer is to receive notifications. */
			Subscribe(observer: System.IObserver$1<T>): IDisposable;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Provides a mechanism for receiving push-based notifications.
		 */
		export function IObserver$(T: IType): IType;

		/** Provides a mechanism for receiving push-based notifications. */
		export interface IObserver$1<T> {
			/**
			 * Notifies the observer that the provider has finished sending push-based notifications.
			 */
			OnCompleted(): void;

			/** Notifies the observer that the provider has experienced an error condition. */
			OnError(error: System.Exception): void;

			/** Provides the observer with new data. */
			OnNext(value: T): void;
		}
	}

	export namespace System {
		/** [Generic type factory] Defines a mechanism for parsing a string to a value. */
		export function IParsable$(TSelf: IType): IType;

		/** Defines a mechanism for parsing a string to a value. */
		export interface IParsable$1<TSelf> {
		}
	}

	export namespace System {
		/** [Generic type factory] Defines a provider for progress updates. */
		export function IProgress$(T: IType): IType;

		/** Defines a provider for progress updates. */
		export interface IProgress$1<T> {
			/** Reports a progress update. */
			Report(value: T): void;
		}
	}

	export namespace System {
		/**
		 * Provides functionality to format the string representation of an object into a span.
		 */
		export interface ISpanFormattable extends System.IFormattable {
			TryFormat(
				destination: System.Span$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.IFormatProvider | undefined;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Defines a mechanism for parsing a span of characters to a
		 * value.
		 */
		export function ISpanParsable$(TSelf: IType): IType;

		/** Defines a mechanism for parsing a span of characters to a value. */
		export interface ISpanParsable$1<TSelf> extends System.IParsable$1<TSelf> {
		}
	}

	export namespace System {
		/**
		 * Provides functionality to format the string representation of an object into a span as
		 * UTF-8.
		 */
		export interface IUtf8SpanFormattable {
			TryFormat(
				utf8Destination: System.Span$1<number>,
				format: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.IFormatProvider | undefined;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Defines a mechanism for parsing a span of UTF-8 characters to a
		 * value.
		 */
		export function IUtf8SpanParsable$(TSelf: IType): IType;

		/** Defines a mechanism for parsing a span of UTF-8 characters to a value. */
		export interface IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System {
		/** [Generic type factory] Provides support for lazy initialization. */
		export function Lazy$(T: IType): typeof Lazy$1<any>;

		/** Provides support for lazy initialization. */
		export class Lazy$1<T> {
			/**
			 * Initializes a new instance of the {@link System.Lazy<>} class. When lazy
			 * initialization occurs, the parameterless constructor of the target type is used.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Lazy<>} class. When lazy
			 * initialization occurs, the parameterless constructor of the target type and the
			 * specified initialization mode are used.
			 */
			constructor(isThreadSafe: boolean);

			/**
			 * Initializes a new instance of the {@link System.Lazy<>} class. When lazy
			 * initialization occurs, the specified initialization function is used.
			 */
			constructor(valueFactory: System.Func$1<T>);

			/**
			 * Initializes a new instance of the {@link System.Lazy<>} class. When lazy
			 * initialization occurs, the specified initialization function and initialization mode
			 * are used.
			 */
			constructor(
				valueFactory: System.Func$1<T>,
				isThreadSafe: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.Lazy<>} class that uses the specified
			 * initialization function and thread-safety mode.
			 */
			constructor(
				valueFactory: System.Func$1<T>,
				mode: System.Threading.LazyThreadSafetyMode,
			);

			/**
			 * Initializes a new instance of the {@link System.Lazy<>} class that uses the
			 * parameterless constructor of `T` and the specified thread-safety mode.
			 */
			constructor(mode: System.Threading.LazyThreadSafetyMode);

			/**
			 * Initializes a new instance of the {@link System.Lazy<>} class that uses a
			 * preinitialized specified value.
			 */
			constructor(value: T);

			/**
			 * Gets a value that indicates whether a value has been created for this
			 * {@link System.Lazy<>} instance.
			 */
			readonly IsValueCreated: boolean;

			/** Gets the lazily initialized value of the current {@link System.Lazy<>} instance. */
			readonly Value: T;

			/**
			 * Creates and returns a string representation of the {@link System.Lazy`1.Value}
			 * property for this instance.
			 */
			ToString(): string | undefined;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Provides a lazy indirect reference to an object and its
		 * associated metadata for use by the Managed Extensibility Framework.
		 */
		export function Lazy$(T: IType, TMetadata: IType): typeof Lazy$2<any, any>;

		/**
		 * Provides a lazy indirect reference to an object and its associated metadata for use by
		 * the Managed Extensibility Framework.
		 */
		export class Lazy$2<T, TMetadata> extends System.Lazy$1<T> {
			/**
			 * Initializes a new instance of the {@link System.Lazy<,>} class with the specified
			 * metadata that uses the specified function to get the referenced object.
			 */
			constructor(
				valueFactory: System.Func$1<T>,
				metadata: TMetadata,
			);

			/**
			 * Initializes a new instance of the {@link System.Lazy<,>} class with the specified
			 * metadata and thread safety value that uses the specified function to get the
			 * referenced object.
			 */
			constructor(
				valueFactory: System.Func$1<T>,
				metadata: TMetadata,
				isThreadSafe: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.Lazy<,>} class with the specified
			 * metadata and thread synchronization mode that uses the specified function to get the
			 * referenced object.
			 */
			constructor(
				valueFactory: System.Func$1<T>,
				metadata: TMetadata,
				mode: System.Threading.LazyThreadSafetyMode,
			);

			/**
			 * Initializes a new instance of the {@link System.Lazy<,>} class with the specified
			 * metadata.
			 */
			constructor(metadata: TMetadata);

			/**
			 * Initializes a new instance of the {@link System.Lazy<,>} class with the specified
			 * metadata and thread safety value.
			 */
			constructor(
				metadata: TMetadata,
				isThreadSafe: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.Lazy<,>} class with the specified
			 * metadata and thread synchronization mode.
			 */
			constructor(
				metadata: TMetadata,
				mode: System.Threading.LazyThreadSafetyMode,
			);

			/** Gets the metadata associated with the referenced object. */
			readonly Metadata: TMetadata;
		}
	}

	export namespace System {
		/**
		 * An enumeration used with the {@link System.LoaderOptimizationAttribute} class to
		 * specify loader optimizations for an executable.
		 */
		export enum LoaderOptimization {
			/**
			 * Indicates that no optimizations for sharing internal resources are specified. If the
			 * default domain or hosting interface specified an optimization, then the loader uses
			 * that; otherwise, the loader uses {@link System.LoaderOptimization.SingleDomain}.
			 */
			NotSpecified = 0,

			/**
			 * Indicates that the application will probably have a single domain, and loader must not
			 * share internal resources across application domains.
			 */
			SingleDomain = 1,

			/**
			 * Indicates that the application will probably have many domains that use the same code,
			 * and the loader must share maximal internal resources across application domains.
			 */
			MultiDomain = 2,

			/**
			 * Do not use. This mask selects the domain-related values, screening out the unused
			 * {@link System.LoaderOptimization.DisallowBindings} flag.
			 */
			DomainMask = 3,

			/**
			 * Indicates that the application will probably host unique code in multiple domains, and
			 * the loader must share resources across application domains only for globally available
			 * (strong-named) assemblies that have been added to the global assembly cache.
			 */
			MultiDomainHost = 3,

			/** Ignored by the common language runtime. */
			DisallowBindings = 4,
		}
	}

	export namespace System {
		/**
		 * Used to set the default loader optimization policy for the main method of an
		 * executable application.
		 */
		export class LoaderOptimizationAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.LoaderOptimizationAttribute} class to
			 * the specified value.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link System.LoaderOptimizationAttribute} class to
			 * the specified value.
			 */
			constructor(value: System.LoaderOptimization);

			/** Gets the current {@link System.LoaderOptimization} value for this instance. */
			readonly Value: System.LoaderOptimization;
		}
	}

	export namespace System {
		/**
		 * Enables access to objects across application domain boundaries in applications that
		 * support remoting.
		 */
		export class MarshalByRefObject {
			/**
			 * Retrieves the current lifetime service object that controls the lifetime policy for
			 * this instance.
			 */
			GetLifetimeService(): System.Object;

			/**
			 * Obtains a lifetime service object to control the lifetime policy for this instance.
			 */
			InitializeLifetimeService(): System.Object;
		}
	}

	export namespace System {
		/**
		 * Provides constants and static methods for trigonometric, logarithmic, and other common
		 * mathematical functions.
		 */
		export namespace Math {
			/** Returns the absolute value of a {@link System.Decimal} number. */
			export function Abs(value: System.Decimal): System.Decimal;

			/** Returns the absolute value of a double-precision floating-point number. */
			export function Abs(value: number): number;

			/** Returns the absolute value of a 16-bit signed integer. */
			export function Abs(value: number): number;

			/** Returns the absolute value of a 32-bit signed integer. */
			export function Abs(value: number): number;

			/** Returns the absolute value of a 64-bit signed integer. */
			export function Abs(value: number): number;

			/** Returns the absolute value of a native signed integer. */
			export function Abs(value: System.IntPtr): System.IntPtr;

			/** Returns the absolute value of an 8-bit signed integer. */
			export function Abs(value: number): number;

			/** Returns the absolute value of a single-precision floating-point number. */
			export function Abs(value: number): number;

			/** Returns the angle whose cosine is the specified number. */
			export function Acos(d: number): number;

			/** Returns the angle whose hyperbolic cosine is the specified number. */
			export function Acosh(d: number): number;

			/** Returns the angle whose sine is the specified number. */
			export function Asin(d: number): number;

			/** Returns the angle whose hyperbolic sine is the specified number. */
			export function Asinh(d: number): number;

			/** Returns the angle whose tangent is the specified number. */
			export function Atan(d: number): number;

			/** Returns the angle whose tangent is the quotient of two specified numbers. */
			export function Atan2(
				y: number,
				x: number,
			): number;

			/** Returns the angle whose hyperbolic tangent is the specified number. */
			export function Atanh(d: number): number;

			/** Produces the full product of two 32-bit numbers. */
			export function BigMul(
				a: number,
				b: number,
			): number;

			export function BigMul(
				a: number,
				b: number,
			): { result: number, low: number };

			export function BigMul(
				a: number,
				b: number,
			): { result: number, low: number };

			/** Returns the largest value that compares less than a specified value. */
			export function BitDecrement(x: number): number;

			/** Returns the smallest value that compares greater than a specified value. */
			export function BitIncrement(x: number): number;

			/** Returns the cube root of a specified number. */
			export function Cbrt(d: number): number;

			/**
			 * Returns the smallest integral value that is greater than or equal to the specified
			 * decimal number.
			 */
			export function Ceiling(d: System.Decimal): System.Decimal;

			/**
			 * Returns the smallest integral value that is greater than or equal to the specified
			 * double-precision floating-point number.
			 */
			export function Ceiling(a: number): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: System.Decimal,
				min: System.Decimal,
				max: System.Decimal,
			): System.Decimal;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: System.IntPtr,
				min: System.IntPtr,
				max: System.IntPtr,
			): System.IntPtr;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/** Returns `value` clamped to the inclusive range of `min` and `max`. */
			export function Clamp(
				value: System.UIntPtr,
				min: System.UIntPtr,
				max: System.UIntPtr,
			): System.UIntPtr;

			/** Returns a value with the magnitude of `x` and the sign of `y`. */
			export function CopySign(
				x: number,
				y: number,
			): number;

			/** Returns the cosine of the specified angle. */
			export function Cos(d: number): number;

			/** Returns the hyperbolic cosine of the specified angle. */
			export function Cosh(value: number): number;

			export function DivRem(
				a: number,
				b: number,
			): { _result: number, result: number };

			export function DivRem(
				a: number,
				b: number,
			): { _result: number, result: number };

			/** Produces the quotient and the remainder of two unsigned 8-bit numbers. */
			export function DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Produces the quotient and the remainder of two signed 16-bit numbers. */
			export function DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Produces the quotient and the remainder of two signed 32-bit numbers. */
			export function DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Produces the quotient and the remainder of two signed 64-bit numbers. */
			export function DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Produces the quotient and the remainder of two signed native-size numbers. */
			export function DivRem(
				left: System.IntPtr,
				right: System.IntPtr,
			): [System.IntPtr, System.IntPtr];

			/** Produces the quotient and the remainder of two signed 8-bit numbers. */
			export function DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Produces the quotient and the remainder of two unsigned 16-bit numbers. */
			export function DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Produces the quotient and the remainder of two unsigned 32-bit numbers. */
			export function DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Produces the quotient and the remainder of two unsigned 64-bit numbers. */
			export function DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Produces the quotient and the remainder of two unsigned native-size numbers. */
			export function DivRem(
				left: System.UIntPtr,
				right: System.UIntPtr,
			): [System.UIntPtr, System.UIntPtr];

			/** Returns `e` raised to the specified power. */
			export function Exp(d: number): number;

			/**
			 * Returns the largest integral value less than or equal to the specified decimal number.
			 */
			export function Floor(d: System.Decimal): System.Decimal;

			/**
			 * Returns the largest integral value less than or equal to the specified
			 * double-precision floating-point number.
			 */
			export function Floor(d: number): number;

			/** Returns (x * y) + z, rounded as one ternary operation. */
			export function FusedMultiplyAdd(
				x: number,
				y: number,
				z: number,
			): number;

			/**
			 * Returns the remainder resulting from the division of a specified number by another
			 * specified number.
			 */
			export function IEEERemainder(
				x: number,
				y: number,
			): number;

			/** Returns the base 2 integer logarithm of a specified number. */
			export function ILogB(x: number): number;

			/** Returns the natural (base `e` ) logarithm of a specified number. */
			export function Log(d: number): number;

			/** Returns the logarithm of a specified number in a specified base. */
			export function Log(
				a: number,
				newBase: number,
			): number;

			/** Returns the base 10 logarithm of a specified number. */
			export function Log10(d: number): number;

			/** Returns the base 2 logarithm of a specified number. */
			export function Log2(x: number): number;

			/** Returns the larger of two 8-bit unsigned integers. */
			export function Max(
				val1: number,
				val2: number,
			): number;

			/** Returns the larger of two decimal numbers. */
			export function Max(
				val1: System.Decimal,
				val2: System.Decimal,
			): System.Decimal;

			/** Returns the larger of two double-precision floating-point numbers. */
			export function Max(
				val1: number,
				val2: number,
			): number;

			/** Returns the larger of two 16-bit signed integers. */
			export function Max(
				val1: number,
				val2: number,
			): number;

			/** Returns the larger of two 32-bit signed integers. */
			export function Max(
				val1: number,
				val2: number,
			): number;

			/** Returns the larger of two 64-bit signed integers. */
			export function Max(
				val1: number,
				val2: number,
			): number;

			/** Returns the larger of two native signed integers. */
			export function Max(
				val1: System.IntPtr,
				val2: System.IntPtr,
			): System.IntPtr;

			/** Returns the larger of two 8-bit signed integers. */
			export function Max(
				val1: number,
				val2: number,
			): number;

			/** Returns the larger of two single-precision floating-point numbers. */
			export function Max(
				val1: number,
				val2: number,
			): number;

			/** Returns the larger of two 16-bit unsigned integers. */
			export function Max(
				val1: number,
				val2: number,
			): number;

			/** Returns the larger of two 32-bit unsigned integers. */
			export function Max(
				val1: number,
				val2: number,
			): number;

			/** Returns the larger of two 64-bit unsigned integers. */
			export function Max(
				val1: number,
				val2: number,
			): number;

			/** Returns the larger of two native unsigned integers. */
			export function Max(
				val1: System.UIntPtr,
				val2: System.UIntPtr,
			): System.UIntPtr;

			/** Returns the larger magnitude of two double-precision floating-point numbers. */
			export function MaxMagnitude(
				x: number,
				y: number,
			): number;

			/** Returns the smaller of two 8-bit unsigned integers. */
			export function Min(
				val1: number,
				val2: number,
			): number;

			/** Returns the smaller of two decimal numbers. */
			export function Min(
				val1: System.Decimal,
				val2: System.Decimal,
			): System.Decimal;

			/** Returns the smaller of two double-precision floating-point numbers. */
			export function Min(
				val1: number,
				val2: number,
			): number;

			/** Returns the smaller of two 16-bit signed integers. */
			export function Min(
				val1: number,
				val2: number,
			): number;

			/** Returns the smaller of two 32-bit signed integers. */
			export function Min(
				val1: number,
				val2: number,
			): number;

			/** Returns the smaller of two 64-bit signed integers. */
			export function Min(
				val1: number,
				val2: number,
			): number;

			/** Returns the smaller of two native signed integers. */
			export function Min(
				val1: System.IntPtr,
				val2: System.IntPtr,
			): System.IntPtr;

			/** Returns the smaller of two 8-bit signed integers. */
			export function Min(
				val1: number,
				val2: number,
			): number;

			/** Returns the smaller of two single-precision floating-point numbers. */
			export function Min(
				val1: number,
				val2: number,
			): number;

			/** Returns the smaller of two 16-bit unsigned integers. */
			export function Min(
				val1: number,
				val2: number,
			): number;

			/** Returns the smaller of two 32-bit unsigned integers. */
			export function Min(
				val1: number,
				val2: number,
			): number;

			/** Returns the smaller of two 64-bit unsigned integers. */
			export function Min(
				val1: number,
				val2: number,
			): number;

			/** Returns the smaller of two native unsigned integers. */
			export function Min(
				val1: System.UIntPtr,
				val2: System.UIntPtr,
			): System.UIntPtr;

			/** Returns the smaller magnitude of two double-precision floating-point numbers. */
			export function MinMagnitude(
				x: number,
				y: number,
			): number;

			/** Returns a specified number raised to the specified power. */
			export function Pow(
				x: number,
				y: number,
			): number;

			/** Returns an estimate of the reciprocal of a specified number. */
			export function ReciprocalEstimate(d: number): number;

			/** Returns an estimate of the reciprocal square root of a specified number. */
			export function ReciprocalSqrtEstimate(d: number): number;

			/**
			 * Rounds a decimal value to the nearest integral value, and rounds midpoint values to
			 * the nearest even number.
			 */
			export function Round(d: System.Decimal): System.Decimal;

			/**
			 * Rounds a decimal value to a specified number of fractional digits, and rounds midpoint
			 * values to the nearest even number.
			 */
			export function Round(
				d: System.Decimal,
				decimals: number,
			): System.Decimal;

			/**
			 * Rounds a decimal value to a specified number of fractional digits using the specified
			 * rounding convention.
			 */
			export function Round(
				d: System.Decimal,
				decimals: number,
				mode: System.MidpointRounding,
			): System.Decimal;

			/** Rounds a decimal value an integer using the specified rounding convention. */
			export function Round(
				d: System.Decimal,
				mode: System.MidpointRounding,
			): System.Decimal;

			/**
			 * Rounds a double-precision floating-point value to the nearest integral value, and
			 * rounds midpoint values to the nearest even number.
			 */
			export function Round(a: number): number;

			/**
			 * Rounds a double-precision floating-point value to a specified number of fractional
			 * digits, and rounds midpoint values to the nearest even number.
			 */
			export function Round(
				value: number,
				digits: number,
			): number;

			/**
			 * Rounds a double-precision floating-point value to a specified number of fractional
			 * digits using the specified rounding convention.
			 */
			export function Round(
				value: number,
				digits: number,
				mode: System.MidpointRounding,
			): number;

			/**
			 * Rounds a double-precision floating-point value to an integer using the specified
			 * rounding convention.
			 */
			export function Round(
				value: number,
				mode: System.MidpointRounding,
			): number;

			/** Returns x * 2^n computed efficiently. */
			export function ScaleB(
				x: number,
				n: number,
			): number;

			/** Returns an integer that indicates the sign of a decimal number. */
			export function Sign(value: System.Decimal): number;

			/**
			 * Returns an integer that indicates the sign of a double-precision floating-point
			 * number.
			 */
			export function Sign(value: number): number;

			/** Returns an integer that indicates the sign of a 16-bit signed integer. */
			export function Sign(value: number): number;

			/** Returns an integer that indicates the sign of a 32-bit signed integer. */
			export function Sign(value: number): number;

			/** Returns an integer that indicates the sign of a 64-bit signed integer. */
			export function Sign(value: number): number;

			/** Returns an integer that indicates the sign of a native sized signed integer. */
			export function Sign(value: System.IntPtr): number;

			/** Returns an integer that indicates the sign of an 8-bit signed integer. */
			export function Sign(value: number): number;

			/**
			 * Returns an integer that indicates the sign of a single-precision floating-point
			 * number.
			 */
			export function Sign(value: number): number;

			/** Returns the sine of the specified angle. */
			export function Sin(a: number): number;

			/** Returns the sine and cosine of the specified angle. */
			export function SinCos(x: number): [number, number];

			/** Returns the hyperbolic sine of the specified angle. */
			export function Sinh(value: number): number;

			/** Returns the square root of a specified number. */
			export function Sqrt(d: number): number;

			/** Returns the tangent of the specified angle. */
			export function Tan(a: number): number;

			/** Returns the hyperbolic tangent of the specified angle. */
			export function Tanh(value: number): number;

			/** Calculates the integral part of a specified decimal number. */
			export function Truncate(d: System.Decimal): System.Decimal;

			/**
			 * Calculates the integral part of a specified double-precision floating-point number.
			 */
			export function Truncate(d: number): number;
		}
	}

	export namespace System {
		/**
		 * Provides constants and static methods for trigonometric, logarithmic, and other common
		 * mathematical functions.
		 */
		export namespace MathF {
			/** Returns the absolute value of a single-precision floating-point number. */
			export function Abs(x: number): number;

			/** Returns the angle whose cosine is the specified number. */
			export function Acos(x: number): number;

			/** Returns the angle whose hyperbolic cosine is the specified number. */
			export function Acosh(x: number): number;

			/** Returns the angle whose sine is the specified number. */
			export function Asin(x: number): number;

			/** Returns the angle whose hyperbolic sine is the specified number. */
			export function Asinh(x: number): number;

			/** Returns the angle whose tangent is the specified number. */
			export function Atan(x: number): number;

			/** Returns the angle whose tangent is the quotient of two specified numbers. */
			export function Atan2(
				y: number,
				x: number,
			): number;

			/** Returns the angle whose hyperbolic tangent is the specified number. */
			export function Atanh(x: number): number;

			/** Returns the largest value that compares less than a specified value. */
			export function BitDecrement(x: number): number;

			/** Returns the smallest value that compares greater than a specified value. */
			export function BitIncrement(x: number): number;

			/** Returns the cube root of a specified number. */
			export function Cbrt(x: number): number;

			/**
			 * Returns the smallest integral value that is greater than or equal to the specified
			 * single-precision floating-point number.
			 */
			export function Ceiling(x: number): number;

			/** Returns a value with the magnitude of `x` and the sign of `y`. */
			export function CopySign(
				x: number,
				y: number,
			): number;

			/** Returns the cosine of the specified angle. */
			export function Cos(x: number): number;

			/** Returns the hyperbolic cosine of the specified angle. */
			export function Cosh(x: number): number;

			/** Returns `e` raised to the specified power. */
			export function Exp(x: number): number;

			/**
			 * Returns the largest integral value less than or equal to the specified
			 * single-precision floating-point number.
			 */
			export function Floor(x: number): number;

			/** Returns (x * y) + z, rounded as one ternary operation. */
			export function FusedMultiplyAdd(
				x: number,
				y: number,
				z: number,
			): number;

			/**
			 * Returns the remainder resulting from the division of a specified number by another
			 * specified number.
			 */
			export function IEEERemainder(
				x: number,
				y: number,
			): number;

			/** Returns the base 2 integer logarithm of a specified number. */
			export function ILogB(x: number): number;

			/** Returns the natural (base `e` ) logarithm of a specified number. */
			export function Log(x: number): number;

			/** Returns the logarithm of a specified number in a specified base. */
			export function Log(
				x: number,
				y: number,
			): number;

			/** Returns the base 10 logarithm of a specified number. */
			export function Log10(x: number): number;

			/** Returns the base 2 logarithm of a specified number. */
			export function Log2(x: number): number;

			/** Returns the larger of two single-precision floating-point numbers. */
			export function Max(
				x: number,
				y: number,
			): number;

			/** Returns the larger magnitude of two single-precision floating-point numbers. */
			export function MaxMagnitude(
				x: number,
				y: number,
			): number;

			/** Returns the smaller of two single-precision floating-point numbers. */
			export function Min(
				x: number,
				y: number,
			): number;

			/** Returns the smaller magnitude of two single-precision floating-point numbers. */
			export function MinMagnitude(
				x: number,
				y: number,
			): number;

			/** Returns a specified number raised to the specified power. */
			export function Pow(
				x: number,
				y: number,
			): number;

			/** Returns an estimate of the reciprocal of a specified number. */
			export function ReciprocalEstimate(x: number): number;

			/** Returns an estimate of the reciprocal square root of a specified number. */
			export function ReciprocalSqrtEstimate(x: number): number;

			/**
			 * Rounds a single-precision floating-point value to the nearest integral value, and
			 * rounds midpoint values to the nearest even number.
			 */
			export function Round(x: number): number;

			/**
			 * Rounds a single-precision floating-point value to a specified number of fractional
			 * digits, and rounds midpoint values to the nearest even number.
			 */
			export function Round(
				x: number,
				digits: number,
			): number;

			/**
			 * Rounds a single-precision floating-point value to a specified number of fractional
			 * digits using the specified rounding convention.
			 */
			export function Round(
				x: number,
				digits: number,
				mode: System.MidpointRounding,
			): number;

			/**
			 * Rounds a single-precision floating-point value to an integer using the specified
			 * rounding convention.
			 */
			export function Round(
				x: number,
				mode: System.MidpointRounding,
			): number;

			/** Returns x * 2^n computed efficiently. */
			export function ScaleB(
				x: number,
				n: number,
			): number;

			/**
			 * Returns an integer that indicates the sign of a single-precision floating-point
			 * number.
			 */
			export function Sign(x: number): number;

			/** Returns the sine of the specified angle. */
			export function Sin(x: number): number;

			/** Returns the sine and cosine of the specified angle. */
			export function SinCos(x: number): [number, number];

			/** Returns the hyperbolic sine of the specified angle. */
			export function Sinh(x: number): number;

			/** Returns the square root of a specified number. */
			export function Sqrt(x: number): number;

			/** Returns the tangent of the specified angle. */
			export function Tan(x: number): number;

			/** Returns the hyperbolic tangent of the specified angle. */
			export function Tanh(x: number): number;

			/**
			 * Calculates the integral part of a specified single-precision floating-point number.
			 */
			export function Truncate(x: number): number;
		}
	}

	export namespace System {
		/** The exception that is thrown when an attempt to access a class member fails. */
		export class MemberAccessException extends System.SystemException {
			/** Initializes a new instance of the {@link System.MemberAccessException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.MemberAccessException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.MemberAccessException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a contiguous region of memory. */
		export function Memory$(T: IType): typeof Memory$1<any>;

		/** Represents a contiguous region of memory. */
		export class Memory$1<T> extends System.ValueType implements System.IEquatable$1<unknown> {
			constructor(array: T[] | undefined);

			constructor(
				array: T[] | undefined,
				start: number,
				length: number,
			);

			/** Returns an empty {@link System.Memory<>} object. */
			static readonly Empty: unknown;

			/** Indicates whether the current instance is empty. */
			readonly IsEmpty: boolean;

			/** Gets the number of items in the current instance. */
			readonly Length: number;

			/** Returns a span from the current instance. */
			readonly Span: System.Span$1<T>;

			/**
			 * Copies the contents of a {@link System.Memory<>} object into a destination
			 * {@link System.Memory<>} object.
			 */
			CopyTo(destination: unknown): void;

			/**
			 * Determines whether the specified {@link System.Memory<>} object is equal to the
			 * current object.
			 */
			Equals(other: unknown): boolean;

			/** Determines whether the specified object is equal to the current object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Creates a handle for the {@link System.Memory<>} object. */
			Pin(): System.Buffers.MemoryHandle;

			/** Forms a slice out of the current memory that begins at a specified index. */
			Slice(start: number): unknown;

			/**
			 * Forms a slice out of the current memory starting at a specified index for a specified
			 * length.
			 */
			Slice(
				start: number,
				length: number,
			): unknown;

			/** Copies the contents from the memory into a new array. */
			ToArray(): T[];

			/** Returns the string representation of this {@link System.Memory<>} object. */
			ToString(): string;

			/**
			 * Copies the contents of the memory into a destination {@link System.Memory<>} instance.
			 */
			TryCopyTo(destination: unknown): boolean;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is an invalid attempt to access a method, such
		 * as accessing a private method from partially trusted code.
		 */
		export class MethodAccessException extends System.MemberAccessException {
			/**
			 * Initializes a new instance of the {@link System.MethodAccessException} class, setting
			 * the {@link System.Exception.Message} property of the new instance to a system-supplied
			 * message that describes the error, such as "Attempt to access the method failed." This
			 * message takes into account the current system culture.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.MethodAccessException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.MethodAccessException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * Specifies the strategy that mathematical rounding methods should use to round a
		 * number.
		 */
		export enum MidpointRounding {
			/**
			 * The strategy of rounding to the nearest number, and when a number is halfway between
			 * two others, it's rounded toward the nearest even number.
			 */
			ToEven = 0,

			/**
			 * The strategy of rounding to the nearest number, and when a number is halfway between
			 * two others, it's rounded toward the nearest number that's away from zero.
			 */
			AwayFromZero = 1,

			/**
			 * The strategy of directed rounding toward zero, with the result closest to and no
			 * greater in magnitude than the infinitely precise result.
			 */
			ToZero = 2,

			/**
			 * The strategy of downwards-directed rounding, with the result closest to and no greater
			 * than the infinitely precise result.
			 */
			ToNegativeInfinity = 3,

			/**
			 * The strategy of upwards-directed rounding, with the result closest to and no less than
			 * the infinitely precise result.
			 */
			ToPositiveInfinity = 4,
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is an attempt to dynamically access a field
		 * that does not exist. If a field in a class library has been removed or renamed,
		 * recompile any assemblies that reference that library.
		 */
		export class MissingFieldException extends System.MissingMemberException {
			/** Initializes a new instance of the {@link System.MissingFieldException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.MissingFieldException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.MissingFieldException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.MissingFieldException} class with the
			 * specified class name and field name.
			 */
			constructor(
				className: string | undefined,
				fieldName: string | undefined,
			);

			/**
			 * Gets the text string showing the signature of the missing field, the class name, and
			 * the field name. This property is read-only.
			 */
			readonly Message: string;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is an attempt to dynamically access a class
		 * member that does not exist or that is not declared as public. If a member in a class
		 * library has been removed or renamed, recompile any assemblies that reference that
		 * library.
		 */
		export class MissingMemberException extends System.MemberAccessException {
			/** Initializes a new instance of the {@link System.MissingMemberException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.MissingMemberException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.MissingMemberException} class with a
			 * specified error message and a reference to the inner exception that is the root cause
			 * of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.MissingMemberException} class with the
			 * specified class name and member name.
			 */
			constructor(
				className: string | undefined,
				memberName: string | undefined,
			);

			/**
			 * Gets the text string showing the class name, the member name, and the signature of the
			 * missing member.
			 */
			readonly Message: string;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is an attempt to dynamically access a method
		 * that does not exist.
		 */
		export class MissingMethodException extends System.MissingMemberException {
			/** Initializes a new instance of the {@link System.MissingMethodException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.MissingMethodException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.MissingMethodException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.MissingMethodException} class with the
			 * specified class name and method name.
			 */
			constructor(
				className: string | undefined,
				methodName: string | undefined,
			);

			/**
			 * Gets the text string showing the class name, the method name, and the signature of the
			 * missing method. This property is read-only.
			 */
			readonly Message: string;
		}
	}

	export namespace System {
		/** Represents a runtime handle for a module. */
		export class ModuleHandle extends System.ValueType implements System.IEquatable$1<System.ModuleHandle> {
			/** Gets the metadata stream version. */
			readonly MDStreamVersion: number;

			/**
			 * Returns a {@link System.Boolean} value indicating whether the specified
			 * {@link System.ModuleHandle} structure is equal to the current
			 * {@link System.ModuleHandle}.
			 */
			Equals(handle: System.ModuleHandle): boolean;

			/**
			 * Returns a {@link System.Boolean} value indicating whether the specified object is a
			 * {@link System.ModuleHandle} structure, and equal to the current
			 * {@link System.ModuleHandle}.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns a runtime handle for the field identified by the specified metadata token. */
			GetRuntimeFieldHandleFromMetadataToken(fieldToken: number): System.RuntimeFieldHandle;

			/**
			 * Returns a runtime method handle for the method or constructor identified by the
			 * specified metadata token.
			 */
			GetRuntimeMethodHandleFromMetadataToken(methodToken: number): System.RuntimeMethodHandle;

			/**
			 * Returns a runtime type handle for the type identified by the specified metadata token.
			 */
			GetRuntimeTypeHandleFromMetadataToken(typeToken: number): System.RuntimeTypeHandle;

			/** Returns a runtime handle for the field identified by the specified metadata token. */
			ResolveFieldHandle(fieldToken: number): System.RuntimeFieldHandle;

			/**
			 * Returns a runtime field handle for the field identified by the specified metadata
			 * token, specifying the generic type arguments of the type and method where the token is
			 * in scope.
			 */
			ResolveFieldHandle(
				fieldToken: number,
				typeInstantiationContext: System.RuntimeTypeHandle[] | undefined,
				methodInstantiationContext: System.RuntimeTypeHandle[] | undefined,
			): System.RuntimeFieldHandle;

			/**
			 * Returns a runtime method handle for the method or constructor identified by the
			 * specified metadata token.
			 */
			ResolveMethodHandle(methodToken: number): System.RuntimeMethodHandle;

			/**
			 * Returns a runtime method handle for the method or constructor identified by the
			 * specified metadata token, specifying the generic type arguments of the type and method
			 * where the token is in scope.
			 */
			ResolveMethodHandle(
				methodToken: number,
				typeInstantiationContext: System.RuntimeTypeHandle[] | undefined,
				methodInstantiationContext: System.RuntimeTypeHandle[] | undefined,
			): System.RuntimeMethodHandle;

			/**
			 * Returns a runtime type handle for the type identified by the specified metadata token.
			 */
			ResolveTypeHandle(typeToken: number): System.RuntimeTypeHandle;

			/**
			 * Returns a runtime type handle for the type identified by the specified metadata token,
			 * specifying the generic type arguments of the type and method where the token is in
			 * scope.
			 */
			ResolveTypeHandle(
				typeToken: number,
				typeInstantiationContext: System.RuntimeTypeHandle[] | undefined,
				methodInstantiationContext: System.RuntimeTypeHandle[] | undefined,
			): System.RuntimeTypeHandle;
		}
	}

	export namespace System {
		/**
		 * Indicates that the COM threading model for an application is multithreaded apartment
		 * (MTA).
		 */
		export class MTAThreadAttribute extends System.Attribute {
			/** Initializes a new instance of the {@link System.MTAThreadAttribute} class. */
			constructor();
		}
	}

	export namespace System {
		/**
		 * Represents a multicast delegate; that is, a delegate that can have more than one
		 * element in its invocation list.
		 */
		export class MulticastDelegate extends System.Delegate implements System.ICloneable {
			/** Determines whether this multicast delegate and the specified object are equal. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the invocation list of this multicast delegate, in invocation order. */
			GetInvocationList(): System.Delegate[];
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is an attempt to combine two delegates based
		 * on the {@link System.Delegate} type instead of the {@link System.MulticastDelegate}
		 * type. This class cannot be inherited.
		 */
		export class MulticastNotSupportedException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.MulticastNotSupportedException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.MulticastNotSupportedException} class
			 * with a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.MulticastNotSupportedException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * Indicates that a field of a serializable class should not be serialized. This class
		 * cannot be inherited.
		 */
		export class NonSerializedAttribute extends System.Attribute {
			/** Initializes a new instance of the {@link System.NonSerializedAttribute} class. */
			constructor();
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when a floating-point value is positive infinity,
		 * negative infinity, or Not-a-Number (NaN).
		 */
		export class NotFiniteNumberException extends System.ArithmeticException {
			/** Initializes a new instance of the {@link System.NotFiniteNumberException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.NotFiniteNumberException} class with
			 * the invalid number.
			 */
			constructor(offendingNumber: number);

			/**
			 * Initializes a new instance of the {@link System.NotFiniteNumberException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.NotFiniteNumberException} class with a
			 * specified error message and the invalid number.
			 */
			constructor(
				message: string | undefined,
				offendingNumber: number,
			);

			/**
			 * Initializes a new instance of the {@link System.NotFiniteNumberException} class with a
			 * specified error message, the invalid number, and a reference to the inner exception
			 * that is root cause of this exception.
			 */
			constructor(
				message: string | undefined,
				offendingNumber: number,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.NotFiniteNumberException} class with a
			 * specified error message and a reference to the inner exception that is root cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Gets the invalid number that is a positive infinity, a negative infinity, or
			 * Not-a-Number (NaN).
			 */
			readonly OffendingNumber: number;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when a requested method or operation is not implemented.
		 */
		export class NotImplementedException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.NotImplementedException} class with
			 * default properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.NotImplementedException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.NotImplementedException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an invoked method is not supported, or when there is
		 * an attempt to read, seek, or write to a stream that does not support the invoked
		 * functionality.
		 */
		export class NotSupportedException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.NotSupportedException} class, setting
			 * the {@link System.Exception.Message} property of the new instance to a system-supplied
			 * message that describes the error. This message takes into account the current system
			 * culture.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.NotSupportedException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.NotSupportedException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Supports a value type that can be assigned `null`. This class cannot be inherited. */
		export namespace Nullable {
			/** Compares the relative values of two {@link System.Nullable<>} objects. */
			export function Compare<T>(
				n1: T | undefined,
				n2: T | undefined,
			): number;

			/** Indicates whether two specified {@link System.Nullable<>} objects are equal. */
			export function Equals<T>(
				n1: T | undefined,
				n2: T | undefined,
			): boolean;

			/** Returns the underlying type argument of the specified nullable type. */
			export function GetUnderlyingType(nullableType: System.Type): System.Type | undefined;

			export function GetValueRefOrDefaultRef<T>(nullable: T | undefined): T;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a value type that can be assigned `null`. */
		export function Nullable$(T: IType): typeof Nullable$1<any>;

		/** Represents a value type that can be assigned `null`. */
		export class Nullable$1<T> extends System.ValueType {
			/**
			 * Initializes a new instance of the {@link System.Nullable<>} structure to the specified
			 * value.
			 */
			constructor(value: T);

			/**
			 * Gets a value indicating whether the current {@link System.Nullable<>} object has a
			 * valid value of its underlying type.
			 */
			readonly HasValue: boolean;

			/**
			 * Gets the value of the current {@link System.Nullable<>} object if it has been assigned
			 * a valid underlying value.
			 */
			readonly Value: T;

			/**
			 * Indicates whether the current {@link System.Nullable<>} object is equal to a specified
			 * object.
			 */
			Equals(other: System.Object | undefined): boolean;

			/**
			 * Retrieves the hash code of the object returned by the {@link System.Nullable`1.Value}
			 * property.
			 */
			GetHashCode(): number;

			/**
			 * Retrieves the value of the current {@link System.Nullable<>} object, or the default
			 * value of the underlying type.
			 */
			GetValueOrDefault(): T;

			/**
			 * Retrieves the value of the current {@link System.Nullable<>} object, or the specified
			 * default value.
			 */
			GetValueOrDefault(defaultValue: T): T;

			/**
			 * Returns the text representation of the value of the current {@link System.Nullable<>}
			 * object.
			 */
			ToString(): string | undefined;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is an attempt to dereference a null object
		 * reference.
		 */
		export class NullReferenceException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.NullReferenceException} class, setting
			 * the {@link System.Exception.Message} property of the new instance to a system-supplied
			 * message that describes the error, such as "The value 'null' was found where an
			 * instance of an object was required." This message takes into account the current
			 * system culture.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.NullReferenceException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.NullReferenceException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * Supports all classes in the .NET class hierarchy and provides low-level services to
		 * derived classes. This is the ultimate base class of all .NET classes; it is the root
		 * of the type hierarchy.
		 */
		export class Object {
			/** Determines whether the specified object instances are considered equal. */
			static Equals(
				objA: System.Object | undefined,
				objB: System.Object | undefined,
			): boolean;

			/**
			 * Determines whether the specified {@link System.Object} instances are the same
			 * instance.
			 */
			static ReferenceEquals(
				objA: System.Object | undefined,
				objB: System.Object | undefined,
			): boolean;
		}
	}

	export namespace System {
		/** The exception that is thrown when an operation is performed on a disposed object. */
		export class ObjectDisposedException extends System.InvalidOperationException {
			/**
			 * Initializes a new instance of the {@link System.ObjectDisposedException} class with a
			 * string containing the name of the disposed object.
			 */
			constructor(objectName: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ObjectDisposedException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.ObjectDisposedException} class with
			 * the specified object name and message.
			 */
			constructor(
				objectName: string | undefined,
				message: string | undefined,
			);

			/** Gets the message that describes the error. */
			readonly Message: string;

			/** Gets the name of the disposed object. */
			readonly ObjectName: string;

			/**
			 * Throws an {@link System.ObjectDisposedException} if the specified `condition` is
			 * `true`.
			 */
			static ThrowIf(
				condition: boolean,
				instance: System.Object,
			): void;

			/**
			 * Throws an {@link System.ObjectDisposedException} if the specified `condition` is
			 * `true`.
			 */
			static ThrowIf(
				condition: boolean,
				type: System.Type,
			): void;
		}
	}

	export namespace System {
		/**
		 * Marks the program elements that are no longer in use. This class cannot be inherited.
		 */
		export class ObsoleteAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.ObsoleteAttribute} class with default
			 * properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.ObsoleteAttribute} class with a
			 * specified workaround message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ObsoleteAttribute} class with a
			 * workaround message and a Boolean value indicating whether the obsolete element usage
			 * is considered an error.
			 */
			constructor(
				message: string | undefined,
				error: boolean,
			);

			/** Gets or sets the ID that the compiler will use when reporting a use of the API. */
			DiagnosticId?: string;

			/**
			 * Gets a value that indicates whether the compiler will treat usage of the obsolete
			 * program element as an error.
			 */
			readonly IsError: boolean;

			/** Gets the workaround message. */
			readonly Message?: string;

			/**
			 * Gets or sets the URL for corresponding documentation. The API accepts a format string
			 * instead of an actual URL, creating a generic URL that includes the diagnostic ID.
			 */
			UrlFormat?: string;
		}
	}

	export namespace System {
		/**
		 * Represents information about an operating system, such as the version and platform
		 * identifier. This class cannot be inherited.
		 */
		export class OperatingSystem implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.OperatingSystem} class, using the
			 * specified platform identifier value and version object.
			 */
			constructor(
				platform: System.PlatformID,
				version: System.Version,
			);

			/**
			 * Gets a {@link System.PlatformID} enumeration value that identifies the operating
			 * system platform.
			 */
			readonly Platform: System.PlatformID;

			/**
			 * Gets the service pack version represented by this {@link System.OperatingSystem}
			 * object.
			 */
			readonly ServicePack: string;

			/** Gets a {@link System.Version} object that identifies the operating system. */
			readonly Version: System.Version;

			/**
			 * Gets the concatenated string representation of the platform identifier, version, and
			 * service pack that are currently installed on the operating system.
			 */
			readonly VersionString: string;

			/**
			 * Creates an {@link System.OperatingSystem} object that is identical to this instance.
			 */
			Clone(): System.Object;

			/** Indicates whether the current application is running on Android. */
			static IsAndroid(): boolean;

			/**
			 * Checks if the Android version (returned by the Linux command uname ) is greater than
			 * or equal to the specified version. This method can be used to guard APIs that were
			 * added in the specified version.
			 */
			static IsAndroidVersionAtLeast(
				major: number,
				minor?: number,
				build?: number,
				revision?: number,
			): boolean;

			/** Indicates whether the current application is running as WASM in a browser. */
			static IsBrowser(): boolean;

			/** Indicates whether the current application is running as WASI. */
			static IsWasi(): boolean;

			/** Indicates whether the current application is running on FreeBSD. */
			static IsFreeBSD(): boolean;

			/**
			 * Checks if the FreeBSD version (returned by the Linux command uname ) is greater than
			 * or equal to the specified version. This method can be used to guard APIs that were
			 * added in the specified version.
			 */
			static IsFreeBSDVersionAtLeast(
				major: number,
				minor?: number,
				build?: number,
				revision?: number,
			): boolean;

			/** Indicates whether the current application is running on iOS or MacCatalyst. */
			static IsIOS(): boolean;

			/**
			 * Checks if the iOS/MacCatalyst version (returned by libobjc.get_operatingSystemVersion
			 * ) is greater than or equal to the specified version. This method can be used to guard
			 * APIs that were added in the specified iOS version.
			 */
			static IsIOSVersionAtLeast(
				major: number,
				minor?: number,
				build?: number,
			): boolean;

			/** Indicates whether the current application is running on Linux. */
			static IsLinux(): boolean;

			/** Indicates whether the current application is running on Mac Catalyst. */
			static IsMacCatalyst(): boolean;

			/**
			 * Check for the Mac Catalyst version (iOS version as presented in Apple documentation)
			 * with a  version comparison. Used to guard APIs that were added in the given Mac
			 * Catalyst release.
			 */
			static IsMacCatalystVersionAtLeast(
				major: number,
				minor?: number,
				build?: number,
			): boolean;

			/** Indicates whether the current application is running on macOS. */
			static IsMacOS(): boolean;

			/**
			 * Checks if the macOS version (returned by libobjc.get_operatingSystemVersion ) is
			 * greater than or equal to the specified version. This method can be used to guard APIs
			 * that were added in the specified macOS version.
			 */
			static IsMacOSVersionAtLeast(
				major: number,
				minor?: number,
				build?: number,
			): boolean;

			/** Indicates whether the current application is running on the specified platform. */
			static IsOSPlatform(platform: string): boolean;

			/**
			 * Checks if the operating system version is greater than or equal to the specified
			 * platform version. This method can be used to guard APIs that were added in the
			 * specified OS version.
			 */
			static IsOSPlatformVersionAtLeast(
				platform: string,
				major: number,
				minor?: number,
				build?: number,
				revision?: number,
			): boolean;

			/** Indicates whether the current application is running on tvOS. */
			static IsTvOS(): boolean;

			/**
			 * Checks if the tvOS version (returned by libobjc.get_operatingSystemVersion ) is
			 * greater than or equal to the specified version. This method can be used to guard APIs
			 * that were added in the specified tvOS version.
			 */
			static IsTvOSVersionAtLeast(
				major: number,
				minor?: number,
				build?: number,
			): boolean;

			/** Indicates whether the current application is running on watchOS. */
			static IsWatchOS(): boolean;

			/**
			 * Checks if the watchOS version (returned by libobjc.get_operatingSystemVersion ) is
			 * greater than or equal to the specified version. This method can be used to guard APIs
			 * that were added in the specified watchOS version.
			 */
			static IsWatchOSVersionAtLeast(
				major: number,
				minor?: number,
				build?: number,
			): boolean;

			/** Indicates whether the current application is running on Windows. */
			static IsWindows(): boolean;

			/**
			 * Checks if the Windows version (returned by RtlGetVersion ) is greater than or equal to
			 * the specified version. This method can be used to guard APIs that were added in the
			 * specified Windows version.
			 */
			static IsWindowsVersionAtLeast(
				major: number,
				minor?: number,
				build?: number,
				revision?: number,
			): boolean;

			/**
			 * Converts the value of this {@link System.OperatingSystem} object to its equivalent
			 * string representation.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown in a thread upon cancellation of an operation that the
		 * thread was executing.
		 */
		export class OperationCanceledException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.OperationCanceledException} class with
			 * a system-supplied error message.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.OperationCanceledException} class with
			 * a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.OperationCanceledException} class with
			 * a specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.OperationCanceledException} class with
			 * a specified error message, a reference to the inner exception that is the cause of
			 * this exception, and a cancellation token.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
				token: AbortSignal,
			);

			/**
			 * Initializes a new instance of the {@link System.OperationCanceledException} class with
			 * a specified error message and a cancellation token.
			 */
			constructor(
				message: string | undefined,
				token: AbortSignal,
			);

			/**
			 * Initializes a new instance of the {@link System.OperationCanceledException} class with
			 * a cancellation token.
			 */
			constructor(token: AbortSignal);

			/** Gets a token associated with the operation that was canceled. */
			readonly CancellationToken: AbortSignal;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when there is not enough memory to continue the execution
		 * of a program.
		 */
		export class OutOfMemoryException extends System.SystemException {
			/** Initializes a new instance of the {@link System.OutOfMemoryException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.OutOfMemoryException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.OutOfMemoryException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an arithmetic, casting, or conversion operation in a
		 * checked context results in an overflow.
		 */
		export class OverflowException extends System.ArithmeticException {
			/** Initializes a new instance of the {@link System.OverflowException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.OverflowException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.OverflowException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * Indicates that a method will allow a variable number of arguments in its invocation.
		 * This class cannot be inherited.
		 */
		export class ParamArrayAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.ParamArrayAttribute} class with
			 * default properties.
			 */
			constructor();
		}
	}

	export namespace System {
		/** Identifies the operating system, or platform, supported by an assembly. */
		export enum PlatformID {
			/** The operating system is Win32s. This value is no longer in use. */
			Win32S = 0,

			/** The operating system is Windows 95 or Windows 98. This value is no longer in use. */
			Win32Windows = 1,

			/** The operating system is Windows NT or later. */
			Win32NT = 2,

			/** The operating system is Windows CE. This value is no longer in use. */
			WinCE = 3,

			/** The operating system is Unix. */
			Unix = 4,

			/** The development platform is Xbox 360. This value is no longer in use. */
			Xbox = 5,

			/**
			 * The operating system is Macintosh. This value was returned by Silverlight. On .NET
			 * Core, its replacement is Unix.
			 */
			MacOSX = 6,

			/** Any other operating system. This includes Browser (WASM). */
			Other = 7,
		}
	}

	export namespace System {
		/** The exception that is thrown when a feature does not run on a particular platform. */
		export class PlatformNotSupportedException extends System.NotSupportedException {
			/**
			 * Initializes a new instance of the {@link System.PlatformNotSupportedException} class
			 * with default properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.PlatformNotSupportedException} class
			 * with a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.PlatformNotSupportedException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Represents the method that defines a set of criteria and
		 * determines whether the specified object meets those criteria.
		 */
		export function Predicate$(T: IType): IType;

		/**
		 * Represents the method that defines a set of criteria and determines whether the
		 * specified object meets those criteria.
		 */
		export interface Predicate$1<T> { (obj: T): boolean; }
	}

	export namespace System {
		/**
		 * [Generic type factory] Provides an {@link System.IProgress<>} that invokes callbacks
		 * for each reported progress value.
		 */
		export function Progress$(T: IType): typeof Progress$1<any>;

		/**
		 * Provides an {@link System.IProgress<>} that invokes callbacks for each reported
		 * progress value.
		 */
		export class Progress$1<T> {
			/** Initializes the {@link System.Progress<>} object. */
			constructor();

			/** Initializes the {@link System.Progress<>} object with the specified callback. */
			constructor(handler: System.Action$1<T>);
		}
	}

	export namespace System {
		/**
		 * Represents a pseudo-random number generator, which is an algorithm that produces a
		 * sequence of numbers that meet certain statistical requirements for randomness.
		 */
		export class Random {
			/**
			 * Initializes a new instance of the {@link System.Random} class using a default seed
			 * value.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Random} class, using the specified
			 * seed value.
			 */
			constructor(Seed: number);

			/**
			 * Provides a thread-safe {@link System.Random} instance that may be used concurrently
			 * from any thread.
			 */
			static readonly Shared: System.Random;

			/**
			 * Creates an array populated with items chosen at random from the provided set of
			 * choices.
			 */
			GetItems<T>(
				choices: System.ReadOnlySpan$1<T>,
				length: number,
			): T[];

			/**
			 * Fills the elements of a specified span with items chosen at random from the provided
			 * set of choices.
			 */
			GetItems<T>(
				choices: System.ReadOnlySpan$1<T>,
				destination: System.Span$1<T>,
			): void;

			GetItems<T>(
				choices: T[],
				length: number,
			): T[];

			/** Returns a non-negative random integer. */
			Next(): number;

			/** Returns a non-negative random integer that is less than the specified maximum. */
			Next(maxValue: number): number;

			/** Returns a random integer that is within a specified range. */
			Next(
				minValue: number,
				maxValue: number,
			): number;

			/** Fills the elements of a specified array of bytes with random numbers. */
			NextBytes(buffer: number[]): void;

			/** Fills the elements of a specified span of bytes with random numbers. */
			NextBytes(buffer: System.Span$1<number>): void;

			/**
			 * Returns a random floating-point number that is greater than or equal to 0.0, and less
			 * than 1.0.
			 */
			NextDouble(): number;

			/** Returns a non-negative random integer. */
			NextInt64(): number;

			/** Returns a non-negative random integer that is less than the specified maximum. */
			NextInt64(maxValue: number): number;

			/** Returns a random integer that is within a specified range. */
			NextInt64(
				minValue: number,
				maxValue: number,
			): number;

			/**
			 * Returns a random floating-point number that is greater than or equal to 0.0, and less
			 * than 1.0.
			 */
			NextSingle(): number;

			/** Performs an in-place shuffle of a span. */
			Shuffle<T>(values: System.Span$1<T>): void;

			Shuffle<T>(values: T[]): void;
		}
	}

	export namespace System {
		/** Represents a range that has start and end indexes. */
		export class Range extends System.ValueType implements System.IEquatable$1<System.Range> {
			/**
			 * Instantiates a new {@link System.Range} instance with the specified starting and
			 * ending indexes.
			 */
			constructor(
				start: System.Index,
				end: System.Index,
			);

			/** Gets a {@link System.Range} object that starts from the first element to the end. */
			static readonly All: System.Range;

			/** Gets an {@link System.Index} that represents the exclusive end index of the range. */
			readonly End: System.Index;

			/** Gets the inclusive start index of the {@link System.Range}. */
			readonly Start: System.Index;

			/**
			 * Creates a {@link System.Range} object starting from the first element in the
			 * collection to a specified end index.
			 */
			static EndAt(end: System.Index): System.Range;

			/**
			 * Returns a value that indicates whether the current instance is equal to a specified
			 * object.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether the current instance is equal to another
			 * {@link System.Range} object.
			 */
			Equals(other: System.Range): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Calculates the start offset and length of the range object using a collection length.
			 */
			GetOffsetAndLength(length: number): [number, number];

			/**
			 * Returns a new {@link System.Range} instance starting from a specified start index to
			 * the end of the collection.
			 */
			static StartAt(start: System.Index): System.Range;

			/** Returns the string representation of the current {@link System.Range} object. */
			ToString(): string;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an array with the wrong number of dimensions is
		 * passed to a method.
		 */
		export class RankException extends System.SystemException {
			/** Initializes a new instance of the {@link System.RankException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.RankException} class with a specified
			 * error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.RankException} class with a specified
			 * error message and a reference to the inner exception that is the cause of this
			 * exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Represents a contiguous region of memory, similar to
		 * {@link System.ReadOnlySpan<>}. Unlike {@link System.ReadOnlySpan<>}, it is not a
		 * byref-like type.
		 */
		export function ReadOnlyMemory$(T: IType): typeof ReadOnlyMemory$1<any>;

		/**
		 * Represents a contiguous region of memory, similar to {@link System.ReadOnlySpan<>}.
		 * Unlike {@link System.ReadOnlySpan<>}, it is not a byref-like type.
		 */
		export class ReadOnlyMemory$1<T> extends System.ValueType implements System.IEquatable$1<unknown> {
			constructor(array: T[] | undefined);

			constructor(
				array: T[] | undefined,
				start: number,
				length: number,
			);

			/** Gets an empty {@link System.ReadOnlyMemory<>}. */
			static readonly Empty: unknown;

			/** Gets a value that indicates whether this read-only memory region is empty. */
			readonly IsEmpty: boolean;

			/** Gets the number of items in the memory region. */
			readonly Length: number;

			/** Gets a span from the memory region. */
			readonly Span: System.ReadOnlySpan$1<T>;

			/**
			 * Copies the contents of the read-only memory region into a destination memory region.
			 */
			CopyTo(destination: unknown): void;

			/**
			 * Determines whether the specified object is equal to the current read-only memory
			 * region.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Determines whether the current instance and a specified
			 * {@link System.ReadOnlyMemory<>} objects are equal.
			 */
			Equals(other: unknown): boolean;

			/** Returns the hash code for this {@link System.ReadOnlyMemory<>}. */
			GetHashCode(): number;

			/** Creates a handle for the memory. */
			Pin(): System.Buffers.MemoryHandle;

			/**
			 * Forms a slice out of the given memory region, beginning at a specified position and
			 * continuing to its end.
			 */
			Slice(start: number): unknown;

			/**
			 * Forms a slice out of the given memory region starting at `start` position for `length`
			 * elements.
			 */
			Slice(
				start: number,
				length: number,
			): unknown;

			/** Copies the contents from the memory region into a new array. */
			ToArray(): T[];

			/** Returns the string representation of this read-only memory instance. */
			ToString(): string;

			/**
			 * Tries to copy the contents of the readonly-only memory into the destination and
			 * returns a value that indicates whether the copy operation succeeded.
			 */
			TryCopyTo(destination: unknown): boolean;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Provides a type-safe and memory-safe read-only representation
		 * of a contiguous region of arbitrary memory.
		 */
		export function ReadOnlySpan$(T: IType): typeof ReadOnlySpan$1<any>;

		/**
		 * Provides a type-safe and memory-safe read-only representation of a contiguous region
		 * of arbitrary memory.
		 */
		export class ReadOnlySpan$1<T> extends System.ValueType {
			constructor(array: T[] | undefined);

			constructor(
				array: T[] | undefined,
				start: number,
				length: number,
			);

			constructor(reference: T);

			/** Returns an empty {@link System.ReadOnlySpan<>}. */
			static readonly Empty: System.ReadOnlySpan$1<any>;

			/** Returns a value that indicates the current read-only span is empty. */
			readonly IsEmpty: boolean;

			/** The number of items in the read-only span. */
			readonly Length: number;

			/**
			 * Copies the contents of this {@link System.ReadOnlySpan<>} into a destination
			 * {@link System.Span<>}.
			 */
			CopyTo(destination: System.Span$1<T>): void;

			/** Not supported. Throws a {@link System.NotSupportedException}. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns an enumerator for this {@link System.ReadOnlySpan<>}. */
			GetEnumerator(): System.ReadOnlySpan.Enumerator$1<T>;

			/** Not supported. Throws a {@link System.NotSupportedException}. */
			GetHashCode(): number;

			/**
			 * Returns a read-only reference to an object of type T that can be used for pinning.
			 * This method is intended to support .NET compilers and is not intended to be called by
			 * user code.
			 */
			GetPinnableReference(): T;

			/** Forms a slice out of the current read-only span that begins at a specified index. */
			Slice(start: number): System.ReadOnlySpan$1<T>;

			/**
			 * Forms a slice out of the current read-only span starting at a specified index for a
			 * specified length.
			 */
			Slice(
				start: number,
				length: number,
			): System.ReadOnlySpan$1<T>;

			/** Copies the contents of this read-only span into a new array. */
			ToArray(): T[];

			/** Returns the string representation of this {@link System.ReadOnlySpan<>}. */
			ToString(): string;

			/**
			 * Attempts to copy the contents of this {@link System.ReadOnlySpan<>} into a
			 * {@link System.Span<>} and returns a value to indicate whether or not the operation
			 * succeeded.
			 */
			TryCopyTo(destination: System.Span$1<T>): boolean;
		}
	}

	export namespace System.ReadOnlySpan {
		export function Enumerator$(T: IType): typeof Enumerator$1<any>;

		export class Enumerator$1<T> extends System.ValueType {
			readonly Current: T;

			MoveNext(): boolean;
		}
	}

	export namespace System {
		/**
		 * Provides data for loader resolution events, such as the
		 * {@link System.AppDomain.TypeResolve}, {@link System.AppDomain.ResourceResolve},
		 * {@link System.AppDomain.ReflectionOnlyAssemblyResolve}, and
		 * {@link System.AppDomain.AssemblyResolve} events.
		 */
		export class ResolveEventArgs extends System.EventArgs {
			/**
			 * Initializes a new instance of the {@link System.ResolveEventArgs} class, specifying
			 * the name of the item to resolve.
			 */
			constructor(name: string);

			/**
			 * Initializes a new instance of the {@link System.ResolveEventArgs} class, specifying
			 * the name of the item to resolve and the assembly whose dependency is being resolved.
			 */
			constructor(
				name: string,
				requestingAssembly: System.Reflection.Assembly | undefined,
			);

			/** Gets the name of the item to resolve. */
			readonly Name: string;

			/** Gets the assembly whose dependency is being resolved. */
			readonly RequestingAssembly?: System.Reflection.Assembly;
		}
	}

	export namespace System {
		/**
		 * Represents a method that handles the {@link System.AppDomain.TypeResolve},
		 * {@link System.AppDomain.ResourceResolve}, or {@link System.AppDomain.AssemblyResolve}
		 * event of an {@link System.AppDomain}.
		 */
		export interface ResolveEventHandler { (
			sender: System.Object | undefined,
			args: System.ResolveEventArgs,
		): System.Reflection.Assembly | undefined; }
	}

	export namespace System {
		/** References a variable-length argument list. */
		export class RuntimeArgumentHandle extends System.ValueType {
		}
	}

	export namespace System {
		/** Represents a field using an internal metadata token. */
		export class RuntimeFieldHandle extends System.ValueType implements System.IEquatable$1<System.RuntimeFieldHandle> {
			/** Gets a handle to the field represented by the current instance. */
			readonly Value: System.IntPtr;

			/** Indicates whether the current instance is equal to the specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Indicates whether the current instance is equal to the specified
			 * {@link System.RuntimeFieldHandle}.
			 */
			Equals(handle: System.RuntimeFieldHandle): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Returns a new {@link System.RuntimeFieldHandle} object created from a handle to a
			 * RuntimeFieldInfo.
			 */
			static FromIntPtr(value: System.IntPtr): System.RuntimeFieldHandle;

			/**
			 * Returns the internal pointer representation of a {@link System.RuntimeFieldHandle}
			 * object.
			 */
			static ToIntPtr(value: System.RuntimeFieldHandle): System.IntPtr;
		}
	}

	export namespace System {
		/**
		 * {@link System.RuntimeMethodHandle} is a handle to the internal metadata representation
		 * of a method.
		 */
		export class RuntimeMethodHandle extends System.ValueType implements System.IEquatable$1<System.RuntimeMethodHandle> {
			/** Gets the value of this instance. */
			readonly Value: System.IntPtr;

			/** Indicates whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Indicates whether this instance is equal to a specified
			 * {@link System.RuntimeMethodHandle}.
			 */
			Equals(handle: System.RuntimeMethodHandle): boolean;

			/** Obtains a pointer to the method represented by this instance. */
			GetFunctionPointer(): System.IntPtr;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Returns a new {@link System.RuntimeMethodHandle} object created from a handle to a
			 * RuntimeMethodInfo.
			 */
			static FromIntPtr(value: System.IntPtr): System.RuntimeMethodHandle;

			/**
			 * Returns the internal pointer representation of a {@link System.RuntimeMethodHandle}
			 * object.
			 */
			static ToIntPtr(value: System.RuntimeMethodHandle): System.IntPtr;
		}
	}

	export namespace System {
		/** Represents a type using an internal metadata token. */
		export class RuntimeTypeHandle extends System.ValueType implements System.IEquatable$1<System.RuntimeTypeHandle> {
			/** Gets a handle to the type represented by this instance. */
			readonly Value: System.IntPtr;

			/**
			 * Indicates whether the specified object is equal to the current
			 * {@link System.RuntimeTypeHandle} structure.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Indicates whether the specified {@link System.RuntimeTypeHandle} structure is equal to
			 * the current {@link System.RuntimeTypeHandle} structure.
			 */
			Equals(handle: System.RuntimeTypeHandle): boolean;

			/** Returns the hash code for the current instance. */
			GetHashCode(): number;

			/**
			 * Gets a handle to the module that contains the type represented by the current
			 * instance.
			 */
			GetModuleHandle(): System.ModuleHandle;

			/**
			 * Returns a new {@link System.RuntimeTypeHandle} object created from a handle to a
			 * RuntimeType.
			 */
			static FromIntPtr(value: System.IntPtr): System.RuntimeTypeHandle;

			/**
			 * Returns the internal pointer representation of a {@link System.RuntimeTypeHandle}
			 * object.
			 */
			static ToIntPtr(value: System.RuntimeTypeHandle): System.IntPtr;
		}
	}

	export namespace System {
		/** Represents an 8-bit signed integer. */
		export class SByte extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.Numerics.IAdditionOperators$3<number, number, number>,
			System.Numerics.IAdditiveIdentity$2<number, number>,
			System.Numerics.IBinaryNumber$1<number>,
			System.Numerics.IBitwiseOperators$3<number, number, number>,
			System.Numerics.IComparisonOperators$3<number, number, boolean>,
			System.Numerics.IEqualityOperators$3<number, number, boolean>,
			System.Numerics.IDecrementOperators$1<number>,
			System.Numerics.IDivisionOperators$3<number, number, number>,
			System.Numerics.IIncrementOperators$1<number>,
			System.Numerics.IModulusOperators$3<number, number, number>,
			System.Numerics.IMultiplicativeIdentity$2<number, number>,
			System.Numerics.IMultiplyOperators$3<number, number, number>,
			System.Numerics.INumber$1<number>,
			System.Numerics.INumberBase$1<number>,
			System.Numerics.ISubtractionOperators$3<number, number, number>,
			System.Numerics.IUnaryNegationOperators$2<number, number>,
			System.Numerics.IUnaryPlusOperators$2<number, number>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<number>,
			System.Numerics.IShiftOperators$3<number, number, number>,
			System.Numerics.IMinMaxValue$1<number>,
			System.Numerics.ISignedNumber$1<number> {
			/** Computes the absolute of a value. */
			static Abs(value: number): number;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/**
			 * Compares this instance to a specified object and returns an indication of their
			 * relative values.
			 */
			CompareTo(obj: System.Object | undefined): number;

			/**
			 * Compares this instance to a specified 8-bit signed integer and returns an indication
			 * of their relative values.
			 */
			CompareTo(value: number): number;

			/** Copies the sign of a value to the sign of another value. */
			static CopySign(
				value: number,
				sign: number,
			): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): number;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value indicating whether this instance is equal to a specified
			 * {@link System.SByte} value.
			 */
			Equals(obj: number): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.SByte}. */
			GetTypeCode(): System.TypeCode;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: number): boolean;

			/** Determines if a value is negative. */
			static IsNegative(value: number): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: number): boolean;

			/** Determines if a value is positive. */
			static IsPositive(value: number): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: number): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: number): number;

			/** Computes the log2 of a value. */
			static Log2(value: number): number;

			/** Compares two values to compute which is greater. */
			static Max(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is greater. */
			static MaxMagnitude(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static MinMagnitude(
				x: number,
				y: number,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the span representation of a number that is in a specified style and
			 * culture-specific format to its 8-bit signed equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number to its 8-bit signed integer equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a number in a specified style to its 8-bit
			 * signed integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): number;

			/**
			 * Converts the string representation of a number that is in a specified style and
			 * culture-specific format to its 8-bit signed equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its 8-bit signed integer equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: number): number;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: number,
				rotateAmount: number,
			): number;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: number,
				rotateAmount: number,
			): number;

			/** Computes the sign of a value. */
			static Sign(value: number): number;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: number): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;
		}
	}

	export namespace System {
		/**
		 * Indicates that a class can be serialized using binary or XML serialization. This class
		 * cannot be inherited.
		 */
		export class SerializableAttribute extends System.Attribute {
			/** Initializes a new instance of the {@link System.SerializableAttribute} class. */
			constructor();
		}
	}

	export namespace System {
		/** Represents a single-precision floating-point number. */
		export class Single extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.Numerics.IAdditionOperators$3<number, number, number>,
			System.Numerics.IAdditiveIdentity$2<number, number>,
			System.Numerics.IBinaryNumber$1<number>,
			System.Numerics.IBitwiseOperators$3<number, number, number>,
			System.Numerics.IComparisonOperators$3<number, number, boolean>,
			System.Numerics.IEqualityOperators$3<number, number, boolean>,
			System.Numerics.IDecrementOperators$1<number>,
			System.Numerics.IDivisionOperators$3<number, number, number>,
			System.Numerics.IIncrementOperators$1<number>,
			System.Numerics.IModulusOperators$3<number, number, number>,
			System.Numerics.IMultiplicativeIdentity$2<number, number>,
			System.Numerics.IMultiplyOperators$3<number, number, number>,
			System.Numerics.INumber$1<number>,
			System.Numerics.INumberBase$1<number>,
			System.Numerics.ISubtractionOperators$3<number, number, number>,
			System.Numerics.IUnaryNegationOperators$2<number, number>,
			System.Numerics.IUnaryPlusOperators$2<number, number>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<number>,
			System.Numerics.IExponentialFunctions$1<number>,
			System.Numerics.IFloatingPointConstants$1<number>,
			System.Numerics.ISignedNumber$1<number>,
			System.Numerics.IHyperbolicFunctions$1<number>,
			System.Numerics.ILogarithmicFunctions$1<number>,
			System.Numerics.IPowerFunctions$1<number>,
			System.Numerics.IRootFunctions$1<number>,
			System.Numerics.ITrigonometricFunctions$1<number>,
			System.Numerics.IMinMaxValue$1<number> {
			/** Computes the absolute of a value. */
			static Abs(value: number): number;

			/** Computes the arc-cosine of a value. */
			static Acos(x: number): number;

			/** Computes the hyperbolic arc-cosine of a value. */
			static Acosh(x: number): number;

			/** Computes the arc-cosine of a value and divides the result by pi . */
			static AcosPi(x: number): number;

			/** Computes the arc-sine of a value. */
			static Asin(x: number): number;

			/** Computes the hyperbolic arc-sine of a value. */
			static Asinh(x: number): number;

			/** Computes the arc-sine of a value and divides the result by pi . */
			static AsinPi(x: number): number;

			/** Computes the arc-tangent of a value. */
			static Atan(x: number): number;

			/** Computes the arc-tangent of the quotient of two values. */
			static Atan2(
				y: number,
				x: number,
			): number;

			/**
			 * Computes the arc-tangent for the quotient of two values and divides the result by pi .
			 */
			static Atan2Pi(
				y: number,
				x: number,
			): number;

			/** Computes the hyperbolic arc-tangent of a value. */
			static Atanh(x: number): number;

			/** Computes the arc-tangent of a value and divides the result by pi. */
			static AtanPi(x: number): number;

			/** Decrements a value to the smallest value that compares less than a given value. */
			static BitDecrement(x: number): number;

			/** Increments a value to the smallest value that compares greater than a given value. */
			static BitIncrement(x: number): number;

			/** Computes the cube-root of a value. */
			static Cbrt(x: number): number;

			/** Computes the ceiling of a value. */
			static Ceiling(x: number): number;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/**
			 * Compares this instance to a specified object and returns an integer that indicates
			 * whether the value of this instance is less than, equal to, or greater than the value
			 * of the specified object.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Compares this instance to a specified single-precision floating-point number and
			 * returns an integer that indicates whether the value of this instance is less than,
			 * equal to, or greater than the value of the specified single-precision floating-point
			 * number.
			 */
			CompareTo(value: number): number;

			/** Copies the sign of a value to the sign of another value. */
			static CopySign(
				value: number,
				sign: number,
			): number;

			/** Computes the cosine of a value. */
			static Cos(x: number): number;

			/** Computes the hyperbolic cosine of a value. */
			static Cosh(x: number): number;

			/** Computes the cosine of a value that has been multipled by pi . */
			static CosPi(x: number): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): number;

			/** Converts a given value from degrees to radians. */
			static DegreesToRadians(degrees: number): number;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value indicating whether this instance and a specified {@link System.Single}
			 * object represent the same value.
			 */
			Equals(obj: number): boolean;

			/** Computes E raised to a given power. */
			static Exp(x: number): number;

			/** Computes 10 raised to a given power. */
			static Exp10(x: number): number;

			/** Computes 10 raised to a given power and subtracts one. */
			static Exp10M1(x: number): number;

			/** Computes 2 raised to a given power. */
			static Exp2(x: number): number;

			/** Computes 2 raised to a given power and subtracts one. */
			static Exp2M1(x: number): number;

			/** Computes E raised to a given power and subtracts one. */
			static ExpM1(x: number): number;

			/** Computes the floor of a value. */
			static Floor(x: number): number;

			/** Computes the fused multiply-add of three values. */
			static FusedMultiplyAdd(
				left: number,
				right: number,
				addend: number,
			): number;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.Single}. */
			GetTypeCode(): System.TypeCode;

			/**
			 * Computes the hypotenuse given two values representing the lengths of the shorter sides
			 * in a right-angled triangle.
			 */
			static Hypot(
				x: number,
				y: number,
			): number;

			/** Computes the remainder of two values as specified by IEEE 754. */
			static Ieee754Remainder(
				left: number,
				right: number,
			): number;

			/** Computes the integer logarithm of a value. */
			static ILogB(x: number): number;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: number): boolean;

			/** Determines whether the specified value is finite (zero, subnormal or normal). */
			static IsFinite(f: number): boolean;

			/**
			 * Returns a value indicating whether the specified number evaluates to negative or
			 * positive infinity.
			 */
			static IsInfinity(f: number): boolean;

			/** Determines if a value represents an integral value. */
			static IsInteger(value: number): boolean;

			/**
			 * Returns a value that indicates whether the specified value is not a number (
				 * {@link System.Single.NaN} ).
				 */
				static IsNaN(f: number): boolean;

			/** Determines whether the specified value is negative. */
			static IsNegative(f: number): boolean;

			/**
			 * Returns a value indicating whether the specified number evaluates to negative
			 * infinity.
			 */
			static IsNegativeInfinity(f: number): boolean;

			/** Determines whether the specified value is normal. */
			static IsNormal(f: number): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: number): boolean;

			/** Determines if a value is positive. */
			static IsPositive(value: number): boolean;

			/**
			 * Returns a value indicating whether the specified number evaluates to positive
			 * infinity.
			 */
			static IsPositiveInfinity(f: number): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: number): boolean;

			/** Determines if a value represents a real number. */
			static IsRealNumber(value: number): boolean;

			/** Determines whether the specified value is subnormal. */
			static IsSubnormal(f: number): boolean;

			/** Performs a linear interpolation between two values based on the given weight. */
			static Lerp(
				value1: number,
				value2: number,
				amount: number,
			): number;

			/** Computes the natural ( base-E logarithm of a value. */
			static Log(x: number): number;

			/** Computes the logarithm of a value in the specified base. */
			static Log(
				x: number,
				newBase: number,
			): number;

			/** Computes the base-10 logarithm of a value. */
			static Log10(x: number): number;

			/** Computes the base-10 logarithm of a value plus one. */
			static Log10P1(x: number): number;

			/** Computes the log2 of a value. */
			static Log2(value: number): number;

			/** Computes the base-2 logarithm of a value plus one. */
			static Log2P1(x: number): number;

			/** Computes the natural ( base-E ) logarithm of a value plus one. */
			static LogP1(x: number): number;

			/** Compares two values to compute which is greater. */
			static Max(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is greater. */
			static MaxMagnitude(
				x: number,
				y: number,
			): number;

			/**
			 * Compares two values to compute which has the greater magnitude and returning the other
			 * value if an input is NaN .
			 */
			static MaxMagnitudeNumber(
				x: number,
				y: number,
			): number;

			/**
			 * Compares two values to compute which is greater and returning the other value if an
			 * input is NaN .
			 */
			static MaxNumber(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static MinMagnitude(
				x: number,
				y: number,
			): number;

			/**
			 * Compares two values to compute which has the lesser magnitude and returning the other
			 * value if an input is NaN .
			 */
			static MinMagnitudeNumber(
				x: number,
				y: number,
			): number;

			/**
			 * Compares two values to compute which is lesser and returning the other value if an
			 * input is NaN .
			 */
			static MinNumber(
				x: number,
				y: number,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts a character span that contains the string representation of a number in a
			 * specified style and culture-specific format to its single-precision floating-point
			 * number equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number to its single-precision floating-point
			 * number equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a number in a specified style to its
			 * single-precision floating-point number equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): number;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its single-precision floating-point number equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its single-precision floating-point number equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Computes a value raised to a given power. */
			static Pow(
				x: number,
				y: number,
			): number;

			/** Converts a given value from radians to degrees. */
			static RadiansToDegrees(radians: number): number;

			/** Computes an estimate of the reciprocal of a value. */
			static ReciprocalEstimate(x: number): number;

			/** Computes an estimate of the reciprocal square root of a value. */
			static ReciprocalSqrtEstimate(x: number): number;

			/** Computes the n-th root of a value. */
			static RootN(
				x: number,
				n: number,
			): number;

			/** Rounds a value to the nearest integer using the default rounding mode (  ). */
			static Round(x: number): number;

			/**
			 * Rounds a value to a specified number of fractional-digits using the default rounding
			 * mode (  ).
			 */
			static Round(
				x: number,
				digits: number,
			): number;

			/**
			 * Rounds a value to a specified number of fractional-digits using the default rounding
			 * mode (  ).
			 */
			static Round(
				x: number,
				digits: number,
				mode: System.MidpointRounding,
			): number;

			/** Rounds a value to the nearest integer using the specified rounding mode. */
			static Round(
				x: number,
				mode: System.MidpointRounding,
			): number;

			/** Computes the product of a value and its base-radix raised to the specified power. */
			static ScaleB(
				x: number,
				n: number,
			): number;

			/** Computes the sign of a value. */
			static Sign(value: number): number;

			/** Computes the sine of a value. */
			static Sin(x: number): number;

			/** Computes the sine and cosine of a value. */
			static SinCos(x: number): [number, number];

			/** Computes the sine and cosine of a value. */
			static SinCosPi(x: number): [number, number];

			/** Computes the hyperbolic sine of a value. */
			static Sinh(x: number): number;

			/** Computes the sine of a value that has been multiplied by pi . */
			static SinPi(x: number): number;

			/** Computes the square-root of a value. */
			static Sqrt(x: number): number;

			/** Computes the tangent of a value. */
			static Tan(x: number): number;

			/** Computes the hyperbolic tangent of a value. */
			static Tanh(x: number): number;

			/** Computes the tangent of a value that has been multipled by pi . */
			static TanPi(x: number): number;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Truncates a value. */
			static Truncate(x: number): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Provides a type-safe and memory-safe representation of a
		 * contiguous region of arbitrary memory.
		 */
		export function Span$(T: IType): typeof Span$1<any>;

		/**
		 * Provides a type-safe and memory-safe representation of a contiguous region of
		 * arbitrary memory.
		 */
		export class Span$1<T> extends System.ValueType {
			constructor(array: T[] | undefined);

			constructor(
				array: T[] | undefined,
				start: number,
				length: number,
			);

			constructor(reference: T);

			/** Returns an empty {@link System.Span<>} object. */
			static readonly Empty: System.Span$1<any>;

			/** Returns a value that indicates whether the current {@link System.Span<>} is empty. */
			readonly IsEmpty: boolean;

			/** Returns the length of the current span. */
			readonly Length: number;

			/** Clears the contents of this {@link System.Span<>} object. */
			Clear(): void;

			/**
			 * Copies the contents of this {@link System.Span<>} into a destination
			 * {@link System.Span<>}.
			 */
			CopyTo(destination: System.Span$1<T>): void;

			/** Calls to this method are not supported. */
			Equals(obj: System.Object | undefined): boolean;

			/** Fills the elements of this span with a specified value. */
			Fill(value: T): void;

			/** Returns an enumerator for this {@link System.Span<>}. */
			GetEnumerator(): System.Span.Enumerator$1<T>;

			/** Throws a {@link System.NotSupportedException}. */
			GetHashCode(): number;

			/**
			 * Returns a reference to an object of type T that can be used for pinning.  This method
			 * is intended to support .NET compilers and is not intended to be called by user code.
			 */
			GetPinnableReference(): T;

			/** Forms a slice out of the current span that begins at a specified index. */
			Slice(start: number): System.Span$1<T>;

			/**
			 * Forms a slice out of the current span starting at a specified index for a specified
			 * length.
			 */
			Slice(
				start: number,
				length: number,
			): System.Span$1<T>;

			/** Copies the contents of this span into a new array. */
			ToArray(): T[];

			/** Returns the string representation of this {@link System.Span<>} object. */
			ToString(): string;

			/**
			 * Attempts to copy the current {@link System.Span<>} to a destination
			 * {@link System.Span<>} and returns a value that indicates whether the copy operation
			 * succeeded.
			 */
			TryCopyTo(destination: System.Span$1<T>): boolean;
		}
	}

	export namespace System.Span {
		export function Enumerator$(T: IType): typeof Enumerator$1<any>;

		export class Enumerator$1<T> extends System.ValueType {
			readonly Current: T;

			MoveNext(): boolean;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when the execution stack exceeds the stack size. This
		 * class cannot be inherited.
		 */
		export class StackOverflowException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.StackOverflowException} class, setting
			 * the {@link System.Exception.Message} property of the new instance to a system-supplied
			 * message that describes the error, such as "The requested operation caused a stack
			 * overflow." This message takes into account the current system culture.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.StackOverflowException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.StackOverflowException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * Indicates that the COM threading model for an application is single-threaded apartment
		 * (STA).
		 */
		export class STAThreadAttribute extends System.Attribute {
			/** Initializes a new instance of the {@link System.STAThreadAttribute} class. */
			constructor();
		}
	}

	export namespace System {
		/** Represents text as a sequence of UTF-16 code units. */
		export class String implements
			System.ICloneable,
			System.IComparable,
			System.IComparable$1<string>,
			System.IEquatable$1<string>,
			System.IParsable$1<string>,
			System.ISpanParsable$1<string> {
			/**
			 * Initializes a new instance of the {@link System.String} class to the value indicated
			 * by a specified Unicode character repeated a specified number of times.
			 */
			constructor(
				c: System.Char,
				count: number,
			);

			/**
			 * Initializes a new instance of the {@link System.String} class to the Unicode
			 * characters indicated in the specified character array.
			 */
			constructor(value: System.Char[] | undefined);

			/**
			 * Initializes a new instance of the {@link System.String} class to the value indicated
			 * by an array of Unicode characters, a starting character position within that array,
			 * and a length.
			 */
			constructor(
				value: System.Char[],
				startIndex: number,
				length: number,
			);

			/**
			 * Initializes a new instance of the {@link System.String} class to the Unicode
			 * characters indicated in the specified read-only span.
			 */
			constructor(value: System.ReadOnlySpan$1<System.Char>);

			/** Gets the number of characters in the current {@link System.String} object. */
			readonly Length: number;

			/** Returns a reference to this instance of {@link System.String}. */
			Clone(): System.Object;

			/**
			 * Compares substrings of two specified {@link System.String} objects and returns an
			 * integer that indicates their relative position in the sort order.
			 */
			static Compare(
				strA: string | undefined,
				indexA: number,
				strB: string | undefined,
				indexB: number,
				length: number,
			): number;

			/**
			 * Compares substrings of two specified {@link System.String} objects, ignoring or
			 * honoring their case, and returns an integer that indicates their relative position in
			 * the sort order.
			 */
			static Compare(
				strA: string | undefined,
				indexA: number,
				strB: string | undefined,
				indexB: number,
				length: number,
				ignoreCase: boolean,
			): number;

			/**
			 * Compares substrings of two specified {@link System.String} objects, ignoring or
			 * honoring their case and using culture-specific information to influence the
			 * comparison, and returns an integer that indicates their relative position in the sort
			 * order.
			 */
			static Compare(
				strA: string | undefined,
				indexA: number,
				strB: string | undefined,
				indexB: number,
				length: number,
				ignoreCase: boolean,
				culture: System.Globalization.CultureInfo | undefined,
			): number;

			/**
			 * Compares substrings of two specified {@link System.String} objects using the specified
			 * comparison options and culture-specific information to influence the comparison, and
			 * returns an integer that indicates the relationship of the two substrings to each other
			 * in the sort order.
			 */
			static Compare(
				strA: string | undefined,
				indexA: number,
				strB: string | undefined,
				indexB: number,
				length: number,
				culture: System.Globalization.CultureInfo | undefined,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Compares substrings of two specified {@link System.String} objects using the specified
			 * rules, and returns an integer that indicates their relative position in the sort
			 * order.
			 */
			static Compare(
				strA: string | undefined,
				indexA: number,
				strB: string | undefined,
				indexB: number,
				length: number,
				comparisonType: System.StringComparison,
			): number;

			/**
			 * Compares two specified {@link System.String} objects and returns an integer that
			 * indicates their relative position in the sort order.
			 */
			static Compare(
				strA: string | undefined,
				strB: string | undefined,
			): number;

			/**
			 * Compares two specified {@link System.String} objects, ignoring or honoring their case,
			 * and returns an integer that indicates their relative position in the sort order.
			 */
			static Compare(
				strA: string | undefined,
				strB: string | undefined,
				ignoreCase: boolean,
			): number;

			/**
			 * Compares two specified {@link System.String} objects, ignoring or honoring their case,
			 * and using culture-specific information to influence the comparison, and returns an
			 * integer that indicates their relative position in the sort order.
			 */
			static Compare(
				strA: string | undefined,
				strB: string | undefined,
				ignoreCase: boolean,
				culture: System.Globalization.CultureInfo | undefined,
			): number;

			/**
			 * Compares two specified {@link System.String} objects using the specified comparison
			 * options and culture-specific information to influence the comparison, and returns an
			 * integer that indicates the relationship of the two strings to each other in the sort
			 * order.
			 */
			static Compare(
				strA: string | undefined,
				strB: string | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Compares two specified {@link System.String} objects using the specified rules, and
			 * returns an integer that indicates their relative position in the sort order.
			 */
			static Compare(
				strA: string | undefined,
				strB: string | undefined,
				comparisonType: System.StringComparison,
			): number;

			/**
			 * Compares substrings of two specified {@link System.String} objects by evaluating the
			 * numeric values of the corresponding {@link System.Char} objects in each substring.
			 */
			static CompareOrdinal(
				strA: string | undefined,
				indexA: number,
				strB: string | undefined,
				indexB: number,
				length: number,
			): number;

			/**
			 * Compares two specified {@link System.String} objects by evaluating the numeric values
			 * of the corresponding {@link System.Char} objects in each string.
			 */
			static CompareOrdinal(
				strA: string | undefined,
				strB: string | undefined,
			): number;

			/**
			 * Compares this instance with a specified {@link System.Object} and indicates whether
			 * this instance precedes, follows, or appears in the same position in the sort order as
			 * the specified {@link System.Object}.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Compares this instance with a specified {@link System.String} object and indicates
			 * whether this instance precedes, follows, or appears in the same position in the sort
			 * order as the specified string.
			 */
			CompareTo(strB: string | undefined): number;

			/**
			 * Concatenates the members of a constructed
			 * {@link System.Collections.Generic.IEnumerable<>} collection of type
			 * {@link System.String}.
			 */
			static Concat(values: Iterable<string | undefined>): string;

			/** Creates the string  representation of a specified object. */
			static Concat(arg0: System.Object | undefined): string;

			/** Concatenates the string representations of two specified objects. */
			static Concat(
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): string;

			/** Concatenates the string representations of three specified objects. */
			static Concat(
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): string;

			/**
			 * Concatenates the string representations of the elements in a specified
			 * {@link System.Object} array.
			 */
			static Concat(args: System.Object | undefined[]): string;

			/**
			 * Concatenates the string representations of two specified read-only character spans.
			 */
			static Concat(
				str0: System.ReadOnlySpan$1<System.Char>,
				str1: System.ReadOnlySpan$1<System.Char>,
			): string;

			/**
			 * Concatenates the string representations of three specified read-only character spans.
			 */
			static Concat(
				str0: System.ReadOnlySpan$1<System.Char>,
				str1: System.ReadOnlySpan$1<System.Char>,
				str2: System.ReadOnlySpan$1<System.Char>,
			): string;

			/**
			 * Concatenates the string representations of four specified read-only character spans.
			 */
			static Concat(
				str0: System.ReadOnlySpan$1<System.Char>,
				str1: System.ReadOnlySpan$1<System.Char>,
				str2: System.ReadOnlySpan$1<System.Char>,
				str3: System.ReadOnlySpan$1<System.Char>,
			): string;

			/** Concatenates two specified instances of {@link System.String}. */
			static Concat(
				str0: string | undefined,
				str1: string | undefined,
			): string;

			/** Concatenates three specified instances of {@link System.String}. */
			static Concat(
				str0: string | undefined,
				str1: string | undefined,
				str2: string | undefined,
			): string;

			/** Concatenates four specified instances of {@link System.String}. */
			static Concat(
				str0: string | undefined,
				str1: string | undefined,
				str2: string | undefined,
				str3: string | undefined,
			): string;

			/** Concatenates the elements of a specified {@link System.String} array. */
			static Concat(values: string | undefined[]): string;

			/**
			 * Concatenates the members of an {@link System.Collections.Generic.IEnumerable<>}
			 * implementation.
			 */
			static Concat<T>(values: Iterable<T>): string;

			/**
			 * Returns a value indicating whether a specified character occurs within this string.
			 */
			Contains(value: System.Char): boolean;

			/**
			 * Returns a value indicating whether a specified character occurs within this string,
			 * using the specified comparison rules.
			 */
			Contains(
				value: System.Char,
				comparisonType: System.StringComparison,
			): boolean;

			/**
			 * Returns a value indicating whether a specified substring occurs within this string.
			 */
			Contains(value: string): boolean;

			/**
			 * Returns a value indicating whether a specified string occurs within this string, using
			 * the specified comparison rules.
			 */
			Contains(
				value: string,
				comparisonType: System.StringComparison,
			): boolean;

			/**
			 * Creates a new instance of {@link System.String} with the same value as a specified
			 * {@link System.String}.
			 */
			static Copy(str: string): string;

			/**
			 * Copies a specified number of characters from a specified position in this instance to
			 * a specified position in an array of Unicode characters.
			 */
			CopyTo(
				sourceIndex: number,
				destination: System.Char[],
				destinationIndex: number,
				count: number,
			): void;

			/** Copies the contents of this string into the destination span. */
			CopyTo(destination: System.Span$1<System.Char>): void;

			/**
			 * Creates a new string with a specific length and initializes it after creation by using
			 * the specified callback.
			 */
			static Create<TState>(
				length: number,
				state: TState,
				action: System.Buffers.SpanAction$2<System.Char, TState>,
			): string;

			/**
			 * Determines whether the end of this string instance matches the specified character.
			 */
			EndsWith(value: System.Char): boolean;

			/** Determines whether the end of this string instance matches the specified string. */
			EndsWith(value: string): boolean;

			/**
			 * Determines whether the end of this string instance matches the specified string when
			 * compared using the specified culture.
			 */
			EndsWith(
				value: string,
				ignoreCase: boolean,
				culture: System.Globalization.CultureInfo | undefined,
			): boolean;

			/**
			 * Determines whether the end of this string instance matches the specified string when
			 * compared using the specified comparison option.
			 */
			EndsWith(
				value: string,
				comparisonType: System.StringComparison,
			): boolean;

			/** Returns an enumeration of {@link System.Text.Rune} from this string. */
			EnumerateRunes(): System.Text.StringRuneEnumerator;

			/**
			 * Determines whether this instance and a specified object, which must also be a
			 * {@link System.String} object, have the same value.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Determines whether this instance and another specified {@link System.String} object
			 * have the same value.
			 */
			Equals(value: string | undefined): boolean;

			/**
			 * Determines whether two specified {@link System.String} objects have the same value.
			 */
			static Equals(
				a: string | undefined,
				b: string | undefined,
			): boolean;

			/**
			 * Determines whether two specified {@link System.String} objects have the same value. A
			 * parameter specifies the culture, case, and sort rules used in the comparison.
			 */
			static Equals(
				a: string | undefined,
				b: string | undefined,
				comparisonType: System.StringComparison,
			): boolean;

			/**
			 * Determines whether this string and a specified {@link System.String} object have the
			 * same value. A parameter specifies the culture, case, and sort rules used in the
			 * comparison.
			 */
			Equals(
				value: string | undefined,
				comparisonType: System.StringComparison,
			): boolean;

			/**
			 * Replaces the format item or items in a specified string with the string representation
			 * of the corresponding object. A parameter supplies culture-specific formatting
			 * information.
			 */
			static Format(
				provider: System.IFormatProvider | undefined,
				format: string,
				arg0: System.Object | undefined,
			): string;

			/**
			 * Replaces the format items in a string with the string representation of two specified
			 * objects. A parameter supplies culture-specific formatting information.
			 */
			static Format(
				provider: System.IFormatProvider | undefined,
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): string;

			/**
			 * Replaces the format items in a string with the string representation of three
			 * specified objects. An parameter supplies culture-specific formatting information.
			 */
			static Format(
				provider: System.IFormatProvider | undefined,
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): string;

			/**
			 * Replaces the format items in a string with the string representations of corresponding
			 * objects in a specified array. A parameter supplies culture-specific formatting
			 * information.
			 */
			static Format(
				provider: System.IFormatProvider | undefined,
				format: string,
				args: System.Object | undefined[],
			): string;

			/**
			 * Replaces one or more format items in a string with the string representation of a
			 * specified object.
			 */
			static Format(
				format: string,
				arg0: System.Object | undefined,
			): string;

			/**
			 * Replaces the format items in a string with the string representation of two specified
			 * objects.
			 */
			static Format(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): string;

			/**
			 * Replaces the format items in a string with the string representation of three
			 * specified objects.
			 */
			static Format(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): string;

			/**
			 * Replaces the format item in a specified string with the string representation of a
			 * corresponding object in a specified array.
			 */
			static Format(
				format: string,
				args: System.Object | undefined[],
			): string;

			/**
			 * Replaces the format item or items in a {@link System.Text.CompositeFormat} with the
			 * string representation of the corresponding objects in the specified format.
			 */
			static Format<TArg0>(
				provider: System.IFormatProvider | undefined,
				format: System.Text.CompositeFormat,
				arg0: TArg0,
			): string;

			/**
			 * Replaces the format item or items in a {@link System.Text.CompositeFormat} with the
			 * string representation of the corresponding objects in the specified format.
			 */
			static Format<TArg0, TArg1>(
				provider: System.IFormatProvider | undefined,
				format: System.Text.CompositeFormat,
				arg0: TArg0,
				arg1: TArg1,
			): string;

			/**
			 * Replaces the format item or items in a {@link System.Text.CompositeFormat} with the
			 * string representation of the corresponding objects in the specified format.
			 */
			static Format<TArg0, TArg1, TArg2>(
				provider: System.IFormatProvider | undefined,
				format: System.Text.CompositeFormat,
				arg0: TArg0,
				arg1: TArg1,
				arg2: TArg2,
			): string;

			/**
			 * Replaces the format item or items in a {@link System.Text.CompositeFormat} with the
			 * string representation of the corresponding objects in the specified format.
			 */
			static Format(
				provider: System.IFormatProvider | undefined,
				format: System.Text.CompositeFormat,
				args: System.Object | undefined[],
			): string;

			/**
			 * Replaces the format item or items in a {@link System.Text.CompositeFormat} with the
			 * string representation of the corresponding objects in the specified format.
			 */
			static Format(
				provider: System.IFormatProvider | undefined,
				format: System.Text.CompositeFormat,
				args: System.ReadOnlySpan$1<System.Object | undefined>,
			): string;

			/**
			 * Retrieves an object that can iterate through the individual characters in this string.
			 */
			GetEnumerator(): System.CharEnumerator;

			/** Returns the hash code for this string. */
			GetHashCode(): number;

			/** Returns the hash code for the provided read-only character span. */
			static GetHashCode(value: System.ReadOnlySpan$1<System.Char>): number;

			/**
			 * Returns the hash code for the provided read-only character span using the specified
			 * rules.
			 */
			static GetHashCode(
				value: System.ReadOnlySpan$1<System.Char>,
				comparisonType: System.StringComparison,
			): number;

			/** Returns the hash code for this string using the specified rules. */
			GetHashCode(comparisonType: System.StringComparison): number;

			/**
			 * Returns a reference to the element of the string at index zero.  This method is
			 * intended to support .NET compilers and is not intended to be called by user code.
			 */
			GetPinnableReference(): System.Char;

			/** Returns the {@link System.TypeCode} for the {@link System.String} class. */
			GetTypeCode(): System.TypeCode;

			/**
			 * Reports the zero-based index of the first occurrence of the specified Unicode
			 * character in this string.
			 */
			IndexOf(value: System.Char): number;

			/**
			 * Reports the zero-based index of the first occurrence of the specified Unicode
			 * character in this string. The search starts at a specified character position.
			 */
			IndexOf(
				value: System.Char,
				startIndex: number,
			): number;

			/**
			 * Reports the zero-based index of the first occurrence of the specified character in
			 * this instance. The search starts at a specified character position and examines a
			 * specified number of character positions.
			 */
			IndexOf(
				value: System.Char,
				startIndex: number,
				count: number,
			): number;

			/**
			 * Reports the zero-based index of the first occurrence of the specified Unicode
			 * character in this string. A parameter specifies the type of search to use for the
			 * specified character.
			 */
			IndexOf(
				value: System.Char,
				comparisonType: System.StringComparison,
			): number;

			/**
			 * Reports the zero-based index of the first occurrence of the specified string in this
			 * instance.
			 */
			IndexOf(value: string): number;

			/**
			 * Reports the zero-based index of the first occurrence of the specified string in this
			 * instance. The search starts at a specified character position.
			 */
			IndexOf(
				value: string,
				startIndex: number,
			): number;

			/**
			 * Reports the zero-based index of the first occurrence of the specified string in this
			 * instance. The search starts at a specified character position and examines a specified
			 * number of character positions.
			 */
			IndexOf(
				value: string,
				startIndex: number,
				count: number,
			): number;

			/**
			 * Reports the zero-based index of the first occurrence of the specified string in the
			 * current {@link System.String} object. Parameters specify the starting search position
			 * in the current string, the number of characters in the current string to search, and
			 * the type of search to use for the specified string.
			 */
			IndexOf(
				value: string,
				startIndex: number,
				count: number,
				comparisonType: System.StringComparison,
			): number;

			/**
			 * Reports the zero-based index of the first occurrence of the specified string in the
			 * current {@link System.String} object. Parameters specify the starting search position
			 * in the current string and the type of search to use for the specified string.
			 */
			IndexOf(
				value: string,
				startIndex: number,
				comparisonType: System.StringComparison,
			): number;

			/**
			 * Reports the zero-based index of the first occurrence of the specified string in the
			 * current {@link System.String} object. A parameter specifies the type of search to use
			 * for the specified string.
			 */
			IndexOf(
				value: string,
				comparisonType: System.StringComparison,
			): number;

			/**
			 * Reports the zero-based index of the first occurrence in this instance of any character
			 * in a specified array of Unicode characters.
			 */
			IndexOfAny(anyOf: System.Char[]): number;

			/**
			 * Reports the zero-based index of the first occurrence in this instance of any character
			 * in a specified array of Unicode characters. The search starts at a specified character
			 * position.
			 */
			IndexOfAny(
				anyOf: System.Char[],
				startIndex: number,
			): number;

			/**
			 * Reports the zero-based index of the first occurrence in this instance of any character
			 * in a specified array of Unicode characters. The search starts at a specified character
			 * position and examines a specified number of character positions.
			 */
			IndexOfAny(
				anyOf: System.Char[],
				startIndex: number,
				count: number,
			): number;

			/**
			 * Returns a new string in which a specified string is inserted at a specified index
			 * position in this instance.
			 */
			Insert(
				startIndex: number,
				value: string,
			): string;

			/** Retrieves the system's reference to the specified {@link System.String}. */
			static Intern(str: string): string;

			/** Retrieves a reference to a specified {@link System.String}. */
			static IsInterned(str: string): string | undefined;

			/** Indicates whether this string is in Unicode normalization form C. */
			IsNormalized(): boolean;

			/** Indicates whether this string is in the specified Unicode normalization form. */
			IsNormalized(normalizationForm: System.Text.NormalizationForm): boolean;

			/** Indicates whether the specified string is `null` or an empty string (""). */
			static IsNullOrEmpty(value: string | undefined): boolean;

			/**
			 * Indicates whether a specified string is `null`, empty, or consists only of white-space
			 * characters.
			 */
			static IsNullOrWhiteSpace(value: string | undefined): boolean;

			/**
			 * Concatenates the string representations of an array of objects, using the specified
			 * separator between each member.
			 */
			static Join(
				separator: System.Char,
				values: System.Object | undefined[],
			): string;

			/**
			 * Concatenates an array of strings, using the specified separator between each member.
			 */
			static Join(
				separator: System.Char,
				value: string | undefined[],
			): string;

			/**
			 * Concatenates an array of strings, using the specified separator between each member,
			 * starting with the element in `value` located at the `startIndex` position, and
			 * concatenating up to `count` elements.
			 */
			static Join(
				separator: System.Char,
				value: string | undefined[],
				startIndex: number,
				count: number,
			): string;

			/**
			 * Concatenates the members of a constructed
			 * {@link System.Collections.Generic.IEnumerable<>} collection of type
			 * {@link System.String}, using the specified separator between each member.
			 */
			static Join(
				separator: string | undefined,
				values: Iterable<string | undefined>,
			): string;

			/**
			 * Concatenates the elements of an object array, using the specified separator between
			 * each element.
			 */
			static Join(
				separator: string | undefined,
				values: System.Object | undefined[],
			): string;

			/**
			 * Concatenates all the elements of a string array, using the specified separator between
			 * each element.
			 */
			static Join(
				separator: string | undefined,
				value: string | undefined[],
			): string;

			/**
			 * Concatenates the specified elements of a string array, using the specified separator
			 * between each element.
			 */
			static Join(
				separator: string | undefined,
				value: string | undefined[],
				startIndex: number,
				count: number,
			): string;

			/**
			 * Concatenates the members of a collection, using the specified separator between each
			 * member.
			 */
			static Join<T>(
				separator: System.Char,
				values: Iterable<T>,
			): string;

			/**
			 * Concatenates the members of a collection, using the specified separator between each
			 * member.
			 */
			static Join<T>(
				separator: string | undefined,
				values: Iterable<T>,
			): string;

			/**
			 * Reports the zero-based index position of the last occurrence of a specified Unicode
			 * character within this instance.
			 */
			LastIndexOf(value: System.Char): number;

			/**
			 * Reports the zero-based index position of the last occurrence of a specified Unicode
			 * character within this instance. The search starts at a specified character position
			 * and proceeds backward toward the beginning of the string.
			 */
			LastIndexOf(
				value: System.Char,
				startIndex: number,
			): number;

			/**
			 * Reports the zero-based index position of the last occurrence of the specified Unicode
			 * character in a substring within this instance. The search starts at a specified
			 * character position and proceeds backward toward the beginning of the string for a
			 * specified number of character positions.
			 */
			LastIndexOf(
				value: System.Char,
				startIndex: number,
				count: number,
			): number;

			/**
			 * Reports the zero-based index position of the last occurrence of a specified string
			 * within this instance.
			 */
			LastIndexOf(value: string): number;

			/**
			 * Reports the zero-based index position of the last occurrence of a specified string
			 * within this instance. The search starts at a specified character position and proceeds
			 * backward toward the beginning of the string.
			 */
			LastIndexOf(
				value: string,
				startIndex: number,
			): number;

			/**
			 * Reports the zero-based index position of the last occurrence of a specified string
			 * within this instance. The search starts at a specified character position and proceeds
			 * backward toward the beginning of the string for a specified number of character
			 * positions.
			 */
			LastIndexOf(
				value: string,
				startIndex: number,
				count: number,
			): number;

			/**
			 * Reports the zero-based index position of the last occurrence of a specified string
			 * within this instance. The search starts at a specified character position and proceeds
			 * backward toward the beginning of the string for the specified number of character
			 * positions. A parameter specifies the type of comparison to perform when searching for
			 * the specified string.
			 */
			LastIndexOf(
				value: string,
				startIndex: number,
				count: number,
				comparisonType: System.StringComparison,
			): number;

			/**
			 * Reports the zero-based index of the last occurrence of a specified string within the
			 * current {@link System.String} object. The search starts at a specified character
			 * position and proceeds backward toward the beginning of the string. A parameter
			 * specifies the type of comparison to perform when searching for the specified string.
			 */
			LastIndexOf(
				value: string,
				startIndex: number,
				comparisonType: System.StringComparison,
			): number;

			/**
			 * Reports the zero-based index of the last occurrence of a specified string within the
			 * current {@link System.String} object. A parameter specifies the type of search to use
			 * for the specified string.
			 */
			LastIndexOf(
				value: string,
				comparisonType: System.StringComparison,
			): number;

			/**
			 * Reports the zero-based index position of the last occurrence in this instance of one
			 * or more characters specified in a Unicode array.
			 */
			LastIndexOfAny(anyOf: System.Char[]): number;

			/**
			 * Reports the zero-based index position of the last occurrence in this instance of one
			 * or more characters specified in a Unicode array. The search starts at a specified
			 * character position and proceeds backward toward the beginning of the string.
			 */
			LastIndexOfAny(
				anyOf: System.Char[],
				startIndex: number,
			): number;

			/**
			 * Reports the zero-based index position of the last occurrence in this instance of one
			 * or more characters specified in a Unicode array. The search starts at a specified
			 * character position and proceeds backward toward the beginning of the string for a
			 * specified number of character positions.
			 */
			LastIndexOfAny(
				anyOf: System.Char[],
				startIndex: number,
				count: number,
			): number;

			/**
			 * Returns a new string whose textual value is the same as this string, but whose binary
			 * representation is in Unicode normalization form C.
			 */
			Normalize(): string;

			/**
			 * Returns a new string whose textual value is the same as this string, but whose binary
			 * representation is in the specified Unicode normalization form.
			 */
			Normalize(normalizationForm: System.Text.NormalizationForm): string;

			/**
			 * Returns a new string that right-aligns the characters in this instance by padding them
			 * with spaces on the left, for a specified total length.
			 */
			PadLeft(totalWidth: number): string;

			/**
			 * Returns a new string that right-aligns the characters in this instance by padding them
			 * on the left with a specified Unicode character, for a specified total length.
			 */
			PadLeft(
				totalWidth: number,
				paddingChar: System.Char,
			): string;

			/**
			 * Returns a new string that left-aligns the characters in this string by padding them
			 * with spaces on the right, for a specified total length.
			 */
			PadRight(totalWidth: number): string;

			/**
			 * Returns a new string that left-aligns the characters in this string by padding them on
			 * the right with a specified Unicode character, for a specified total length.
			 */
			PadRight(
				totalWidth: number,
				paddingChar: System.Char,
			): string;

			/**
			 * Returns a new string in which all the characters in the current instance, beginning at
			 * a specified position and continuing through the last position, have been deleted.
			 */
			Remove(startIndex: number): string;

			/**
			 * Returns a new string in which a specified number of characters in the current instance
			 * beginning at a specified position have been deleted.
			 */
			Remove(
				startIndex: number,
				count: number,
			): string;

			/**
			 * Returns a new string in which all occurrences of a specified Unicode character in this
			 * instance are replaced with another specified Unicode character.
			 */
			Replace(
				oldChar: System.Char,
				newChar: System.Char,
			): string;

			/**
			 * Returns a new string in which all occurrences of a specified string in the current
			 * instance are replaced with another specified string.
			 */
			Replace(
				oldValue: string,
				newValue: string | undefined,
			): string;

			/**
			 * Returns a new string in which all occurrences of a specified string in the current
			 * instance are replaced with another specified string, using the provided culture and
			 * case sensitivity.
			 */
			Replace(
				oldValue: string,
				newValue: string | undefined,
				ignoreCase: boolean,
				culture: System.Globalization.CultureInfo | undefined,
			): string;

			/**
			 * Returns a new string in which all occurrences of a specified string in the current
			 * instance are replaced with another specified string, using the provided comparison
			 * type.
			 */
			Replace(
				oldValue: string,
				newValue: string | undefined,
				comparisonType: System.StringComparison,
			): string;

			/**
			 * Replaces all newline sequences in the current string with
			 * {@link System.Environment.NewLine}.
			 */
			ReplaceLineEndings(): string;

			/** Replaces all newline sequences in the current string with `replacementText`. */
			ReplaceLineEndings(replacementText: string): string;

			/**
			 * Splits a string into a maximum number of substrings based on a specified delimiting
			 * character and, optionally, options. Splits a string into a maximum number of
			 * substrings based on the provided character separator, optionally omitting empty
			 * substrings from the result.
			 */
			Split(
				separator: System.Char,
				count: number,
				options?: System.StringSplitOptions,
			): string[];

			/**
			 * Splits a string into substrings based on a specified delimiting character and,
			 * optionally, options.
			 */
			Split(
				separator: System.Char,
				options?: System.StringSplitOptions,
			): string[];

			/** Splits a string into substrings based on specified delimiting characters. */
			Split(separator: System.Char[] | undefined): string[];

			/**
			 * Splits a string into a maximum number of substrings based on specified delimiting
			 * characters.
			 */
			Split(
				separator: System.Char[] | undefined,
				count: number,
			): string[];

			/**
			 * Splits a string into a maximum number of substrings based on specified delimiting
			 * characters and, optionally, options.
			 */
			Split(
				separator: System.Char[] | undefined,
				count: number,
				options: System.StringSplitOptions,
			): string[];

			/**
			 * Splits a string into substrings based on specified delimiting characters and options.
			 */
			Split(
				separator: System.Char[] | undefined,
				options: System.StringSplitOptions,
			): string[];

			/**
			 * Splits a string into a maximum number of substrings based on a specified delimiting
			 * string and, optionally, options.
			 */
			Split(
				separator: string | undefined,
				count: number,
				options?: System.StringSplitOptions,
			): string[];

			/** Splits a string into substrings that are based on the provided string separator. */
			Split(
				separator: string | undefined,
				options?: System.StringSplitOptions,
			): string[];

			/**
			 * Splits a string into a maximum number of substrings based on specified delimiting
			 * strings and, optionally, options.
			 */
			Split(
				separator: string[] | undefined,
				count: number,
				options: System.StringSplitOptions,
			): string[];

			/**
			 * Splits a string into substrings based on a specified delimiting string and,
			 * optionally, options.
			 */
			Split(
				separator: string[] | undefined,
				options: System.StringSplitOptions,
			): string[];

			/** Determines whether this string instance starts with the specified character. */
			StartsWith(value: System.Char): boolean;

			/**
			 * Determines whether the beginning of this string instance matches the specified string.
			 */
			StartsWith(value: string): boolean;

			/**
			 * Determines whether the beginning of this string instance matches the specified string
			 * when compared using the specified culture.
			 */
			StartsWith(
				value: string,
				ignoreCase: boolean,
				culture: System.Globalization.CultureInfo | undefined,
			): boolean;

			/**
			 * Determines whether the beginning of this string instance matches the specified string
			 * when compared using the specified comparison option.
			 */
			StartsWith(
				value: string,
				comparisonType: System.StringComparison,
			): boolean;

			/**
			 * Retrieves a substring from this instance. The substring starts at a specified
			 * character position and continues to the end of the string.
			 */
			Substring(startIndex: number): string;

			/**
			 * Retrieves a substring from this instance. The substring starts at a specified
			 * character position and has a specified length.
			 */
			Substring(
				startIndex: number,
				length: number,
			): string;

			/** Copies the characters in this instance to a Unicode character array. */
			ToCharArray(): System.Char[];

			/**
			 * Copies the characters in a specified substring in this instance to a Unicode character
			 * array.
			 */
			ToCharArray(
				startIndex: number,
				length: number,
			): System.Char[];

			/** Returns a copy of this string converted to lowercase. */
			ToLower(): string;

			/**
			 * Returns a copy of this string converted to lowercase, using the casing rules of the
			 * specified culture.
			 */
			ToLower(culture: System.Globalization.CultureInfo | undefined): string;

			/**
			 * Returns a copy of this {@link System.String} object converted to lowercase using the
			 * casing rules of the invariant culture.
			 */
			ToLowerInvariant(): string;

			/**
			 * Returns this instance of {@link System.String} ; no actual conversion is performed.
			 */
			ToString(): string;

			/**
			 * Returns this instance of {@link System.String} ; no actual conversion is performed.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/** Returns a copy of this string converted to uppercase. */
			ToUpper(): string;

			/**
			 * Returns a copy of this string converted to uppercase, using the casing rules of the
			 * specified culture.
			 */
			ToUpper(culture: System.Globalization.CultureInfo | undefined): string;

			/**
			 * Returns a copy of this {@link System.String} object converted to uppercase using the
			 * casing rules of the invariant culture.
			 */
			ToUpperInvariant(): string;

			/** Removes all leading and trailing white-space characters from the current string. */
			Trim(): string;

			/** Removes all leading and trailing instances of a character from the current string. */
			Trim(trimChar: System.Char): string;

			/**
			 * Removes all leading and trailing occurrences of a set of characters specified in an
			 * array from the current string.
			 */
			Trim(trimChars: System.Char[] | undefined): string;

			/** Removes all the trailing white-space characters from the current string. */
			TrimEnd(): string;

			/** Removes all the trailing occurrences of a character from the current string. */
			TrimEnd(trimChar: System.Char): string;

			/**
			 * Removes all the trailing occurrences of a set of characters specified in an array from
			 * the current string.
			 */
			TrimEnd(trimChars: System.Char[] | undefined): string;

			/** Removes all the leading white-space characters from the current string. */
			TrimStart(): string;

			/**
			 * Removes all the leading occurrences of a specified character from the current string.
			 */
			TrimStart(trimChar: System.Char): string;

			/**
			 * Removes all the leading occurrences of a set of characters specified in an array from
			 * the current string.
			 */
			TrimStart(trimChars: System.Char[] | undefined): string;

			/** Copies the contents of this string into the destination span. */
			TryCopyTo(destination: System.Span$1<System.Char>): boolean;
		}
	}

	export namespace System {
		/**
		 * Represents a string comparison operation that uses specific case and culture-based or
		 * ordinal comparison rules.
		 */
		export class StringComparer implements
			System.Collections.IComparer,
			System.Collections.IEqualityComparer {
			/**
			 * Gets a {@link System.StringComparer} object that performs a case-sensitive string
			 * comparison using the word comparison rules of the current culture.
			 */
			static readonly CurrentCulture: System.StringComparer;

			/**
			 * Gets a {@link System.StringComparer} object that performs case-insensitive string
			 * comparisons using the word comparison rules of the current culture.
			 */
			static readonly CurrentCultureIgnoreCase: System.StringComparer;

			/**
			 * Gets a {@link System.StringComparer} object that performs a case-sensitive string
			 * comparison using the word comparison rules of the invariant culture.
			 */
			static readonly InvariantCulture: System.StringComparer;

			/**
			 * Gets a {@link System.StringComparer} object that performs a case-insensitive string
			 * comparison using the word comparison rules of the invariant culture.
			 */
			static readonly InvariantCultureIgnoreCase: System.StringComparer;

			/**
			 * Gets a {@link System.StringComparer} object that performs a case-sensitive ordinal
			 * string comparison.
			 */
			static readonly Ordinal: System.StringComparer;

			/**
			 * Gets a {@link System.StringComparer} object that performs a case-insensitive ordinal
			 * string comparison.
			 */
			static readonly OrdinalIgnoreCase: System.StringComparer;

			/**
			 * When overridden in a derived class, compares two objects and returns an indication of
			 * their relative sort order.
			 */
			Compare(
				x: System.Object | undefined,
				y: System.Object | undefined,
			): number;

			/**
			 * When overridden in a derived class, compares two strings and returns an indication of
			 * their relative sort order.
			 */
			Compare(
				x: string | undefined,
				y: string | undefined,
			): number;

			/**
			 * Creates a {@link System.StringComparer} object that compares strings according to the
			 * rules of a specified culture.
			 */
			static Create(
				culture: System.Globalization.CultureInfo,
				ignoreCase: boolean,
			): System.StringComparer;

			/**
			 * Creates a {@link System.StringComparer} object that compares strings according to the
			 * rules of a specified culture and string options.
			 */
			static Create(
				culture: System.Globalization.CultureInfo,
				options: System.Globalization.CompareOptions,
			): System.StringComparer;

			/** When overridden in a derived class, indicates whether two objects are equal. */
			Equals(
				x: System.Object | undefined,
				y: System.Object | undefined,
			): boolean;

			/** When overridden in a derived class, indicates whether two strings are equal. */
			Equals(
				x: string | undefined,
				y: string | undefined,
			): boolean;

			/**
			 * Converts the specified {@link System.StringComparison} instance to a
			 * {@link System.StringComparer} instance.
			 */
			static FromComparison(comparisonType: System.StringComparison): System.StringComparer;

			/** When overridden in a derived class, gets the hash code for the specified object. */
			GetHashCode(obj: System.Object): number;

			/** When overridden in a derived class, gets the hash code for the specified string. */
			GetHashCode(obj: string): number;

			static IsWellKnownCultureAwareComparer(comparer: System.Collections.Generic.IEqualityComparer$1<string | undefined> | undefined): { result: boolean, compareInfo?: System.Globalization.CompareInfo, compareOptions?: System.Globalization.CompareOptions };

			static IsWellKnownOrdinalComparer(comparer: System.Collections.Generic.IEqualityComparer$1<string | undefined> | undefined): { result: boolean, ignoreCase?: boolean };
		}
	}

	export namespace System {
		/**
		 * Specifies the culture, case, and sort rules to be used by certain overloads of the
		 * {@link System.String.Compare(System.String,System.String)} and
		 * {@link System.String.Equals(System.Object)} methods.
		 */
		export enum StringComparison {
			/** Compare strings using culture-sensitive sort rules and the current culture. */
			CurrentCulture = 0,

			/**
			 * Compare strings using culture-sensitive sort rules, the current culture, and ignoring
			 * the case of the strings being compared.
			 */
			CurrentCultureIgnoreCase = 1,

			/** Compare strings using culture-sensitive sort rules and the invariant culture. */
			InvariantCulture = 2,

			/**
			 * Compare strings using culture-sensitive sort rules, the invariant culture, and
			 * ignoring the case of the strings being compared.
			 */
			InvariantCultureIgnoreCase = 3,

			/** Compare strings using ordinal (binary) sort rules. */
			Ordinal = 4,

			/**
			 * Compare strings using ordinal (binary) sort rules and ignoring the case of the strings
			 * being compared.
			 */
			OrdinalIgnoreCase = 5,
		}
	}

	export namespace System {
		/** Provides extension methods to work with string normalization. */
		export namespace StringNormalizationExtensions {
		}
	}

	export namespace System {
		/**
		 * Specifies options for applicable {@link System.String.Split} method overloads, such as
		 * whether to omit empty substrings from the returned array or trim whitespace from
		 * substrings.
		 */
		export enum StringSplitOptions {
			/** Use the default options when splitting strings. */
			None = 0,

			/**
			 * Omit array elements that contain an empty string from the result. If
			 * {@link System.StringSplitOptions.RemoveEmptyEntries} and
			 * {@link System.StringSplitOptions.TrimEntries} are specified together, then substrings
			 * that consist only of white-space characters are also removed from the result.
			 */
			RemoveEmptyEntries = 1,

			/**
			 * Trim white-space characters from each substring in the result. This field is available
			 * in .NET 5 and later versions only. If
			 * {@link System.StringSplitOptions.RemoveEmptyEntries} and
			 * {@link System.StringSplitOptions.TrimEntries} are specified together, then substrings
			 * that consist only of white-space characters are also removed from the result.
			 */
			TrimEntries = 2,
		}
	}

	export namespace System {
		/** Serves as the base class for system exceptions namespace. */
		export class SystemException extends System.Exception {
			/** Initializes a new instance of the {@link System.SystemException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.SystemException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.SystemException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Indicates that the value of a static field is unique for each thread. */
		export class ThreadStaticAttribute extends System.Attribute {
			/** Initializes a new instance of the {@link System.ThreadStaticAttribute} class. */
			constructor();
		}
	}

	export namespace System {
		/**
		 * Represents a time of day, as would be read from a clock, within the range 00:00:00 to
		 * 23:59:59.9999999.
		 */
		export class TimeOnly extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<System.TimeOnly>,
			System.IEquatable$1<System.TimeOnly>,
			System.IFormattable,
			System.IParsable$1<System.TimeOnly>,
			System.ISpanFormattable,
			System.ISpanParsable$1<System.TimeOnly>,
			System.IUtf8SpanFormattable {
			/**
			 * Initializes a new instance of the {@link System.TimeOnly} structure to the specified
			 * hour and the minute.
			 */
			constructor(
				hour: number,
				minute: number,
			);

			/**
			 * Initializes a new instance of the {@link System.TimeOnly} structure to the specified
			 * hour, minute, and second.
			 */
			constructor(
				hour: number,
				minute: number,
				second: number,
			);

			/**
			 * Initializes a new instance of the {@link System.TimeOnly} structure to the specified
			 * hour, minute, second, and millisecond.
			 */
			constructor(
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			);

			/**
			 * Initializes a new instance of the {@link System.TimeOnly} structure to the specified
			 * hour, minute, second, millisecond, and microsecond.
			 */
			constructor(
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				microsecond: number,
			);

			/**
			 * Initializes a new instance of the {@link System.TimeOnly} structure using a specified
			 * number of ticks.
			 */
			constructor(ticks: number);

			/** Gets the hour component of the time represented by this instance. */
			readonly Hour: number;

			/** Gets the largest possible value of {@link System.TimeOnly}. */
			static readonly MaxValue: System.TimeOnly;

			/** Gets the microsecond component of the time represented by this instance. */
			readonly Microsecond: number;

			/** Gets the millisecond component of the time represented by this instance. */
			readonly Millisecond: number;

			/** Gets the minute component of the time represented by this instance. */
			readonly Minute: number;

			/** Gets the smallest possible value of {@link System.TimeOnly}. */
			static readonly MinValue: System.TimeOnly;

			/** Gets the nanosecond component of the time represented by this instance. */
			readonly Nanosecond: number;

			/** Gets the seconds component of the time represented by this instance. */
			readonly Second: number;

			/** Gets the number of ticks that represent the time of this instance. */
			readonly Ticks: number;

			/**
			 * Returns a new {@link System.TimeOnly} that adds the value of the specified time span
			 * to the value of this instance.
			 */
			Add(value: number): System.TimeOnly;

			Add(value: number): { result: System.TimeOnly, wrappedDays: number };

			/**
			 * Returns a new {@link System.TimeOnly} that adds the specified number of hours to the
			 * value of this instance.
			 */
			AddHours(value: number): System.TimeOnly;

			AddHours(value: number): { result: System.TimeOnly, wrappedDays: number };

			/**
			 * Returns a new {@link System.TimeOnly} that adds the specified number of minutes to the
			 * value of this instance.
			 */
			AddMinutes(value: number): System.TimeOnly;

			AddMinutes(value: number): { result: System.TimeOnly, wrappedDays: number };

			/**
			 * Compares the value of this instance to a specified object that contains a specified
			 * {@link System.TimeOnly} value, and returns an integer that indicates whether this
			 * instance is earlier than, the same as, or later than the specified
			 * {@link System.TimeOnly} value.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Compares the value of this instance to a specified {@link System.TimeOnly} value and
			 * indicates whether this instance is earlier than, the same as, or later than the
			 * specified {@link System.TimeOnly} value.
			 */
			CompareTo(value: System.TimeOnly): number;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Returns a value indicating whether the value of this instance is equal to the value of
			 * the specified {@link System.TimeOnly} instance.
			 */
			Equals(value: System.TimeOnly): boolean;

			/**
			 * Constructs a {@link System.TimeOnly} object from a {@link System.DateTime}
			 * representing the time of the day in this {@link System.DateTime} object.
			 */
			static FromDateTime(dateTime: js.DateTime): System.TimeOnly;

			/**
			 * Constructs a {@link System.TimeOnly} object from a time span representing the time
			 * elapsed since midnight.
			 */
			static FromTimeSpan(timeSpan: number): System.TimeOnly;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Determines if a time falls within the range provided. Supports both "normal" ranges
			 * such as 10:00-12:00, and ranges that span midnight such as 23:00-01:00.
			 */
			IsBetween(
				start: System.TimeOnly,
				end: System.TimeOnly,
			): boolean;

			Deconstruct(): { hour: number, minute: number };

			Deconstruct(): { hour: number, minute: number, second: number };

			Deconstruct(): { hour: number, minute: number, second: number, millisecond: number };

			Deconstruct(): { hour: number, minute: number, second: number, millisecond: number, microsecond: number };

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.TimeOnly;

			/**
			 * Converts a memory span that contains string representation of a time to its
			 * equivalent by using culture-specific format information and a formatting style.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
				style?: System.Globalization.DateTimeStyles,
			): System.TimeOnly;

			/**
			 * Converts the string representation of a time to its {@link System.TimeOnly} equivalent
			 * by using the conventions of the current culture.
			 */
			static Parse(s: string): System.TimeOnly;

			/** Parses a string into a value. */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): System.TimeOnly;

			/**
			 * Converts the string representation of a time to its {@link System.TimeOnly} equivalent
			 * by using culture-specific format information and a formatting style.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
				style?: System.Globalization.DateTimeStyles,
			): System.TimeOnly;

			/**
			 * Converts the specified span representation of a time to its {@link System.TimeOnly}
			 * equivalent using the specified format, culture-specific format information, and style.
			 * The format of the string representation must match the specified format exactly or an
			 * exception is thrown.
			 */
			static ParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
				style?: System.Globalization.DateTimeStyles,
			): System.TimeOnly;

			/**
			 * Converts the specified span to its {@link System.TimeOnly} equivalent using the
			 * specified array of formats. The format of the string representation must match at
			 * least one of the specified formats exactly or an exception is thrown.
			 */
			static ParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				formats: string[],
			): System.TimeOnly;

			/**
			 * Converts the specified span representation of a time to its {@link System.TimeOnly}
			 * equivalent using the specified array of formats, culture-specific format information,
			 * and style. The format of the string representation must match at least one of the
			 * specified formats exactly or an exception is thrown.
			 */
			static ParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				formats: string[],
				provider: System.IFormatProvider | undefined,
				style?: System.Globalization.DateTimeStyles,
			): System.TimeOnly;

			/**
			 * Converts the specified string representation of a time to its {@link System.TimeOnly}
			 * equivalent using the specified format. The format of the string representation must
			 * match the specified format exactly or an exception is thrown.
			 */
			static ParseExact(
				s: string,
				format: string,
			): System.TimeOnly;

			/**
			 * Converts the specified string representation of a time to its {@link System.TimeOnly}
			 * equivalent using the specified format, culture-specific format information, and style.
			 * The format of the string representation must match the specified format exactly or an
			 * exception is thrown.
			 */
			static ParseExact(
				s: string,
				format: string,
				provider: System.IFormatProvider | undefined,
				style?: System.Globalization.DateTimeStyles,
			): System.TimeOnly;

			/**
			 * Converts the specified span to a {@link System.TimeOnly} equivalent using the
			 * specified array of formats. The format of the string representation must match at
			 * least one of the specified formats exactly or an exception is thrown.
			 */
			static ParseExact(
				s: string,
				formats: string[],
			): System.TimeOnly;

			/**
			 * Converts the specified string representation of a time to its {@link System.TimeOnly}
			 * equivalent using the specified array of formats, culture-specific format information,
			 * and style. The format of the string representation must match at least one of the
			 * specified formats exactly or an exception is thrown.
			 */
			static ParseExact(
				s: string,
				formats: string[],
				provider: System.IFormatProvider | undefined,
				style?: System.Globalization.DateTimeStyles,
			): System.TimeOnly;

			/**
			 * Converts the value of the current {@link System.TimeOnly} instance to its equivalent
			 * long date string representation.
			 */
			ToLongTimeString(): string;

			/**
			 * Converts the current {@link System.TimeOnly} instance to its equivalent short time
			 * string representation.
			 */
			ToShortTimeString(): string;

			/**
			 * Converts the current {@link System.TimeOnly} instance to its equivalent short time
			 * string representation using the formatting conventions of the current culture.
			 */
			ToString(): string;

			/**
			 * Converts the value of the current {@link System.TimeOnly} instance to its equivalent
			 * string representation using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the current {@link System.TimeOnly} instance to its equivalent string
			 * representation using the specified format and the formatting conventions of the
			 * current culture.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the value of the current {@link System.TimeOnly} instance to its equivalent
			 * string representation using the specified culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/**
			 * Convert the current {@link System.TimeOnly} instance to a {@link System.TimeSpan}
			 * object.
			 */
			ToTimeSpan(): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.TimeOnly | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.TimeOnly | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): System.TimeOnly | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.TimeOnly | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): System.TimeOnly | undefined;

			static TryParse(s: string | undefined): System.TimeOnly | undefined;

			static TryParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.TimeOnly | undefined;

			static TryParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
			): System.TimeOnly | undefined;

			static TryParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				formats: string | undefined[] | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.TimeOnly | undefined;

			static TryParseExact(
				s: System.ReadOnlySpan$1<System.Char>,
				formats: string | undefined[] | undefined,
			): System.TimeOnly | undefined;

			static TryParseExact(
				s: string | undefined,
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.TimeOnly | undefined;

			static TryParseExact(
				s: string | undefined,
				format: string | undefined,
			): System.TimeOnly | undefined;

			static TryParseExact(
				s: string | undefined,
				formats: string | undefined[] | undefined,
				provider: System.IFormatProvider | undefined,
				style: System.Globalization.DateTimeStyles,
			): System.TimeOnly | undefined;

			static TryParseExact(
				s: string | undefined,
				formats: string | undefined[] | undefined,
			): System.TimeOnly | undefined;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when the time allotted for a process or operation has
		 * expired.
		 */
		export class TimeoutException extends System.SystemException {
			/** Initializes a new instance of the {@link System.TimeoutException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.TimeoutException} class with the
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.TimeoutException} class with the
			 * specified error message and inner exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Represents a time interval. */
		export class TimeSpan extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.IUtf8SpanFormattable {
			/**
			 * Initializes a new instance of the {@link System.TimeSpan} structure to a specified
			 * number of hours, minutes, and seconds.
			 */
			constructor(
				hours: number,
				minutes: number,
				seconds: number,
			);

			/**
			 * Initializes a new instance of the {@link System.TimeSpan} structure to a specified
			 * number of days, hours, minutes, and seconds.
			 */
			constructor(
				days: number,
				hours: number,
				minutes: number,
				seconds: number,
			);

			/**
			 * Initializes a new instance of the {@link System.TimeSpan} structure to a specified
			 * number of days, hours, minutes, seconds, and milliseconds.
			 */
			constructor(
				days: number,
				hours: number,
				minutes: number,
				seconds: number,
				milliseconds: number,
			);

			/**
			 * Initializes a new instance of the {@link System.TimeSpan} structure to a specified
			 * number of days, hours, minutes, seconds, milliseconds, and microseconds.
			 */
			constructor(
				days: number,
				hours: number,
				minutes: number,
				seconds: number,
				milliseconds: number,
				microseconds: number,
			);

			/**
			 * Initializes a new instance of the {@link System.TimeSpan} structure to the specified
			 * number of ticks.
			 */
			constructor(ticks: number);

			/**
			 * Gets the days component of the time interval represented by the current
			 * {@link System.TimeSpan} structure.
			 */
			readonly Days: number;

			/**
			 * Gets the hours component of the time interval represented by the current
			 * {@link System.TimeSpan} structure.
			 */
			readonly Hours: number;

			/**
			 * Gets the microseconds component of the time interval represented by the current
			 * {@link System.TimeSpan} structure.
			 */
			readonly Microseconds: number;

			/**
			 * Gets the milliseconds component of the time interval represented by the current
			 * {@link System.TimeSpan} structure.
			 */
			readonly Milliseconds: number;

			/**
			 * Gets the minutes component of the time interval represented by the current
			 * {@link System.TimeSpan} structure.
			 */
			readonly Minutes: number;

			/**
			 * Gets the nanoseconds component of the time interval represented by the current
			 * {@link System.TimeSpan} structure.
			 */
			readonly Nanoseconds: number;

			/**
			 * Gets the seconds component of the time interval represented by the current
			 * {@link System.TimeSpan} structure.
			 */
			readonly Seconds: number;

			/**
			 * Gets the number of ticks that represent the value of the current
			 * {@link System.TimeSpan} structure.
			 */
			readonly Ticks: number;

			/**
			 * Gets the value of the current {@link System.TimeSpan} structure expressed in whole and
			 * fractional days.
			 */
			readonly TotalDays: number;

			/**
			 * Gets the value of the current {@link System.TimeSpan} structure expressed in whole and
			 * fractional hours.
			 */
			readonly TotalHours: number;

			/**
			 * Gets the value of the current {@link System.TimeSpan} structure expressed in whole and
			 * fractional microseconds.
			 */
			readonly TotalMicroseconds: number;

			/**
			 * Gets the value of the current {@link System.TimeSpan} structure expressed in whole and
			 * fractional milliseconds.
			 */
			readonly TotalMilliseconds: number;

			/**
			 * Gets the value of the current {@link System.TimeSpan} structure expressed in whole and
			 * fractional minutes.
			 */
			readonly TotalMinutes: number;

			/**
			 * Gets the value of the current {@link System.TimeSpan} structure expressed in whole and
			 * fractional nanoseconds.
			 */
			readonly TotalNanoseconds: number;

			/**
			 * Gets the value of the current {@link System.TimeSpan} structure expressed in whole and
			 * fractional seconds.
			 */
			readonly TotalSeconds: number;

			/**
			 * Returns a new {@link System.TimeSpan} object whose value is the sum of the specified
			 * {@link System.TimeSpan} object and this instance.
			 */
			Add(ts: number): number;

			/**
			 * Compares two {@link System.TimeSpan} values and returns an integer that indicates
			 * whether the first value is shorter than, equal to, or longer than the second value.
			 */
			static Compare(
				t1: number,
				t2: number,
			): number;

			/**
			 * Compares this instance to a specified object and returns an integer that indicates
			 * whether this instance is shorter than, equal to, or longer than the specified object.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Compares this instance to a specified {@link System.TimeSpan} object and returns an
			 * integer that indicates whether this instance is shorter than, equal to, or longer than
			 * the {@link System.TimeSpan} object.
			 */
			CompareTo(value: number): number;

			/**
			 * Returns a new {@link System.TimeSpan} object whose value is the result of dividing
			 * this instance by the specified `divisor`.
			 */
			Divide(divisor: number): number;

			/**
			 * Returns a new {@link System.Double} value that's the result of dividing this instance
			 * by `ts`.
			 */
			Divide(ts: number): number;

			/**
			 * Returns a new {@link System.TimeSpan} object whose value is the absolute value of the
			 * current {@link System.TimeSpan} object.
			 */
			Duration(): number;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Returns a value indicating whether this instance is equal to a specified
			 * {@link System.TimeSpan} object.
			 */
			Equals(obj: number): boolean;

			/**
			 * Returns a value that indicates whether two specified instances of
			 * {@link System.TimeSpan} are equal.
			 */
			static Equals(
				t1: number,
				t2: number,
			): boolean;

			/**
			 * Returns a {@link System.TimeSpan} that represents a specified number of days, where
			 * the specification is accurate to the nearest millisecond.
			 */
			static FromDays(value: number): number;

			/**
			 * Returns a {@link System.TimeSpan} that represents a specified number of hours, where
			 * the specification is accurate to the nearest millisecond.
			 */
			static FromHours(value: number): number;

			/**
			 * Returns a {@link System.TimeSpan} that represents a specified number of microseconds.
			 */
			static FromMicroseconds(value: number): number;

			/**
			 * Returns a {@link System.TimeSpan} that represents a specified number of milliseconds.
			 */
			static FromMilliseconds(value: number): number;

			/**
			 * Returns a {@link System.TimeSpan} that represents a specified number of minutes, where
			 * the specification is accurate to the nearest millisecond.
			 */
			static FromMinutes(value: number): number;

			/**
			 * Returns a {@link System.TimeSpan} that represents a specified number of seconds, where
			 * the specification is accurate to the nearest millisecond.
			 */
			static FromSeconds(value: number): number;

			/**
			 * Returns a {@link System.TimeSpan} that represents a specified time, where the
			 * specification is in units of ticks.
			 */
			static FromTicks(value: number): number;

			/** Returns a hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Returns a new {@link System.TimeSpan} object which value is the result of
			 * multiplication of this instance and the specified `factor`.
			 */
			Multiply(factor: number): number;

			/**
			 * Returns a new {@link System.TimeSpan} object whose value is the negated value of this
			 * instance.
			 */
			Negate(): number;

			/**
			 * Converts the span representation of a time interval to its {@link System.TimeSpan}
			 * equivalent by using the specified culture-specific format information.
			 */
			static Parse(
				input: System.ReadOnlySpan$1<System.Char>,
				formatProvider?: System.IFormatProvider,
			): number;

			/**
			 * Converts the string representation of a time interval to its {@link System.TimeSpan}
			 * equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a time interval to its {@link System.TimeSpan}
			 * equivalent by using the specified culture-specific format information.
			 */
			static Parse(
				input: string,
				formatProvider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the char span of a time interval to its {@link System.TimeSpan} equivalent by
			 * using the specified format and culture-specific format information. The format of the
			 * string representation must match the specified format exactly.
			 */
			static ParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				formatProvider: System.IFormatProvider | undefined,
				styles?: System.Globalization.TimeSpanStyles,
			): number;

			/**
			 * Converts the string representation of a time interval to its {@link System.TimeSpan}
			 * equivalent by using the specified formats, culture-specific format information, and
			 * styles. The format of the string representation must match one of the specified
			 * formats exactly.
			 */
			static ParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				formats: string[],
				formatProvider: System.IFormatProvider | undefined,
				styles?: System.Globalization.TimeSpanStyles,
			): number;

			/**
			 * Converts the string representation of a time interval to its {@link System.TimeSpan}
			 * equivalent by using the specified format and culture-specific format information. The
			 * format of the string representation must match the specified format exactly.
			 */
			static ParseExact(
				input: string,
				format: string,
				formatProvider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a time interval to its {@link System.TimeSpan}
			 * equivalent by using the specified format, culture-specific format information, and
			 * styles. The format of the string representation must match the specified format
			 * exactly.
			 */
			static ParseExact(
				input: string,
				format: string,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.TimeSpanStyles,
			): number;

			/**
			 * Converts the string representation of a time interval to its {@link System.TimeSpan}
			 * equivalent by using the specified array of format strings and culture-specific format
			 * information. The format of the string representation must match one of the specified
			 * formats exactly.
			 */
			static ParseExact(
				input: string,
				formats: string[],
				formatProvider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a time interval to its {@link System.TimeSpan}
			 * equivalent by using the specified formats, culture-specific format information, and
			 * styles. The format of the string representation must match one of the specified
			 * formats exactly.
			 */
			static ParseExact(
				input: string,
				formats: string[],
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.TimeSpanStyles,
			): number;

			/**
			 * Returns a new {@link System.TimeSpan} object whose value is the difference between the
			 * specified {@link System.TimeSpan} object and this instance.
			 */
			Subtract(ts: number): number;

			/**
			 * Converts the value of the current {@link System.TimeSpan} object to its equivalent
			 * string representation.
			 */
			ToString(): string;

			/**
			 * Converts the value of the current {@link System.TimeSpan} object to its equivalent
			 * string representation by using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the value of the current {@link System.TimeSpan} object to its equivalent
			 * string representation by using the specified format and culture-specific formatting
			 * information.
			 */
			ToString(
				format: string | undefined,
				formatProvider: System.IFormatProvider | undefined,
			): string;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				formatProvider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				formatProvider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				input: System.ReadOnlySpan$1<System.Char>,
				formatProvider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				input: string | undefined,
				formatProvider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;

			static TryParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.TimeSpanStyles,
			): number | undefined;

			static TryParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				format: System.ReadOnlySpan$1<System.Char>,
				formatProvider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				formats: string | undefined[] | undefined,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.TimeSpanStyles,
			): number | undefined;

			static TryParseExact(
				input: System.ReadOnlySpan$1<System.Char>,
				formats: string | undefined[] | undefined,
				formatProvider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParseExact(
				input: string | undefined,
				format: string | undefined,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.TimeSpanStyles,
			): number | undefined;

			static TryParseExact(
				input: string | undefined,
				format: string | undefined,
				formatProvider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParseExact(
				input: string | undefined,
				formats: string | undefined[] | undefined,
				formatProvider: System.IFormatProvider | undefined,
				styles: System.Globalization.TimeSpanStyles,
			): number | undefined;

			static TryParseExact(
				input: string | undefined,
				formats: string | undefined[] | undefined,
				formatProvider: System.IFormatProvider | undefined,
			): number | undefined;
		}
	}

	export namespace System {
		/** Represents a time zone. */
		export class TimeZone {
			/** Gets the time zone of the current computer. */
			static readonly CurrentTimeZone: System.TimeZone;

			/** Gets the daylight saving time zone name. */
			readonly DaylightName: string;

			/** Gets the standard time zone name. */
			readonly StandardName: string;

			/** Returns the daylight saving time period for a particular year. */
			GetDaylightChanges(year: number): System.Globalization.DaylightTime;

			/** Returns the Coordinated Universal Time (UTC) offset for the specified local time. */
			GetUtcOffset(time: js.DateTime): number;

			/**
			 * Returns a value indicating whether the specified date and time is within a daylight
			 * saving time period.
			 */
			IsDaylightSavingTime(time: js.DateTime): boolean;

			/**
			 * Returns a value indicating whether the specified date and time is within the specified
			 * daylight saving time period.
			 */
			static IsDaylightSavingTime(
				time: js.DateTime,
				daylightTimes: System.Globalization.DaylightTime,
			): boolean;

			/** Returns the local time that corresponds to a specified date and time value. */
			ToLocalTime(time: js.DateTime): js.DateTime;

			/** Returns the Coordinated Universal Time (UTC) that corresponds to a specified time. */
			ToUniversalTime(time: js.DateTime): js.DateTime;
		}
	}

	export namespace System {
		/** Represents any time zone in the world. */
		export class TimeZoneInfo implements System.IEquatable$1<System.TimeZoneInfo> {
			/**
			 * Gets the time difference between the current time zone's standard time and Coordinated
			 * Universal Time (UTC).
			 */
			readonly BaseUtcOffset: number;

			/** Gets the display name for the current time zone's daylight saving time. */
			readonly DaylightName: string;

			/** Gets the general display name that represents the time zone. */
			readonly DisplayName: string;

			/** Returns `true` if this TimeZoneInfo object has an IANA ID. */
			readonly HasIanaId: boolean;

			/** Gets the time zone identifier. */
			readonly Id: string;

			/** Gets a {@link System.TimeZoneInfo} object that represents the local time zone. */
			static readonly Local: System.TimeZoneInfo;

			/** Gets the display name for the time zone's standard time. */
			readonly StandardName: string;

			/** Gets a value indicating whether the time zone has any daylight saving time rules. */
			readonly SupportsDaylightSavingTime: boolean;

			/**
			 * Gets a {@link System.TimeZoneInfo} object that represents the Coordinated Universal
			 * Time (UTC) zone.
			 */
			static readonly Utc: System.TimeZoneInfo;

			/** Clears cached time zone data. */
			static ClearCachedData(): void;

			/** Converts a time to the time in a particular time zone. */
			static ConvertTime(
				dateTime: js.DateTime,
				destinationTimeZone: System.TimeZoneInfo,
			): js.DateTime;

			/** Converts a time from one time zone to another. */
			static ConvertTime(
				dateTime: js.DateTime,
				sourceTimeZone: System.TimeZoneInfo,
				destinationTimeZone: System.TimeZoneInfo,
			): js.DateTime;

			/** Converts a time to the time in a particular time zone. */
			static ConvertTime(
				dateTimeOffset: js.DateTimeOffset,
				destinationTimeZone: System.TimeZoneInfo,
			): js.DateTimeOffset;

			/**
			 * Converts a time to the time in another time zone based on the time zone's identifier.
			 */
			static ConvertTimeBySystemTimeZoneId(
				dateTime: js.DateTime,
				destinationTimeZoneId: string,
			): js.DateTime;

			/** Converts a time from one time zone to another based on time zone identifiers. */
			static ConvertTimeBySystemTimeZoneId(
				dateTime: js.DateTime,
				sourceTimeZoneId: string,
				destinationTimeZoneId: string,
			): js.DateTime;

			/**
			 * Converts a time to the time in another time zone based on the time zone's identifier.
			 */
			static ConvertTimeBySystemTimeZoneId(
				dateTimeOffset: js.DateTimeOffset,
				destinationTimeZoneId: string,
			): js.DateTimeOffset;

			/** Converts a Coordinated Universal Time (UTC) to the time in a specified time zone. */
			static ConvertTimeFromUtc(
				dateTime: js.DateTime,
				destinationTimeZone: System.TimeZoneInfo,
			): js.DateTime;

			/** Converts the specified date and time to Coordinated Universal Time (UTC). */
			static ConvertTimeToUtc(dateTime: js.DateTime): js.DateTime;

			/** Converts the time in a specified time zone to Coordinated Universal Time (UTC). */
			static ConvertTimeToUtc(
				dateTime: js.DateTime,
				sourceTimeZone: System.TimeZoneInfo,
			): js.DateTime;

			/**
			 * Creates a custom time zone with a specified identifier, an offset from Coordinated
			 * Universal Time (UTC), a display name, and a standard time display name.
			 */
			static CreateCustomTimeZone(
				id: string,
				baseUtcOffset: number,
				displayName: string | undefined,
				standardDisplayName: string | undefined,
			): System.TimeZoneInfo;

			static CreateCustomTimeZone(
				id: string,
				baseUtcOffset: number,
				displayName: string | undefined,
				standardDisplayName: string | undefined,
				daylightDisplayName: string | undefined,
				adjustmentRules: System.TimeZoneInfo.AdjustmentRule[] | undefined,
			): System.TimeZoneInfo;

			static CreateCustomTimeZone(
				id: string,
				baseUtcOffset: number,
				displayName: string | undefined,
				standardDisplayName: string | undefined,
				daylightDisplayName: string | undefined,
				adjustmentRules: System.TimeZoneInfo.AdjustmentRule[] | undefined,
				disableDaylightSavingTime: boolean,
			): System.TimeZoneInfo;

			/**
			 * Determines whether the current {@link System.TimeZoneInfo} object and another object
			 * are equal.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Determines whether the current {@link System.TimeZoneInfo} object and another
			 * {@link System.TimeZoneInfo} object are equal.
			 */
			Equals(other: System.TimeZoneInfo | undefined): boolean;

			/** Instantiates a new {@link System.TimeZoneInfo} object based on its identifier. */
			static FindSystemTimeZoneById(id: string): System.TimeZoneInfo;

			static TryFindSystemTimeZoneById(id: string): System.TimeZoneInfo | undefined;

			/**
			 * Deserializes a string to re-create an original serialized {@link System.TimeZoneInfo}
			 * object.
			 */
			static FromSerializedString(source: string): System.TimeZoneInfo;

			/**
			 * Retrieves an array of {@link System.TimeZoneInfo.AdjustmentRule} objects that apply to
			 * the current {@link System.TimeZoneInfo} object.
			 */
			GetAdjustmentRules(): System.TimeZoneInfo.AdjustmentRule[];

			/**
			 * Returns information about the possible dates and times that an ambiguous date and time
			 * can be mapped to.
			 */
			GetAmbiguousTimeOffsets(dateTime: js.DateTime): number[];

			/**
			 * Returns information about the possible dates and times that an ambiguous date and time
			 * can be mapped to.
			 */
			GetAmbiguousTimeOffsets(dateTimeOffset: js.DateTimeOffset): number[];

			/**
			 * Serves as a hash function for hashing algorithms and data structures such as hash
			 * tables.
			 */
			GetHashCode(): number;

			/**
			 * Returns a sorted collection of all the time zones about which information is available
			 * on the local system.
			 */
			static GetSystemTimeZones(): readonly System.TimeZoneInfo[];

			/**
			 * Returns a {@link System.Collections.ObjectModel.ReadOnlyCollection<>} containing all
			 * valid TimeZone's from the local machine. This method does not throw
			 * TimeZoneNotFoundException or InvalidTimeZoneException.
			 */
			static GetSystemTimeZones(skipSorting: boolean): readonly System.TimeZoneInfo[];

			/**
			 * Calculates the offset or difference between the time in this time zone and Coordinated
			 * Universal Time (UTC) for a particular date and time.
			 */
			GetUtcOffset(dateTime: js.DateTime): number;

			/**
			 * Calculates the offset or difference between the time in this time zone and Coordinated
			 * Universal Time (UTC) for a particular date and time.
			 */
			GetUtcOffset(dateTimeOffset: js.DateTimeOffset): number;

			/**
			 * Indicates whether the current object and another {@link System.TimeZoneInfo} object
			 * have the same adjustment rules.
			 */
			HasSameRules(other: System.TimeZoneInfo): boolean;

			/**
			 * Determines whether a particular date and time in a particular time zone is ambiguous
			 * and can be mapped to two or more Coordinated Universal Time (UTC) times.
			 */
			IsAmbiguousTime(dateTime: js.DateTime): boolean;

			/**
			 * Determines whether a particular date and time in a particular time zone is ambiguous
			 * and can be mapped to two or more Coordinated Universal Time (UTC) times.
			 */
			IsAmbiguousTime(dateTimeOffset: js.DateTimeOffset): boolean;

			/**
			 * Indicates whether a specified date and time falls in the range of daylight saving time
			 * for the time zone of the current {@link System.TimeZoneInfo} object.
			 */
			IsDaylightSavingTime(dateTime: js.DateTime): boolean;

			/**
			 * Indicates whether a specified date and time falls in the range of daylight saving time
			 * for the time zone of the current {@link System.TimeZoneInfo} object.
			 */
			IsDaylightSavingTime(dateTimeOffset: js.DateTimeOffset): boolean;

			/** Indicates whether a particular date and time is invalid. */
			IsInvalidTime(dateTime: js.DateTime): boolean;

			/** Converts the current {@link System.TimeZoneInfo} object to a serialized string. */
			ToSerializedString(): string;

			/** Returns the current {@link System.TimeZoneInfo} object's display name. */
			ToString(): string;

			static TryConvertIanaIdToWindowsId(ianaId: string): string | undefined;

			static TryConvertWindowsIdToIanaId(
				windowsId: string,
				region: string | undefined,
			): string | undefined;

			static TryConvertWindowsIdToIanaId(windowsId: string): string | undefined;
		}
	}

	export namespace System.TimeZoneInfo {
		export class AdjustmentRule implements System.IEquatable$1<System.TimeZoneInfo.AdjustmentRule> {
			readonly BaseUtcOffsetDelta: number;

			readonly DateEnd: js.DateTime;

			readonly DateStart: js.DateTime;

			readonly DaylightDelta: number;

			readonly DaylightTransitionEnd: System.TimeZoneInfo.TransitionTime;

			readonly DaylightTransitionStart: System.TimeZoneInfo.TransitionTime;

			static CreateAdjustmentRule(
				dateStart: js.DateTime,
				dateEnd: js.DateTime,
				daylightDelta: number,
				daylightTransitionStart: System.TimeZoneInfo.TransitionTime,
				daylightTransitionEnd: System.TimeZoneInfo.TransitionTime,
			): System.TimeZoneInfo.AdjustmentRule;

			static CreateAdjustmentRule(
				dateStart: js.DateTime,
				dateEnd: js.DateTime,
				daylightDelta: number,
				daylightTransitionStart: System.TimeZoneInfo.TransitionTime,
				daylightTransitionEnd: System.TimeZoneInfo.TransitionTime,
				baseUtcOffsetDelta: number,
			): System.TimeZoneInfo.AdjustmentRule;

			Equals(other: System.TimeZoneInfo.AdjustmentRule | undefined): boolean;

			Equals(obj: System.Object | undefined): boolean;

			GetHashCode(): number;
		}
	}

	export namespace System.TimeZoneInfo {
		export class TransitionTime extends System.ValueType implements System.IEquatable$1<System.TimeZoneInfo.TransitionTime> {
			readonly Day: number;

			readonly DayOfWeek: System.DayOfWeek;

			readonly IsFixedDateRule: boolean;

			readonly Month: number;

			readonly TimeOfDay: js.DateTime;

			readonly Week: number;

			static CreateFixedDateRule(
				timeOfDay: js.DateTime,
				month: number,
				day: number,
			): System.TimeZoneInfo.TransitionTime;

			static CreateFloatingDateRule(
				timeOfDay: js.DateTime,
				month: number,
				week: number,
				dayOfWeek: System.DayOfWeek,
			): System.TimeZoneInfo.TransitionTime;

			Equals(obj: System.Object | undefined): boolean;

			Equals(other: System.TimeZoneInfo.TransitionTime): boolean;

			GetHashCode(): number;
		}
	}

	export namespace System {
		/** The exception that is thrown when a time zone cannot be found. */
		export class TimeZoneNotFoundException extends System.Exception {
			/**
			 * Initializes a new instance of the {@link System.TimeZoneNotFoundException} class with
			 * a system-supplied message.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.TimeZoneNotFoundException} class with
			 * the specified message string.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.TimeZoneNotFoundException} class with
			 * a specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Provides static methods for creating tuple objects. */
		export namespace Tuple {
			/** Creates a new 1-tuple, or singleton. */
			export function Create<T1>(item1: T1): [T1];

			/** Creates a new 2-tuple, or pair. */
			export function Create<T1, T2>(
				item1: T1,
				item2: T2,
			): [T1, T2];

			/** Creates a new 3-tuple, or triple. */
			export function Create<T1, T2, T3>(
				item1: T1,
				item2: T2,
				item3: T3,
			): [T1, T2, T3];

			/** Creates a new 4-tuple, or quadruple. */
			export function Create<T1, T2, T3, T4>(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
			): [T1, T2, T3, T4];

			/** Creates a new 5-tuple, or quintuple. */
			export function Create<T1, T2, T3, T4, T5>(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
			): [T1, T2, T3, T4, T5];

			/** Creates a new 6-tuple, or sextuple. */
			export function Create<T1, T2, T3, T4, T5, T6>(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
			): [T1, T2, T3, T4, T5, T6];

			/** Creates a new 7-tuple, or septuple. */
			export function Create<T1, T2, T3, T4, T5, T6, T7>(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
				item7: T7,
			): [T1, T2, T3, T4, T5, T6, T7];

			/** Creates a new 8-tuple, or octuple. */
			export function Create<T1, T2, T3, T4, T5, T6, T7, T8>(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
				item7: T7,
				item8: T8,
			): [T1, T2, T3, T4, T5, T6, T7, [T8]];
		}
	}

	export namespace System {
		/**
		 * Provides extension methods for tuples to interoperate with language support for tuples
		 * in C#.
		 */
		export namespace TupleExtensions {
			export function Deconstruct<T1>(value: [T1]): { item1: T1 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15]]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16]]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17]]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16, item17: T17 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18]]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16, item17: T17, item18: T18 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19]]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16, item17: T17, item18: T18, item19: T19 };

			export function Deconstruct<T1, T2>(value: [T1, T2]): { item1: T1, item2: T2 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19, T20]]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16, item17: T17, item18: T18, item19: T19, item20: T20 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19, T20, T21]]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16, item17: T17, item18: T18, item19: T19, item20: T20, item21: T21 };

			export function Deconstruct<T1, T2, T3>(value: [T1, T2, T3]): { item1: T1, item2: T2, item3: T3 };

			export function Deconstruct<T1, T2, T3, T4>(value: [T1, T2, T3, T4]): { item1: T1, item2: T2, item3: T3, item4: T4 };

			export function Deconstruct<T1, T2, T3, T4, T5>(value: [T1, T2, T3, T4, T5]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6>(value: [T1, T2, T3, T4, T5, T6]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7>(value: [T1, T2, T3, T4, T5, T6, T7]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8>(value: [T1, T2, T3, T4, T5, T6, T7, [T8]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8 };

			export function Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9]]): { item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9 };

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1>(value: [T1]): [T1];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15]]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16]]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17]]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18]]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19]]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2>(value: [T1, T2]): [T1, T2];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19, T20]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19, T20]]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19, T20, T21]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19, T20, T21]]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3>(value: [T1, T2, T3]): [T1, T2, T3];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4>(value: [T1, T2, T3, T4]): [T1, T2, T3, T4];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5>(value: [T1, T2, T3, T4, T5]): [T1, T2, T3, T4, T5];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6>(value: [T1, T2, T3, T4, T5, T6]): [T1, T2, T3, T4, T5, T6];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7>(value: [T1, T2, T3, T4, T5, T6, T7]): [T1, T2, T3, T4, T5, T6, T7];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8>(value: [T1, T2, T3, T4, T5, T6, T7, [T8]]): [T1, T2, T3, T4, T5, T6, T7, [T8]];

			/**
			 * Converts an instance of the `ValueTuple` structure to an instance of the `Tuple`
			 * class.
			 */
			export function ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1>(value: [T1]): [T1];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15]]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16]]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17]]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18]]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19]]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2>(value: [T1, T2]): [T1, T2];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19, T20]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19, T20]]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19, T20, T21]]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9, T10, T11, T12, T13, T14, [T15, T16, T17, T18, T19, T20, T21]]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3>(value: [T1, T2, T3]): [T1, T2, T3];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4>(value: [T1, T2, T3, T4]): [T1, T2, T3, T4];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5>(value: [T1, T2, T3, T4, T5]): [T1, T2, T3, T4, T5];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6>(value: [T1, T2, T3, T4, T5, T6]): [T1, T2, T3, T4, T5, T6];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7>(value: [T1, T2, T3, T4, T5, T6, T7]): [T1, T2, T3, T4, T5, T6, T7];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(value: [T1, T2, T3, T4, T5, T6, T7, [T8]]): [T1, T2, T3, T4, T5, T6, T7, [T8]];

			/**
			 * Converts an instance of the `Tuple` class to an instance of the `ValueTuple`
			 * structure.
			 */
			export function ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value: [T1, T2, T3, T4, T5, T6, T7, [T8, T9]]): [T1, T2, T3, T4, T5, T6, T7, [T8, T9]];
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a 1-tuple, or singleton. */
		export function Tuple$(T1: IType): typeof Tuple$1<any>;

		/** Represents a 1-tuple, or singleton. */
		export class Tuple$1<T1> {
			/** Initializes a new instance of the {@link System.Tuple<>} class. */
			constructor(item1: T1);

			/** Gets the value of the {@link System.Tuple<>} object's single component. */
			readonly Item1: T1;

			/**
			 * Returns a value that indicates whether the current {@link System.Tuple<>} object is
			 * equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for the current {@link System.Tuple<>} object. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.Tuple<>} instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a 2-tuple, or pair. */
		export function Tuple$(T1: IType, T2: IType): typeof Tuple$2<any, any>;

		/** Represents a 2-tuple, or pair. */
		export class Tuple$2<T1, T2> {
			/** Initializes a new instance of the {@link System.Tuple<,>} class. */
			constructor(
				item1: T1,
				item2: T2,
			);

			/** Gets the value of the current {@link System.Tuple<,>} object's first component. */
			readonly Item1: T1;

			/** Gets the value of the current {@link System.Tuple<,>} object's second component. */
			readonly Item2: T2;

			/**
			 * Returns a value that indicates whether the current {@link System.Tuple<,>} object is
			 * equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for the current {@link System.Tuple<,>} object. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.Tuple<,>} instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a 3-tuple, or triple. */
		export function Tuple$(T1: IType, T2: IType, T3: IType): typeof Tuple$3<any, any, any>;

		/** Represents a 3-tuple, or triple. */
		export class Tuple$3<T1, T2, T3> {
			/** Initializes a new instance of the {@link System.Tuple<,,>} class. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
			);

			/** Gets the value of the current {@link System.Tuple<,,>} object's first component. */
			readonly Item1: T1;

			/** Gets the value of the current {@link System.Tuple<,,>} object's second component. */
			readonly Item2: T2;

			/** Gets the value of the current {@link System.Tuple<,,>} object's third component. */
			readonly Item3: T3;

			/**
			 * Returns a value that indicates whether the current {@link System.Tuple<,,>} object is
			 * equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for the current {@link System.Tuple<,,>} object. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.Tuple<,,>} instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a 4-tuple, or quadruple. */
		export function Tuple$(T1: IType, T2: IType, T3: IType, T4: IType): typeof Tuple$4<any, any, any, any>;

		/** Represents a 4-tuple, or quadruple. */
		export class Tuple$4<T1, T2, T3, T4> {
			/** Initializes a new instance of the {@link System.Tuple<,,,>} class. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
			);

			/** Gets the value of the current {@link System.Tuple<,,,>} object's first component. */
			readonly Item1: T1;

			/** Gets the value of the current {@link System.Tuple<,,,>} object's second component. */
			readonly Item2: T2;

			/** Gets the value of the current {@link System.Tuple<,,,>} object's third component. */
			readonly Item3: T3;

			/** Gets the value of the current {@link System.Tuple<,,,>} object's fourth component. */
			readonly Item4: T4;

			/**
			 * Returns a value that indicates whether the current {@link System.Tuple<,,,>} object is
			 * equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for the current {@link System.Tuple<,,,>} object. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.Tuple<,,,>} instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a 5-tuple, or quintuple. */
		export function Tuple$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType): typeof Tuple$5<any, any, any, any, any>;

		/** Represents a 5-tuple, or quintuple. */
		export class Tuple$5<T1, T2, T3, T4, T5> {
			/** Initializes a new instance of the {@link System.Tuple<,,,,>} class. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
			);

			/** Gets the value of the current {@link System.Tuple<,,,,>} object's first component. */
			readonly Item1: T1;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,>} object's second component.
			 */
			readonly Item2: T2;

			/** Gets the value of the current {@link System.Tuple<,,,,>} object's third component. */
			readonly Item3: T3;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,>} object's fourth component.
			 */
			readonly Item4: T4;

			/** Gets the value of the current {@link System.Tuple<,,,,>} object's fifth component. */
			readonly Item5: T5;

			/**
			 * Returns a value that indicates whether the current {@link System.Tuple<,,,,>} object
			 * is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for the current {@link System.Tuple<,,,,>} object. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.Tuple<,,,,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a 6-tuple, or sextuple. */
		export function Tuple$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType): typeof Tuple$6<any, any, any, any, any, any>;

		/** Represents a 6-tuple, or sextuple. */
		export class Tuple$6<T1, T2, T3, T4, T5, T6> {
			/** Initializes a new instance of the {@link System.Tuple<,,,,,>} class. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
			);

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,>} object's first component.
			 */
			readonly Item1: T1;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,>} object's second component.
			 */
			readonly Item2: T2;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,>} object's third component.
			 */
			readonly Item3: T3;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,>} object's fourth component.
			 */
			readonly Item4: T4;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,>} object's fifth component.
			 */
			readonly Item5: T5;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,>} object's sixth component.
			 */
			readonly Item6: T6;

			/**
			 * Returns a value that indicates whether the current {@link System.Tuple<,,,,,>} object
			 * is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for the current {@link System.Tuple<,,,,,>} object. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.Tuple<,,,,,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a 7-tuple, or septuple. */
		export function Tuple$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType): typeof Tuple$7<any, any, any, any, any, any, any>;

		/** Represents a 7-tuple, or septuple. */
		export class Tuple$7<T1, T2, T3, T4, T5, T6, T7> {
			/** Initializes a new instance of the {@link System.Tuple<,,,,,,>} class. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
				item7: T7,
			);

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,>} object's first component.
			 */
			readonly Item1: T1;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,>} object's second component.
			 */
			readonly Item2: T2;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,>} object's third component.
			 */
			readonly Item3: T3;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,>} object's fourth component.
			 */
			readonly Item4: T4;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,>} object's fifth component.
			 */
			readonly Item5: T5;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,>} object's sixth component.
			 */
			readonly Item6: T6;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,>} object's seventh component.
			 */
			readonly Item7: T7;

			/**
			 * Returns a value that indicates whether the current {@link System.Tuple<,,,,,,>} object
			 * is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for the current {@link System.Tuple<,,,,,,>} object. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.Tuple<,,,,,,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents an n-tuple, where n is 8 or greater. */
		export function Tuple$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, TRest: IType): typeof Tuple$8<any, any, any, any, any, any, any, any>;

		/** Represents an n-tuple, where n is 8 or greater. */
		export class Tuple$8<T1, T2, T3, T4, T5, T6, T7, TRest> {
			/** Initializes a new instance of the {@link System.Tuple<,,,,,,,>} class. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
				item7: T7,
				rest: TRest,
			);

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,,>} object's first component.
			 */
			readonly Item1: T1;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,,>} object's second component.
			 */
			readonly Item2: T2;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,,>} object's third component.
			 */
			readonly Item3: T3;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,,>} object's fourth component.
			 */
			readonly Item4: T4;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,,>} object's fifth component.
			 */
			readonly Item5: T5;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,,>} object's sixth component.
			 */
			readonly Item6: T6;

			/**
			 * Gets the value of the current {@link System.Tuple<,,,,,,,>} object's seventh
			 * component.
			 */
			readonly Item7: T7;

			/** Gets the current {@link System.Tuple<,,,,,,,>} object's remaining components. */
			readonly Rest: TRest;

			/**
			 * Returns a value that indicates whether the current {@link System.Tuple<,,,,,,,>}
			 * object is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Calculates the hash code for the current {@link System.Tuple<,,,,,,,>} object. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.Tuple<,,,,,,,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/**
		 * Represents type declarations: class types, interface types, array types, value types,
		 * enumeration types, type parameters, generic type definitions, and open or closed
		 * constructed generic types.
		 */
		export class Type extends System.Reflection.MemberInfo implements
			System.Reflection.ICustomAttributeProvider,
			System.Reflection.IReflect {
			/**
			 * Gets the {@link System.Reflection.Assembly} in which the type is declared. For generic
			 * types, gets the {@link System.Reflection.Assembly} in which the generic type is
			 * defined.
			 */
			readonly Assembly: System.Reflection.Assembly;

			/**
			 * Gets the assembly-qualified name of the type, which includes the name of the assembly
			 * from which this {@link System.Type} object was loaded.
			 */
			readonly AssemblyQualifiedName?: string;

			/** Gets the attributes associated with the {@link System.Type}. */
			readonly Attributes: System.Reflection.TypeAttributes;

			/** Gets the type from which the current {@link System.Type} directly inherits. */
			readonly BaseType?: System.Type;

			/**
			 * Gets a value indicating whether the current {@link System.Type} object has type
			 * parameters that have not been replaced by specific types.
			 */
			readonly ContainsGenericParameters: boolean;

			/**
			 * Gets a {@link System.Reflection.MethodBase} that represents the declaring method, if
			 * the current {@link System.Type} represents a type parameter of a generic method.
			 */
			readonly DeclaringMethod?: System.Reflection.MethodBase;

			/** Gets the type that declares the current nested type or generic type parameter. */
			readonly DeclaringType?: System.Type;

			/**
			 * Gets a reference to the default binder, which implements internal rules for selecting
			 * the appropriate members to be called by
			 * {@link System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])}.
			 */
			static readonly DefaultBinder: System.Reflection.Binder;

			/**
			 * Gets the fully qualified name of the type, including its namespace but not its
			 * assembly.
			 */
			readonly FullName?: string;

			/**
			 * Gets a combination of {@link System.Reflection.GenericParameterAttributes} flags that
			 * describe the covariance and special constraints of the current generic type parameter.
			 */
			readonly GenericParameterAttributes: System.Reflection.GenericParameterAttributes;

			/**
			 * Gets the position of the type parameter in the type parameter list of the generic type
			 * or method that declared the parameter, when the {@link System.Type} object represents
			 * a type parameter of a generic type or a generic method.
			 */
			readonly GenericParameterPosition: number;

			/** Gets an array of the generic type arguments for this type. */
			readonly GenericTypeArguments: System.Type[];

			/** Gets the GUID associated with the {@link System.Type}. */
			readonly GUID: string;

			/**
			 * Gets a value indicating whether the current {@link System.Type} encompasses or refers
			 * to another type; that is, whether the current {@link System.Type} is an array, a
			 * pointer, or is passed by reference.
			 */
			readonly HasElementType: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} is abstract and must be
			 * overridden.
			 */
			readonly IsAbstract: boolean;

			/**
			 * Gets a value indicating whether the string format attribute `AnsiClass` is selected
			 * for the {@link System.Type}.
			 */
			readonly IsAnsiClass: boolean;

			/** Gets a value that indicates whether the type is an array. */
			readonly IsArray: boolean;

			/**
			 * Gets a value indicating whether the string format attribute `AutoClass` is selected
			 * for the {@link System.Type}.
			 */
			readonly IsAutoClass: boolean;

			/**
			 * Gets a value indicating whether the fields of the current type are laid out
			 * automatically by the common language runtime.
			 */
			readonly IsAutoLayout: boolean;

			/** Gets a value indicating whether the {@link System.Type} is passed by reference. */
			readonly IsByRef: boolean;

			/** Gets a value that indicates whether the type is a byref-like structure. */
			readonly IsByRefLike: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} is a class or a delegate; that
			 * is, not a value type or interface.
			 */
			readonly IsClass: boolean;

			/** Gets a value indicating whether the {@link System.Type} is a COM object. */
			readonly IsCOMObject: boolean;

			/**
			 * Gets a value that indicates whether this object represents a constructed generic type.
			 * You can create instances of a constructed generic type.
			 */
			readonly IsConstructedGenericType: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} can be hosted in a context.
			 */
			readonly IsContextful: boolean;

			/**
			 * Gets a value indicating whether the current {@link System.Type} represents an
			 * enumeration.
			 */
			readonly IsEnum: boolean;

			/**
			 * Gets a value indicating whether the fields of the current type are laid out at
			 * explicitly specified offsets.
			 */
			readonly IsExplicitLayout: boolean;

			/**
			 * Gets a value that indicates whether the current {@link System.Type} is a function
			 * pointer.
			 */
			readonly IsFunctionPointer: boolean;

			/**
			 * Gets a value that indicates whether the current {@link System.Type} represents a type
			 * parameter in the definition of a generic method.
			 */
			readonly IsGenericMethodParameter: boolean;

			/**
			 * Gets a value indicating whether the current {@link System.Type} represents a type
			 * parameter in the definition of a generic type or method.
			 */
			readonly IsGenericParameter: boolean;

			/** Gets a value indicating whether the current type is a generic type. */
			readonly IsGenericType: boolean;

			/**
			 * Gets a value indicating whether the current {@link System.Type} represents a generic
			 * type definition, from which other generic types can be constructed.
			 */
			readonly IsGenericTypeDefinition: boolean;

			/**
			 * Gets a value that indicates whether the current {@link System.Type} represents a type
			 * parameter in the definition of a generic type.
			 */
			readonly IsGenericTypeParameter: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} has a
			 * {@link System.Runtime.InteropServices.ComImportAttribute} attribute applied,
			 * indicating that it was imported from a COM type library.
			 */
			readonly IsImport: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} is an interface; that is, not
			 * a class or a value type.
			 */
			readonly IsInterface: boolean;

			/**
			 * Gets a value indicating whether the fields of the current type are laid out
			 * sequentially, in the order that they were defined or emitted to the metadata.
			 */
			readonly IsLayoutSequential: boolean;

			/** Gets a value indicating whether the {@link System.Type} is marshaled by reference. */
			readonly IsMarshalByRef: boolean;

			/**
			 * Gets a value indicating whether the current {@link System.Type} object represents a
			 * type whose definition is nested inside the definition of another type.
			 */
			readonly IsNested: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} is nested and visible only
			 * within its own assembly.
			 */
			readonly IsNestedAssembly: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} is nested and visible only to
			 * classes that belong to both its own family and its own assembly.
			 */
			readonly IsNestedFamANDAssem: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} is nested and visible only
			 * within its own family.
			 */
			readonly IsNestedFamily: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} is nested and visible only to
			 * classes that belong to either its own family or to its own assembly.
			 */
			readonly IsNestedFamORAssem: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} is nested and declared
			 * private.
			 */
			readonly IsNestedPrivate: boolean;

			/** Gets a value indicating whether a class is nested and declared public. */
			readonly IsNestedPublic: boolean;

			/** Gets a value indicating whether the {@link System.Type} is not declared public. */
			readonly IsNotPublic: boolean;

			/** Gets a value indicating whether the {@link System.Type} is a pointer. */
			readonly IsPointer: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} is one of the primitive types.
			 */
			readonly IsPrimitive: boolean;

			/** Gets a value indicating whether the {@link System.Type} is declared public. */
			readonly IsPublic: boolean;

			/** Gets a value indicating whether the {@link System.Type} is declared sealed. */
			readonly IsSealed: boolean;

			/**
			 * Gets a value that indicates whether the current type is security-critical or
			 * security-safe-critical at the current trust level, and therefore can perform critical
			 * operations.
			 */
			readonly IsSecurityCritical: boolean;

			/**
			 * Gets a value that indicates whether the current type is security-safe-critical at the
			 * current trust level; that is, whether it can perform critical operations and can be
			 * accessed by transparent code.
			 */
			readonly IsSecuritySafeCritical: boolean;

			/**
			 * Gets a value that indicates whether the current type is transparent at the current
			 * trust level, and therefore cannot perform critical operations.
			 */
			readonly IsSecurityTransparent: boolean;

			/** Gets a value indicating whether the {@link System.Type} is binary serializable. */
			readonly IsSerializable: boolean;

			/** Gets a value that indicates whether the type is a signature type. */
			readonly IsSignatureType: boolean;

			/**
			 * Gets a value indicating whether the type has a name that requires special handling.
			 */
			readonly IsSpecialName: boolean;

			/**
			 * Gets a value that indicates whether the type is an array type that can represent only
			 * a single-dimensional array with a zero lower bound.
			 */
			readonly IsSZArray: boolean;

			/** Gets a value that indicates whether the type is a type definition. */
			readonly IsTypeDefinition: boolean;

			/**
			 * Gets a value indicating whether the string format attribute `UnicodeClass` is selected
			 * for the {@link System.Type}.
			 */
			readonly IsUnicodeClass: boolean;

			/**
			 * Gets a value that indicates whether the current {@link System.Type} is an unmanaged
			 * function pointer.
			 */
			readonly IsUnmanagedFunctionPointer: boolean;

			/** Gets a value indicating whether the {@link System.Type} is a value type. */
			readonly IsValueType: boolean;

			/**
			 * Gets a value that indicates whether the type is an array type that can represent a
			 * multi-dimensional array or an array with an arbitrary lower bound.
			 */
			readonly IsVariableBoundArray: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Type} can be accessed by code
			 * outside the assembly.
			 */
			readonly IsVisible: boolean;

			/**
			 * Gets a {@link System.Reflection.MemberTypes} value indicating that this member is a
			 * type or a nested type.
			 */
			readonly MemberType: System.Reflection.MemberTypes;

			/** Gets the module (the DLL) in which the current {@link System.Type} is defined. */
			readonly Module: System.Reflection.Module;

			/** Gets the namespace of the {@link System.Type}. */
			readonly Namespace?: string;

			/** Gets the class object that was used to obtain this member. */
			readonly ReflectedType?: System.Type;

			/** Gets the handle for the current {@link System.Type}. */
			readonly TypeHandle: System.RuntimeTypeHandle;

			/** Gets the initializer for the type. */
			readonly TypeInitializer?: System.Reflection.ConstructorInfo;

			/**
			 * Indicates the type provided by the common language runtime that represents this type.
			 */
			readonly UnderlyingSystemType: System.Type;

			/**
			 * Determines if the underlying system type of the current {@link System.Type} object is
			 * the same as the underlying system type of the specified {@link System.Object}.
			 */
			Equals(o: System.Object | undefined): boolean;

			/**
			 * Determines if the underlying system type of the current {@link System.Type} is the
			 * same as the underlying system type of the specified {@link System.Type}.
			 */
			Equals(o: System.Type | undefined): boolean;

			/**
			 * Returns an array of {@link System.Type} objects representing a filtered list of
			 * interfaces implemented or inherited by the current {@link System.Type}.
			 */
			FindInterfaces(
				filter: System.Reflection.TypeFilter,
				filterCriteria: System.Object | undefined,
			): System.Type[];

			/**
			 * Returns a filtered array of {@link System.Reflection.MemberInfo} objects of the
			 * specified member type.
			 */
			FindMembers(
				memberType: System.Reflection.MemberTypes,
				bindingAttr: System.Reflection.BindingFlags,
				filter: System.Reflection.MemberFilter | undefined,
				filterCriteria: System.Object | undefined,
			): System.Reflection.MemberInfo[];

			/** Gets the number of dimensions in an array. */
			GetArrayRank(): number;

			/**
			 * Searches for a constructor whose parameters match the specified argument types and
			 * modifiers, using the specified binding constraints and the specified calling
			 * convention.
			 */
			GetConstructor(
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				callConvention: System.Reflection.CallingConventions,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.ConstructorInfo | undefined;

			/**
			 * Searches for a constructor whose parameters match the specified argument types and
			 * modifiers, using the specified binding constraints.
			 */
			GetConstructor(
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.ConstructorInfo | undefined;

			/**
			 * Searches for a constructor whose parameters match the specified argument types, using
			 * the specified binding constraints.
			 */
			GetConstructor(
				bindingAttr: System.Reflection.BindingFlags,
				types: System.Type[],
			): System.Reflection.ConstructorInfo | undefined;

			/**
			 * Searches for a public instance constructor whose parameters match the types in the
			 * specified array.
			 */
			GetConstructor(types: System.Type[]): System.Reflection.ConstructorInfo | undefined;

			/** Returns all the public constructors defined for the current {@link System.Type}. */
			GetConstructors(): System.Reflection.ConstructorInfo[];

			/**
			 * When overridden in a derived class, searches for the constructors defined for the
			 * current {@link System.Type}, using the specified `BindingFlags`.
			 */
			GetConstructors(bindingAttr: System.Reflection.BindingFlags): System.Reflection.ConstructorInfo[];

			/**
			 * Searches for the members defined for the current {@link System.Type} whose
			 * {@link System.Reflection.DefaultMemberAttribute} is set.
			 */
			GetDefaultMembers(): System.Reflection.MemberInfo[];

			/**
			 * When overridden in a derived class, returns the {@link System.Type} of the object
			 * encompassed or referred to by the current array, pointer or reference type.
			 */
			GetElementType(): System.Type | undefined;

			/**
			 * Returns the name of the constant that has the specified value, for the current
			 * enumeration type.
			 */
			GetEnumName(value: System.Object): string | undefined;

			/** Returns the names of the members of the current enumeration type. */
			GetEnumNames(): string[];

			/** Returns the underlying type of the current enumeration type. */
			GetEnumUnderlyingType(): System.Type;

			/** Returns an array of the values of the constants in the current enumeration type. */
			GetEnumValues(): System.Array;

			/**
			 * Retrieves an array of the values of the underlying type constants of this enumeration
			 * type.
			 */
			GetEnumValuesAsUnderlyingType(): System.Array;

			/**
			 * Returns the {@link System.Reflection.EventInfo} object representing the specified
			 * public event.
			 */
			GetEvent(name: string): System.Reflection.EventInfo | undefined;

			/**
			 * When overridden in a derived class, returns the {@link System.Reflection.EventInfo}
			 * object representing the specified event, using the specified binding constraints.
			 */
			GetEvent(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.EventInfo | undefined;

			/**
			 * Returns all the public events that are declared or inherited by the current
			 * {@link System.Type}.
			 */
			GetEvents(): System.Reflection.EventInfo[];

			/**
			 * When overridden in a derived class, searches for events that are declared or inherited
			 * by the current {@link System.Type}, using the specified binding constraints.
			 */
			GetEvents(bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo[];

			/** Searches for the public field with the specified name. */
			GetField(name: string): System.Reflection.FieldInfo | undefined;

			/** Searches for the specified field, using the specified binding constraints. */
			GetField(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.FieldInfo | undefined;

			/** Returns all the public fields of the current {@link System.Type}. */
			GetFields(): System.Reflection.FieldInfo[];

			/**
			 * When overridden in a derived class, searches for the fields defined for the current
			 * {@link System.Type}, using the specified binding constraints.
			 */
			GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];

			/**
			 * When overridden in a derived class, returns the calling conventions of the current
			 * function pointer {@link System.Type}.
			 */
			GetFunctionPointerCallingConventions(): System.Type[];

			/**
			 * When overridden in a derived class, returns the parameter types of the current
			 * function pointer {@link System.Type}.
			 */
			GetFunctionPointerParameterTypes(): System.Type[];

			/**
			 * When overridden in a derived class, returns the return type of the current function
			 * pointer {@link System.Type}.
			 */
			GetFunctionPointerReturnType(): System.Type;

			/**
			 * Returns an array of {@link System.Type} objects that represent the type arguments of a
			 * closed generic type or the type parameters of a generic type definition.
			 */
			GetGenericArguments(): System.Type[];

			/**
			 * Returns an array of {@link System.Type} objects that represent the constraints on the
			 * current generic type parameter.
			 */
			GetGenericParameterConstraints(): System.Type[];

			/**
			 * Returns a {@link System.Type} object that represents a generic type definition from
			 * which the current generic type can be constructed.
			 */
			GetGenericTypeDefinition(): System.Type;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Searches for the interface with the specified name. */
			GetInterface(name: string): System.Type | undefined;

			/**
			 * When overridden in a derived class, searches for the specified interface, specifying
			 * whether to do a case-insensitive search for the interface name.
			 */
			GetInterface(
				name: string,
				ignoreCase: boolean,
			): System.Type | undefined;

			/** Returns an interface mapping for the specified interface type. */
			GetInterfaceMap(interfaceType: System.Type): System.Reflection.InterfaceMapping;

			/**
			 * When overridden in a derived class, gets all the interfaces implemented or inherited
			 * by the current {@link System.Type}.
			 */
			GetInterfaces(): System.Type[];

			/** Searches for the public members with the specified name. */
			GetMember(name: string): System.Reflection.MemberInfo[];

			/** Searches for the specified members, using the specified binding constraints. */
			GetMember(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.MemberInfo[];

			/**
			 * Searches for the specified members of the specified member type, using the specified
			 * binding constraints.
			 */
			GetMember(
				name: string,
				type: System.Reflection.MemberTypes,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.MemberInfo[];

			/** Returns all the public members of the current {@link System.Type}. */
			GetMembers(): System.Reflection.MemberInfo[];

			/**
			 * When overridden in a derived class, searches for the members defined for the current
			 * {@link System.Type}, using the specified binding constraints.
			 */
			GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];

			/**
			 * Searches for the {@link System.Reflection.MemberInfo} on the current
			 * {@link System.Type} that matches the specified {@link System.Reflection.MemberInfo}.
			 */
			GetMemberWithSameMetadataDefinitionAs(member: System.Reflection.MemberInfo): System.Reflection.MemberInfo;

			/** Searches for the public method with the specified name. */
			GetMethod(name: string): System.Reflection.MethodInfo | undefined;

			/**
			 * Searches for the specified method whose parameters match the specified generic
			 * parameter count, argument types and modifiers, using the specified binding constraints
			 * and the specified calling convention.
			 */
			GetMethod(
				name: string,
				genericParameterCount: number,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				callConvention: System.Reflection.CallingConventions,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.MethodInfo | undefined;

			/**
			 * Searches for the specified method whose parameters match the specified generic
			 * parameter count, argument types and modifiers, using the specified binding
			 * constraints.
			 */
			GetMethod(
				name: string,
				genericParameterCount: number,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.MethodInfo | undefined;

			/**
			 * Searches for the specified public method whose parameters match the specified generic
			 * parameter count and argument types.
			 */
			GetMethod(
				name: string,
				genericParameterCount: number,
				types: System.Type[],
			): System.Reflection.MethodInfo | undefined;

			/**
			 * Searches for the specified public method whose parameters match the specified generic
			 * parameter count, argument types and modifiers.
			 */
			GetMethod(
				name: string,
				genericParameterCount: number,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.MethodInfo | undefined;

			/** Searches for the specified method, using the specified binding constraints. */
			GetMethod(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.MethodInfo | undefined;

			/**
			 * Searches for the specified method whose parameters match the specified argument types
			 * and modifiers, using the specified binding constraints and the specified calling
			 * convention.
			 */
			GetMethod(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				callConvention: System.Reflection.CallingConventions,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.MethodInfo | undefined;

			/**
			 * Searches for the specified method whose parameters match the specified argument types
			 * and modifiers, using the specified binding constraints.
			 */
			GetMethod(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.MethodInfo | undefined;

			/**
			 * Searches for the specified method whose parameters match the specified argument types,
			 * using the specified binding constraints.
			 */
			GetMethod(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
				types: System.Type[],
			): System.Reflection.MethodInfo | undefined;

			/**
			 * Searches for the specified public method whose parameters match the specified argument
			 * types.
			 */
			GetMethod(
				name: string,
				types: System.Type[],
			): System.Reflection.MethodInfo | undefined;

			/**
			 * Searches for the specified public method whose parameters match the specified argument
			 * types and modifiers.
			 */
			GetMethod(
				name: string,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.MethodInfo | undefined;

			/** Returns all the public methods of the current {@link System.Type}. */
			GetMethods(): System.Reflection.MethodInfo[];

			/**
			 * When overridden in a derived class, searches for the methods defined for the current
			 * {@link System.Type}, using the specified binding constraints.
			 */
			GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];

			/** Searches for the public nested type with the specified name. */
			GetNestedType(name: string): System.Type | undefined;

			/**
			 * When overridden in a derived class, searches for the specified nested type, using the
			 * specified binding constraints.
			 */
			GetNestedType(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Type | undefined;

			/** Returns the public types nested in the current {@link System.Type}. */
			GetNestedTypes(): System.Type[];

			/**
			 * When overridden in a derived class, searches for the types nested in the current
			 * {@link System.Type}, using the specified binding constraints.
			 */
			GetNestedTypes(bindingAttr: System.Reflection.BindingFlags): System.Type[];

			/**
			 * When overridden in a derived class, returns the optional custom modifiers of the
			 * current {@link System.Type}.
			 */
			GetOptionalCustomModifiers(): System.Type[];

			/** Returns all the public properties of the current {@link System.Type}. */
			GetProperties(): System.Reflection.PropertyInfo[];

			/**
			 * When overridden in a derived class, searches for the properties of the current
			 * {@link System.Type}, using the specified binding constraints.
			 */
			GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];

			/** Searches for the public property with the specified name. */
			GetProperty(name: string): System.Reflection.PropertyInfo | undefined;

			/** Searches for the specified property, using the specified binding constraints. */
			GetProperty(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.PropertyInfo | undefined;

			/**
			 * Searches for the specified property whose parameters match the specified argument
			 * types and modifiers, using the specified binding constraints.
			 */
			GetProperty(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				returnType: System.Type | undefined,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.PropertyInfo | undefined;

			/** Searches for the public property with the specified name and return type. */
			GetProperty(
				name: string,
				returnType: System.Type | undefined,
			): System.Reflection.PropertyInfo | undefined;

			/**
			 * Searches for the specified public property whose parameters match the specified
			 * argument types.
			 */
			GetProperty(
				name: string,
				returnType: System.Type | undefined,
				types: System.Type[],
			): System.Reflection.PropertyInfo | undefined;

			/**
			 * Searches for the specified public property whose parameters match the specified
			 * argument types and modifiers.
			 */
			GetProperty(
				name: string,
				returnType: System.Type | undefined,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.PropertyInfo | undefined;

			/**
			 * Searches for the specified public property whose parameters match the specified
			 * argument types.
			 */
			GetProperty(
				name: string,
				types: System.Type[],
			): System.Reflection.PropertyInfo | undefined;

			/**
			 * When overridden in a derived class, returns the required custom modifiers of the
			 * current {@link System.Type}.
			 */
			GetRequiredCustomModifiers(): System.Type[];

			/** Gets the current {@link System.Type}. */
			GetType(): System.Type;

			/**
			 * Gets the {@link System.Type} with the specified name, performing a case-sensitive
			 * search.
			 */
			static GetType(typeName: string): System.Type | undefined;

			/**
			 * Gets the {@link System.Type} with the specified name, performing a case-sensitive
			 * search and specifying whether to throw an exception if the type is not found.
			 */
			static GetType(
				typeName: string,
				throwOnError: boolean,
			): System.Type | undefined;

			/**
			 * Gets the {@link System.Type} with the specified name, specifying whether to throw an
			 * exception if the type is not found and whether to perform a case-sensitive search.
			 */
			static GetType(
				typeName: string,
				throwOnError: boolean,
				ignoreCase: boolean,
			): System.Type | undefined;

			/**
			 * Gets the type with the specified name, optionally providing custom methods to resolve
			 * the assembly and the type.
			 */
			static GetType(
				typeName: string,
				assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly | undefined> | undefined,
				typeResolver: System.Func$4<System.Reflection.Assembly | undefined, string, boolean, System.Type | undefined> | undefined,
			): System.Type | undefined;

			/**
			 * Gets the type with the specified name, specifying whether to throw an exception if the
			 * type is not found, and optionally providing custom methods to resolve the assembly and
			 * the type.
			 */
			static GetType(
				typeName: string,
				assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly | undefined> | undefined,
				typeResolver: System.Func$4<System.Reflection.Assembly | undefined, string, boolean, System.Type | undefined> | undefined,
				throwOnError: boolean,
			): System.Type | undefined;

			/**
			 * Gets the type with the specified name, specifying whether to perform a case-sensitive
			 * search and whether to throw an exception if the type is not found, and optionally
			 * providing custom methods to resolve the assembly and the type.
			 */
			static GetType(
				typeName: string,
				assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly | undefined> | undefined,
				typeResolver: System.Func$4<System.Reflection.Assembly | undefined, string, boolean, System.Type | undefined> | undefined,
				throwOnError: boolean,
				ignoreCase: boolean,
			): System.Type | undefined;

			/** Gets the types of the objects in the specified array. */
			static GetTypeArray(args: System.Object[]): System.Type[];

			/** Gets the underlying type code of the specified {@link System.Type}. */
			static GetTypeCode(type: System.Type | undefined): System.TypeCode;

			/** Gets the type associated with the specified class identifier (CLSID). */
			static GetTypeFromCLSID(clsid: string): System.Type | undefined;

			/**
			 * Gets the type associated with the specified class identifier (CLSID), specifying
			 * whether to throw an exception if an error occurs while loading the type.
			 */
			static GetTypeFromCLSID(
				clsid: string,
				throwOnError: boolean,
			): System.Type | undefined;

			/**
			 * Gets the type associated with the specified class identifier (CLSID) from the
			 * specified server.
			 */
			static GetTypeFromCLSID(
				clsid: string,
				server: string | undefined,
			): System.Type | undefined;

			/**
			 * Gets the type associated with the specified class identifier (CLSID) from the
			 * specified server, specifying whether to throw an exception if an error occurs while
			 * loading the type.
			 */
			static GetTypeFromCLSID(
				clsid: string,
				server: string | undefined,
				throwOnError: boolean,
			): System.Type | undefined;

			/** Gets the type referenced by the specified type handle. */
			static GetTypeFromHandle(handle: System.RuntimeTypeHandle): System.Type | undefined;

			/**
			 * Gets the type associated with the specified program identifier (ProgID), returning
			 * null if an error is encountered while loading the {@link System.Type}.
			 */
			static GetTypeFromProgID(progID: string): System.Type | undefined;

			/**
			 * Gets the type associated with the specified program identifier (ProgID), specifying
			 * whether to throw an exception if an error occurs while loading the type.
			 */
			static GetTypeFromProgID(
				progID: string,
				throwOnError: boolean,
			): System.Type | undefined;

			/**
			 * Gets the type associated with the specified program identifier (progID) from the
			 * specified server, returning null if an error is encountered while loading the type.
			 */
			static GetTypeFromProgID(
				progID: string,
				server: string | undefined,
			): System.Type | undefined;

			/**
			 * Gets the type associated with the specified program identifier (progID) from the
			 * specified server, specifying whether to throw an exception if an error occurs while
			 * loading the type.
			 */
			static GetTypeFromProgID(
				progID: string,
				server: string | undefined,
				throwOnError: boolean,
			): System.Type | undefined;

			/** Gets the handle for the {@link System.Type} of a specified object. */
			static GetTypeHandle(o: System.Object): System.RuntimeTypeHandle;

			/**
			 * Invokes the specified member, using the specified binding constraints and matching the
			 * specified argument list.
			 */
			InvokeMember(
				name: string,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				target: System.Object | undefined,
				args: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * Invokes the specified member, using the specified binding constraints and matching the
			 * specified argument list and culture.
			 */
			InvokeMember(
				name: string,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				target: System.Object | undefined,
				args: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
			): System.Object | undefined;

			/**
			 * When overridden in a derived class, invokes the specified member, using the specified
			 * binding constraints and matching the specified argument list, modifiers and culture.
			 */
			InvokeMember(
				name: string,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				target: System.Object | undefined,
				args: System.Object | undefined[] | undefined,
				modifiers: System.Reflection.ParameterModifier[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				namedParameters: string[] | undefined,
			): System.Object | undefined;

			/**
			 * Determines whether an instance of a specified type `c` can be assigned to a variable
			 * of the current type.
			 */
			IsAssignableFrom(c: System.Type | undefined): boolean;

			/**
			 * Determines whether the current type can be assigned to a variable of the specified
			 * `targetType`.
			 */
			IsAssignableTo(targetType: System.Type | undefined): boolean;

			/**
			 * Returns a value that indicates whether the specified value exists in the current
			 * enumeration type.
			 */
			IsEnumDefined(value: System.Object): boolean;

			/**
			 * Determines whether two COM types have the same identity and are eligible for type
			 * equivalence.
			 */
			IsEquivalentTo(other: System.Type | undefined): boolean;

			/**
			 * Determines whether the specified object is an instance of the current
			 * {@link System.Type}.
			 */
			IsInstanceOfType(o: System.Object | undefined): boolean;

			/**
			 * Determines whether the current {@link System.Type} derives from the specified
			 * {@link System.Type}.
			 */
			IsSubclassOf(c: System.Type): boolean;

			/**
			 * Returns a {@link System.Type} object representing a one-dimensional array of the
			 * current type, with a lower bound of zero.
			 */
			MakeArrayType(): System.Type;

			/**
			 * Returns a {@link System.Type} object representing an array of the current type, with
			 * the specified number of dimensions.
			 */
			MakeArrayType(rank: number): System.Type;

			/**
			 * Returns a {@link System.Type} object that represents the current type when passed as a
			 * `ref` parameter ( `ByRef` parameter in Visual Basic).
			 */
			MakeByRefType(): System.Type;

			/**
			 * Returns a signature type object that can be passed into the Type[] array parameter of
			 * a {@link System.Type.GetMethod} method to represent a generic parameter reference.
			 */
			static MakeGenericMethodParameter(position: number): System.Type;

			/**
			 * Creates a generic signature type, which allows third party reimplementations of
			 * Reflection to fully support the use of signature types in querying type members.
			 */
			static MakeGenericSignatureType(
				genericTypeDefinition: System.Type,
				typeArguments: System.Type[],
			): System.Type;

			/**
			 * Substitutes the elements of an array of types for the type parameters of the current
			 * generic type definition and returns a {@link System.Type} object representing the
			 * resulting constructed type.
			 */
			MakeGenericType(typeArguments: System.Type[]): System.Type;

			/**
			 * Returns a {@link System.Type} object that represents a pointer to the current type.
			 */
			MakePointerType(): System.Type;

			/**
			 * Gets the {@link System.Type} with the specified name, specifying whether to perform a
			 * case-sensitive search and whether to throw an exception if the type is not found. The
			 * type is loaded for reflection only, not for execution.
			 */
			static ReflectionOnlyGetType(
				typeName: string,
				throwIfNotFound: boolean,
				ignoreCase: boolean,
			): System.Type | undefined;

			/** Returns a `String` representing the name of the current `Type`. */
			ToString(): string;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when a method attempts to use a type that it does not
		 * have access to.
		 */
		export class TypeAccessException extends System.TypeLoadException {
			/**
			 * Initializes a new instance of the {@link System.TypeAccessException} class with a
			 * system-supplied message that describes the error.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.TypeAccessException} class with a
			 * specified message that describes the error.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.TypeAccessException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Specifies the type of an object. */
		export enum TypeCode {
			/** A null reference. */
			Empty = 0,

			/**
			 * A general type representing any reference or value type not explicitly represented by
			 * another `TypeCode`.
			 */
			Object = 1,

			/** A database null (column) value. */
			DBNull = 2,

			/** A simple type representing Boolean values of `true` or `false`. */
			Boolean = 3,

			/**
			 * An integral type representing unsigned 16-bit integers with values between 0 and
			 * 65535. The set of possible values for the {@link System.TypeCode.Char} type
			 * corresponds to the Unicode character set.
			 */
			Char = 4,

			/**
			 * An integral type representing signed 8-bit integers with values between -128 and 127.
			 */
			SByte = 5,

			/**
			 * An integral type representing unsigned 8-bit integers with values between 0 and 255.
			 */
			Byte = 6,

			/**
			 * An integral type representing signed 16-bit integers with values between -32768 and
			 * 32767.
			 */
			Int16 = 7,

			/**
			 * An integral type representing unsigned 16-bit integers with values between 0 and
			 * 65535.
			 */
			UInt16 = 8,

			/**
			 * An integral type representing signed 32-bit integers with values between -2147483648
			 * and 2147483647.
			 */
			Int32 = 9,

			/**
			 * An integral type representing unsigned 32-bit integers with values between 0 and
			 * 4294967295.
			 */
			UInt32 = 10,

			/**
			 * An integral type representing signed 64-bit integers with values between
			 * -9223372036854775808 and 9223372036854775807.
			 */
			Int64 = 11,

			/**
			 * An integral type representing unsigned 64-bit integers with values between 0 and
			 * 18446744073709551615.
			 */
			UInt64 = 12,

			/**
			 * A floating point type representing values ranging from approximately 1.5 x 10 -45 to
			 * 3.4 x 10 38 with a precision of 7 digits.
			 */
			Single = 13,

			/**
			 * A floating point type representing values ranging from approximately 5.0 x 10 -324 to
			 * 1.7 x 10 308 with a precision of 15-16 digits.
			 */
			Double = 14,

			/**
			 * A simple type representing values ranging from 1.0 x 10 -28 to approximately 7.9 x 10
			 * 28 with 28-29 significant digits.
			 */
			Decimal = 15,

			/** A type representing a date and time value. */
			DateTime = 16,

			/** A sealed class type representing Unicode character strings. */
			String = 18,
		}
	}

	export namespace System {
		/**
		 * Describes objects that contain both a managed pointer to a location and a runtime
		 * representation of the type that may be stored at that location.
		 */
		export class TypedReference extends System.ValueType {
			/** Checks if this object is equal to the specified object. */
			Equals(o: System.Object | undefined): boolean;

			/** Returns the hash code of this object. */
			GetHashCode(): number;

			/** Returns the type of the target of the specified `TypedReference`. */
			static GetTargetType(value: System.TypedReference): System.Type;

			/**
			 * Makes a `TypedReference` for a field identified by a specified object and list of
			 * field descriptions.
			 */
			static MakeTypedReference(
				target: System.Object,
				flds: System.Reflection.FieldInfo[],
			): System.TypedReference;

			/** Converts the specified value to a `TypedReference`. This method is not supported. */
			static SetTypedReference(
				target: System.TypedReference,
				value: System.Object | undefined,
			): void;

			/** Returns the internal metadata type handle for the specified `TypedReference`. */
			static TargetTypeToken(value: System.TypedReference): System.RuntimeTypeHandle;

			/** Converts the specified `TypedReference` to an `Object`. */
			static ToObject(value: System.TypedReference): System.Object;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown as a wrapper around the exception thrown by the class
		 * initializer. This class cannot be inherited.
		 */
		export class TypeInitializationException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.TypeInitializationException} class
			 * with the default error message, the specified type name, and a reference to the inner
			 * exception that is the root cause of this exception.
			 */
			constructor(
				fullTypeName: string | undefined,
				innerException: System.Exception | undefined,
			);

			/** Gets the fully qualified name of the type that fails to initialize. */
			readonly TypeName: string;
		}
	}

	export namespace System {
		/** The exception that is thrown when type-loading failures occur. */
		export class TypeLoadException extends System.SystemException {
			/** Initializes a new instance of the {@link System.TypeLoadException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.TypeLoadException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.TypeLoadException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);

			/** Gets the error message for this exception. */
			readonly Message: string;

			/** Gets the fully qualified name of the type that causes the exception. */
			readonly TypeName: string;
		}
	}

	export namespace System {
		/** The exception that is thrown when there is an attempt to access an unloaded class. */
		export class TypeUnloadedException extends System.SystemException {
			/** Initializes a new instance of the {@link System.TypeUnloadedException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.TypeUnloadedException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.TypeUnloadedException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/** Represents a 128-bit unsigned integer. */
		export class UInt128 extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<System.UInt128>,
			System.IEquatable$1<System.UInt128>,
			System.IFormattable,
			System.IParsable$1<System.UInt128>,
			System.ISpanFormattable,
			System.ISpanParsable$1<System.UInt128>,
			System.Numerics.IAdditionOperators$3<System.UInt128, System.UInt128, System.UInt128>,
			System.Numerics.IAdditiveIdentity$2<System.UInt128, System.UInt128>,
			System.Numerics.IBinaryNumber$1<System.UInt128>,
			System.Numerics.IBitwiseOperators$3<System.UInt128, System.UInt128, System.UInt128>,
			System.Numerics.IComparisonOperators$3<System.UInt128, System.UInt128, boolean>,
			System.Numerics.IEqualityOperators$3<System.UInt128, System.UInt128, boolean>,
			System.Numerics.IDecrementOperators$1<System.UInt128>,
			System.Numerics.IDivisionOperators$3<System.UInt128, System.UInt128, System.UInt128>,
			System.Numerics.IIncrementOperators$1<System.UInt128>,
			System.Numerics.IModulusOperators$3<System.UInt128, System.UInt128, System.UInt128>,
			System.Numerics.IMultiplicativeIdentity$2<System.UInt128, System.UInt128>,
			System.Numerics.IMultiplyOperators$3<System.UInt128, System.UInt128, System.UInt128>,
			System.Numerics.INumber$1<System.UInt128>,
			System.Numerics.INumberBase$1<System.UInt128>,
			System.Numerics.ISubtractionOperators$3<System.UInt128, System.UInt128, System.UInt128>,
			System.Numerics.IUnaryNegationOperators$2<System.UInt128, System.UInt128>,
			System.Numerics.IUnaryPlusOperators$2<System.UInt128, System.UInt128>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<System.UInt128>,
			System.Numerics.IShiftOperators$3<System.UInt128, number, System.UInt128>,
			System.Numerics.IMinMaxValue$1<System.UInt128>,
			System.Numerics.IUnsignedNumber$1<System.UInt128> {
			/** Initializes a new instance of the {@link System.UInt128} struct. */
			constructor(
				upper: number,
				lower: number,
			);

			/** Gets the maximum value of the current type. */
			static readonly MaxValue: System.UInt128;

			/** Gets the minimum value of the current type. */
			static readonly MinValue: System.UInt128;

			/** Gets the value 1 for the type. */
			static readonly One: System.UInt128;

			/** Gets the value 0 for the type. */
			static readonly Zero: System.UInt128;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: System.UInt128,
				min: System.UInt128,
				max: System.UInt128,
			): System.UInt128;

			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(value: System.UInt128): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): System.UInt128;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): System.UInt128;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): System.UInt128;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: System.UInt128,
				right: System.UInt128,
			): [System.UInt128, System.UInt128];

			/** Determines whether the specified object is equal to the current object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Indicates whether the current object is equal to another object of the same type. */
			Equals(other: System.UInt128): boolean;

			/** Serves as the default hash function. */
			GetHashCode(): number;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: System.UInt128): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: System.UInt128): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: System.UInt128): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: System.UInt128): System.UInt128;

			/** Computes the log2 of a value. */
			static Log2(value: System.UInt128): System.UInt128;

			/** Compares two values to compute which is greater. */
			static Max(
				x: System.UInt128,
				y: System.UInt128,
			): System.UInt128;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: System.UInt128,
				y: System.UInt128,
			): System.UInt128;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.UInt128;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.UInt128;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.UInt128;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.UInt128;

			/** Parses a string into a value. */
			static Parse(s: string): System.UInt128;

			/** Parses a string into a value. */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): System.UInt128;

			/** Parses a string into a value. */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.UInt128;

			/** Parses a string into a value. */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): System.UInt128;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: System.UInt128): System.UInt128;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: System.UInt128,
				rotateAmount: number,
			): System.UInt128;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: System.UInt128,
				rotateAmount: number,
			): System.UInt128;

			/** Computes the sign of a value. */
			static Sign(value: System.UInt128): number;

			/** Returns a string that represents the current object. */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/** Formats the value of the current instance using the specified format. */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: System.UInt128): System.UInt128;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.UInt128 | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.UInt128 | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): System.UInt128 | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.UInt128 | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.UInt128 | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): System.UInt128 | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.UInt128 | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): System.UInt128 | undefined;

			static TryParse(s: string | undefined): System.UInt128 | undefined;
		}
	}

	export namespace System {
		/** Represents a 16-bit unsigned integer. */
		export class UInt16 extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.Numerics.IAdditionOperators$3<number, number, number>,
			System.Numerics.IAdditiveIdentity$2<number, number>,
			System.Numerics.IBinaryNumber$1<number>,
			System.Numerics.IBitwiseOperators$3<number, number, number>,
			System.Numerics.IComparisonOperators$3<number, number, boolean>,
			System.Numerics.IEqualityOperators$3<number, number, boolean>,
			System.Numerics.IDecrementOperators$1<number>,
			System.Numerics.IDivisionOperators$3<number, number, number>,
			System.Numerics.IIncrementOperators$1<number>,
			System.Numerics.IModulusOperators$3<number, number, number>,
			System.Numerics.IMultiplicativeIdentity$2<number, number>,
			System.Numerics.IMultiplyOperators$3<number, number, number>,
			System.Numerics.INumber$1<number>,
			System.Numerics.INumberBase$1<number>,
			System.Numerics.ISubtractionOperators$3<number, number, number>,
			System.Numerics.IUnaryNegationOperators$2<number, number>,
			System.Numerics.IUnaryPlusOperators$2<number, number>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<number>,
			System.Numerics.IShiftOperators$3<number, number, number>,
			System.Numerics.IMinMaxValue$1<number>,
			System.Numerics.IUnsignedNumber$1<number> {
			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/**
			 * Compares this instance to a specified object and returns an indication of their
			 * relative values.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Compares this instance to a specified 16-bit unsigned integer and returns an
			 * indication of their relative values.
			 */
			CompareTo(value: number): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): number;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value indicating whether this instance is equal to a specified
			 * {@link System.UInt16} value.
			 */
			Equals(obj: number): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.UInt16}. */
			GetTypeCode(): System.TypeCode;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: number): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: number): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: number): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: number): number;

			/** Computes the log2 of a value. */
			static Log2(value: number): number;

			/** Compares two values to compute which is greater. */
			static Max(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: number,
				y: number,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the span representation of a number in a specified style and culture-specific
			 * format to its 16-bit unsigned integer equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number to its 16-bit unsigned integer
			 * equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a number in a specified style to its 16-bit
			 * unsigned integer equivalent.  This method is not CLS-compliant. The CLS-compliant
			 * alternative is
			 * {@link System.Int32.Parse(System.String,System.Globalization.NumberStyles)}.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): number;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its 16-bit unsigned integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its 16-bit unsigned integer equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: number): number;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: number,
				rotateAmount: number,
			): number;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: number,
				rotateAmount: number,
			): number;

			/** Computes the sign of a value. */
			static Sign(value: number): number;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: number): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;
		}
	}

	export namespace System {
		/** Represents a 32-bit unsigned integer. */
		export class UInt32 extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.Numerics.IAdditionOperators$3<number, number, number>,
			System.Numerics.IAdditiveIdentity$2<number, number>,
			System.Numerics.IBinaryNumber$1<number>,
			System.Numerics.IBitwiseOperators$3<number, number, number>,
			System.Numerics.IComparisonOperators$3<number, number, boolean>,
			System.Numerics.IEqualityOperators$3<number, number, boolean>,
			System.Numerics.IDecrementOperators$1<number>,
			System.Numerics.IDivisionOperators$3<number, number, number>,
			System.Numerics.IIncrementOperators$1<number>,
			System.Numerics.IModulusOperators$3<number, number, number>,
			System.Numerics.IMultiplicativeIdentity$2<number, number>,
			System.Numerics.IMultiplyOperators$3<number, number, number>,
			System.Numerics.INumber$1<number>,
			System.Numerics.INumberBase$1<number>,
			System.Numerics.ISubtractionOperators$3<number, number, number>,
			System.Numerics.IUnaryNegationOperators$2<number, number>,
			System.Numerics.IUnaryPlusOperators$2<number, number>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<number>,
			System.Numerics.IShiftOperators$3<number, number, number>,
			System.Numerics.IMinMaxValue$1<number>,
			System.Numerics.IUnsignedNumber$1<number> {
			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/**
			 * Compares this instance to a specified object and returns an indication of their
			 * relative values.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Compares this instance to a specified 32-bit unsigned integer and returns an
			 * indication of their relative values.
			 */
			CompareTo(value: number): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): number;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value indicating whether this instance is equal to a specified
			 * {@link System.UInt32}.
			 */
			Equals(obj: number): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.UInt32}. */
			GetTypeCode(): System.TypeCode;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: number): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: number): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: number): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: number): number;

			/** Computes the log2 of a value. */
			static Log2(value: number): number;

			/** Compares two values to compute which is greater. */
			static Max(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: number,
				y: number,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the span representation of a number in a specified style and culture-specific
			 * format to its 32-bit unsigned integer equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number to its 32-bit unsigned integer
			 * equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a number in a specified style to its 32-bit
			 * unsigned integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): number;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its 32-bit unsigned integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its 32-bit unsigned integer equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: number): number;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: number,
				rotateAmount: number,
			): number;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: number,
				rotateAmount: number,
			): number;

			/** Computes the sign of a value. */
			static Sign(value: number): number;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: number): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;
		}
	}

	export namespace System {
		/** Represents a 64-bit unsigned integer. */
		export class UInt64 extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<number>,
			System.IEquatable$1<number>,
			System.IFormattable,
			System.IParsable$1<number>,
			System.ISpanFormattable,
			System.ISpanParsable$1<number>,
			System.Numerics.IAdditionOperators$3<number, number, number>,
			System.Numerics.IAdditiveIdentity$2<number, number>,
			System.Numerics.IBinaryNumber$1<number>,
			System.Numerics.IBitwiseOperators$3<number, number, number>,
			System.Numerics.IComparisonOperators$3<number, number, boolean>,
			System.Numerics.IEqualityOperators$3<number, number, boolean>,
			System.Numerics.IDecrementOperators$1<number>,
			System.Numerics.IDivisionOperators$3<number, number, number>,
			System.Numerics.IIncrementOperators$1<number>,
			System.Numerics.IModulusOperators$3<number, number, number>,
			System.Numerics.IMultiplicativeIdentity$2<number, number>,
			System.Numerics.IMultiplyOperators$3<number, number, number>,
			System.Numerics.INumber$1<number>,
			System.Numerics.INumberBase$1<number>,
			System.Numerics.ISubtractionOperators$3<number, number, number>,
			System.Numerics.IUnaryNegationOperators$2<number, number>,
			System.Numerics.IUnaryPlusOperators$2<number, number>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<number>,
			System.Numerics.IShiftOperators$3<number, number, number>,
			System.Numerics.IMinMaxValue$1<number>,
			System.Numerics.IUnsignedNumber$1<number> {
			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: number,
				min: number,
				max: number,
			): number;

			/**
			 * Compares this instance to a specified object and returns an indication of their
			 * relative values.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Compares this instance to a specified 64-bit unsigned integer and returns an
			 * indication of their relative values.
			 */
			CompareTo(value: number): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): number;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): number;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: number,
				right: number,
			): [number, number];

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value indicating whether this instance is equal to a specified
			 * {@link System.UInt64} value.
			 */
			Equals(obj: number): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the {@link System.TypeCode} for value type {@link System.UInt64}. */
			GetTypeCode(): System.TypeCode;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: number): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: number): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: number): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: number): number;

			/** Computes the log2 of a value. */
			static Log2(value: number): number;

			/** Compares two values to compute which is greater. */
			static Max(
				x: number,
				y: number,
			): number;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: number,
				y: number,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the span representation of a number in a specified style and culture-specific
			 * format to its 64-bit unsigned integer equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): number;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number to its 64-bit unsigned integer
			 * equivalent.
			 */
			static Parse(s: string): number;

			/**
			 * Converts the string representation of a number in a specified style to its 64-bit
			 * unsigned integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): number;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its 64-bit unsigned integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its 64-bit unsigned integer equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): number;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: number): number;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: number,
				rotateAmount: number,
			): number;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: number,
				rotateAmount: number,
			): number;

			/** Computes the sign of a value. */
			static Sign(value: number): number;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: number): number;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): number | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): number | undefined;

			static TryParse(s: string | undefined): number | undefined;
		}
	}

	export namespace System {
		/** Represents an unsigned integer where the bit-width is the same as a pointer. */
		export class UIntPtr extends System.ValueType implements
			System.IComparable,
			System.IComparable$1<System.UIntPtr>,
			System.IEquatable$1<System.UIntPtr>,
			System.IFormattable,
			System.IParsable$1<System.UIntPtr>,
			System.ISpanFormattable,
			System.ISpanParsable$1<System.UIntPtr>,
			System.Numerics.IAdditionOperators$3<System.UIntPtr, System.UIntPtr, System.UIntPtr>,
			System.Numerics.IAdditiveIdentity$2<System.UIntPtr, System.UIntPtr>,
			System.Numerics.IBinaryNumber$1<System.UIntPtr>,
			System.Numerics.IBitwiseOperators$3<System.UIntPtr, System.UIntPtr, System.UIntPtr>,
			System.Numerics.IComparisonOperators$3<System.UIntPtr, System.UIntPtr, boolean>,
			System.Numerics.IEqualityOperators$3<System.UIntPtr, System.UIntPtr, boolean>,
			System.Numerics.IDecrementOperators$1<System.UIntPtr>,
			System.Numerics.IDivisionOperators$3<System.UIntPtr, System.UIntPtr, System.UIntPtr>,
			System.Numerics.IIncrementOperators$1<System.UIntPtr>,
			System.Numerics.IModulusOperators$3<System.UIntPtr, System.UIntPtr, System.UIntPtr>,
			System.Numerics.IMultiplicativeIdentity$2<System.UIntPtr, System.UIntPtr>,
			System.Numerics.IMultiplyOperators$3<System.UIntPtr, System.UIntPtr, System.UIntPtr>,
			System.Numerics.INumber$1<System.UIntPtr>,
			System.Numerics.INumberBase$1<System.UIntPtr>,
			System.Numerics.ISubtractionOperators$3<System.UIntPtr, System.UIntPtr, System.UIntPtr>,
			System.Numerics.IUnaryNegationOperators$2<System.UIntPtr, System.UIntPtr>,
			System.Numerics.IUnaryPlusOperators$2<System.UIntPtr, System.UIntPtr>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<System.UIntPtr>,
			System.Numerics.IShiftOperators$3<System.UIntPtr, number, System.UIntPtr>,
			System.Numerics.IMinMaxValue$1<System.UIntPtr>,
			System.Numerics.IUnsignedNumber$1<System.UIntPtr> {
			/**
			 * Initializes a new instance of the {@link System.UIntPtr} structure using the specified
			 * 32-bit unsigned integer.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of {@link System.UIntPtr} using the specified 64-bit
			 * unsigned integer.
			 */
			constructor(value: number);

			/** Represents the largest possible value of  . */
			static readonly MaxValue: System.UIntPtr;

			/** Represents the smallest possible value of  . */
			static readonly MinValue: System.UIntPtr;

			/** Gets the size of this instance. */
			static readonly Size: number;

			/** Adds an offset to an unsigned integer. */
			static Add(
				pointer: System.UIntPtr,
				offset: number,
			): System.UIntPtr;

			/** Clamps a value to an inclusive minimum and maximum value. */
			static Clamp(
				value: System.UIntPtr,
				min: System.UIntPtr,
				max: System.UIntPtr,
			): System.UIntPtr;

			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(value: System.Object | undefined): number;

			/**
			 * Compares the current instance with another object of the same type and returns an
			 * integer that indicates whether the current instance precedes, follows, or occurs in
			 * the same position in the sort order as the other object.
			 */
			CompareTo(value: System.UIntPtr): number;

			/**
			 * Creates an instance of the current type from a value, throwing an overflow exception
			 * for any values that fall outside the representable range of the current type.
			 */
			static CreateChecked<TOther>(value: TOther): System.UIntPtr;

			/**
			 * Creates an instance of the current type from a value, saturating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateSaturating<TOther>(value: TOther): System.UIntPtr;

			/**
			 * Creates an instance of the current type from a value, truncating any values that fall
			 * outside the representable range of the current type.
			 */
			static CreateTruncating<TOther>(value: TOther): System.UIntPtr;

			/** Computes the quotient and remainder of two values. */
			static DivRem(
				left: System.UIntPtr,
				right: System.UIntPtr,
			): [System.UIntPtr, System.UIntPtr];

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Indicates whether the current object is equal to another object of the same type. */
			Equals(other: System.UIntPtr): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Determines if a value represents an even integral number. */
			static IsEvenInteger(value: System.UIntPtr): boolean;

			/** Determines if a value represents an odd integral number. */
			static IsOddInteger(value: System.UIntPtr): boolean;

			/** Determines if a value is a power of two. */
			static IsPow2(value: System.UIntPtr): boolean;

			/** Computes the number of leading zeros in a value. */
			static LeadingZeroCount(value: System.UIntPtr): System.UIntPtr;

			/** Computes the log2 of a value. */
			static Log2(value: System.UIntPtr): System.UIntPtr;

			/** Compares two values to compute which is greater. */
			static Max(
				x: System.UIntPtr,
				y: System.UIntPtr,
			): System.UIntPtr;

			/** Compares two values to compute which is lesser. */
			static Min(
				x: System.UIntPtr,
				y: System.UIntPtr,
			): System.UIntPtr;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.UIntPtr;

			/** Parses a span of UTF-8 characters into a value. */
			static Parse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.UIntPtr;

			/**
			 * Converts the read-only span of characters representation of a number in optionally
			 * specified style and optionally specified culture-specific format to its unsigned
			 * native integer equivalent.
			 */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				style?: System.Globalization.NumberStyles,
				provider?: System.IFormatProvider,
			): System.UIntPtr;

			/** Parses a span of characters into a value. */
			static Parse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.UIntPtr;

			/**
			 * Converts the string representation of a number to its unsigned native integer
			 * equivalent.
			 */
			static Parse(s: string): System.UIntPtr;

			/**
			 * Converts the string representation of a number in a specified style to its unsigned
			 * native integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
			): System.UIntPtr;

			/**
			 * Converts the string representation of a number in a specified style and
			 * culture-specific format to its unsigned native integer equivalent.
			 */
			static Parse(
				s: string,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.UIntPtr;

			/**
			 * Converts the string representation of a number in a specified culture-specific format
			 * to its unsigned native integer equivalent.
			 */
			static Parse(
				s: string,
				provider: System.IFormatProvider | undefined,
			): System.UIntPtr;

			/** Computes the number of bits that are set in a value. */
			static PopCount(value: System.UIntPtr): System.UIntPtr;

			/** Rotates a value left by a given amount. */
			static RotateLeft(
				value: System.UIntPtr,
				rotateAmount: number,
			): System.UIntPtr;

			/** Rotates a value right by a given amount. */
			static RotateRight(
				value: System.UIntPtr,
				rotateAmount: number,
			): System.UIntPtr;

			/** Computes the sign of a value. */
			static Sign(value: System.UIntPtr): number;

			/** Subtracts an offset from an unsigned integer. */
			static Subtract(
				pointer: System.UIntPtr,
				offset: number,
			): System.UIntPtr;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation.
			 */
			ToString(): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation
			 * using the specified format and culture-specific format information.
			 */
			ToString(provider: System.IFormatProvider | undefined): string;

			/**
			 * Converts the numeric value of this instance to its equivalent string representation,
			 * using the specified format.
			 */
			ToString(format: string | undefined): string;

			/** Formats the value of the current instance using the specified format. */
			ToString(
				format: string | undefined,
				provider: System.IFormatProvider | undefined,
			): string;

			/** Converts the value of this instance to a 32-bit unsigned integer. */
			ToUInt32(): number;

			/** Converts the value of this instance to a 64-bit unsigned integer. */
			ToUInt64(): number;

			/** Computes the number of trailing zeros in a value. */
			static TrailingZeroCount(value: System.UIntPtr): System.UIntPtr;

			TryFormat(
				destination: System.Span$1<System.Char>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				format?: System.ReadOnlySpan$1<System.Char>,
				provider?: System.IFormatProvider,
			): System.IFormatProvider | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.UIntPtr | undefined;

			static TryParse(
				utf8Text: System.ReadOnlySpan$1<number>,
				provider: System.IFormatProvider | undefined,
			): System.UIntPtr | undefined;

			static TryParse(utf8Text: System.ReadOnlySpan$1<number>): System.UIntPtr | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.UIntPtr | undefined;

			static TryParse(
				s: System.ReadOnlySpan$1<System.Char>,
				provider: System.IFormatProvider | undefined,
			): System.UIntPtr | undefined;

			static TryParse(s: System.ReadOnlySpan$1<System.Char>): System.UIntPtr | undefined;

			static TryParse(
				s: string | undefined,
				style: System.Globalization.NumberStyles,
				provider: System.IFormatProvider | undefined,
			): System.UIntPtr | undefined;

			static TryParse(
				s: string | undefined,
				provider: System.IFormatProvider | undefined,
			): System.UIntPtr | undefined;

			static TryParse(s: string | undefined): System.UIntPtr | undefined;
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when the operating system denies access because of an I/O
		 * error or a specific type of security error.
		 */
		export class UnauthorizedAccessException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.UnauthorizedAccessException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.UnauthorizedAccessException} class
			 * with a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.UnauthorizedAccessException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * Provides data for the event that is raised when there is an exception that is not
		 * handled in any application domain.
		 */
		export class UnhandledExceptionEventArgs extends System.EventArgs {
			/**
			 * Initializes a new instance of the {@link System.UnhandledExceptionEventArgs} class
			 * with the exception object and a common language runtime termination flag.
			 */
			constructor(
				exception: System.Object,
				isTerminating: boolean,
			);

			/** Gets the unhandled exception object. */
			readonly ExceptionObject: System.Object;

			/** Indicates whether the common language runtime is terminating. */
			readonly IsTerminating: boolean;
		}
	}

	export namespace System {
		/**
		 * Represents the method that will handle the event raised by an exception that is not
		 * handled by the application domain.
		 */
		export interface UnhandledExceptionEventHandler { (
			sender: System.Object,
			e: System.UnhandledExceptionEventArgs,
		): void; }
	}

	export namespace System {
		/** Provides static methods for creating value tuples. */
		export class ValueTuple extends System.ValueType implements
			System.IComparable$1<[]>,
			System.IEquatable$1<[]> {
			/**
			 * Compares the current {@link System.ValueTuple} instance to a specified
			 * {@link System.ValueTuple} instance.
			 */
			CompareTo(other: []): number;

			/** Creates a new value tuple with zero components. */
			static Create(): [];

			/** Creates a new value tuple with 1 component (a singleton). */
			static Create<T1>(item1: T1): [T1];

			/** Creates a new value tuple with 2 components (a pair). */
			static Create<T1, T2>(
				item1: T1,
				item2: T2,
			): [T1, T2];

			/** Creates a new value tuple with 3 components (a triple). */
			static Create<T1, T2, T3>(
				item1: T1,
				item2: T2,
				item3: T3,
			): [T1, T2, T3];

			/** Creates a new value tuple with 4 components (a quadruple). */
			static Create<T1, T2, T3, T4>(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
			): [T1, T2, T3, T4];

			/** Creates a new value tuple with 5 components (a quintuple). */
			static Create<T1, T2, T3, T4, T5>(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
			): [T1, T2, T3, T4, T5];

			/** Creates a new value tuple with 6 components (a sexuple). */
			static Create<T1, T2, T3, T4, T5, T6>(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
			): [T1, T2, T3, T4, T5, T6];

			/** Creates a new value tuple with 7 components (a septuple). */
			static Create<T1, T2, T3, T4, T5, T6, T7>(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
				item7: T7,
			): [T1, T2, T3, T4, T5, T6, T7];

			/** Creates a new value tuple with 8 components (an octuple). */
			static Create<T1, T2, T3, T4, T5, T6, T7, T8>(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
				item7: T7,
				item8: T8,
			): [T1, T2, T3, T4, T5, T6, T7, [T8]];

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple} instance
			 * is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Determines whether two {@link System.ValueTuple} instances are equal. This method
			 * always returns `true`.
			 */
			Equals(other: []): boolean;

			/** Returns the hash code for the current {@link System.ValueTuple} instance. */
			GetHashCode(): number;

			/** Returns the string representation of this {@link System.ValueTuple} instance. */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a value tuple with a single component. */
		export function ValueTuple$(T1: IType): typeof ValueTuple$1<any>;

		/** Represents a value tuple with a single component. */
		export class ValueTuple$1<T1> extends System.ValueType implements
			System.IComparable$1<[T1]>,
			System.IEquatable$1<[T1]> {
			/** Initializes a new {@link System.ValueTuple<>} instance. */
			constructor(item1: T1);

			/**
			 * Compares the current {@link System.ValueTuple<>} instance to a specified
			 * {@link System.ValueTuple<>} instance.
			 */
			CompareTo(other: [T1]): number;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<>}
			 * instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<>}
			 * instance is equal to a specified {@link System.ValueTuple<>} instance.
			 */
			Equals(other: [T1]): boolean;

			/** Calculates the hash code for the current {@link System.ValueTuple<>} instance. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.ValueTuple<>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a value tuple with 2 components. */
		export function ValueTuple$(T1: IType, T2: IType): typeof ValueTuple$2<any, any>;

		/** Represents a value tuple with 2 components. */
		export class ValueTuple$2<T1, T2> extends System.ValueType implements
			System.IComparable$1<[T1, T2]>,
			System.IEquatable$1<[T1, T2]> {
			/** Initializes a new {@link System.ValueTuple<,>} instance. */
			constructor(
				item1: T1,
				item2: T2,
			);

			/**
			 * Compares the current {@link System.ValueTuple<,>} instance to a specified
			 * {@link System.ValueTuple<,>} instance.
			 */
			CompareTo(other: [T1, T2]): number;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,>}
			 * instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,>}
			 * instance is equal to a specified {@link System.ValueTuple<,>} instance.
			 */
			Equals(other: [T1, T2]): boolean;

			/** Calculates the hash code for the current {@link System.ValueTuple<,>} instance. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.ValueTuple<,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a value tuple with 3 components. */
		export function ValueTuple$(T1: IType, T2: IType, T3: IType): typeof ValueTuple$3<any, any, any>;

		/** Represents a value tuple with 3 components. */
		export class ValueTuple$3<T1, T2, T3> extends System.ValueType implements
			System.IComparable$1<[T1, T2, T3]>,
			System.IEquatable$1<[T1, T2, T3]> {
			/** Initializes a new {@link System.ValueTuple<,,>} instance. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
			);

			/**
			 * Compares the current {@link System.ValueTuple<,,>} instance to a specified
			 * {@link System.ValueTuple<,,>} instance.
			 */
			CompareTo(other: [T1, T2, T3]): number;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,>}
			 * instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,>}
			 * instance is equal to a specified {@link System.ValueTuple<,,>} instance.
			 */
			Equals(other: [T1, T2, T3]): boolean;

			/** Calculates the hash code for the current {@link System.ValueTuple<,,>} instance. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.ValueTuple<,,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a value tuple with 4 components. */
		export function ValueTuple$(T1: IType, T2: IType, T3: IType, T4: IType): typeof ValueTuple$4<any, any, any, any>;

		/** Represents a value tuple with 4 components. */
		export class ValueTuple$4<T1, T2, T3, T4> extends System.ValueType implements
			System.IComparable$1<[T1, T2, T3, T4]>,
			System.IEquatable$1<[T1, T2, T3, T4]> {
			/** Initializes a new {@link System.ValueTuple<,,,>} instance. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
			);

			/**
			 * Compares the current {@link System.ValueTuple<,,,>} instance to a specified
			 * {@link System.ValueTuple<,,,>} instance.
			 */
			CompareTo(other: [T1, T2, T3, T4]): number;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,,>}
			 * instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,,>}
			 * instance is equal to a specified {@link System.ValueTuple<,,,>} instance.
			 */
			Equals(other: [T1, T2, T3, T4]): boolean;

			/** Calculates the hash code for the current {@link System.ValueTuple<,,,>} instance. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.ValueTuple<,,,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a value tuple with 5 components. */
		export function ValueTuple$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType): typeof ValueTuple$5<any, any, any, any, any>;

		/** Represents a value tuple with 5 components. */
		export class ValueTuple$5<T1, T2, T3, T4, T5> extends System.ValueType implements
			System.IComparable$1<[T1, T2, T3, T4, T5]>,
			System.IEquatable$1<[T1, T2, T3, T4, T5]> {
			/** Initializes a new {@link System.ValueTuple<,,,,>} instance. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
			);

			/**
			 * Compares the current {@link System.ValueTuple<,,,,>} instance to a specified
			 * {@link System.ValueTuple<,,,,>} instance.
			 */
			CompareTo(other: [T1, T2, T3, T4, T5]): number;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,,,>}
			 * instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,,,>}
			 * instance is equal to a specified {@link System.ValueTuple<,,,,>} instance.
			 */
			Equals(other: [T1, T2, T3, T4, T5]): boolean;

			/** Calculates the hash code for the current {@link System.ValueTuple<,,,,>} instance. */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.ValueTuple<,,,,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a value tuple with 6 components. */
		export function ValueTuple$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType): typeof ValueTuple$6<any, any, any, any, any, any>;

		/** Represents a value tuple with 6 components. */
		export class ValueTuple$6<T1, T2, T3, T4, T5, T6> extends System.ValueType implements
			System.IComparable$1<[T1, T2, T3, T4, T5, T6]>,
			System.IEquatable$1<[T1, T2, T3, T4, T5, T6]> {
			/** Initializes a new {@link System.ValueTuple<,,,,,>} instance. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
			);

			/**
			 * Compares the current {@link System.ValueTuple<,,,,,>} instance to a specified
			 * {@link System.ValueTuple<,,,,,>} instance.
			 */
			CompareTo(other: [T1, T2, T3, T4, T5, T6]): number;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,,,,>}
			 * instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,,,,>}
			 * instance is equal to a specified {@link System.ValueTuple<,,,,,>} instance.
			 */
			Equals(other: [T1, T2, T3, T4, T5, T6]): boolean;

			/**
			 * Calculates the hash code for the current {@link System.ValueTuple<,,,,,>} instance.
			 */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.ValueTuple<,,,,,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents a value tuple with 7 components. */
		export function ValueTuple$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType): typeof ValueTuple$7<any, any, any, any, any, any, any>;

		/** Represents a value tuple with 7 components. */
		export class ValueTuple$7<T1, T2, T3, T4, T5, T6, T7> extends System.ValueType implements
			System.IComparable$1<[T1, T2, T3, T4, T5, T6, T7]>,
			System.IEquatable$1<[T1, T2, T3, T4, T5, T6, T7]> {
			/**
			 * Initializes a new {@link System.ValueTuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)} instance.
			 */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
				item7: T7,
			);

			/**
			 * Compares the current {@link System.ValueTuple<,,,,,,>} instance to a specified
			 * {@link System.ValueTuple<,,,,,,>} instance.
			 */
			CompareTo(other: [T1, T2, T3, T4, T5, T6, T7]): number;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,,,,,>}
			 * instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,,,,,>}
			 * instance is equal to a specified {@link System.ValueTuple<,,,,,,>} instance.
			 */
			Equals(other: [T1, T2, T3, T4, T5, T6, T7]): boolean;

			/**
			 * Calculates the hash code for the current {@link System.ValueTuple<,,,,,,>} instance.
			 */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.ValueTuple<,,,,,,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** [Generic type factory] Represents an n-value tuple, where n is 8 or greater. */
		export function ValueTuple$(T1: IType, T2: IType, T3: IType, T4: IType, T5: IType, T6: IType, T7: IType, TRest: IType): typeof ValueTuple$8<any, any, any, any, any, any, any, any>;

		/** Represents an n-value tuple, where n is 8 or greater. */
		export class ValueTuple$8<T1, T2, T3, T4, T5, T6, T7, TRest> extends System.ValueType implements
			System.IComparable$1<[T1, T2, T3, T4, T5, T6, T7, TRest]>,
			System.IEquatable$1<[T1, T2, T3, T4, T5, T6, T7, TRest]> {
			/** Initializes a new {@link System.ValueTuple<,,,,,,,>} instance. */
			constructor(
				item1: T1,
				item2: T2,
				item3: T3,
				item4: T4,
				item5: T5,
				item6: T6,
				item7: T7,
				rest: TRest,
			);

			/**
			 * Compares the current {@link System.ValueTuple<,,,,,,,>} instance to a specified
			 * {@link System.ValueTuple<,,,,,,,>} instance.
			 */
			CompareTo(other: [T1, T2, T3, T4, T5, T6, T7, TRest]): number;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,,,,,,>}
			 * instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether the current {@link System.ValueTuple<,,,,,,,>}
			 * instance is equal to a specified {@link System.ValueTuple<,,,,,,,>} instance.
			 */
			Equals(other: [T1, T2, T3, T4, T5, T6, T7, TRest]): boolean;

			/**
			 * Calculates the hash code for the current {@link System.ValueTuple<,,,,,,,>} instance.
			 */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the value of this {@link System.ValueTuple<,,,,,,,>}
			 * instance.
			 */
			ToString(): string;
		}
	}

	export namespace System {
		/** Provides the base class for value types. */
		export class ValueType {
			/** Indicates whether this instance and a specified object are equal. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns the fully qualified type name of this instance. */
			ToString(): string | undefined;
		}
	}

	export namespace System {
		/**
		 * Represents the version number of an assembly, operating system, or the common language
		 * runtime. This class cannot be inherited.
		 */
		export class Version implements
			System.ICloneable,
			System.IComparable,
			System.IComparable$1<System.Version>,
			System.IEquatable$1<System.Version> {
			/** Initializes a new instance of the {@link System.Version} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Version} class using the specified
			 * major and minor values.
			 */
			constructor(
				major: number,
				minor: number,
			);

			/**
			 * Initializes a new instance of the {@link System.Version} class using the specified
			 * major, minor, and build values.
			 */
			constructor(
				major: number,
				minor: number,
				build: number,
			);

			/**
			 * Initializes a new instance of the {@link System.Version} class with the specified
			 * major, minor, build, and revision numbers.
			 */
			constructor(
				major: number,
				minor: number,
				build: number,
				revision: number,
			);

			/**
			 * Initializes a new instance of the {@link System.Version} class using the specified
			 * string.
			 */
			constructor(version: string);

			/**
			 * Gets the value of the build component of the version number for the current
			 * {@link System.Version} object.
			 */
			readonly Build: number;

			/**
			 * Gets the value of the major component of the version number for the current
			 * {@link System.Version} object.
			 */
			readonly Major: number;

			/** Gets the high 16 bits of the revision number. */
			readonly MajorRevision: number;

			/**
			 * Gets the value of the minor component of the version number for the current
			 * {@link System.Version} object.
			 */
			readonly Minor: number;

			/** Gets the low 16 bits of the revision number. */
			readonly MinorRevision: number;

			/**
			 * Gets the value of the revision component of the version number for the current
			 * {@link System.Version} object.
			 */
			readonly Revision: number;

			/**
			 * Returns a new {@link System.Version} object whose value is the same as the current
			 * {@link System.Version} object.
			 */
			Clone(): System.Object;

			/**
			 * Compares the current {@link System.Version} object to a specified object and returns
			 * an indication of their relative values.
			 */
			CompareTo(version: System.Object | undefined): number;

			/**
			 * Compares the current {@link System.Version} object to a specified
			 * {@link System.Version} object and returns an indication of their relative values.
			 */
			CompareTo(value: System.Version | undefined): number;

			/**
			 * Returns a value indicating whether the current {@link System.Version} object is equal
			 * to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value indicating whether the current {@link System.Version} object and a
			 * specified {@link System.Version} object represent the same value.
			 */
			Equals(obj: System.Version | undefined): boolean;

			/** Returns a hash code for the current {@link System.Version} object. */
			GetHashCode(): number;

			/**
			 * Converts the specified read-only span of characters that represents a version number
			 * to an equivalent {@link System.Version} object.
			 */
			static Parse(input: System.ReadOnlySpan$1<System.Char>): System.Version;

			/**
			 * Converts the string representation of a version number to an equivalent
			 * {@link System.Version} object.
			 */
			static Parse(input: string): System.Version;

			/**
			 * Converts the value of the current {@link System.Version} object to its equivalent
			 * {@link System.String} representation.
			 */
			ToString(): string;

			/**
			 * Converts the value of the current {@link System.Version} object to its equivalent
			 * {@link System.String} representation. A specified count indicates the number of
			 * components to return.
			 */
			ToString(fieldCount: number): string;

			TryFormat(
				destination: System.Span$1<System.Char>,
				fieldCount: number,
			): number | undefined;

			TryFormat(destination: System.Span$1<System.Char>): number | undefined;

			TryFormat(
				utf8Destination: System.Span$1<number>,
				fieldCount: number,
			): number | undefined;

			TryFormat(utf8Destination: System.Span$1<number>): number | undefined;

			static TryParse(input: System.ReadOnlySpan$1<System.Char>): System.Version | undefined;

			static TryParse(input: string | undefined): System.Version | undefined;
		}
	}

	export namespace System {
		/** Specifies a return value type for a method that does not return a value. */
		export class Void extends System.ValueType {
		}
	}

	export namespace System {
		/**
		 * Represents a weak reference, which references an object while still allowing that
		 * object to be reclaimed by garbage collection.
		 */
		export class WeakReference {
			/**
			 * Initializes a new instance of the {@link System.WeakReference} class, referencing the
			 * specified object.
			 */
			constructor(target: System.Object | undefined);

			/**
			 * Initializes a new instance of the {@link System.WeakReference} class, referencing the
			 * specified object and using the specified resurrection tracking.
			 */
			constructor(
				target: System.Object | undefined,
				trackResurrection: boolean,
			);

			/**
			 * Gets an indication whether the object referenced by the current
			 * {@link System.WeakReference} object has been garbage collected.
			 */
			readonly IsAlive: boolean;

			/**
			 * Gets or sets the object (the target) referenced by the current
			 * {@link System.WeakReference} object.
			 */
			Target?: System.Object;

			/**
			 * Gets an indication whether the object referenced by the current
			 * {@link System.WeakReference} object is tracked after it is finalized.
			 */
			readonly TrackResurrection: boolean;
		}
	}

	export namespace System {
		/**
		 * [Generic type factory] Represents a typed weak reference, which references an object
		 * while still allowing that object to be reclaimed by garbage collection.
		 */
		export function WeakReference$(T: IType): typeof WeakReference$1<any>;

		/**
		 * Represents a typed weak reference, which references an object while still allowing
		 * that object to be reclaimed by garbage collection.
		 */
		export class WeakReference$1<T> {
			/**
			 * Initializes a new instance of the {@link System.WeakReference<>} class that references
			 * the specified object.
			 */
			constructor(target: T);

			/**
			 * Initializes a new instance of the {@link System.WeakReference<>} class that references
			 * the specified object and uses the specified resurrection tracking.
			 */
			constructor(
				target: T,
				trackResurrection: boolean,
			);

			/**
			 * Sets the target object that is referenced by this {@link System.WeakReference<>}
			 * object.
			 */
			SetTarget(target: T): void;

			TryGetTarget(): T | undefined;
		}
	}

	export namespace System {
		/** A customizable parser based on the File scheme. */
		export class FileStyleUriParser extends System.UriParser {
			/** Creates a customizable parser based on the File scheme. */
			constructor();
		}
	}

	export namespace System {
		/** A customizable parser based on the File Transfer Protocol (FTP) scheme. */
		export class FtpStyleUriParser extends System.UriParser {
			/** Creates a customizable parser based on the File Transfer Protocol (FTP) scheme. */
			constructor();
		}
	}

	export namespace System {
		/** A customizable parser for a hierarchical URI. */
		export class GenericUriParser extends System.UriParser {
			/** Create a customizable parser for a hierarchical URI. */
			constructor(options: System.GenericUriParserOptions);
		}
	}

	export namespace System {
		/** Specifies options for a {@link System.UriParser}. */
		export enum GenericUriParserOptions {
			/**
			 * The parser: requires an authority; converts backslashes into forward slashes;
			 * unescapes path dots, forward slashes, and back slashes; and removes trailing dots,
			 * empty segments, and dots-only segments.
			 */
			Default = 0,

			/** The parser allows a registry-based authority. */
			GenericAuthority = 1,

			/** The parser allows a URI with no authority. */
			AllowEmptyAuthority = 2,

			/** The scheme does not define a user information part. */
			NoUserInfo = 4,

			/** The scheme does not define a port. */
			NoPort = 8,

			/** The scheme does not define a query part. */
			NoQuery = 16,

			/** The scheme does not define a fragment part. */
			NoFragment = 32,

			/** The parser does not convert back slashes into forward slashes. */
			DontConvertPathBackslashes = 64,

			/** The parser does not canonicalize the URI. */
			DontCompressPath = 128,

			/** The parser does not unescape path dots, forward slashes, or back slashes. */
			DontUnescapePathDotsAndSlashes = 256,

			/**
			 * The parser supports Internationalized Domain Name (IDN) parsing (IDN) of host names.
			 * Whether IDN is used is dictated by configuration values.
			 */
			Idn = 512,

			/**
			 * The parser supports the parsing rules specified in RFC 3987 for International Resource
			 * Identifiers (IRI). Whether IRI is used is dictated by configuration values.
			 */
			IriParsing = 1024,
		}
	}

	export namespace System {
		/** A customizable parser based on the Gopher scheme. */
		export class GopherStyleUriParser extends System.UriParser {
			/** Creates a customizable parser based on the Gopher scheme. */
			constructor();
		}
	}

	export namespace System {
		/** A customizable parser based on the HTTP scheme. */
		export class HttpStyleUriParser extends System.UriParser {
			/** Create a customizable parser based on the HTTP scheme. */
			constructor();
		}
	}

	export namespace System {
		/**
		 * A customizable parser based on the Lightweight Directory Access Protocol (LDAP)
		 * scheme.
		 */
		export class LdapStyleUriParser extends System.UriParser {
			/**
			 * Creates a customizable parser based on the Lightweight Directory Access Protocol
			 * (LDAP) scheme.
			 */
			constructor();
		}
	}

	export namespace System {
		/** A parser based on the NetPipe scheme for the "Indigo" system. */
		export class NetPipeStyleUriParser extends System.UriParser {
			/** Create a parser based on the NetPipe scheme for the "Indigo" system. */
			constructor();
		}
	}

	export namespace System {
		/** A parser based on the NetTcp scheme for the "Indigo" system. */
		export class NetTcpStyleUriParser extends System.UriParser {
			/** Create a parser based on the NetTcp scheme for the "Indigo" system. */
			constructor();
		}
	}

	export namespace System {
		/**
		 * A customizable parser based on the news scheme using the Network News Transfer
		 * Protocol (NNTP).
		 */
		export class NewsStyleUriParser extends System.UriParser {
			/**
			 * Create a customizable parser based on the news scheme using the Network News Transfer
			 * Protocol (NNTP).
			 */
			constructor();
		}
	}

	export namespace System {
		/**
		 * Provides an object representation of a uniform resource identifier (URI) and easy
		 * access to the parts of the URI.
		 */
		export class Uri {
			/** Initializes a new instance of the {@link System.Uri} class with the specified URI. */
			constructor(uriString: string);

			/**
			 * Initializes a new instance of the {@link System.Uri} class with the specified URI,
			 * with explicit control of character escaping.
			 */
			constructor(
				uriString: string,
				dontEscape: boolean,
			);

			constructor(
				uriString: string,
				creationOptions: System.UriCreationOptions,
			);

			/**
			 * Initializes a new instance of the {@link System.Uri} class with the specified URI.
			 * This constructor allows you to specify if the URI string is a relative URI, absolute
			 * URI, or is indeterminate.
			 */
			constructor(
				uriString: string,
				uriKind: System.UriKind,
			);

			/**
			 * Initializes a new instance of the {@link System.Uri} class based on the specified base
			 * URI and relative URI string.
			 */
			constructor(
				baseUri: System.Uri,
				relativeUri: string | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.Uri} class based on the specified base
			 * and relative URIs, with explicit control of character escaping.
			 */
			constructor(
				baseUri: System.Uri,
				relativeUri: string | undefined,
				dontEscape: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.Uri} class based on the combination of
			 * a specified base {@link System.Uri} instance and a relative {@link System.Uri}
			 * instance.
			 */
			constructor(
				baseUri: System.Uri,
				relativeUri: System.Uri,
			);

			/** Gets the absolute path of the URI. */
			readonly AbsolutePath: string;

			/** Gets the absolute URI. */
			readonly AbsoluteUri: string;

			/**
			 * Gets the Domain Name System (DNS) host name or IP address and the port number for a
			 * server.
			 */
			readonly Authority: string;

			/**
			 * Gets a host name that, after being unescaped if necessary, is safe to use for DNS
			 * resolution.
			 */
			readonly DnsSafeHost: string;

			/** Gets the escaped URI fragment, including the leading '#' character if not empty. */
			readonly Fragment: string;

			/** Gets the host component of this instance. */
			readonly Host: string;

			/** Gets the type of the host name specified in the URI. */
			readonly HostNameType: System.UriHostNameType;

			/**
			 * Gets the RFC 3490 compliant International Domain Name of the host, using Punycode as
			 * appropriate. This string, after being unescaped if necessary, is safe to use for DNS
			 * resolution.
			 */
			readonly IdnHost: string;

			/** Gets a value that indicates whether the {@link System.Uri} instance is absolute. */
			readonly IsAbsoluteUri: boolean;

			/**
			 * Gets a value that indicates whether the port value of the URI is the default for this
			 * scheme.
			 */
			readonly IsDefaultPort: boolean;

			/**
			 * Gets a value that indicates whether the specified {@link System.Uri} is a file URI.
			 */
			readonly IsFile: boolean;

			/**
			 * Gets a value that indicates whether the specified {@link System.Uri} references the
			 * local host.
			 */
			readonly IsLoopback: boolean;

			/**
			 * Gets a value that indicates whether the specified {@link System.Uri} is a universal
			 * naming convention (UNC) path.
			 */
			readonly IsUnc: boolean;

			/** Gets a local operating-system representation of a file name. */
			readonly LocalPath: string;

			/**
			 * Gets the original URI string that was passed to the {@link System.Uri} constructor.
			 */
			readonly OriginalString: string;

			/**
			 * Gets the {@link System.Uri.AbsolutePath} and {@link System.Uri.Query} properties
			 * separated by a question mark (?).
			 */
			readonly PathAndQuery: string;

			/** Gets the port number of this URI. */
			readonly Port: number;

			/**
			 * Gets any query information included in the specified URI, including the leading '?'
			 * character if not empty.
			 */
			readonly Query: string;

			/** Gets the scheme name for this URI. */
			readonly Scheme: string;

			/** Gets an array containing the path segments that make up the specified URI. */
			readonly Segments: string[];

			/**
			 * Gets a value that indicates whether the URI string was completely escaped before the
			 * {@link System.Uri} instance was created.
			 */
			readonly UserEscaped: boolean;

			/**
			 * Gets the user name, password, or other user-specific information associated with the
			 * specified URI.
			 */
			readonly UserInfo: string;

			/** Determines whether the specified host name is a valid DNS name. */
			static CheckHostName(name: string | undefined): System.UriHostNameType;

			/** Determines whether the specified scheme name is valid. */
			static CheckSchemeName(schemeName: string | undefined): boolean;

			/** Compares the specified parts of two URIs using the specified comparison rules. */
			static Compare(
				uri1: System.Uri | undefined,
				uri2: System.Uri | undefined,
				partsToCompare: System.UriComponents,
				compareFormat: System.UriFormat,
				comparisonType: System.StringComparison,
			): number;

			/** Compares two {@link System.Uri} instances for equality. */
			Equals(comparand: System.Object | undefined): boolean;

			/** Converts a string to its escaped representation. */
			static EscapeDataString(stringToEscape: string): string;

			/** Converts a URI string to its escaped representation. */
			static EscapeUriString(stringToEscape: string): string;

			/** Gets the decimal value of a hexadecimal digit. */
			static FromHex(digit: System.Char): number;

			/**
			 * Gets the specified components of the current instance using the specified escaping for
			 * special characters.
			 */
			GetComponents(
				components: System.UriComponents,
				format: System.UriFormat,
			): string;

			/** Gets the hash code for the URI. */
			GetHashCode(): number;

			/** Gets the specified portion of a {@link System.Uri} instance. */
			GetLeftPart(part: System.UriPartial): string;

			/** Converts a specified character into its hexadecimal equivalent. */
			static HexEscape(character: System.Char): string;

			static HexUnescape(
				pattern: string,
				index: number,
			): System.Char;

			/**
			 * Determines whether the current {@link System.Uri} instance is a base of the specified
			 * {@link System.Uri} instance.
			 */
			IsBaseOf(uri: System.Uri): boolean;

			/** Determines whether a specified character is a valid hexadecimal digit. */
			static IsHexDigit(character: System.Char): boolean;

			/** Determines whether a character in a string is hexadecimal encoded. */
			static IsHexEncoding(
				pattern: string,
				index: number,
			): boolean;

			/**
			 * Indicates whether the string used to construct this {@link System.Uri} was well-formed
			 * and does not require further escaping.
			 */
			IsWellFormedOriginalString(): boolean;

			/**
			 * Indicates whether the string is well-formed by attempting to construct a URI with the
			 * string and ensures that the string does not require further escaping.
			 */
			static IsWellFormedUriString(
				uriString: string | undefined,
				uriKind: System.UriKind,
			): boolean;

			/** Determines the difference between two {@link System.Uri} instances. */
			MakeRelative(toUri: System.Uri): string;

			/** Determines the difference between two {@link System.Uri} instances. */
			MakeRelativeUri(uri: System.Uri): System.Uri;

			/**
			 * Gets a canonical string representation for the specified {@link System.Uri} instance.
			 */
			ToString(): string;

			static TryCreate(
				uriString: string | undefined,
				creationOptions: System.UriCreationOptions | undefined,
			): System.Uri | undefined;

			static TryCreate(
				uriString: string | undefined,
				uriKind: System.UriKind,
			): System.Uri | undefined;

			static TryCreate(
				baseUri: System.Uri | undefined,
				relativeUri: string | undefined,
			): System.Uri | undefined;

			static TryCreate(
				baseUri: System.Uri | undefined,
				relativeUri: System.Uri | undefined,
			): System.Uri | undefined;

			TryFormat(destination: System.Span$1<System.Char>): number | undefined;

			/** Converts a string to its unescaped representation. */
			static UnescapeDataString(stringToUnescape: string): string;
		}
	}

	export namespace System {
		/**
		 * Provides a custom constructor for uniform resource identifiers (URIs) and modifies
		 * URIs for the {@link System.Uri} class.
		 */
		export class UriBuilder {
			/** Initializes a new instance of the {@link System.UriBuilder} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.UriBuilder} class with the specified
			 * URI.
			 */
			constructor(uri: string);

			/**
			 * Initializes a new instance of the {@link System.UriBuilder} class with the specified
			 * scheme and host.
			 */
			constructor(
				schemeName: string | undefined,
				hostName: string | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.UriBuilder} class with the specified
			 * scheme, host, and port.
			 */
			constructor(
				scheme: string | undefined,
				host: string | undefined,
				portNumber: number,
			);

			/**
			 * Initializes a new instance of the {@link System.UriBuilder} class with the specified
			 * scheme, host, port number, and path.
			 */
			constructor(
				scheme: string | undefined,
				host: string | undefined,
				port: number,
				pathValue: string | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.UriBuilder} class with the specified
			 * scheme, host, port number, path, and query string or fragment identifier.
			 */
			constructor(
				scheme: string | undefined,
				host: string | undefined,
				port: number,
				path: string | undefined,
				extraValue: string | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.UriBuilder} class with the specified
			 * {@link System.Uri} instance.
			 */
			constructor(uri: System.Uri);

			/**
			 * Gets or sets the fragment portion of the URI, including the leading '#' character if
			 * not empty.
			 */
			Fragment: string;

			/** Gets or sets the Domain Name System (DNS) host name or IP address of a server. */
			Host: string;

			/** Gets or sets the password associated with the user that accesses the URI. */
			Password: string;

			/** Gets or sets the path to the resource referenced by the URI. */
			Path: string;

			/** Gets or sets the port number of the URI. */
			Port: number;

			/**
			 * Gets or sets any query information included in the URI, including the leading '?'
			 * character if not empty.
			 */
			Query: string;

			/** Gets or sets the scheme name of the URI. */
			Scheme: string;

			/**
			 * Gets the {@link System.Uri} instance constructed by the specified
			 * {@link System.UriBuilder} instance.
			 */
			readonly Uri: System.Uri;

			/** Gets or sets the user name associated with the user that accesses the URI. */
			UserName: string;

			/**
			 * Compares an existing {@link System.Uri} instance with the contents of the
			 * {@link System.UriBuilder} for equality.
			 */
			Equals(rparam: System.Object | undefined): boolean;

			/** Returns the hash code for the URI. */
			GetHashCode(): number;

			/** Returns the display string for the specified {@link System.UriBuilder} instance. */
			ToString(): string;
		}
	}

	export namespace System {
		/** Specifies the parts of a {@link System.Uri}. */
		export enum UriComponents {
			/**
			 * The complete {@link System.Uri} context that is needed for Uri Serializers. The
			 * context includes the IPv6 scope.
			 */
			SerializationInfoString = -2147483648,

			/** The {@link System.Uri.Scheme} data. */
			Scheme = 1,

			/** The {@link System.Uri.UserInfo} data. */
			UserInfo = 2,

			/** The {@link System.Uri.Host} data. */
			Host = 4,

			/** The {@link System.Uri.Port} data. */
			Port = 8,

			/**
			 * The {@link System.Uri.Scheme}, {@link System.Uri.Host}, and {@link System.Uri.Port}
			 * data.
			 */
			SchemeAndServer = 13,

			/** The {@link System.Uri.LocalPath} data. */
			Path = 16,

			/** The {@link System.Uri.Query} data. */
			Query = 32,

			/**
			 * The {@link System.Uri.LocalPath} and {@link System.Uri.Query} data. Also see
			 * {@link System.Uri.PathAndQuery}.
			 */
			PathAndQuery = 48,

			/**
			 * The {@link System.Uri.Scheme}, {@link System.Uri.Host}, {@link System.Uri.Port},
			 * {@link System.Uri.LocalPath}, and {@link System.Uri.Query} data.
			 */
			HttpRequestUrl = 61,

			/** The {@link System.Uri.Fragment} data. */
			Fragment = 64,

			/**
			 * The {@link System.Uri.Scheme}, {@link System.Uri.UserInfo}, {@link System.Uri.Host},
			 * {@link System.Uri.Port}, {@link System.Uri.LocalPath}, {@link System.Uri.Query}, and
			 * {@link System.Uri.Fragment} data.
			 */
			AbsoluteUri = 127,

			/**
			 * The {@link System.Uri.Port} data. If no port data is in the {@link System.Uri} and a
			 * default port has been assigned to the {@link System.Uri.Scheme}, the default port is
			 * returned. If there is no default port, -1 is returned.
			 */
			StrongPort = 128,

			/**
			 * The {@link System.Uri.Host} and {@link System.Uri.Port} data. If no port data is in
			 * the Uri and a default port has been assigned to the {@link System.Uri.Scheme}, the
			 * default port is returned. If there is no default port, -1 is returned.
			 */
			HostAndPort = 132,

			/**
			 * The {@link System.Uri.UserInfo}, {@link System.Uri.Host}, and {@link System.Uri.Port}
			 * data. If no port data is in the {@link System.Uri} and a default port has been
			 * assigned to the {@link System.Uri.Scheme}, the default port is returned. If there is
			 * no default port, -1 is returned.
			 */
			StrongAuthority = 134,

			/** The normalized form of the {@link System.Uri.Host}. */
			NormalizedHost = 256,

			/** Specifies that the delimiter should be included. */
			KeepDelimiter = 1073741824,
		}
	}

	export namespace System {
		/** Provides options that control how a {@link System.Uri} is created and behaves. */
		export class UriCreationOptions extends System.ValueType {
			/**
			 * Gets or sets a value that indicates whether the path and query are validated and
			 * normalized.
			 */
			DangerousDisablePathAndQueryCanonicalization: boolean;
		}
	}

	export namespace System {
		/** Controls how URI information is escaped. */
		export enum UriFormat {
			/** Escaping is performed according to the rules in RFC 2396. */
			UriEscaped = 1,

			/** No escaping is performed. */
			Unescaped = 2,

			/**
			 * Characters that have a reserved meaning in the requested URI components remain
			 * escaped. All others are not escaped.
			 */
			SafeUnescaped = 3,
		}
	}

	export namespace System {
		/**
		 * The exception that is thrown when an invalid Uniform Resource Identifier (URI) is
		 * detected.
		 */
		export class UriFormatException extends System.FormatException {
			/** Initializes a new instance of the {@link System.UriFormatException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.UriFormatException} class with the
			 * specified message.
			 */
			constructor(textString: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.UriFormatException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				textString: string | undefined,
				e: System.Exception | undefined,
			);
		}
	}

	export namespace System {
		/**
		 * Defines host name types for the {@link System.Uri.CheckHostName(System.String)}
		 * method.
		 */
		export enum UriHostNameType {
			/** The type of the host name is not supplied. */
			Unknown = 0,

			/** The host is set, but the type cannot be determined. */
			Basic = 1,

			/** The host name is a domain name system (DNS) style host name. */
			Dns = 2,

			/** The host name is an Internet Protocol (IP) version 4 host address. */
			IPv4 = 3,

			/** The host name is an Internet Protocol (IP) version 6 host address. */
			IPv6 = 4,
		}
	}

	export namespace System {
		/** Defines the different kinds of URIs. */
		export enum UriKind {
			/** The URI kind is indeterminate. */
			RelativeOrAbsolute = 0,

			/** The URI is absolute. */
			Absolute = 1,

			/** The URI is relative. */
			Relative = 2,
		}
	}

	export namespace System {
		/** Parses a new URI scheme. This is an abstract class. */
		export class UriParser {
			/** Indicates whether the parser for a scheme is registered. */
			static IsKnownScheme(schemeName: string): boolean;

			/** Associates a scheme and port number with a {@link System.UriParser}. */
			static Register(
				uriParser: System.UriParser,
				schemeName: string,
				defaultPort: number,
			): void;
		}
	}

	export namespace System {
		/**
		 * Defines the parts of a URI for the {@link System.Uri.GetLeftPart(System.UriPartial)}
		 * method.
		 */
		export enum UriPartial {
			/** The scheme segment of the URI. */
			Scheme = 0,

			/** The scheme and authority segments of the URI. */
			Authority = 1,

			/** The scheme, authority, and path segments of the URI. */
			Path = 2,

			/** The scheme, authority, path, and query segments of the URI. */
			Query = 3,
		}
	}

	export namespace System.Threading {
		/** Propagates notification that operations should be canceled. */
		export class CancellationToken extends System.ValueType implements System.IEquatable$1<AbortSignal> {
			/** Initializes the {@link System.Threading.CancellationToken}. */
			constructor(canceled: boolean);

			/** Gets whether this token is capable of being in the canceled state. */
			readonly CanBeCanceled: boolean;

			/** Gets whether cancellation has been requested for this token. */
			readonly IsCancellationRequested: boolean;

			/** Returns an empty {@link System.Threading.CancellationToken} value. */
			static readonly None: AbortSignal;

			/**
			 * Gets a {@link System.Threading.WaitHandle} that is signaled when the token is
			 * canceled.
			 */
			readonly WaitHandle: System.Threading.WaitHandle;

			/**
			 * Determines whether the current {@link System.Threading.CancellationToken} instance is
			 * equal to the specified {@link System.Object}.
			 */
			Equals(other: System.Object | undefined): boolean;

			/**
			 * Determines whether the current {@link System.Threading.CancellationToken} instance is
			 * equal to the specified token.
			 */
			Equals(other: AbortSignal): boolean;

			/** Serves as a hash function for a {@link System.Threading.CancellationToken}. */
			GetHashCode(): number;

			/**
			 * Registers a delegate that will be called when this
			 * {@link System.Threading.CancellationToken} is canceled.
			 */
			Register(callback: () => void): System.Threading.CancellationTokenRegistration;

			/**
			 * Registers a delegate that will be called when this
			 * {@link System.Threading.CancellationToken} is canceled.
			 */
			Register(
				callback: () => void,
				useSynchronizationContext: boolean,
			): System.Threading.CancellationTokenRegistration;

			/**
			 * Registers a delegate that will be called when this
			 * {@link System.Threading.CancellationToken} is canceled.
			 */
			Register(
				callback: System.Action$2<System.Object | undefined, AbortSignal>,
				state: System.Object | undefined,
			): System.Threading.CancellationTokenRegistration;

			/**
			 * Registers a delegate that will be called when this
			 * {@link System.Threading.CancellationToken} is canceled.
			 */
			Register(
				callback: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
			): System.Threading.CancellationTokenRegistration;

			/**
			 * Registers a delegate that will be called when this
			 * {@link System.Threading.CancellationToken} is canceled.
			 */
			Register(
				callback: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
				useSynchronizationContext: boolean,
			): System.Threading.CancellationTokenRegistration;

			/**
			 * Throws a {@link System.OperationCanceledException} if this token has had cancellation
			 * requested.
			 */
			ThrowIfCancellationRequested(): void;

			/**
			 * Registers a delegate that will be called when this
			 * {@link System.Threading.CancellationToken} is canceled.
			 */
			UnsafeRegister(
				callback: System.Action$2<System.Object | undefined, AbortSignal>,
				state: System.Object | undefined,
			): System.Threading.CancellationTokenRegistration;

			/**
			 * Registers a delegate that is called when this
			 * {@link System.Threading.CancellationToken} is canceled.
			 */
			UnsafeRegister(
				callback: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
			): System.Threading.CancellationTokenRegistration;
		}
	}

	export namespace System.Threading {
		/**
		 * Represents a callback delegate that has been registered with a
		 * {@link System.Threading.CancellationToken}.
		 */
		export class CancellationTokenRegistration extends System.ValueType implements
			System.IAsyncDisposable,
			IDisposable,
			System.IEquatable$1<System.Threading.CancellationTokenRegistration> {
			/**
			 * Gets the {@link System.Threading.CancellationToken} with which this registration is
			 * associated.
			 */
			readonly Token: AbortSignal;

			/**
			 * Disposes of the registration and unregisters the target callback from the associated
			 * {@link System.Threading.CancellationToken}.
			 */
			dispose(): void;

			/**
			 * Disposes of the registration and unregisters the target callback from the associated
			 * {@link System.Threading.CancellationToken}.
			 */
			DisposeAsync(): Promise<void>;

			/**
			 * Determines whether the current {@link System.Threading.CancellationTokenRegistration}
			 * instance is equal to the specified
			 * {@link System.Threading.CancellationTokenRegistration}.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Determines whether the current {@link System.Threading.CancellationTokenRegistration}
			 * instance is equal to the specified
			 * {@link System.Threading.CancellationTokenRegistration}.
			 */
			Equals(other: System.Threading.CancellationTokenRegistration): boolean;

			/**
			 * Serves as a hash function for a
			 * {@link System.Threading.CancellationTokenRegistration}.
			 */
			GetHashCode(): number;

			/**
			 * Disposes of the registration and unregisters the target callback from the associated
			 * {@link System.Threading.CancellationToken}.
			 */
			Unregister(): boolean;
		}
	}

	export namespace System.Threading {
		/**
		 * Signals to a {@link System.Threading.CancellationToken} that it should be canceled.
		 */
		export class CancellationTokenSource implements IDisposable {
			/**
			 * Initializes a new instance of the {@link System.Threading.CancellationTokenSource}
			 * class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Threading.CancellationTokenSource}
			 * class that will be canceled after the specified {@link System.TimeSpan}.
			 */
			constructor(
				delay: number,
				timeProvider: System.TimeProvider,
			);

			/**
			 * Initializes a new instance of the {@link System.Threading.CancellationTokenSource}
			 * class that will be canceled after the specified delay in milliseconds.
			 */
			constructor(millisecondsDelay: number);

			/**
			 * Initializes a new instance of the {@link System.Threading.CancellationTokenSource}
			 * class that will be canceled after the specified time span.
			 */
			constructor(delay: number);

			/**
			 * Gets whether cancellation has been requested for this
			 * {@link System.Threading.CancellationTokenSource}.
			 */
			readonly IsCancellationRequested: boolean;

			/**
			 * Gets the {@link System.Threading.CancellationToken} associated with this
			 * {@link System.Threading.CancellationTokenSource}.
			 */
			readonly Token: AbortSignal;

			/** Communicates a request for cancellation. */
			Cancel(): void;

			/**
			 * Communicates a request for cancellation, and specifies whether remaining callbacks and
			 * cancelable operations should be processed if an exception occurs.
			 */
			Cancel(throwOnFirstException: boolean): void;

			/**
			 * Schedules a cancel operation on this {@link System.Threading.CancellationTokenSource}
			 * after the specified number of milliseconds.
			 */
			CancelAfter(millisecondsDelay: number): void;

			/**
			 * Schedules a cancel operation on this {@link System.Threading.CancellationTokenSource}
			 * after the specified time span.
			 */
			CancelAfter(delay: number): void;

			/** Communicates a request for cancellation asynchronously. */
			CancelAsync(): Promise<void>;

			/**
			 * Creates a {@link System.Threading.CancellationTokenSource} that will be in the
			 * canceled state when the supplied token is in the canceled state.
			 */
			static CreateLinkedTokenSource(token: AbortSignal): System.Threading.CancellationTokenSource;

			/**
			 * Creates a {@link System.Threading.CancellationTokenSource} that will be in the
			 * canceled state when any of the source tokens are in the canceled state.
			 */
			static CreateLinkedTokenSource(
				token1: AbortSignal,
				token2: AbortSignal,
			): System.Threading.CancellationTokenSource;

			/**
			 * Creates a {@link System.Threading.CancellationTokenSource} that will be in the
			 * canceled state when any of the source tokens in the specified array are in the
			 * canceled state.
			 */
			static CreateLinkedTokenSource(tokens: AbortSignal[]): System.Threading.CancellationTokenSource;

			/**
			 * Releases all resources used by the current instance of the
			 * {@link System.Threading.CancellationTokenSource} class.
			 */
			dispose(): void;

			/**
			 * Attempts to reset the {@link System.Threading.CancellationTokenSource} to be used for
			 * an unrelated operation.
			 */
			TryReset(): boolean;
		}
	}

	export namespace System.Threading {
		/**
		 * Specifies how a {@link System.Lazy<>} instance synchronizes access among multiple
		 * threads.
		 */
		export enum LazyThreadSafetyMode {
			/**
			 * The {@link System.Lazy<>} instance is not thread safe; if the instance is accessed
			 * from multiple threads, its behavior is undefined. Use this mode only when high
			 * performance is crucial and the {@link System.Lazy<>} instance is guaranteed never to
			 * be initialized from more than one thread. If you use a {@link System.Lazy<>}
			 * constructor that specifies an initialization method ( `valueFactory` parameter), and
			 * if that initialization method throws an exception (or fails to handle an exception)
			 * the first time you call the {@link System.Lazy`1.Value} property, then the exception
			 * is cached and thrown again on subsequent calls to the {@link System.Lazy`1.Value}
			 * property. If you use a {@link System.Lazy<>} constructor that does not specify an
			 * initialization method, exceptions that are thrown by the parameterless constructor for
			 * `T` are not cached. In that case, a subsequent call to the {@link System.Lazy`1.Value}
			 * property might successfully initialize the {@link System.Lazy<>} instance. If the
			 * initialization method recursively accesses the {@link System.Lazy`1.Value} property of
			 * the {@link System.Lazy<>} instance, an {@link System.InvalidOperationException} is
			 * thrown.
			 */
			None = 0,

			/**
			 * When multiple threads try to initialize a {@link System.Lazy<>} instance
			 * simultaneously, all threads are allowed to run the initialization method (or the
			 * parameterless constructor, if there is no initialization method). The first thread to
			 * complete initialization sets the value of the {@link System.Lazy<>} instance. This is
			 * referred to as Publication in the field names. That value is returned to any other
			 * threads that were simultaneously running the initialization method, unless the
			 * initialization method throws exceptions on those threads. Any instances of `T` that
			 * were created by the competing threads are discarded. Effectively, the publication of
			 * the initialized value is thread-safe in the sense that only one of the initialized
			 * values may be published and used by all threads. If the initialization method throws
			 * an exception on any thread, the exception is propagated out of the
			 * {@link System.Lazy`1.Value} property on that thread. The exception is not cached. The
			 * value of the {@link System.Lazy`1.IsValueCreated} property remains `false`, and
			 * subsequent calls to the {@link System.Lazy`1.Value} property, either by the thread
			 * where the exception was thrown or by other threads, cause the initialization method to
			 * run again. If the initialization method recursively accesses the
			 * {@link System.Lazy`1.Value} property of the {@link System.Lazy<>} instance, no
			 * exception is thrown.
			 */
			PublicationOnly = 1,

			/**
			 * Locks are used to ensure that only a single thread can initialize a
			 * {@link System.Lazy<>} instance in a thread-safe manner. Effectively, the
			 * initialization method is executed in a thread-safe manner (referred to as Execution in
			 * the field name). Publication of the initialized value is also thread-safe in the sense
			 * that only one value may be published and used by all threads. If the initialization
			 * method (or the parameterless constructor, if there is no initialization method) uses
			 * locks internally, deadlocks can occur. If you use a {@link System.Lazy<>} constructor
			 * that specifies an initialization method ( `valueFactory` parameter), and if that
			 * initialization method throws an exception (or fails to handle an exception) the first
			 * time you call the {@link System.Lazy`1.Value} property, then the exception is cached
			 * and thrown again on subsequent calls to the {@link System.Lazy`1.Value} property. If
			 * you use a {@link System.Lazy<>} constructor that does not specify an initialization
			 * method, exceptions that are thrown by the parameterless constructor for `T` are not
			 * cached. In that case, a subsequent call to the {@link System.Lazy`1.Value} property
			 * might successfully initialize the {@link System.Lazy<>} instance. If the
			 * initialization method recursively accesses the {@link System.Lazy`1.Value} property of
			 * the {@link System.Lazy<>} instance, an {@link System.InvalidOperationException} is
			 * thrown.
			 */
			ExecutionAndPublication = 2,
		}
	}

	export namespace System.Threading {
		/** Provides a periodic timer that enables waiting asynchronously for timer ticks. */
		export class PeriodicTimer implements IDisposable {
			/** Initializes the timer. */
			constructor(period: number);

			/** Initializes the timer. */
			constructor(
				period: number,
				timeProvider: System.TimeProvider,
			);

			/** Gets or sets the period between ticks. */
			Period: number;

			/** Stops the timer and releases the associated managed resources. */
			dispose(): void;

			/** Waits for the next tick of the timer, or for the timer to be stopped. */
			WaitForNextTickAsync(cancellationToken?: AbortSignal): Promise<boolean>;
		}
	}

	export namespace System.Threading {
		/**
		 * Contains constants that specify infinite time-out intervals. This class cannot be
		 * inherited.
		 */
		export namespace Timeout {
		}
	}

	export namespace System.Threading {
		/** Represents a timer that can have its due time and period changed. */
		export interface ITimer extends
			IDisposable,
			System.IAsyncDisposable {
			/**
			 * Changes the start time and the interval between method invocations for a timer, using
			 * {@link System.TimeSpan} values to measure time intervals.
			 */
			Change(
				dueTime: number,
				period: number,
			): boolean;
		}
	}

	export namespace System.Threading {
		/**
		 * Provides a mechanism for executing a method on a thread pool thread at specified
		 * intervals. This class cannot be inherited.
		 */
		export class Timer extends System.MarshalByRefObject implements
			System.IAsyncDisposable,
			IDisposable,
			System.Threading.ITimer {
			/**
			 * Initializes a new instance of the {@link System.Threading.Timer} class with an
			 * infinite period and an infinite due time, using the newly created
			 * {@link System.Threading.Timer} object as the state object.
			 */
			constructor(callback: System.Threading.TimerCallback);

			/**
			 * Initializes a new instance of the `Timer` class, using a 32-bit signed integer to
			 * specify the time interval.
			 */
			constructor(
				callback: System.Threading.TimerCallback,
				state: System.Object | undefined,
				dueTime: number,
				period: number,
			);

			/**
			 * Initializes a new instance of the `Timer` class, using 64-bit signed integers to
			 * measure time intervals.
			 */
			constructor(
				callback: System.Threading.TimerCallback,
				state: System.Object | undefined,
				dueTime: number,
				period: number,
			);

			/**
			 * Initializes a new instance of the `Timer` class, using {@link System.TimeSpan} values
			 * to measure time intervals.
			 */
			constructor(
				callback: System.Threading.TimerCallback,
				state: System.Object | undefined,
				dueTime: number,
				period: number,
			);

			/**
			 * Initializes a new instance of the `Timer` class, using 32-bit unsigned integers to
			 * measure time intervals.
			 */
			constructor(
				callback: System.Threading.TimerCallback,
				state: System.Object | undefined,
				dueTime: number,
				period: number,
			);

			/**
			 * Gets the number of timers that are currently active. An active timer is registered to
			 * tick at some point in the future, and has not yet been canceled.
			 */
			static readonly ActiveCount: number;

			/**
			 * Changes the start time and the interval between method invocations for a timer, using
			 * 32-bit signed integers to measure time intervals.
			 */
			Change(
				dueTime: number,
				period: number,
			): boolean;

			/**
			 * Changes the start time and the interval between method invocations for a timer, using
			 * 64-bit signed integers to measure time intervals.
			 */
			Change(
				dueTime: number,
				period: number,
			): boolean;

			/**
			 * Changes the start time and the interval between method invocations for a timer, using
			 * {@link System.TimeSpan} values to measure time intervals.
			 */
			Change(
				dueTime: number,
				period: number,
			): boolean;

			/**
			 * Changes the start time and the interval between method invocations for a timer, using
			 * 32-bit unsigned integers to measure time intervals.
			 */
			Change(
				dueTime: number,
				period: number,
			): boolean;

			/**
			 * Releases all resources used by the current instance of {@link System.Threading.Timer}.
			 */
			dispose(): void;

			/**
			 * Releases all resources used by the current instance of {@link System.Threading.Timer}
			 * and signals when the timer has been disposed of.
			 */
			dispose(notifyObject: System.Threading.WaitHandle): boolean;

			/**
			 * Releases all resources used by the current instance of {@link System.Threading.Timer}.
			 */
			DisposeAsync(): Promise<void>;
		}
	}

	export namespace System.Threading {
		/** Represents the method that handles calls from a {@link System.Threading.Timer}. */
		export interface TimerCallback { (state: System.Object | undefined): void; }
	}

	export namespace System.Threading {
		/**
		 * Encapsulates operating system-specific objects that wait for exclusive access to
		 * shared resources.
		 */
		export class WaitHandle extends System.MarshalByRefObject implements IDisposable {
			/** Gets or sets the native operating system handle. */
			Handle: System.IntPtr;

			/** Gets or sets the native operating system handle. */
			SafeWaitHandle: Microsoft.Win32.SafeHandles.SafeWaitHandle;

			/** Releases all resources held by the current {@link System.Threading.WaitHandle}. */
			Close(): void;

			/**
			 * Releases all resources used by the current instance of the
			 * {@link System.Threading.WaitHandle} class.
			 */
			dispose(): void;

			/** Signals one {@link System.Threading.WaitHandle} and waits on another. */
			static SignalAndWait(
				toSignal: System.Threading.WaitHandle,
				toWaitOn: System.Threading.WaitHandle,
			): boolean;

			/**
			 * Signals one {@link System.Threading.WaitHandle} and waits on another, specifying a
			 * time-out interval as a 32-bit signed integer and specifying whether to exit the
			 * synchronization domain for the context before entering the wait.
			 */
			static SignalAndWait(
				toSignal: System.Threading.WaitHandle,
				toWaitOn: System.Threading.WaitHandle,
				millisecondsTimeout: number,
				exitContext: boolean,
			): boolean;

			/**
			 * Signals one {@link System.Threading.WaitHandle} and waits on another, specifying the
			 * time-out interval as a {@link System.TimeSpan} and specifying whether to exit the
			 * synchronization domain for the context before entering the wait.
			 */
			static SignalAndWait(
				toSignal: System.Threading.WaitHandle,
				toWaitOn: System.Threading.WaitHandle,
				timeout: number,
				exitContext: boolean,
			): boolean;

			/** Waits for all the elements in the specified array to receive a signal. */
			static WaitAll(waitHandles: System.Threading.WaitHandle[]): boolean;

			/**
			 * Waits for all the elements in the specified array to receive a signal, using an
			 * {@link System.Int32} value to specify the time interval.
			 */
			static WaitAll(
				waitHandles: System.Threading.WaitHandle[],
				millisecondsTimeout: number,
			): boolean;

			/**
			 * Waits for all the elements in the specified array to receive a signal, using an
			 * {@link System.Int32} value to specify the time interval and specifying whether to exit
			 * the synchronization domain before the wait.
			 */
			static WaitAll(
				waitHandles: System.Threading.WaitHandle[],
				millisecondsTimeout: number,
				exitContext: boolean,
			): boolean;

			/**
			 * Waits for all the elements in the specified array to receive a signal, using a
			 * {@link System.TimeSpan} value to specify the time interval.
			 */
			static WaitAll(
				waitHandles: System.Threading.WaitHandle[],
				timeout: number,
			): boolean;

			/**
			 * Waits for all the elements in the specified array to receive a signal, using a
			 * {@link System.TimeSpan} value to specify the time interval, and specifying whether to
			 * exit the synchronization domain before the wait.
			 */
			static WaitAll(
				waitHandles: System.Threading.WaitHandle[],
				timeout: number,
				exitContext: boolean,
			): boolean;

			/** Waits for any of the elements in the specified array to receive a signal. */
			static WaitAny(waitHandles: System.Threading.WaitHandle[]): number;

			/**
			 * Waits for any of the elements in the specified array to receive a signal, using a
			 * 32-bit signed integer to specify the time interval.
			 */
			static WaitAny(
				waitHandles: System.Threading.WaitHandle[],
				millisecondsTimeout: number,
			): number;

			/**
			 * Waits for any of the elements in the specified array to receive a signal, using a
			 * 32-bit signed integer to specify the time interval, and specifying whether to exit the
			 * synchronization domain before the wait.
			 */
			static WaitAny(
				waitHandles: System.Threading.WaitHandle[],
				millisecondsTimeout: number,
				exitContext: boolean,
			): number;

			/**
			 * Waits for any of the elements in the specified array to receive a signal, using a
			 * {@link System.TimeSpan} to specify the time interval.
			 */
			static WaitAny(
				waitHandles: System.Threading.WaitHandle[],
				timeout: number,
			): number;

			/**
			 * Waits for any of the elements in the specified array to receive a signal, using a
			 * {@link System.TimeSpan} to specify the time interval and specifying whether to exit
			 * the synchronization domain before the wait.
			 */
			static WaitAny(
				waitHandles: System.Threading.WaitHandle[],
				timeout: number,
				exitContext: boolean,
			): number;

			/**
			 * Blocks the current thread until the current {@link System.Threading.WaitHandle}
			 * receives a signal.
			 */
			WaitOne(): boolean;

			/**
			 * Blocks the current thread until the current {@link System.Threading.WaitHandle}
			 * receives a signal, using a 32-bit signed integer to specify the time interval in
			 * milliseconds.
			 */
			WaitOne(millisecondsTimeout: number): boolean;

			/**
			 * Blocks the current thread until the current {@link System.Threading.WaitHandle}
			 * receives a signal, using a 32-bit signed integer to specify the time interval and
			 * specifying whether to exit the synchronization domain before the wait.
			 */
			WaitOne(
				millisecondsTimeout: number,
				exitContext: boolean,
			): boolean;

			/**
			 * Blocks the current thread until the current instance receives a signal, using a
			 * {@link System.TimeSpan} to specify the time interval.
			 */
			WaitOne(timeout: number): boolean;

			/**
			 * Blocks the current thread until the current instance receives a signal, using a
			 * {@link System.TimeSpan} to specify the time interval and specifying whether to exit
			 * the synchronization domain before the wait.
			 */
			WaitOne(
				timeout: number,
				exitContext: boolean,
			): boolean;
		}
	}

	export namespace System.Threading {
		/** Provides convenience methods to for working with a safe handle for a wait handle. */
		export namespace WaitHandleExtensions {
			/** Gets the safe handle for a native operating system wait handle. */
			export function GetSafeWaitHandle(waitHandle: System.Threading.WaitHandle): Microsoft.Win32.SafeHandles.SafeWaitHandle;

			/** Sets a safe handle for a native operating system wait handle. */
			export function SetSafeWaitHandle(
				waitHandle: System.Threading.WaitHandle,
				value: Microsoft.Win32.SafeHandles.SafeWaitHandle | undefined,
			): void;
		}
	}

	export namespace System.Threading {
		/** Extension methods from {@link System.Threading.WaitHandleExtensions} */
		export interface WaitHandle {
			/** Gets the safe handle for a native operating system wait handle. */
			GetSafeWaitHandle(): Microsoft.Win32.SafeHandles.SafeWaitHandle;

			/** Sets a safe handle for a native operating system wait handle. */
			SetSafeWaitHandle(value: Microsoft.Win32.SafeHandles.SafeWaitHandle | undefined): void;
		}
	}

	export namespace System.Threading.Tasks {
		/** Options to control behavior when awaiting. */
		export enum ConfigureAwaitOptions {
			/** No options specified. */
			None = 0,

			/**
			 * Attempts to marshal the continuation back to the original
			 * {@link System.Threading.SynchronizationContext} or
			 * {@link System.Threading.Tasks.TaskScheduler} present on the originating thread at the
			 * time of the await.
			 */
			ContinueOnCapturedContext = 1,

			/**
			 * Avoids throwing an exception at the completion of awaiting a
			 * {@link System.Threading.Tasks.Task} that ends in the
			 * {@link System.Threading.Tasks.TaskStatus.Faulted} or
			 * {@link System.Threading.Tasks.TaskStatus.Canceled} state.
			 */
			SuppressThrowing = 2,

			/**
			 * Forces an await on an already completed {@link System.Threading.Tasks.Task} to behave
			 * as if the {@link System.Threading.Tasks.Task} wasn't yet completed, such that the
			 * current asynchronous method will be forced to yield its execution.
			 */
			ForceYielding = 4,
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Provides task schedulers that coordinate to execute tasks while ensuring that
		 * concurrent tasks may run concurrently and exclusive tasks never do.
		 */
		export class ConcurrentExclusiveSchedulerPair {
			/**
			 * Initializes a new instance of the
			 * {@link System.Threading.Tasks.ConcurrentExclusiveSchedulerPair} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Threading.Tasks.ConcurrentExclusiveSchedulerPair} class that targets the
			 * specified scheduler.
			 */
			constructor(taskScheduler: System.Threading.Tasks.TaskScheduler);

			/**
			 * Initializes a new instance of the
			 * {@link System.Threading.Tasks.ConcurrentExclusiveSchedulerPair} class that targets the
			 * specified scheduler with a maximum concurrency level.
			 */
			constructor(
				taskScheduler: System.Threading.Tasks.TaskScheduler,
				maxConcurrencyLevel: number,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Threading.Tasks.ConcurrentExclusiveSchedulerPair} class that targets the
			 * specified scheduler with a maximum concurrency level and a maximum number of scheduled
			 * tasks that may be processed as a unit.
			 */
			constructor(
				taskScheduler: System.Threading.Tasks.TaskScheduler,
				maxConcurrencyLevel: number,
				maxItemsPerTask: number,
			);

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when the scheduler has
			 * completed processing.
			 */
			readonly Completion: Promise<void>;

			/**
			 * Gets a {@link System.Threading.Tasks.TaskScheduler} that can be used to schedule tasks
			 * to this pair that may run concurrently with other tasks on this pair.
			 */
			readonly ConcurrentScheduler: System.Threading.Tasks.TaskScheduler;

			/**
			 * Gets a {@link System.Threading.Tasks.TaskScheduler} that can be used to schedule tasks
			 * to this pair that must run exclusively with regards to other tasks on this pair.
			 */
			readonly ExclusiveScheduler: System.Threading.Tasks.TaskScheduler;

			/** Informs the scheduler pair that it should not accept any more tasks. */
			Complete(): void;
		}
	}

	export namespace System.Threading.Tasks {
		/** Represents an asynchronous operation. */
		export class Task implements
			IDisposable {
			/** Initializes a new {@link System.Threading.Tasks.Task} with the specified action. */
			constructor(action: () => void);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task} with the specified action and
			 * {@link System.Threading.CancellationToken}.
			 */
			constructor(
				action: () => void,
				cancellationToken: AbortSignal,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task} with the specified action and
			 * creation options.
			 */
			constructor(
				action: () => void,
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task} with the specified action and
			 * creation options.
			 */
			constructor(
				action: () => void,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task} with the specified action and
			 * state.
			 */
			constructor(
				action: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task} with the specified action,
			 * state, and options.
			 */
			constructor(
				action: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task} with the specified action,
			 * state, and options.
			 */
			constructor(
				action: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task} with the specified action,
			 * state, and options.
			 */
			constructor(
				action: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			);

			/**
			 * Gets the state object supplied when the {@link System.Threading.Tasks.Task} was
			 * created, or null if none was supplied.
			 */
			readonly AsyncState?: System.Object;

			/** Gets a task that has already completed successfully. */
			static readonly CompletedTask: Promise<void>;

			/**
			 * Gets the {@link System.Threading.Tasks.TaskCreationOptions} used to create this task.
			 */
			readonly CreationOptions: System.Threading.Tasks.TaskCreationOptions;

			/** Returns the ID of the currently executing {@link System.Threading.Tasks.Task}. */
			static readonly CurrentId?: number;

			/**
			 * Gets the {@link System.AggregateException} that caused the
			 * {@link System.Threading.Tasks.Task} to end prematurely. If the
			 * {@link System.Threading.Tasks.Task} completed successfully or has not yet thrown any
			 * exceptions, this will return `null`.
			 */
			readonly Exception?: System.AggregateException;

			/**
			 * Provides access to factory methods for creating and configuring
			 * {@link System.Threading.Tasks.Task} and {@link System.Threading.Tasks.Task<>}
			 * instances.
			 */
			static readonly Factory: System.Threading.Tasks.TaskFactory;

			/** Gets an ID for this {@link System.Threading.Tasks.Task} instance. */
			readonly Id: number;

			/**
			 * Gets whether this {@link System.Threading.Tasks.Task} instance has completed execution
			 * due to being canceled.
			 */
			readonly IsCanceled: boolean;

			/** Gets a value that indicates whether the task has completed. */
			readonly IsCompleted: boolean;

			/** Gets whether the task ran to completion. */
			readonly IsCompletedSuccessfully: boolean;

			/**
			 * Gets whether the {@link System.Threading.Tasks.Task} completed due to an unhandled
			 * exception.
			 */
			readonly IsFaulted: boolean;

			/** Gets the {@link System.Threading.Tasks.TaskStatus} of this task. */
			readonly Status: System.Threading.Tasks.TaskStatus;

			/**
			 * Creates a continuation that receives caller-supplied state information and executes
			 * when the target {@link System.Threading.Tasks.Task} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<void>, System.Object | undefined>,
				state: System.Object | undefined,
			): Promise<void>;

			/**
			 * Creates a continuation that receives caller-supplied state information and a
			 * cancellation token and that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<void>, System.Object | undefined>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a continuation that receives caller-supplied state information and a
			 * cancellation token and that executes when the target
			 * {@link System.Threading.Tasks.Task} completes. The continuation executes based on a
			 * set of specified conditions and uses a specified scheduler.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<void>, System.Object | undefined>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that receives caller-supplied state information and executes
			 * when the target {@link System.Threading.Tasks.Task} completes. The continuation
			 * executes based on a set of specified conditions.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<void>, System.Object | undefined>,
				state: System.Object | undefined,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<void>;

			/**
			 * Creates a continuation that receives caller-supplied state information and executes
			 * asynchronously when the target {@link System.Threading.Tasks.Task} completes. The
			 * continuation uses a specified scheduler.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<void>, System.Object | undefined>,
				state: System.Object | undefined,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes.
			 */
			ContinueWith(continuationAction: System.Action$1<Promise<void>>): Promise<void>;

			/**
			 * Creates a continuation that receives a cancellation token and executes asynchronously
			 * when the target {@link System.Threading.Tasks.Task} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<void>>,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a continuation that executes when the target task competes according to the
			 * specified {@link System.Threading.Tasks.TaskContinuationOptions}. The continuation
			 * receives a cancellation token and uses a specified scheduler.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<void>>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that executes when the target task completes according to the
			 * specified {@link System.Threading.Tasks.TaskContinuationOptions}.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<void>>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<void>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes. The continuation uses a specified
			 * scheduler.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<void>>,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that receives caller-supplied state information and executes
			 * asynchronously when the target {@link System.Threading.Tasks.Task} completes and
			 * returns a value.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$3<Promise<void>, System.Object | undefined, TResult>,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes and returns a value. The continuation
			 * receives caller-supplied state information and a cancellation token.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$3<Promise<void>, System.Object | undefined, TResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes based on the specified task continuation options
			 * when the target {@link System.Threading.Tasks.Task} completes and returns a value. The
			 * continuation receives caller-supplied state information and a cancellation token and
			 * uses the specified scheduler.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$3<Promise<void>, System.Object | undefined, TResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes based on the specified task continuation options
			 * when the target {@link System.Threading.Tasks.Task} completes. The continuation
			 * receives caller-supplied state information.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$3<Promise<void>, System.Object | undefined, TResult>,
				state: System.Object | undefined,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes. The continuation receives
			 * caller-supplied state information and uses a specified scheduler.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$3<Promise<void>, System.Object | undefined, TResult>,
				state: System.Object | undefined,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task<>} completes and returns a value.
			 */
			ContinueWith<TResult>(continuationFunction: System.Func$2<Promise<void>, TResult>): Promise<TResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes and returns a value. The continuation
			 * receives a cancellation token.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes according to the specified continuation options
			 * and returns a value. The continuation is passed a cancellation token and uses a
			 * specified scheduler.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes according to the specified continuation options
			 * and returns a value.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes and returns a value. The continuation
			 * uses a specified scheduler.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/** Creates a task that completes after a specified number of milliseconds. */
			static Delay(millisecondsDelay: number): Promise<void>;

			/**
			 * Creates a cancellable task that completes after a specified number of milliseconds.
			 */
			static Delay(
				millisecondsDelay: number,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/** Creates a task that completes after a specified time interval. */
			static Delay(delay: number): Promise<void>;

			/** Creates a cancellable task that completes after a specified time interval. */
			static Delay(
				delay: number,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/** Creates a task that completes after a specified time interval. */
			static Delay(
				delay: number,
				timeProvider: System.TimeProvider,
			): Promise<void>;

			/** Creates a cancellable task that completes after a specified time interval. */
			static Delay(
				delay: number,
				timeProvider: System.TimeProvider,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Releases all resources used by the current instance of the
			 * {@link System.Threading.Tasks.Task} class.
			 */
			dispose(): void;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that's completed due to cancellation
			 * with a specified cancellation token.
			 */
			static FromCanceled(cancellationToken: AbortSignal): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that's completed due to cancellation
			 * with a specified cancellation token.
			 */
			static FromCanceled<TResult>(cancellationToken: AbortSignal): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that has completed with a specified
			 * exception.
			 */
			static FromException(exception: System.Exception): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that's completed with a specified
			 * exception.
			 */
			static FromException<TResult>(exception: System.Exception): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that's completed successfully with the
			 * specified result.
			 */
			static FromResult<TResult>(result: TResult): Promise<TResult>;

			/**
			 * Queues the specified work to run on the thread pool and returns a
			 * {@link System.Threading.Tasks.Task} object that represents that work.
			 */
			static Run(action: () => void): Promise<void>;

			/**
			 * Queues the specified work to run on the thread pool and returns a
			 * {@link System.Threading.Tasks.Task} object that represents that work. A cancellation
			 * token allows the work to be cancelled if it has not yet started.
			 */
			static Run(
				action: () => void,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Queues the specified work to run on the thread pool and returns a proxy for the task
			 * returned by `function`.
			 */
			static Run(_function: System.Func$1<Promise<void> | undefined>): Promise<void>;

			/**
			 * Queues the specified work to run on the thread pool and returns a proxy for the task
			 * returned by `function`. A cancellation token allows the work to be cancelled if it has
			 * not yet started.
			 */
			static Run(
				_function: System.Func$1<Promise<void> | undefined>,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Runs the {@link System.Threading.Tasks.Task} synchronously on the current
			 * {@link System.Threading.Tasks.TaskScheduler}.
			 */
			RunSynchronously(): void;

			/**
			 * Runs the {@link System.Threading.Tasks.Task} synchronously on the
			 * {@link System.Threading.Tasks.TaskScheduler} provided.
			 */
			RunSynchronously(scheduler: System.Threading.Tasks.TaskScheduler): void;

			/**
			 * Queues the specified work to run on the thread pool and returns a proxy for the
			 * `Task(TResult)` returned by `function`. A cancellation token allows the work to be
			 * cancelled if it has not yet started.
			 */
			static Run<TResult>(_function: System.Func$1<Promise<TResult> | undefined>): Promise<TResult>;

			/**
			 * Queues the specified work to run on the thread pool and returns a proxy for the
			 * `Task(TResult)` returned by `function`.
			 */
			static Run<TResult>(
				_function: System.Func$1<Promise<TResult> | undefined>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Queues the specified work to run on the thread pool and returns a
			 * {@link System.Threading.Tasks.Task<>} object that represents that work. A cancellation
			 * token allows the work to be cancelled if it has not yet started.
			 */
			static Run<TResult>(_function: System.Func$1<TResult>): Promise<TResult>;

			/**
			 * Queues the specified work to run on the thread pool and returns a `Task(TResult)`
			 * object that represents that work.
			 */
			static Run<TResult>(
				_function: System.Func$1<TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Starts the {@link System.Threading.Tasks.Task}, scheduling it for execution to the
			 * current {@link System.Threading.Tasks.TaskScheduler}.
			 */
			Start(): void;

			/**
			 * Starts the {@link System.Threading.Tasks.Task}, scheduling it for execution to the
			 * specified {@link System.Threading.Tasks.TaskScheduler}.
			 */
			Start(scheduler: System.Threading.Tasks.TaskScheduler): void;

			/** Waits for the {@link System.Threading.Tasks.Task} to complete execution. */
			Wait(): void;

			/**
			 * Waits for the {@link System.Threading.Tasks.Task} to complete execution within a
			 * specified number of milliseconds.
			 */
			Wait(millisecondsTimeout: number): boolean;

			/**
			 * Waits for the {@link System.Threading.Tasks.Task} to complete execution. The wait
			 * terminates if a timeout interval elapses or a cancellation token is canceled before
			 * the task completes.
			 */
			Wait(
				millisecondsTimeout: number,
				cancellationToken: AbortSignal,
			): boolean;

			/**
			 * Waits for the {@link System.Threading.Tasks.Task} to complete execution. The wait
			 * terminates if a cancellation token is canceled before the task completes.
			 */
			Wait(cancellationToken: AbortSignal): void;

			/**
			 * Waits for the {@link System.Threading.Tasks.Task} to complete execution within a
			 * specified time interval.
			 */
			Wait(timeout: number): boolean;

			/** Waits for the {@link System.Threading.Tasks.Task} to complete execution. */
			Wait(
				timeout: number,
				cancellationToken: AbortSignal,
			): boolean;

			/**
			 * Waits for all of the provided {@link System.Threading.Tasks.Task} objects to complete
			 * execution.
			 */
			static WaitAll(tasks: Promise<void>[]): void;

			/**
			 * Waits for all of the provided {@link System.Threading.Tasks.Task} objects to complete
			 * execution within a specified number of milliseconds.
			 */
			static WaitAll(
				tasks: Promise<void>[],
				millisecondsTimeout: number,
			): boolean;

			/**
			 * Waits for all of the provided {@link System.Threading.Tasks.Task} objects to complete
			 * execution within a specified number of milliseconds or until the wait is cancelled.
			 */
			static WaitAll(
				tasks: Promise<void>[],
				millisecondsTimeout: number,
				cancellationToken: AbortSignal,
			): boolean;

			/**
			 * Waits for all of the provided {@link System.Threading.Tasks.Task} objects to complete
			 * execution unless the wait is cancelled.
			 */
			static WaitAll(
				tasks: Promise<void>[],
				cancellationToken: AbortSignal,
			): void;

			/**
			 * Waits for all of the provided cancellable {@link System.Threading.Tasks.Task} objects
			 * to complete execution within a specified time interval.
			 */
			static WaitAll(
				tasks: Promise<void>[],
				timeout: number,
			): boolean;

			/**
			 * Waits for any of the provided {@link System.Threading.Tasks.Task} objects to complete
			 * execution.
			 */
			static WaitAny(tasks: Promise<void>[]): number;

			/**
			 * Waits for any of the provided {@link System.Threading.Tasks.Task} objects to complete
			 * execution within a specified number of milliseconds.
			 */
			static WaitAny(
				tasks: Promise<void>[],
				millisecondsTimeout: number,
			): number;

			/**
			 * Waits for any of the provided {@link System.Threading.Tasks.Task} objects to complete
			 * execution within a specified number of milliseconds or until a cancellation token is
			 * cancelled.
			 */
			static WaitAny(
				tasks: Promise<void>[],
				millisecondsTimeout: number,
				cancellationToken: AbortSignal,
			): number;

			/**
			 * Waits for any of the provided {@link System.Threading.Tasks.Task} objects to complete
			 * execution unless the wait is cancelled.
			 */
			static WaitAny(
				tasks: Promise<void>[],
				cancellationToken: AbortSignal,
			): number;

			/**
			 * Waits for any of the provided {@link System.Threading.Tasks.Task} objects to complete
			 * execution within a specified time interval.
			 */
			static WaitAny(
				tasks: Promise<void>[],
				timeout: number,
			): number;

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when this
			 * {@link System.Threading.Tasks.Task} completes or when the specified
			 * {@link System.Threading.CancellationToken} has cancellation requested.
			 */
			WaitAsync(cancellationToken: AbortSignal): Promise<void>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when this
			 * {@link System.Threading.Tasks.Task} completes or when the specified timeout expires.
			 */
			WaitAsync(timeout: number): Promise<void>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when this
			 * {@link System.Threading.Tasks.Task} completes, when the specified timeout expires, or
			 * when the specified {@link System.Threading.CancellationToken} has cancellation
			 * requested.
			 */
			WaitAsync(
				timeout: number,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when this
			 * {@link System.Threading.Tasks.Task} completes or when the specified timeout expires.
			 */
			WaitAsync(
				timeout: number,
				timeProvider: System.TimeProvider,
			): Promise<void>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when this
			 * {@link System.Threading.Tasks.Task} completes, when the specified timeout expires, or
			 * when the specified {@link System.Threading.CancellationToken} has cancellation
			 * requested.
			 */
			WaitAsync(
				timeout: number,
				timeProvider: System.TimeProvider,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a task that will complete when all of the {@link System.Threading.Tasks.Task}
			 * objects in an enumerable collection have completed.
			 */
			static WhenAll(tasks: Iterable<Promise<void>>): Promise<void>;

			/**
			 * Creates a task that will complete when all of the {@link System.Threading.Tasks.Task}
			 * objects in an array have completed.
			 */
			static WhenAll(tasks: Promise<void>[]): Promise<void>;

			/**
			 * Creates a task that will complete when all of the
			 * {@link System.Threading.Tasks.Task<>} objects in an enumerable collection have
			 * completed.
			 */
			static WhenAll<TResult>(tasks: Iterable<Promise<TResult>>): Promise<TResult[]>;

			static WhenAll<TResult>(tasks: Promise<TResult>[]): Promise<TResult[]>;

			/** Creates a task that will complete when any of the supplied tasks have completed. */
			static WhenAny(tasks: Iterable<Promise<void>>): Promise<Promise<void>>;

			/**
			 * Creates a task that will complete when either of the supplied tasks have completed.
			 */
			static WhenAny(
				task1: Promise<void>,
				task2: Promise<void>,
			): Promise<Promise<void>>;

			/** Creates a task that will complete when any of the supplied tasks have completed. */
			static WhenAny(tasks: Promise<void>[]): Promise<Promise<void>>;

			/** Creates a task that will complete when any of the supplied tasks have completed. */
			static WhenAny<TResult>(tasks: Iterable<Promise<TResult>>): Promise<Promise<TResult>>;

			/**
			 * Creates a task that will complete when either of the supplied tasks have completed.
			 */
			static WhenAny<TResult>(
				task1: Promise<TResult>,
				task2: Promise<TResult>,
			): Promise<Promise<TResult>>;

			static WhenAny<TResult>(tasks: Promise<TResult>[]): Promise<Promise<TResult>>;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Provides a set of static methods for configuring task-related behaviors on
		 * asynchronous enumerables and disposables.
		 */
		export namespace TaskAsyncEnumerableExtensions {
			/**
			 * Converts an {@link System.Collections.Generic.IAsyncEnumerable<>} instance into an
			 * {@link System.Collections.Generic.IEnumerable<>} that enumerates elements in a
			 * blocking manner.
			 */
			export function ToBlockingEnumerable<T>(
				source: AsyncIterable<T>,
				cancellationToken?: AbortSignal,
			): Iterable<T>;
		}
	}

	export namespace System.Threading.Tasks {
		/** Represents an exception used to communicate task cancellation. */
		export class TaskCanceledException extends System.OperationCanceledException {
			/**
			 * Initializes a new instance of the {@link System.Threading.Tasks.TaskCanceledException}
			 * class with a system-supplied message that describes the error.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Threading.Tasks.TaskCanceledException}
			 * class with a specified message that describes the error.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.Threading.Tasks.TaskCanceledException}
			 * class with a specified error message and a reference to the inner exception that is
			 * the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.Threading.Tasks.TaskCanceledException}
			 * class with a specified error message, a reference to the inner exception that is the
			 * cause of this exception, and the {@link System.Threading.CancellationToken} that
			 * triggered the cancellation.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
				token: AbortSignal,
			);

			/**
			 * Initializes a new instance of the {@link System.Threading.Tasks.TaskCanceledException}
			 * class with a reference to the {@link System.Threading.Tasks.Task} that has been
			 * canceled.
			 */
			constructor(task: Promise<void> | undefined);

			/** Gets the task associated with this exception. */
			readonly Task?: Promise<void>;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Represents the producer side of a {@link System.Threading.Tasks.Task} unbound to a
		 * delegate, providing access to the consumer side through the
		 * {@link System.Threading.Tasks.Task} property.
		 */
		export class TaskCompletionSource {
			/** Creates a {@link System.Threading.Tasks.TaskCompletionSource}. */
			constructor();

			/**
			 * Creates a {@link System.Threading.Tasks.TaskCompletionSource} with the specified
			 * state.
			 */
			constructor(state: System.Object | undefined);

			/**
			 * Creates a {@link System.Threading.Tasks.TaskCompletionSource} with the specified state
			 * and options.
			 */
			constructor(
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			);

			/**
			 * Creates a {@link System.Threading.Tasks.TaskCompletionSource} with the specified
			 * options.
			 */
			constructor(creationOptions: System.Threading.Tasks.TaskCreationOptions);

			/**
			 * Gets the {@link System.Threading.Tasks.Task} created by this
			 * {@link System.Threading.Tasks.TaskCompletionSource}.
			 */
			readonly Task: Promise<void>;

			/**
			 * Transitions the underlying {@link System.Threading.Tasks.Task} into the
			 * {@link System.Threading.Tasks.TaskStatus.Canceled} state.
			 */
			SetCanceled(): void;

			/**
			 * Transitions the underlying {@link System.Threading.Tasks.Task} into the
			 * {@link System.Threading.Tasks.TaskStatus.Canceled} state using the specified token.
			 */
			SetCanceled(cancellationToken: AbortSignal): void;

			/**
			 * Transitions the underlying {@link System.Threading.Tasks.Task} into the
			 * {@link System.Threading.Tasks.TaskStatus.Faulted} state.
			 */
			SetException(exceptions: Iterable<System.Exception>): void;

			/**
			 * Transitions the underlying {@link System.Threading.Tasks.Task} into the
			 * {@link System.Threading.Tasks.TaskStatus.Faulted} state.
			 */
			SetException(exception: System.Exception): void;

			/**
			 * Transitions the underlying {@link System.Threading.Tasks.Task} into the
			 * {@link System.Threading.Tasks.TaskStatus.RanToCompletion} state.
			 */
			SetResult(): void;

			/**
			 * Attempts to transition the underlying {@link System.Threading.Tasks.Task} into the
			 * {@link System.Threading.Tasks.TaskStatus.Canceled} state.
			 */
			TrySetCanceled(): boolean;

			/**
			 * Attempts to transition the underlying {@link System.Threading.Tasks.Task} into the
			 * {@link System.Threading.Tasks.TaskStatus.Canceled} state.
			 */
			TrySetCanceled(cancellationToken: AbortSignal): boolean;

			/**
			 * Attempts to transition the underlying {@link System.Threading.Tasks.Task} into the
			 * {@link System.Threading.Tasks.TaskStatus.Faulted} state.
			 */
			TrySetException(exceptions: Iterable<System.Exception>): boolean;

			/**
			 * Attempts to transition the underlying {@link System.Threading.Tasks.Task} into the
			 * {@link System.Threading.Tasks.TaskStatus.Faulted} state.
			 */
			TrySetException(exception: System.Exception): boolean;

			/**
			 * Attempts to transition the underlying {@link System.Threading.Tasks.Task} into the
			 * {@link System.Threading.Tasks.TaskStatus.RanToCompletion} state.
			 */
			TrySetResult(): boolean;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * [Generic type factory] Represents the producer side of a
		 * {@link System.Threading.Tasks.Task<>} unbound to a delegate, providing access to the
		 * consumer side through the {@link System.Threading.Tasks.TaskCompletionSource`1.Task}
		 * property.
		 */
		export function TaskCompletionSource$(TResult: IType): typeof TaskCompletionSource$1<any>;

		/**
		 * Represents the producer side of a {@link System.Threading.Tasks.Task<>} unbound to a
		 * delegate, providing access to the consumer side through the
		 * {@link System.Threading.Tasks.TaskCompletionSource`1.Task} property.
		 */
		export class TaskCompletionSource$1<TResult> {
			/** Creates a {@link System.Threading.Tasks.TaskCompletionSource<>}. */
			constructor();

			/**
			 * Creates a {@link System.Threading.Tasks.TaskCompletionSource<>} with the specified
			 * state.
			 */
			constructor(state: System.Object | undefined);

			/**
			 * Creates a {@link System.Threading.Tasks.TaskCompletionSource<>} with the specified
			 * state and options.
			 */
			constructor(
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			);

			/**
			 * Creates a {@link System.Threading.Tasks.TaskCompletionSource<>} with the specified
			 * options.
			 */
			constructor(creationOptions: System.Threading.Tasks.TaskCreationOptions);

			/**
			 * Gets the {@link System.Threading.Tasks.Task<>} created by this
			 * {@link System.Threading.Tasks.TaskCompletionSource<>}.
			 */
			readonly Task: Promise<TResult>;

			/**
			 * Transitions the underlying {@link System.Threading.Tasks.Task<>} into the
			 * {@link System.Threading.Tasks.TaskStatus.Canceled} state.
			 */
			SetCanceled(): void;

			/**
			 * Transitions the underlying {@link System.Threading.Tasks.Task<>} into the
			 * {@link System.Threading.Tasks.TaskStatus.Canceled} state using the specified token.
			 */
			SetCanceled(cancellationToken: AbortSignal): void;

			/**
			 * Transitions the underlying {@link System.Threading.Tasks.Task<>} into the
			 * {@link System.Threading.Tasks.TaskStatus.Faulted} state and binds a collection of
			 * exception objects to it.
			 */
			SetException(exceptions: Iterable<System.Exception>): void;

			/**
			 * Transitions the underlying {@link System.Threading.Tasks.Task<>} into the
			 * {@link System.Threading.Tasks.TaskStatus.Faulted} state and binds it to a specified
			 * exception.
			 */
			SetException(exception: System.Exception): void;

			/**
			 * Transitions the underlying {@link System.Threading.Tasks.Task<>} into the
			 * {@link System.Threading.Tasks.TaskStatus.RanToCompletion} state.
			 */
			SetResult(result: TResult): void;

			/**
			 * Attempts to transition the underlying {@link System.Threading.Tasks.Task<>} into the
			 * {@link System.Threading.Tasks.TaskStatus.Canceled} state.
			 */
			TrySetCanceled(): boolean;

			/**
			 * Attempts to transition the underlying {@link System.Threading.Tasks.Task<>} into the
			 * {@link System.Threading.Tasks.TaskStatus.Canceled} state and enables a cancellation
			 * token to be stored in the canceled task.
			 */
			TrySetCanceled(cancellationToken: AbortSignal): boolean;

			/**
			 * Attempts to transition the underlying {@link System.Threading.Tasks.Task<>} into the
			 * {@link System.Threading.Tasks.TaskStatus.Faulted} state and binds a collection of
			 * exception objects to it.
			 */
			TrySetException(exceptions: Iterable<System.Exception>): boolean;

			/**
			 * Attempts to transition the underlying {@link System.Threading.Tasks.Task<>} into the
			 * {@link System.Threading.Tasks.TaskStatus.Faulted} state and binds it to a specified
			 * exception.
			 */
			TrySetException(exception: System.Exception): boolean;

			/**
			 * Attempts to transition the underlying {@link System.Threading.Tasks.Task<>} into the
			 * {@link System.Threading.Tasks.TaskStatus.RanToCompletion} state.
			 */
			TrySetResult(result: TResult): boolean;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Specifies the behavior for a task that is created by using the
		 * {@link System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)}
		 * or
		 * {@link System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)}
		 * method.
		 */
		export enum TaskContinuationOptions {
			/**
			 * When no continuation options are specified, specifies that default behavior should be
			 * used when executing a continuation. The continuation runs asynchronously when the
			 * antecedent task completes, regardless of the antecedent's final
			 * {@link System.Threading.Tasks.Task.Status} property value. If the continuation is a
			 * child task, it is created as a detached nested task.
			 */
			None = 0,

			/**
			 * A hint to a {@link System.Threading.Tasks.TaskScheduler} to schedule task in the order
			 * in which they were scheduled, so that tasks scheduled sooner are more likely to run
			 * sooner, and tasks scheduled later are more likely to run later.
			 */
			PreferFairness = 1,

			/**
			 * Specifies that a continuation will be a long-running, course-grained operation. It
			 * provides a hint to the {@link System.Threading.Tasks.TaskScheduler} that
			 * oversubscription may be warranted.
			 */
			LongRunning = 2,

			/**
			 * Specifies that the continuation, if it is a child task, is attached to a parent in the
			 * task hierarchy. The continuation can be a child task only if its antecedent is also a
			 * child task. By default, a child task (that is, an inner task created by an outer task)
			 * executes independently of its parent. You can use the
			 * {@link System.Threading.Tasks.TaskContinuationOptions.AttachedToParent} option so that
			 * the parent and child tasks are synchronized.    Note that if a parent task is
			 * configured with the {@link System.Threading.Tasks.TaskCreationOptions.DenyChildAttach}
			 * option, the {@link System.Threading.Tasks.TaskCreationOptions.AttachedToParent} option
			 * in the child task has no effect, and the child task will execute as a detached child
			 * task.    For more information, see Attached and Detached Child Tasks.
			 */
			AttachedToParent = 4,

			/**
			 * Specifies that any child task (that is, any nested inner task created by this
			 * continuation) that is created with the
			 * {@link System.Threading.Tasks.TaskCreationOptions.AttachedToParent} option and
			 * attempts to execute as an attached child task will not be able to attach to the parent
			 * task and will execute instead as a detached child task. For more information, see
			 * Attached and Detached Child Tasks.
			 */
			DenyChildAttach = 8,

			/**
			 * Specifies that tasks created by the continuation by calling methods such as
			 * {@link System.Threading.Tasks.Task.Run(System.Action)} or
			 * {@link System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})}
			 * see the default scheduler ( {@link System.Threading.Tasks.TaskScheduler.Default} )
			 * rather than the scheduler on which this continuation is running as the current
			 * scheduler.
			 */
			HideScheduler = 16,

			/**
			 * In the case of continuation cancellation, prevents completion of the continuation
			 * until the antecedent has completed.
			 */
			LazyCancellation = 32,

			/**
			 * Specifies that the continuation task should be run asynchronously.  This option has
			 * precedence over
			 * {@link System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously}.
			 */
			RunContinuationsAsynchronously = 64,

			/**
			 * Specifies that the continuation task should not be scheduled if its antecedent ran to
			 * completion. An antecedent runs to completion if its
			 * {@link System.Threading.Tasks.Task.Status} property upon completion is
			 * {@link System.Threading.Tasks.TaskStatus.RanToCompletion}. This option is not valid
			 * for multi-task continuations.
			 */
			NotOnRanToCompletion = 65536,

			/**
			 * Specifies that the continuation task should not be scheduled if its antecedent threw
			 * an unhandled exception. An antecedent throws an unhandled exception if its
			 * {@link System.Threading.Tasks.Task.Status} property upon completion is
			 * {@link System.Threading.Tasks.TaskStatus.Faulted}. This option is not valid for
			 * multi-task continuations.
			 */
			NotOnFaulted = 131072,

			/**
			 * Specifies that the continuation should be scheduled only if its antecedent was
			 * canceled.  An antecedent is canceled if its {@link System.Threading.Tasks.Task.Status}
			 * property upon completion is {@link System.Threading.Tasks.TaskStatus.Canceled}. This
			 * option is not valid for multi-task continuations.
			 */
			OnlyOnCanceled = 196608,

			/**
			 * Specifies that the continuation task should not be scheduled if its antecedent was
			 * canceled. An antecedent is canceled if its {@link System.Threading.Tasks.Task.Status}
			 * property upon completion is {@link System.Threading.Tasks.TaskStatus.Canceled}. This
			 * option is not valid for multi-task continuations.
			 */
			NotOnCanceled = 262144,

			/**
			 * Specifies that the continuation task should be scheduled only if its antecedent threw
			 * an unhandled exception. An antecedent throws an unhandled exception if its
			 * {@link System.Threading.Tasks.Task.Status} property upon completion is
			 * {@link System.Threading.Tasks.TaskStatus.Faulted}.    The
			 * {@link System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted} option guarantees
			 * that the {@link System.Threading.Tasks.Task.Exception} property in the antecedent is
			 * not `null`. You can use that property to catch the exception and see which exception
			 * caused the task to fault. If you do not access the
			 * {@link System.Threading.Tasks.Task.Exception} property, the exception is unhandled.
			 * Also, if you attempt to access the {@link System.Threading.Tasks.Task`1.Result}
			 * property of a task that has been canceled or has faulted, a new exception is thrown.
			 *  This option is not valid for multi-task continuations.
			 */
			OnlyOnFaulted = 327680,

			/**
			 * Specifies that the continuation should be scheduled only if its antecedent ran to
			 * completion. An antecedent runs to completion if its
			 * {@link System.Threading.Tasks.Task.Status} property upon completion is
			 * {@link System.Threading.Tasks.TaskStatus.RanToCompletion}. This option is not valid
			 * for multi-task continuations.
			 */
			OnlyOnRanToCompletion = 393216,

			/**
			 * Specifies that the continuation task should be executed synchronously. With this
			 * option specified, the continuation runs on the same thread that causes the antecedent
			 * task to transition into its final state. If the antecedent is already complete when
			 * the continuation is created, the continuation will run on the thread that creates the
			 * continuation. If the antecedent's {@link System.Threading.CancellationTokenSource} is
			 * disposed in a `finally` block ( `Finally` in Visual Basic), a continuation with this
			 * option will run in that `finally` block. Only very short-running continuations should
			 * be executed synchronously.    Because the task executes synchronously, there is no
			 * need to call a method such as {@link System.Threading.Tasks.Task.Wait} to ensure that
			 * the calling thread waits for the task to complete.
			 */
			ExecuteSynchronously = 524288,
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Specifies flags that control optional behavior for the creation and execution of
		 * tasks.
		 */
		export enum TaskCreationOptions {
			/** Specifies that the default behavior should be used. */
			None = 0,

			/**
			 * A hint to a {@link System.Threading.Tasks.TaskScheduler} to schedule a task in as fair
			 * a manner as possible, meaning that tasks scheduled sooner will be more likely to be
			 * run sooner, and tasks scheduled later will be more likely to be run later.
			 */
			PreferFairness = 1,

			/**
			 * Specifies that a task will be a long-running, coarse-grained operation involving
			 * fewer, larger components than fine-grained systems. It provides a hint to the
			 * {@link System.Threading.Tasks.TaskScheduler} that oversubscription may be warranted.
			 * Oversubscription lets you create more threads than the available number of hardware
			 * threads. It also provides a hint  to the task scheduler that an additional thread
			 * might be required for the task so that it does not block the forward progress of other
			 * threads or work items on the local thread-pool queue.
			 */
			LongRunning = 2,

			/**
			 * Specifies that a task is attached to a parent in the task hierarchy. By default, a
			 * child task (that is, an inner task created by an outer task) executes independently of
			 * its parent. You can use the
			 * {@link System.Threading.Tasks.TaskContinuationOptions.AttachedToParent} option so that
			 * the parent and child tasks are synchronized.    Note that if a parent task is
			 * configured with the {@link System.Threading.Tasks.TaskCreationOptions.DenyChildAttach}
			 * option, the {@link System.Threading.Tasks.TaskCreationOptions.AttachedToParent} option
			 * in the child task has no effect, and the child task will execute as a detached child
			 * task.    For more information, see Attached and Detached Child Tasks.
			 */
			AttachedToParent = 4,

			/**
			 * Specifies that any child task that attempts to execute as an attached child task (that
			 * is, it is created with the
			 * {@link System.Threading.Tasks.TaskCreationOptions.AttachedToParent} option) will not
			 * be able to attach to the parent task and will execute instead as a detached child
			 * task. For more information, see Attached and Detached Child Tasks.
			 */
			DenyChildAttach = 8,

			/**
			 * Prevents the ambient scheduler from being seen as the current scheduler in the created
			 * task. This means that operations like StartNew or ContinueWith that are performed in
			 * the created task will see {@link System.Threading.Tasks.TaskScheduler.Default} as the
			 * current scheduler.
			 */
			HideScheduler = 16,

			/**
			 * Forces continuations added to the current task to be executed asynchronously.    Note
			 * that the
			 * {@link System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously}
			 * member is available in the {@link System.Threading.Tasks.TaskCreationOptions}
			 * enumeration starting with the .NET Framework 4.6.
			 */
			RunContinuationsAsynchronously = 64,
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Provides a set of static (Shared in Visual Basic) methods for working with specific
		 * kinds of {@link System.Threading.Tasks.Task} instances.
		 */
		export namespace TaskExtensions {
			/**
			 * Creates a proxy {@link System.Threading.Tasks.Task} that represents the asynchronous
			 * operation of a `Task<Task>` (C#) or `Task (Of Task)` (Visual Basic).
			 */
			export function Unwrap(task: Promise<Promise<void>>): Promise<void>;

			/**
			 * Creates a proxy {@link System.Threading.Tasks.Task} that represents the asynchronous
			 * operation of a `Task<Task<T>>` (C#) or `Task (Of Task(Of T))` (Visual Basic).
			 */
			export function Unwrap<TResult>(task: Promise<Promise<TResult>>): Promise<TResult>;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Provides support for creating and scheduling {@link System.Threading.Tasks.Task}
		 * objects.
		 */
		export class TaskFactory {
			/**
			 * Initializes a {@link System.Threading.Tasks.TaskFactory} instance with the default
			 * configuration.
			 */
			constructor();

			/**
			 * Initializes a {@link System.Threading.Tasks.TaskFactory} instance with the specified
			 * configuration.
			 */
			constructor(cancellationToken: AbortSignal);

			/**
			 * Initializes a {@link System.Threading.Tasks.TaskFactory} instance with the specified
			 * configuration.
			 */
			constructor(
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler | undefined,
			);

			/**
			 * Initializes a {@link System.Threading.Tasks.TaskFactory} instance with the specified
			 * configuration.
			 */
			constructor(
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			);

			/**
			 * Initializes a {@link System.Threading.Tasks.TaskFactory} instance with the specified
			 * configuration.
			 */
			constructor(scheduler: System.Threading.Tasks.TaskScheduler | undefined);

			/** Gets the default cancellation token for this task factory. */
			readonly CancellationToken: AbortSignal;

			/** Gets the default task continuation options for this task factory. */
			readonly ContinuationOptions: System.Threading.Tasks.TaskContinuationOptions;

			/** Gets the default task creation options for this task factory. */
			readonly CreationOptions: System.Threading.Tasks.TaskCreationOptions;

			/** Gets the default task scheduler for this task factory. */
			readonly Scheduler?: System.Threading.Tasks.TaskScheduler;

			/**
			 * Creates a continuation task that starts when a set of specified tasks has completed.
			 */
			ContinueWhenAll(
				tasks: Promise<void>[],
				continuationAction: System.Action$1<Promise<void>[]>,
			): Promise<void>;

			/**
			 * Creates a continuation task that starts when a set of specified tasks has completed.
			 */
			ContinueWhenAll(
				tasks: Promise<void>[],
				continuationAction: System.Action$1<Promise<void>[]>,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a continuation task that starts when a set of specified tasks has completed.
			 */
			ContinueWhenAll(
				tasks: Promise<void>[],
				continuationAction: System.Action$1<Promise<void>[]>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation task that starts when a set of specified tasks has completed.
			 */
			ContinueWhenAll(
				tasks: Promise<void>[],
				continuationAction: System.Action$1<Promise<void>[]>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<void>;

			/**
			 * Creates a continuation task that starts when a set of specified tasks has completed.
			 */
			ContinueWhenAll<TResult>(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>[], TResult>,
			): Promise<TResult>;

			/**
			 * Creates a continuation task that starts when a set of specified tasks has completed.
			 */
			ContinueWhenAll<TResult>(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>[], TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates a continuation task that starts when a set of specified tasks has completed.
			 */
			ContinueWhenAll<TResult>(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>[], TResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a continuation task that starts when a set of specified tasks has completed.
			 */
			ContinueWhenAll<TResult>(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>[], TResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			ContinueWhenAll<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationAction: System.Action$1<Promise<TAntecedentResult>[]>,
			): Promise<void>;

			ContinueWhenAll<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationAction: System.Action$1<Promise<TAntecedentResult>[]>,
				cancellationToken: AbortSignal,
			): Promise<void>;

			ContinueWhenAll<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationAction: System.Action$1<Promise<TAntecedentResult>[]>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			ContinueWhenAll<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationAction: System.Action$1<Promise<TAntecedentResult>[]>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<void>;

			ContinueWhenAll<TAntecedentResult, TResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>[], TResult>,
			): Promise<TResult>;

			ContinueWhenAll<TAntecedentResult, TResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>[], TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			ContinueWhenAll<TAntecedentResult, TResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>[], TResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			ContinueWhenAll<TAntecedentResult, TResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>[], TResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			/**
			 * Creates a continuation {@link System.Threading.Tasks.Task} that will be started upon
			 * the completion of any Task in the provided set.
			 */
			ContinueWhenAny(
				tasks: Promise<void>[],
				continuationAction: System.Action$1<Promise<void>>,
			): Promise<void>;

			/**
			 * Creates a continuation {@link System.Threading.Tasks.Task} that will be started upon
			 * the completion of any Task in the provided set.
			 */
			ContinueWhenAny(
				tasks: Promise<void>[],
				continuationAction: System.Action$1<Promise<void>>,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a continuation {@link System.Threading.Tasks.Task} that will be started upon
			 * the completion of any Task in the provided set.
			 */
			ContinueWhenAny(
				tasks: Promise<void>[],
				continuationAction: System.Action$1<Promise<void>>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation {@link System.Threading.Tasks.Task} that will be started upon
			 * the completion of any Task in the provided set.
			 */
			ContinueWhenAny(
				tasks: Promise<void>[],
				continuationAction: System.Action$1<Promise<void>>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<void>;

			/**
			 * Creates a continuation {@link System.Threading.Tasks.Task<>} that will be started upon
			 * the completion of any Task in the provided set.
			 */
			ContinueWhenAny<TResult>(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>, TResult>,
			): Promise<TResult>;

			/**
			 * Creates a continuation {@link System.Threading.Tasks.Task<>} that will be started upon
			 * the completion of any Task in the provided set.
			 */
			ContinueWhenAny<TResult>(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates a continuation {@link System.Threading.Tasks.Task<>} that will be started upon
			 * the completion of any Task in the provided set.
			 */
			ContinueWhenAny<TResult>(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a continuation {@link System.Threading.Tasks.Task<>} that will be started upon
			 * the completion of any Task in the provided set.
			 */
			ContinueWhenAny<TResult>(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			ContinueWhenAny<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationAction: System.Action$1<Promise<TAntecedentResult>>,
			): Promise<void>;

			ContinueWhenAny<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationAction: System.Action$1<Promise<TAntecedentResult>>,
				cancellationToken: AbortSignal,
			): Promise<void>;

			ContinueWhenAny<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationAction: System.Action$1<Promise<TAntecedentResult>>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			ContinueWhenAny<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationAction: System.Action$1<Promise<TAntecedentResult>>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<void>;

			ContinueWhenAny<TAntecedentResult, TResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>, TResult>,
			): Promise<TResult>;

			ContinueWhenAny<TAntecedentResult, TResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>, TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			ContinueWhenAny<TAntecedentResult, TResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>, TResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			ContinueWhenAny<TAntecedentResult, TResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>, TResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that represents a pair of begin and end
			 * methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync(
				beginMethod: System.Func$3<System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Action$1<System.IAsyncResult>,
				state: System.Object | undefined,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that represents a pair of begin and end
			 * methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync(
				beginMethod: System.Func$3<System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Action$1<System.IAsyncResult>,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that executes an end method action when
			 * a specified {@link System.IAsyncResult} completes.
			 */
			FromAsync(
				asyncResult: System.IAsyncResult,
				endMethod: System.Action$1<System.IAsyncResult>,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that executes an end method action when
			 * a specified {@link System.IAsyncResult} completes.
			 */
			FromAsync(
				asyncResult: System.IAsyncResult,
				endMethod: System.Action$1<System.IAsyncResult>,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that executes an end method action when
			 * a specified {@link System.IAsyncResult} completes.
			 */
			FromAsync(
				asyncResult: System.IAsyncResult,
				endMethod: System.Action$1<System.IAsyncResult>,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that represents a pair of begin and
			 * end methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TResult>(
				beginMethod: System.Func$3<System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that represents a pair of begin and
			 * end methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TResult>(
				beginMethod: System.Func$3<System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that represents a pair of begin and end
			 * methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1>(
				beginMethod: System.Func$4<TArg1, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Action$1<System.IAsyncResult>,
				arg1: TArg1,
				state: System.Object | undefined,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that represents a pair of begin and end
			 * methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1>(
				beginMethod: System.Func$4<TArg1, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Action$1<System.IAsyncResult>,
				arg1: TArg1,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that executes an end method function
			 * when a specified {@link System.IAsyncResult} completes.
			 */
			FromAsync<TResult>(
				asyncResult: System.IAsyncResult,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that executes an end method function
			 * when a specified {@link System.IAsyncResult} completes.
			 */
			FromAsync<TResult>(
				asyncResult: System.IAsyncResult,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that executes an end method function
			 * when a specified {@link System.IAsyncResult} completes.
			 */
			FromAsync<TResult>(
				asyncResult: System.IAsyncResult,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that represents a pair of begin and
			 * end methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TResult>(
				beginMethod: System.Func$4<TArg1, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that represents a pair of begin and
			 * end methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TResult>(
				beginMethod: System.Func$4<TArg1, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that represents a pair of begin and end
			 * methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2>(
				beginMethod: System.Func$5<TArg1, TArg2, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Action$1<System.IAsyncResult>,
				arg1: TArg1,
				arg2: TArg2,
				state: System.Object | undefined,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that represents a pair of begin and end
			 * methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2>(
				beginMethod: System.Func$5<TArg1, TArg2, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Action$1<System.IAsyncResult>,
				arg1: TArg1,
				arg2: TArg2,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that represents a pair of begin and
			 * end methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2, TResult>(
				beginMethod: System.Func$5<TArg1, TArg2, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				arg2: TArg2,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that represents a pair of begin and
			 * end methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2, TResult>(
				beginMethod: System.Func$5<TArg1, TArg2, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				arg2: TArg2,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that represents a pair of begin and end
			 * methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2, TArg3>(
				beginMethod: System.Func$6<TArg1, TArg2, TArg3, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Action$1<System.IAsyncResult>,
				arg1: TArg1,
				arg2: TArg2,
				arg3: TArg3,
				state: System.Object | undefined,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task} that represents a pair of begin and end
			 * methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2, TArg3>(
				beginMethod: System.Func$6<TArg1, TArg2, TArg3, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Action$1<System.IAsyncResult>,
				arg1: TArg1,
				arg2: TArg2,
				arg3: TArg3,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that represents a pair of begin and
			 * end methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2, TArg3, TResult>(
				beginMethod: System.Func$6<TArg1, TArg2, TArg3, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				arg2: TArg2,
				arg3: TArg3,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.Task<>} that represents a pair of begin and
			 * end methods that conform to the Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2, TArg3, TResult>(
				beginMethod: System.Func$6<TArg1, TArg2, TArg3, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				arg2: TArg2,
				arg3: TArg3,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/** Creates and starts a task for the specified action delegate. */
			StartNew(action: () => void): Promise<void>;

			/**
			 * Creates and starts a task for the specified action delegate and cancellation token.
			 */
			StartNew(
				action: () => void,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates and starts a task for the specified action delegate, cancellation token,
			 * creation options and state.
			 */
			StartNew(
				action: () => void,
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/** Creates and starts a task for the specified action delegate and creation options. */
			StartNew(
				action: () => void,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<void>;

			/** Creates and starts a task for the specified action delegate and state. */
			StartNew(
				action: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
			): Promise<void>;

			/**
			 * Creates and starts a task for the specified action delegate, state and cancellation
			 * token.
			 */
			StartNew(
				action: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates and starts a task for the specified action delegate, state, cancellation
			 * token, creation options and task scheduler.
			 */
			StartNew(
				action: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates and starts a task for the specified action delegate, state and creation
			 * options.
			 */
			StartNew(
				action: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<void>;

			/** Creates and starts a task of type  for the specified function delegate and state. */
			StartNew<TResult>(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates and starts a task of type  for the specified function delegate, state and
			 * cancellation token.
			 */
			StartNew<TResult>(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates and starts a task of type  for the specified function delegate, state,
			 * cancellation token, creation options and task scheduler.
			 */
			StartNew<TResult>(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates and starts a task of type  for the specified function delegate, state and
			 * creation options.
			 */
			StartNew<TResult>(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/** Creates and starts a task of type  for the specified function delegate. */
			StartNew<TResult>(_function: System.Func$1<TResult>): Promise<TResult>;

			/**
			 * Creates and starts a task of type  for the specified function delegate and
			 * cancellation token.
			 */
			StartNew<TResult>(
				_function: System.Func$1<TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates and starts a task of type  for the specified function delegate, cancellation
			 * token, creation options and task scheduler.
			 */
			StartNew<TResult>(
				_function: System.Func$1<TResult>,
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates and starts a task of type  for the specified function delegate and creation
			 * options.
			 */
			StartNew<TResult>(
				_function: System.Func$1<TResult>,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * [Generic type factory] Provides support for creating and scheduling
		 * {@link System.Threading.Tasks.Task<>} objects.
		 */
		export function TaskFactory$(TResult: IType): typeof TaskFactory$1<any>;

		/**
		 * Provides support for creating and scheduling {@link System.Threading.Tasks.Task<>}
		 * objects.
		 */
		export class TaskFactory$1<TResult> {
			/**
			 * Initializes a {@link System.Threading.Tasks.TaskFactory<>} instance with the default
			 * configuration.
			 */
			constructor();

			/**
			 * Initializes a {@link System.Threading.Tasks.TaskFactory<>} instance with the default
			 * configuration.
			 */
			constructor(cancellationToken: AbortSignal);

			/**
			 * Initializes a {@link System.Threading.Tasks.TaskFactory<>} instance with the specified
			 * configuration.
			 */
			constructor(
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler | undefined,
			);

			/**
			 * Initializes a {@link System.Threading.Tasks.TaskFactory<>} instance with the specified
			 * configuration.
			 */
			constructor(
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			);

			/**
			 * Initializes a {@link System.Threading.Tasks.TaskFactory<>} instance with the specified
			 * configuration.
			 */
			constructor(scheduler: System.Threading.Tasks.TaskScheduler | undefined);

			/** Gets the default cancellation token for this task factory. */
			readonly CancellationToken: AbortSignal;

			/**
			 * Gets the {@link System.Threading.Tasks.TaskContinuationOptions} enumeration value for
			 * this task factory.
			 */
			readonly ContinuationOptions: System.Threading.Tasks.TaskContinuationOptions;

			/**
			 * Gets the {@link System.Threading.Tasks.TaskCreationOptions} enumeration value for this
			 * task factory.
			 */
			readonly CreationOptions: System.Threading.Tasks.TaskCreationOptions;

			/** Gets the task scheduler for this task factory. */
			readonly Scheduler?: System.Threading.Tasks.TaskScheduler;

			/**
			 * Creates a continuation task that will be started upon the completion of a set of
			 * provided tasks.
			 */
			ContinueWhenAll(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>[], TResult>,
			): Promise<TResult>;

			/**
			 * Creates a continuation task that will be started upon the completion of a set of
			 * provided tasks.
			 */
			ContinueWhenAll(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>[], TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates a continuation task that will be started upon the completion of a set of
			 * provided Tasks.
			 */
			ContinueWhenAll(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>[], TResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a continuation task that will be started upon the completion of a set of
			 * provided Tasks.
			 */
			ContinueWhenAll(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>[], TResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			ContinueWhenAll<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>[], TResult>,
			): Promise<TResult>;

			ContinueWhenAll<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>[], TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			ContinueWhenAll<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>[], TResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			ContinueWhenAll<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>[], TResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			/**
			 * Creates a continuation task that will be started upon the completion of any task in
			 * the provided set.
			 */
			ContinueWhenAny(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>, TResult>,
			): Promise<TResult>;

			/**
			 * Creates a continuation task that will be started upon the completion of any task in
			 * the provided set.
			 */
			ContinueWhenAny(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates a continuation task that will be started upon the completion of any task in
			 * the provided set.
			 */
			ContinueWhenAny(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a continuation task that will be started upon the completion of any task in
			 * the provided set.
			 */
			ContinueWhenAny(
				tasks: Promise<void>[],
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			ContinueWhenAny<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>, TResult>,
			): Promise<TResult>;

			ContinueWhenAny<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>, TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			ContinueWhenAny<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>, TResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			ContinueWhenAny<TAntecedentResult>(
				tasks: Promise<TAntecedentResult>[],
				continuationFunction: System.Func$2<Promise<TAntecedentResult>, TResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			/**
			 * Creates a task that represents a pair of begin and end methods that conform to the
			 * Asynchronous Programming Model pattern.
			 */
			FromAsync(
				beginMethod: System.Func$3<System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates a task that represents a pair of begin and end methods that conform to the
			 * Asynchronous Programming Model pattern.
			 */
			FromAsync(
				beginMethod: System.Func$3<System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/**
			 * Creates a task that executes an end method function when a specified
			 * {@link System.IAsyncResult} completes.
			 */
			FromAsync(
				asyncResult: System.IAsyncResult,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
			): Promise<TResult>;

			/**
			 * Creates a task that executes an end method function when a specified
			 * {@link System.IAsyncResult} completes.
			 */
			FromAsync(
				asyncResult: System.IAsyncResult,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/**
			 * Creates a task that executes an end method function when a specified
			 * {@link System.IAsyncResult} completes.
			 */
			FromAsync(
				asyncResult: System.IAsyncResult,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a task that represents a pair of begin and end methods that conform to the
			 * Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1>(
				beginMethod: System.Func$4<TArg1, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates a task that represents a pair of begin and end methods that conform to the
			 * Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1>(
				beginMethod: System.Func$4<TArg1, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/**
			 * Creates a task that represents a pair of begin and end methods that conform to the
			 * Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2>(
				beginMethod: System.Func$5<TArg1, TArg2, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				arg2: TArg2,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates a task that represents a pair of begin and end methods that conform to the
			 * Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2>(
				beginMethod: System.Func$5<TArg1, TArg2, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				arg2: TArg2,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/**
			 * Creates a task that represents a pair of begin and end methods that conform to the
			 * Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2, TArg3>(
				beginMethod: System.Func$6<TArg1, TArg2, TArg3, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				arg2: TArg2,
				arg3: TArg3,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates a task that represents a pair of begin and end methods that conform to the
			 * Asynchronous Programming Model pattern.
			 */
			FromAsync<TArg1, TArg2, TArg3>(
				beginMethod: System.Func$6<TArg1, TArg2, TArg3, System.AsyncCallback, System.Object | undefined, System.IAsyncResult>,
				endMethod: System.Func$2<System.IAsyncResult, TResult>,
				arg1: TArg1,
				arg2: TArg2,
				arg3: TArg3,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/** Creates and starts a task. */
			StartNew(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
			): Promise<TResult>;

			/** Creates and starts a task. */
			StartNew(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/** Creates and starts a task. */
			StartNew(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/** Creates and starts a task. */
			StartNew(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;

			/** Creates and starts a task. */
			StartNew(_function: System.Func$1<TResult>): Promise<TResult>;

			/** Creates and starts a task. */
			StartNew(
				_function: System.Func$1<TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/** Creates and starts a task. */
			StartNew(
				_function: System.Func$1<TResult>,
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/** Creates and starts a task. */
			StartNew(
				_function: System.Func$1<TResult>,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			): Promise<TResult>;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Represents an object that handles the low-level work of queuing tasks onto threads.
		 */
		export class TaskScheduler {
			/**
			 * Gets the {@link System.Threading.Tasks.TaskScheduler} associated with the currently
			 * executing task.
			 */
			static readonly Current: System.Threading.Tasks.TaskScheduler;

			/**
			 * Gets the default {@link System.Threading.Tasks.TaskScheduler} instance that is
			 * provided by .NET.
			 */
			static readonly Default: System.Threading.Tasks.TaskScheduler;

			/** Gets the unique ID for this {@link System.Threading.Tasks.TaskScheduler}. */
			readonly Id: number;

			/**
			 * Indicates the maximum concurrency level this
			 * {@link System.Threading.Tasks.TaskScheduler} is able to support.
			 */
			readonly MaximumConcurrencyLevel: number;

			/**
			 * Creates a {@link System.Threading.Tasks.TaskScheduler} associated with the current
			 * {@link System.Threading.SynchronizationContext}.
			 */
			static FromCurrentSynchronizationContext(): System.Threading.Tasks.TaskScheduler;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Represents an exception used to communicate an invalid operation by a
		 * {@link System.Threading.Tasks.TaskScheduler}.
		 */
		export class TaskSchedulerException extends System.Exception {
			/**
			 * Initializes a new instance of the
			 * {@link System.Threading.Tasks.TaskSchedulerException} class with a system-supplied
			 * message that describes the error.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Threading.Tasks.TaskSchedulerException} class using the default error
			 * message and a reference to the inner exception that is the cause of this exception.
			 */
			constructor(innerException: System.Exception | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Threading.Tasks.TaskSchedulerException} class with a specified message
			 * that describes the error.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Threading.Tasks.TaskSchedulerException} class with a specified error
			 * message and a reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Represents the current stage in the lifecycle of a
		 * {@link System.Threading.Tasks.Task}.
		 */
		export enum TaskStatus {
			/** The task has been initialized but has not yet been scheduled. */
			Created = 0,

			/**
			 * The task is waiting to be activated and scheduled internally by the .NET
			 * infrastructure.
			 */
			WaitingForActivation = 1,

			/** The task has been scheduled for execution but has not yet begun executing. */
			WaitingToRun = 2,

			/** The task is running but has not yet completed. */
			Running = 3,

			/**
			 * The task has finished executing and is implicitly waiting for attached child tasks to
			 * complete.
			 */
			WaitingForChildrenToComplete = 4,

			/** The task completed execution successfully. */
			RanToCompletion = 5,

			/**
			 * The task acknowledged cancellation by throwing an OperationCanceledException with its
			 * own CancellationToken while the token was in signaled state, or the task's
			 * CancellationToken was already signaled before the task started executing. For more
			 * information, see Task Cancellation.
			 */
			Canceled = 6,

			/** The task completed due to an unhandled exception. */
			Faulted = 7,
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * [Generic type factory] Represents an asynchronous operation that can return a value.
		 */
		export function Task$(TResult: IType): typeof Task$1<any>;

		/** Represents an asynchronous operation that can return a value. */
		export class Task$1<TResult> extends System.Threading.Tasks.Task implements
			IDisposable {
			/**
			 * Initializes a new {@link System.Threading.Tasks.Task<>} with the specified function
			 * and state.
			 */
			constructor(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task<>} with the specified action,
			 * state, and options.
			 */
			constructor(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task<>} with the specified action,
			 * state, and options.
			 */
			constructor(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task<>} with the specified action,
			 * state, and options.
			 */
			constructor(
				_function: System.Func$2<System.Object | undefined, TResult>,
				state: System.Object | undefined,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task<>} with the specified function.
			 */
			constructor(_function: System.Func$1<TResult>);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task<>} with the specified function.
			 */
			constructor(
				_function: System.Func$1<TResult>,
				cancellationToken: AbortSignal,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task<>} with the specified function
			 * and creation options.
			 */
			constructor(
				_function: System.Func$1<TResult>,
				cancellationToken: AbortSignal,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			);

			/**
			 * Initializes a new {@link System.Threading.Tasks.Task<>} with the specified function
			 * and creation options.
			 */
			constructor(
				_function: System.Func$1<TResult>,
				creationOptions: System.Threading.Tasks.TaskCreationOptions,
			);

			/**
			 * Gets a factory method for creating and configuring
			 * {@link System.Threading.Tasks.Task<>} instances.
			 */
			static readonly Factory: System.Threading.Tasks.TaskFactory$1<any>;

			/** Gets the result value of this {@link System.Threading.Tasks.Task<>}. */
			readonly Result: TResult;

			/**
			 * Creates a continuation that is passed state information and that executes when the
			 * target {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<TResult>, System.Object | undefined>,
				state: System.Object | undefined,
			): Promise<void>;

			/**
			 * Creates a continuation that executes when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<TResult>, System.Object | undefined>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a continuation that executes when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<TResult>, System.Object | undefined>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that executes when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<TResult>, System.Object | undefined>,
				state: System.Object | undefined,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<void>;

			/**
			 * Creates a continuation that executes when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<TResult>, System.Object | undefined>,
				state: System.Object | undefined,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that executes asynchronously when the target task completes.
			 */
			ContinueWith(continuationAction: System.Action$1<Promise<TResult>>): Promise<void>;

			/**
			 * Creates a cancelable continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<TResult>>,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a continuation that executes according the condition specified in
			 * `continuationOptions`.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<TResult>>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that executes according the condition specified in
			 * `continuationOptions`.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<TResult>>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<void>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<TResult>>,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that executes when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith<TNewResult>(
				continuationFunction: System.Func$3<Promise<TResult>, System.Object | undefined, TNewResult>,
				state: System.Object | undefined,
			): Promise<TNewResult>;

			/**
			 * Creates a continuation that executes when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith<TNewResult>(
				continuationFunction: System.Func$3<Promise<TResult>, System.Object | undefined, TNewResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			): Promise<TNewResult>;

			/**
			 * Creates a continuation that executes when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith<TNewResult>(
				continuationFunction: System.Func$3<Promise<TResult>, System.Object | undefined, TNewResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TNewResult>;

			/**
			 * Creates a continuation that executes when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith<TNewResult>(
				continuationFunction: System.Func$3<Promise<TResult>, System.Object | undefined, TNewResult>,
				state: System.Object | undefined,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TNewResult>;

			/**
			 * Creates a continuation that executes when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith<TNewResult>(
				continuationFunction: System.Func$3<Promise<TResult>, System.Object | undefined, TNewResult>,
				state: System.Object | undefined,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TNewResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith<TNewResult>(continuationFunction: System.Func$2<Promise<TResult>, TNewResult>): Promise<TNewResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith<TNewResult>(
				continuationFunction: System.Func$2<Promise<TResult>, TNewResult>,
				cancellationToken: AbortSignal,
			): Promise<TNewResult>;

			/**
			 * Creates a continuation that executes according the condition specified in
			 * `continuationOptions`.
			 */
			ContinueWith<TNewResult>(
				continuationFunction: System.Func$2<Promise<TResult>, TNewResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TNewResult>;

			/**
			 * Creates a continuation that executes according the condition specified in
			 * `continuationOptions`.
			 */
			ContinueWith<TNewResult>(
				continuationFunction: System.Func$2<Promise<TResult>, TNewResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TNewResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task<>} completes.
			 */
			ContinueWith<TNewResult>(
				continuationFunction: System.Func$2<Promise<TResult>, TNewResult>,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TNewResult>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task<>} that will complete when this
			 * {@link System.Threading.Tasks.Task<>} completes or when the specified
			 * {@link System.Threading.CancellationToken} has cancellation requested.
			 */
			WaitAsync(cancellationToken: AbortSignal): Promise<TResult>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task<>} that will complete when this
			 * {@link System.Threading.Tasks.Task<>} completes or when the specified timeout expires.
			 */
			WaitAsync(timeout: number): Promise<TResult>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task<>} that will complete when this
			 * {@link System.Threading.Tasks.Task<>} completes, when the specified timeout expires,
			 * or when the specified {@link System.Threading.CancellationToken} has cancellation
			 * requested.
			 */
			WaitAsync(
				timeout: number,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task<>} that will complete when this
			 * {@link System.Threading.Tasks.Task<>} completes or when the specified timeout expires.
			 */
			WaitAsync(
				timeout: number,
				timeProvider: System.TimeProvider,
			): Promise<TResult>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task<>} that will complete when this
			 * {@link System.Threading.Tasks.Task<>} completes, when the specified timeout expires,
			 * or when the specified {@link System.Threading.CancellationToken} has cancellation
			 * requested.
			 */
			WaitAsync(
				timeout: number,
				timeProvider: System.TimeProvider,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates a continuation that receives caller-supplied state information and executes
			 * when the target {@link System.Threading.Tasks.Task} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<void>, System.Object | undefined>,
				state: System.Object | undefined,
			): Promise<void>;

			/**
			 * Creates a continuation that receives caller-supplied state information and a
			 * cancellation token and that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<void>, System.Object | undefined>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a continuation that receives caller-supplied state information and a
			 * cancellation token and that executes when the target
			 * {@link System.Threading.Tasks.Task} completes. The continuation executes based on a
			 * set of specified conditions and uses a specified scheduler.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<void>, System.Object | undefined>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that receives caller-supplied state information and executes
			 * when the target {@link System.Threading.Tasks.Task} completes. The continuation
			 * executes based on a set of specified conditions.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<void>, System.Object | undefined>,
				state: System.Object | undefined,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<void>;

			/**
			 * Creates a continuation that receives caller-supplied state information and executes
			 * asynchronously when the target {@link System.Threading.Tasks.Task} completes. The
			 * continuation uses a specified scheduler.
			 */
			ContinueWith(
				continuationAction: System.Action$2<Promise<void>, System.Object | undefined>,
				state: System.Object | undefined,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes.
			 */
			ContinueWith(continuationAction: System.Action$1<Promise<void>>): Promise<void>;

			/**
			 * Creates a continuation that receives a cancellation token and executes asynchronously
			 * when the target {@link System.Threading.Tasks.Task} completes.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<void>>,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a continuation that executes when the target task competes according to the
			 * specified {@link System.Threading.Tasks.TaskContinuationOptions}. The continuation
			 * receives a cancellation token and uses a specified scheduler.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<void>>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that executes when the target task completes according to the
			 * specified {@link System.Threading.Tasks.TaskContinuationOptions}.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<void>>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<void>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes. The continuation uses a specified
			 * scheduler.
			 */
			ContinueWith(
				continuationAction: System.Action$1<Promise<void>>,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<void>;

			/**
			 * Creates a continuation that receives caller-supplied state information and executes
			 * asynchronously when the target {@link System.Threading.Tasks.Task} completes and
			 * returns a value.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$3<Promise<void>, System.Object | undefined, TResult>,
				state: System.Object | undefined,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes and returns a value. The continuation
			 * receives caller-supplied state information and a cancellation token.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$3<Promise<void>, System.Object | undefined, TResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes based on the specified task continuation options
			 * when the target {@link System.Threading.Tasks.Task} completes and returns a value. The
			 * continuation receives caller-supplied state information and a cancellation token and
			 * uses the specified scheduler.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$3<Promise<void>, System.Object | undefined, TResult>,
				state: System.Object | undefined,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes based on the specified task continuation options
			 * when the target {@link System.Threading.Tasks.Task} completes. The continuation
			 * receives caller-supplied state information.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$3<Promise<void>, System.Object | undefined, TResult>,
				state: System.Object | undefined,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes. The continuation receives
			 * caller-supplied state information and uses a specified scheduler.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$3<Promise<void>, System.Object | undefined, TResult>,
				state: System.Object | undefined,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task<>} completes and returns a value.
			 */
			ContinueWith<TResult>(continuationFunction: System.Func$2<Promise<void>, TResult>): Promise<TResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes and returns a value. The continuation
			 * receives a cancellation token.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				cancellationToken: AbortSignal,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes according to the specified continuation options
			 * and returns a value. The continuation is passed a cancellation token and uses a
			 * specified scheduler.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				cancellationToken: AbortSignal,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes according to the specified continuation options
			 * and returns a value.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				continuationOptions: System.Threading.Tasks.TaskContinuationOptions,
			): Promise<TResult>;

			/**
			 * Creates a continuation that executes asynchronously when the target
			 * {@link System.Threading.Tasks.Task} completes and returns a value. The continuation
			 * uses a specified scheduler.
			 */
			ContinueWith<TResult>(
				continuationFunction: System.Func$2<Promise<void>, TResult>,
				scheduler: System.Threading.Tasks.TaskScheduler,
			): Promise<TResult>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when this
			 * {@link System.Threading.Tasks.Task} completes or when the specified
			 * {@link System.Threading.CancellationToken} has cancellation requested.
			 */
			WaitAsync(cancellationToken: AbortSignal): Promise<void>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when this
			 * {@link System.Threading.Tasks.Task} completes or when the specified timeout expires.
			 */
			WaitAsync(timeout: number): Promise<void>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when this
			 * {@link System.Threading.Tasks.Task} completes, when the specified timeout expires, or
			 * when the specified {@link System.Threading.CancellationToken} has cancellation
			 * requested.
			 */
			WaitAsync(
				timeout: number,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when this
			 * {@link System.Threading.Tasks.Task} completes or when the specified timeout expires.
			 */
			WaitAsync(
				timeout: number,
				timeProvider: System.TimeProvider,
			): Promise<void>;

			/**
			 * Gets a {@link System.Threading.Tasks.Task} that will complete when this
			 * {@link System.Threading.Tasks.Task} completes, when the specified timeout expires, or
			 * when the specified {@link System.Threading.CancellationToken} has cancellation
			 * requested.
			 */
			WaitAsync(
				timeout: number,
				timeProvider: System.TimeProvider,
				cancellationToken: AbortSignal,
			): Promise<void>;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Provides methods for using {@link System.Threading.Tasks.Task} to implement the
		 * Asynchronous Programming Model pattern based on "Begin" and "End" methods.
		 */
		export namespace TaskToAsyncResult {
			/**
			 * Extracts the underlying {@link System.Threading.Tasks.Task} from an
			 * {@link System.IAsyncResult} created by
			 * {@link System.Threading.Tasks.TaskToAsyncResult.Begin(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)}.
			 */
			export function Unwrap(asyncResult: System.IAsyncResult): Promise<void>;

			/**
			 * Extracts the underlying {@link System.Threading.Tasks.Task<>} from an
			 * {@link System.IAsyncResult} created by
			 * {@link System.Threading.Tasks.TaskToAsyncResult.Begin(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)}.
			 */
			export function Unwrap<TResult>(asyncResult: System.IAsyncResult): Promise<TResult>;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * Provides data for the event that is raised when a faulted
		 * {@link System.Threading.Tasks.Task} 's exception goes unobserved.
		 */
		export class UnobservedTaskExceptionEventArgs extends System.EventArgs {
			/**
			 * Initializes a new instance of the
			 * {@link System.Threading.Tasks.UnobservedTaskExceptionEventArgs} class with the
			 * unobserved exception.
			 */
			constructor(exception: System.AggregateException);

			/** Gets the exception that went unobserved. */
			readonly Exception: System.AggregateException;

			/** Gets a value that indicates whether this exception has been marked as "observed." */
			readonly Observed: boolean;

			/**
			 * Marks the {@link System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Exception} as
			 * "observed," thus preventing it from triggering exception escalation policy, which, by
			 * default, terminates the process.
			 */
			SetObserved(): void;
		}
	}

	export namespace System.Threading.Tasks {
		/** Provides an awaitable result of an asynchronous operation. */
		export class ValueTask extends System.ValueType implements System.IEquatable$1<Promise<void>> {
			/**
			 * Initializes a new instance of the {@link System.Threading.Tasks.ValueTask} class using
			 * the supplied {@link System.Threading.Tasks.Sources.IValueTaskSource} object that
			 * represents the operation.
			 */
			constructor(
				source: System.Threading.Tasks.Sources.IValueTaskSource,
				token: number,
			);

			/**
			 * Initializes a new instance of the {@link System.Threading.Tasks.ValueTask} class using
			 * the supplied task that represents the operation.
			 */
			constructor(task: Promise<void>);

			/** Gets a task that has already completed successfully. */
			static readonly CompletedTask: Promise<void>;

			/** Gets a value that indicates whether this object represents a canceled operation. */
			readonly IsCanceled: boolean;

			/** Gets a value that indicates whether this object represents a completed operation. */
			readonly IsCompleted: boolean;

			/**
			 * Gets a value that indicates whether this object represents a successfully completed
			 * operation.
			 */
			readonly IsCompletedSuccessfully: boolean;

			/** Gets a value that indicates whether this object represents a failed operation. */
			readonly IsFaulted: boolean;

			/**
			 * Retrieves a {@link System.Threading.Tasks.Task} object that represents this
			 * {@link System.Threading.Tasks.ValueTask}.
			 */
			AsTask(): Promise<void>;

			/**
			 * Determines whether the specified object is equal to the current
			 * {@link System.Threading.Tasks.ValueTask} instance.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Determines whether the specified {@link System.Threading.Tasks.ValueTask} object is
			 * equal to the current {@link System.Threading.Tasks.ValueTask} object.
			 */
			Equals(other: Promise<void>): boolean;

			/**
			 * Creates a {@link System.Threading.Tasks.ValueTask} that has completed due to
			 * cancellation with the specified cancellation token.
			 */
			static FromCanceled(cancellationToken: AbortSignal): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.ValueTask<>} that has completed due to
			 * cancellation with the specified cancellation token.
			 */
			static FromCanceled<TResult>(cancellationToken: AbortSignal): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.ValueTask} that has completed with the
			 * specified exception.
			 */
			static FromException(exception: System.Exception): Promise<void>;

			/**
			 * Creates a {@link System.Threading.Tasks.ValueTask<>} that has completed with the
			 * specified exception.
			 */
			static FromException<TResult>(exception: System.Exception): Promise<TResult>;

			/**
			 * Creates a {@link System.Threading.Tasks.ValueTask<>} that's completed successfully
			 * with the specified result.
			 */
			static FromResult<TResult>(result: TResult): Promise<TResult>;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Gets a {@link System.Threading.Tasks.ValueTask} that may be used at any point in the
			 * future.
			 */
			Preserve(): Promise<void>;
		}
	}

	export namespace System.Threading.Tasks {
		/**
		 * [Generic type factory] Provides a value type that wraps a
		 * {@link System.Threading.Tasks.Task<>} and a  , only one of which is used.
		 */
		export function ValueTask$(TResult: IType): typeof ValueTask$1<any>;

		/**
		 * Provides a value type that wraps a {@link System.Threading.Tasks.Task<>} and a  , only
		 * one of which is used.
		 */
		export class ValueTask$1<TResult> extends System.ValueType implements System.IEquatable$1<Promise<TResult>> {
			/**
			 * Initializes a new instance of the {@link System.Threading.Tasks.ValueTask<>} class
			 * with a {@link System.Threading.Tasks.Sources.IValueTaskSource<>} object that
			 * represents the operation.
			 */
			constructor(
				source: System.Threading.Tasks.Sources.IValueTaskSource$1<TResult>,
				token: number,
			);

			/**
			 * Initializes a new instance of the {@link System.Threading.Tasks.ValueTask<>} class
			 * using the supplied task that represents the operation.
			 */
			constructor(task: Promise<TResult>);

			/**
			 * Initializes a new instance of the {@link System.Threading.Tasks.ValueTask<>} class
			 * using the supplied result of a successful operation.
			 */
			constructor(result: TResult);

			/** Gets a value that indicates whether this object represents a canceled operation. */
			readonly IsCanceled: boolean;

			/** Gets a value that indicates whether this object represents a completed operation. */
			readonly IsCompleted: boolean;

			/**
			 * Gets a value that indicates whether this object represents a successfully completed
			 * operation.
			 */
			readonly IsCompletedSuccessfully: boolean;

			/** Gets a value that indicates whether this object represents a failed operation. */
			readonly IsFaulted: boolean;

			/** Gets the result. */
			readonly Result: TResult;

			/**
			 * Retrieves a {@link System.Threading.Tasks.Task<>} object that represents this
			 * {@link System.Threading.Tasks.ValueTask<>}.
			 */
			AsTask(): Promise<TResult>;

			/** Determines whether the specified object is equal to the current object. */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Determines whether the specified {@link System.Threading.Tasks.ValueTask<>} object is
			 * equal to the current {@link System.Threading.Tasks.ValueTask<>} object.
			 */
			Equals(other: Promise<TResult>): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Gets a {@link System.Threading.Tasks.ValueTask<>} that may be used at any point in the
			 * future.
			 */
			Preserve(): Promise<TResult>;

			/** Returns a string that represents the current object. */
			ToString(): string | undefined;
		}
	}

	export namespace System.Threading.Tasks.Sources {
		/**
		 * Represents an object that can be wrapped by a
		 * {@link System.Threading.Tasks.ValueTask}.
		 */
		export interface IValueTaskSource {
			/** Gets the result of the {@link System.Threading.Tasks.Sources.IValueTaskSource}. */
			GetResult(token: number): void;

			/** Gets the status of the current operation. */
			GetStatus(token: number): System.Threading.Tasks.Sources.ValueTaskSourceStatus;

			/**
			 * Schedules the continuation action for this
			 * {@link System.Threading.Tasks.Sources.IValueTaskSource}.
			 */
			OnCompleted(
				continuation: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
				token: number,
				flags: System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags,
			): void;
		}
	}

	export namespace System.Threading.Tasks.Sources {
		/**
		 * [Generic type factory] Represents an object that can be wrapped by a
		 * {@link System.Threading.Tasks.ValueTask<>}.
		 */
		export function IValueTaskSource$(TResult: IType): IType;

		/**
		 * Represents an object that can be wrapped by a
		 * {@link System.Threading.Tasks.ValueTask<>}.
		 */
		export interface IValueTaskSource$1<TResult> {
			/** Gets the result of the {@link System.Threading.Tasks.Sources.IValueTaskSource<>}. */
			GetResult(token: number): TResult;

			/** Gets the status of the current operation. */
			GetStatus(token: number): System.Threading.Tasks.Sources.ValueTaskSourceStatus;

			/**
			 * Schedules the continuation action for this
			 * {@link System.Threading.Tasks.Sources.IValueTaskSource<>}.
			 */
			OnCompleted(
				continuation: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
				token: number,
				flags: System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags,
			): void;
		}
	}

	export namespace System.Threading.Tasks.Sources {
		/**
		 * [Generic type factory] Provides the core logic for implementing a manual-reset
		 * {@link System.Threading.Tasks.Sources.IValueTaskSource} or
		 * {@link System.Threading.Tasks.Sources.IValueTaskSource<>}.
		 */
		export function ManualResetValueTaskSourceCore$(TResult: IType): typeof ManualResetValueTaskSourceCore$1<any>;

		/**
		 * Provides the core logic for implementing a manual-reset
		 * {@link System.Threading.Tasks.Sources.IValueTaskSource} or
		 * {@link System.Threading.Tasks.Sources.IValueTaskSource<>}.
		 */
		export class ManualResetValueTaskSourceCore$1<TResult> extends System.ValueType {
			/** Gets or sets whether to force continuations to run asynchronously. */
			RunContinuationsAsynchronously: boolean;

			/** Gets the operation version. */
			readonly Version: number;

			/** Returns the result of the operation. */
			GetResult(token: number): TResult;

			/** Gets the status of the operation. */
			GetStatus(token: number): System.Threading.Tasks.Sources.ValueTaskSourceStatus;

			/** Schedules the continuation action for this operation. */
			OnCompleted(
				continuation: System.Action$1<System.Object | undefined>,
				state: System.Object | undefined,
				token: number,
				flags: System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags,
			): void;

			/** Resets to prepare for the next operation. */
			Reset(): void;

			/** Completes with an error. */
			SetException(error: System.Exception): void;

			/** Completes with a successful result. */
			SetResult(result: TResult): void;
		}
	}

	export namespace System.Threading.Tasks.Sources {
		/**
		 * Provides flags passed from {@link System.Threading.Tasks.ValueTask} and
		 * {@link System.Threading.Tasks.ValueTask<>} to the `OnCompleted` method to control the
		 * behavior of a continuation.
		 */
		export enum ValueTaskSourceOnCompletedFlags {
			/** No requirements are placed on how the continuation is invoked. */
			None = 0,

			/**
			 * `OnCompleted` should capture the current scheduling context (the
			 * {@link System.Threading.SynchronizationContext} ) and use it when queueing the
			 * continuation for execution.  If this flag is not set, the implementation may choose to
			 * execute the continuation in an arbitrary location.
			 */
			UseSchedulingContext = 1,

			/**
			 * `OnCompleted` should capture the current {@link System.Threading.ExecutionContext} and
			 * use it to run the continuation.
			 */
			FlowExecutionContext = 2,
		}
	}

	export namespace System.Threading.Tasks.Sources {
		/**
		 * Indicates the status of an {@link System.Threading.Tasks.Sources.IValueTaskSource} or
		 * {@link System.Threading.Tasks.Sources.IValueTaskSource<>}.
		 */
		export enum ValueTaskSourceStatus {
			/** The operation has not yet completed. */
			Pending = 0,

			/** The operation completed successfully. */
			Succeeded = 1,

			/** The operation completed with an error. */
			Faulted = 2,

			/** The operation completed due to cancellation. */
			Canceled = 3,
		}
	}

	export namespace System.Text {
		export namespace Ascii {
			/** Determines whether the provided buffers contain equal ASCII characters. */
			export function Equals(
				left: System.ReadOnlySpan$1<number>,
				right: System.ReadOnlySpan$1<number>,
			): boolean;

			/** Determines whether the provided buffers contain equal ASCII characters. */
			export function Equals(
				left: System.ReadOnlySpan$1<number>,
				right: System.ReadOnlySpan$1<System.Char>,
			): boolean;

			/** Determines whether the provided buffers contain equal ASCII characters. */
			export function Equals(
				left: System.ReadOnlySpan$1<System.Char>,
				right: System.ReadOnlySpan$1<number>,
			): boolean;

			/** Determines whether the provided buffers contain equal ASCII characters. */
			export function Equals(
				left: System.ReadOnlySpan$1<System.Char>,
				right: System.ReadOnlySpan$1<System.Char>,
			): boolean;

			/**
			 * Determines whether the provided buffers contain equal ASCII characters, ignoring case
			 * considerations.
			 */
			export function EqualsIgnoreCase(
				left: System.ReadOnlySpan$1<number>,
				right: System.ReadOnlySpan$1<number>,
			): boolean;

			/**
			 * Determines whether the provided buffers contain equal ASCII characters, ignoring case
			 * considerations.
			 */
			export function EqualsIgnoreCase(
				left: System.ReadOnlySpan$1<number>,
				right: System.ReadOnlySpan$1<System.Char>,
			): boolean;

			/**
			 * Determines whether the provided buffers contain equal ASCII characters, ignoring case
			 * considerations.
			 */
			export function EqualsIgnoreCase(
				left: System.ReadOnlySpan$1<System.Char>,
				right: System.ReadOnlySpan$1<number>,
			): boolean;

			/**
			 * Determines whether the provided buffers contain equal ASCII characters, ignoring case
			 * considerations.
			 */
			export function EqualsIgnoreCase(
				left: System.ReadOnlySpan$1<System.Char>,
				right: System.ReadOnlySpan$1<System.Char>,
			): boolean;

			/** Determines whether the provided value contains only ASCII bytes. */
			export function IsValid(value: System.ReadOnlySpan$1<number>): boolean;

			/** Determines whether the provided value contains only ASCII chars. */
			export function IsValid(value: System.ReadOnlySpan$1<System.Char>): boolean;

			/** Determines whether the provided value is ASCII byte. */
			export function IsValid(value: number): boolean;

			/** Determines whether the provided value is ASCII char. */
			export function IsValid(value: System.Char): boolean;

			export function ToLower(
				source: System.ReadOnlySpan$1<number>,
				destination: System.Span$1<number>,
			): { result: System.Buffers.OperationStatus, bytesWritten: number };

			export function ToLower(
				source: System.ReadOnlySpan$1<System.Char>,
				destination: System.Span$1<System.Char>,
			): { result: System.Buffers.OperationStatus, charsWritten: number };

			export function ToLower(
				source: System.ReadOnlySpan$1<number>,
				destination: System.Span$1<System.Char>,
			): { result: System.Buffers.OperationStatus, charsWritten: number };

			export function ToLower(
				source: System.ReadOnlySpan$1<System.Char>,
				destination: System.Span$1<number>,
			): { result: System.Buffers.OperationStatus, bytesWritten: number };

			export function ToUpper(
				source: System.ReadOnlySpan$1<number>,
				destination: System.Span$1<number>,
			): { result: System.Buffers.OperationStatus, bytesWritten: number };

			export function ToUpper(
				source: System.ReadOnlySpan$1<System.Char>,
				destination: System.Span$1<System.Char>,
			): { result: System.Buffers.OperationStatus, charsWritten: number };

			export function ToUpper(
				source: System.ReadOnlySpan$1<number>,
				destination: System.Span$1<System.Char>,
			): { result: System.Buffers.OperationStatus, charsWritten: number };

			export function ToUpper(
				source: System.ReadOnlySpan$1<System.Char>,
				destination: System.Span$1<number>,
			): { result: System.Buffers.OperationStatus, bytesWritten: number };

			export function ToLowerInPlace(value: System.Span$1<number>): { result: System.Buffers.OperationStatus, bytesWritten: number };

			export function ToLowerInPlace(value: System.Span$1<System.Char>): { result: System.Buffers.OperationStatus, charsWritten: number };

			export function ToUpperInPlace(value: System.Span$1<number>): { result: System.Buffers.OperationStatus, bytesWritten: number };

			export function ToUpperInPlace(value: System.Span$1<System.Char>): { result: System.Buffers.OperationStatus, charsWritten: number };

			export function FromUtf16(
				source: System.ReadOnlySpan$1<System.Char>,
				destination: System.Span$1<number>,
			): { result: System.Buffers.OperationStatus, bytesWritten: number };

			export function ToUtf16(
				source: System.ReadOnlySpan$1<number>,
				destination: System.Span$1<System.Char>,
			): { result: System.Buffers.OperationStatus, charsWritten: number };

			/** Trims all leading and trailing ASCII whitespaces from the buffer. */
			export function Trim(value: System.ReadOnlySpan$1<number>): System.Range;

			/** Trims all leading and trailing ASCII whitespaces from the buffer. */
			export function Trim(value: System.ReadOnlySpan$1<System.Char>): System.Range;

			/** Trims all trailing ASCII whitespaces from the buffer. */
			export function TrimEnd(value: System.ReadOnlySpan$1<number>): System.Range;

			/** Trims all trailing ASCII whitespaces from the buffer. */
			export function TrimEnd(value: System.ReadOnlySpan$1<System.Char>): System.Range;

			/** Trims all leading ASCII whitespaces from the buffer. */
			export function TrimStart(value: System.ReadOnlySpan$1<number>): System.Range;

			/** Trims all leading ASCII whitespaces from the buffer. */
			export function TrimStart(value: System.ReadOnlySpan$1<System.Char>): System.Range;
		}
	}

	export namespace System.Text {
		/** Represents a parsed composite format string. */
		export class CompositeFormat {
			/**
			 * Gets the original composite format string used to create this
			 * {@link System.Text.CompositeFormat} instance.
			 */
			readonly Format: string;

			/**
			 * Gets the minimum number of arguments that must be passed to a formatting operation
			 * using this {@link System.Text.CompositeFormat}.
			 */
			readonly MinimumArgumentCount: number;

			/** Parses the specified composite format string. */
			static Parse(format: string): System.Text.CompositeFormat;
		}
	}

	export namespace System.Text {
		/** Converts a sequence of encoded bytes into a set of characters. */
		export class Decoder {
			/**
			 * Gets or sets a {@link System.Text.DecoderFallback} object for the current
			 * {@link System.Text.Decoder} object.
			 */
			Fallback?: System.Text.DecoderFallback;

			/**
			 * Gets the {@link System.Text.DecoderFallbackBuffer} object associated with the current
			 * {@link System.Text.Decoder} object.
			 */
			readonly FallbackBuffer: System.Text.DecoderFallbackBuffer;

			Convert(
				bytes: number[],
				byteIndex: number,
				byteCount: number,
				chars: System.Char[],
				charIndex: number,
				charCount: number,
				flush: boolean,
			): { bytesUsed: number, charsUsed: number, completed: boolean };

			Convert(
				bytes: System.ReadOnlySpan$1<number>,
				chars: System.Span$1<System.Char>,
				flush: boolean,
			): { bytesUsed: number, charsUsed: number, completed: boolean };

			/**
			 * When overridden in a derived class, calculates the number of characters produced by
			 * decoding a sequence of bytes from the specified byte array.
			 */
			GetCharCount(
				bytes: number[],
				index: number,
				count: number,
			): number;

			/**
			 * When overridden in a derived class, calculates the number of characters produced by
			 * decoding a sequence of bytes from the specified byte array. A parameter indicates
			 * whether to clear the internal state of the decoder after the calculation.
			 */
			GetCharCount(
				bytes: number[],
				index: number,
				count: number,
				flush: boolean,
			): number;

			/**
			 * When overridden in a derived class, calculates the number of characters produced by
			 * decoding the sequence of bytes in the span. A parameter indicates whether to clear the
			 * internal state of the decoder after the calculation.
			 */
			GetCharCount(
				bytes: System.ReadOnlySpan$1<number>,
				flush: boolean,
			): number;

			/**
			 * When overridden in a derived class, decodes a sequence of bytes from the specified
			 * byte array and any bytes in the internal buffer into the specified character array.
			 */
			GetChars(
				bytes: number[],
				byteIndex: number,
				byteCount: number,
				chars: System.Char[],
				charIndex: number,
			): number;

			/**
			 * When overridden in a derived class, decodes a sequence of bytes from the specified
			 * byte array and any bytes in the internal buffer into the specified character array. A
			 * parameter indicates whether to clear the internal state of the decoder after the
			 * conversion.
			 */
			GetChars(
				bytes: number[],
				byteIndex: number,
				byteCount: number,
				chars: System.Char[],
				charIndex: number,
				flush: boolean,
			): number;

			/**
			 * When overridden in a derived class, decodes a sequence of span bytes and any bytes in
			 * the internal buffer into a set of characters that are stored starting at the specified
			 * character pointer. A parameter indicates whether to clear the internal state of the
			 * decoder after the conversion.
			 */
			GetChars(
				bytes: System.ReadOnlySpan$1<number>,
				chars: System.Span$1<System.Char>,
				flush: boolean,
			): number;

			/** When overridden in a derived class, sets the decoder back to its initial state. */
			Reset(): void;
		}
	}

	export namespace System.Text {
		/**
		 * Provides a failure-handling mechanism, called a fallback, for an encoded input byte
		 * sequence that cannot be converted to an input character. The fallback throws an
		 * exception instead of decoding the input byte sequence. This class cannot be inherited.
		 */
		export class DecoderExceptionFallback extends System.Text.DecoderFallback {
			/**
			 * Initializes a new instance of the {@link System.Text.DecoderExceptionFallback} class.
			 */
			constructor();

			/** Gets the maximum number of characters this instance can return. */
			readonly MaxCharCount: number;

			/**
			 * Returns a decoder fallback buffer that throws an exception if it cannot convert a
			 * sequence of bytes to a character.
			 */
			CreateFallbackBuffer(): System.Text.DecoderFallbackBuffer;

			/**
			 * Indicates whether the current {@link System.Text.DecoderExceptionFallback} object and
			 * a specified object are equal.
			 */
			Equals(value: System.Object | undefined): boolean;

			/** Retrieves the hash code for this instance. */
			GetHashCode(): number;
		}
	}

	export namespace System.Text {
		/**
		 * Throws {@link System.Text.DecoderFallbackException} when an encoded input byte
		 * sequence cannot be converted to a decoded output character. This class cannot be
		 * inherited.
		 */
		export class DecoderExceptionFallbackBuffer extends System.Text.DecoderFallbackBuffer {
			/**
			 * Initializes a new instance of the {@link System.Text.DecoderExceptionFallbackBuffer}
			 * class.
			 */
			constructor();

			/**
			 * Gets the number of characters in the current
			 * {@link System.Text.DecoderExceptionFallbackBuffer} object that remain to be processed.
			 */
			readonly Remaining: number;

			/**
			 * Throws {@link System.Text.DecoderFallbackException} when the input byte sequence
			 * cannot be decoded. The nominal return value is not used.
			 */
			Fallback(
				bytesUnknown: number[],
				index: number,
			): boolean;

			/** Retrieves the next character in the exception data buffer. */
			GetNextChar(): System.Char;

			/**
			 * Causes the next call to {@link System.Text.DecoderExceptionFallbackBuffer.GetNextChar}
			 * to access the exception data buffer character position that is prior to the current
			 * position.
			 */
			MovePrevious(): boolean;
		}
	}

	export namespace System.Text {
		/**
		 * Provides a failure-handling mechanism, called a fallback, for an encoded input byte
		 * sequence that cannot be converted to an output character.
		 */
		export class DecoderFallback {
			/**
			 * Gets an object that throws an exception when an input byte sequence cannot be decoded.
			 */
			static readonly ExceptionFallback: System.Text.DecoderFallback;

			/**
			 * When overridden in a derived class, gets the maximum number of characters the current
			 * {@link System.Text.DecoderFallback} object can return.
			 */
			readonly MaxCharCount: number;

			/**
			 * Gets an object that outputs a substitute string in place of an input byte sequence
			 * that cannot be decoded.
			 */
			static readonly ReplacementFallback: System.Text.DecoderFallback;

			/**
			 * When overridden in a derived class, initializes a new instance of the
			 * {@link System.Text.DecoderFallbackBuffer} class.
			 */
			CreateFallbackBuffer(): System.Text.DecoderFallbackBuffer;
		}
	}

	export namespace System.Text {
		/**
		 * Provides a buffer that allows a fallback handler to return an alternate string to a
		 * decoder when it cannot decode an input byte sequence.
		 */
		export class DecoderFallbackBuffer {
			/**
			 * When overridden in a derived class, gets the number of characters in the current
			 * {@link System.Text.DecoderFallbackBuffer} object that remain to be processed.
			 */
			readonly Remaining: number;

			/**
			 * When overridden in a derived class, prepares the fallback buffer to handle the
			 * specified input byte sequence.
			 */
			Fallback(
				bytesUnknown: number[],
				index: number,
			): boolean;

			/**
			 * When overridden in a derived class, retrieves the next character in the fallback
			 * buffer.
			 */
			GetNextChar(): System.Char;

			/**
			 * When overridden in a derived class, causes the next call to the
			 * {@link System.Text.DecoderFallbackBuffer.GetNextChar} method to access the data buffer
			 * character position that is prior to the current character position.
			 */
			MovePrevious(): boolean;

			/** Initializes all data and state information pertaining to this fallback buffer. */
			Reset(): void;
		}
	}

	export namespace System.Text {
		/**
		 * The exception that is thrown when a decoder fallback operation fails. This class
		 * cannot be inherited.
		 */
		export class DecoderFallbackException extends System.ArgumentException {
			/**
			 * Initializes a new instance of the {@link System.Text.DecoderFallbackException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Text.DecoderFallbackException} class.
			 * A parameter specifies the error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.Text.DecoderFallbackException} class.
			 * Parameters specify the error message, the array of bytes being decoded, and the index
			 * of the byte that cannot be decoded.
			 */
			constructor(
				message: string | undefined,
				bytesUnknown: number[] | undefined,
				index: number,
			);

			/**
			 * Initializes a new instance of the {@link System.Text.DecoderFallbackException} class.
			 * Parameters specify the error message and the inner exception that is the cause of this
			 * exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/** Gets the input byte sequence that caused the exception. */
			readonly BytesUnknown?: number[];

			/**
			 * Gets the index position in the input byte sequence of the byte that caused the
			 * exception.
			 */
			readonly Index: number;
		}
	}

	export namespace System.Text {
		/**
		 * Provides a failure-handling mechanism, called a fallback, for an encoded input byte
		 * sequence that cannot be converted to an output character. The fallback emits a
		 * user-specified replacement string instead of a decoded input byte sequence. This class
		 * cannot be inherited.
		 */
		export class DecoderReplacementFallback extends System.Text.DecoderFallback {
			/**
			 * Initializes a new instance of the {@link System.Text.DecoderReplacementFallback}
			 * class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Text.DecoderReplacementFallback} class
			 * using a specified replacement string.
			 */
			constructor(replacement: string);

			/**
			 * Gets the replacement string that is the value of the
			 * {@link System.Text.DecoderReplacementFallback} object.
			 */
			readonly DefaultString: string;

			/**
			 * Gets the number of characters in the replacement string for the
			 * {@link System.Text.DecoderReplacementFallback} object.
			 */
			readonly MaxCharCount: number;

			/**
			 * Creates a {@link System.Text.DecoderFallbackBuffer} object that is initialized with
			 * the replacement string of this {@link System.Text.DecoderReplacementFallback} object.
			 */
			CreateFallbackBuffer(): System.Text.DecoderFallbackBuffer;

			/**
			 * Indicates whether the value of a specified object is equal to the
			 * {@link System.Text.DecoderReplacementFallback} object.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Retrieves the hash code for the value of the
			 * {@link System.Text.DecoderReplacementFallback} object.
			 */
			GetHashCode(): number;
		}
	}

	export namespace System.Text {
		/**
		 * Represents a substitute output string that is emitted when the original input byte
		 * sequence cannot be decoded. This class cannot be inherited.
		 */
		export class DecoderReplacementFallbackBuffer extends System.Text.DecoderFallbackBuffer {
			/**
			 * Initializes a new instance of the {@link System.Text.DecoderReplacementFallbackBuffer}
			 * class using the value of a {@link System.Text.DecoderReplacementFallback} object.
			 */
			constructor(fallback: System.Text.DecoderReplacementFallback);

			/**
			 * Gets the number of characters in the replacement fallback buffer that remain to be
			 * processed.
			 */
			readonly Remaining: number;

			/** Prepares the replacement fallback buffer to use the current replacement string. */
			Fallback(
				bytesUnknown: number[],
				index: number,
			): boolean;

			/** Retrieves the next character in the replacement fallback buffer. */
			GetNextChar(): System.Char;

			/**
			 * Causes the next call to
			 * {@link System.Text.DecoderReplacementFallbackBuffer.GetNextChar} to access the
			 * character position in the replacement fallback buffer prior to the current character
			 * position.
			 */
			MovePrevious(): boolean;

			/**
			 * Initializes all internal state information and data in the
			 * {@link System.Text.DecoderReplacementFallbackBuffer} object.
			 */
			Reset(): void;
		}
	}

	export namespace System.Text {
		/** Converts a set of characters into a sequence of bytes. */
		export class Encoder {
			/**
			 * Gets or sets a {@link System.Text.EncoderFallback} object for the current
			 * {@link System.Text.Encoder} object.
			 */
			Fallback?: System.Text.EncoderFallback;

			/**
			 * Gets the {@link System.Text.EncoderFallbackBuffer} object associated with the current
			 * {@link System.Text.Encoder} object.
			 */
			readonly FallbackBuffer: System.Text.EncoderFallbackBuffer;

			Convert(
				chars: System.Char[],
				charIndex: number,
				charCount: number,
				bytes: number[],
				byteIndex: number,
				byteCount: number,
				flush: boolean,
			): { charsUsed: number, bytesUsed: number, completed: boolean };

			Convert(
				chars: System.ReadOnlySpan$1<System.Char>,
				bytes: System.Span$1<number>,
				flush: boolean,
			): { charsUsed: number, bytesUsed: number, completed: boolean };

			/**
			 * When overridden in a derived class, calculates the number of bytes produced by
			 * encoding a set of characters from the specified character array. A parameter indicates
			 * whether to clear the internal state of the encoder after the calculation.
			 */
			GetByteCount(
				chars: System.Char[],
				index: number,
				count: number,
				flush: boolean,
			): number;

			/**
			 * When overridden in a derived class, calculates the number of bytes produced by
			 * encoding a set of characters in the 'chars' span. A parameter indicates whether to
			 * clear the internal state of the encoder after the calculation.
			 */
			GetByteCount(
				chars: System.ReadOnlySpan$1<System.Char>,
				flush: boolean,
			): number;

			/**
			 * When overridden in a derived class, encodes a set of characters from the specified
			 * character array and any characters in the internal buffer into the specified byte
			 * array. A parameter indicates whether to clear the internal state of the encoder after
			 * the conversion.
			 */
			GetBytes(
				chars: System.Char[],
				charIndex: number,
				charCount: number,
				bytes: number[],
				byteIndex: number,
				flush: boolean,
			): number;

			/**
			 * When overridden in a derived class, encodes a set of characters in the input
			 * characters span and any characters in the internal buffer into a sequence of bytes
			 * that are stored in the input byte span. A parameter indicates whether to clear the
			 * internal state of the encoder after the conversion.
			 */
			GetBytes(
				chars: System.ReadOnlySpan$1<System.Char>,
				bytes: System.Span$1<number>,
				flush: boolean,
			): number;

			/** When overridden in a derived class, sets the encoder back to its initial state. */
			Reset(): void;
		}
	}

	export namespace System.Text {
		/**
		 * Provides a failure-handling mechanism, called a fallback, for an input character that
		 * cannot be converted to an output byte sequence. The fallback throws an exception if an
		 * input character cannot be converted to an output byte sequence. This class cannot be
		 * inherited.
		 */
		export class EncoderExceptionFallback extends System.Text.EncoderFallback {
			/**
			 * Initializes a new instance of the {@link System.Text.EncoderExceptionFallback} class.
			 */
			constructor();

			/** Gets the maximum number of characters this instance can return. */
			readonly MaxCharCount: number;

			/**
			 * Returns an encoder fallback buffer that throws an exception if it cannot convert a
			 * character sequence to a byte sequence.
			 */
			CreateFallbackBuffer(): System.Text.EncoderFallbackBuffer;

			/**
			 * Indicates whether the current {@link System.Text.EncoderExceptionFallback} object and
			 * a specified object are equal.
			 */
			Equals(value: System.Object | undefined): boolean;

			/** Retrieves the hash code for this instance. */
			GetHashCode(): number;
		}
	}

	export namespace System.Text {
		/**
		 * Throws {@link System.Text.EncoderFallbackException} when an input character cannot be
		 * converted to an encoded output byte sequence. This class cannot be inherited.
		 */
		export class EncoderExceptionFallbackBuffer extends System.Text.EncoderFallbackBuffer {
			/**
			 * Initializes a new instance of the {@link System.Text.EncoderExceptionFallbackBuffer}
			 * class.
			 */
			constructor();

			/**
			 * Gets the number of characters in the current
			 * {@link System.Text.EncoderExceptionFallbackBuffer} object that remain to be processed.
			 */
			readonly Remaining: number;

			/**
			 * Throws an exception because the input character cannot be encoded. Parameters specify
			 * the value and index position of the surrogate pair in the input, and the nominal
			 * return value is not used.
			 */
			Fallback(
				charUnknownHigh: System.Char,
				charUnknownLow: System.Char,
				index: number,
			): boolean;

			/**
			 * Throws an exception because the input character cannot be encoded. Parameters specify
			 * the value and index position of the character that cannot be converted.
			 */
			Fallback(
				charUnknown: System.Char,
				index: number,
			): boolean;

			/** Retrieves the next character in the exception fallback buffer. */
			GetNextChar(): System.Char;

			/**
			 * Causes the next call to the
			 * {@link System.Text.EncoderExceptionFallbackBuffer.GetNextChar} method to access the
			 * exception data buffer character position that is prior to the current position.
			 */
			MovePrevious(): boolean;
		}
	}

	export namespace System.Text {
		/**
		 * Provides a failure-handling mechanism, called a fallback, for an input character that
		 * cannot be converted to an encoded output byte sequence.
		 */
		export class EncoderFallback {
			/** Gets an object that throws an exception when an input character cannot be encoded. */
			static readonly ExceptionFallback: System.Text.EncoderFallback;

			/**
			 * When overridden in a derived class, gets the maximum number of characters the current
			 * {@link System.Text.EncoderFallback} object can return.
			 */
			readonly MaxCharCount: number;

			/**
			 * Gets an object that outputs a substitute string in place of an input character that
			 * cannot be encoded.
			 */
			static readonly ReplacementFallback: System.Text.EncoderFallback;

			/**
			 * When overridden in a derived class, initializes a new instance of the
			 * {@link System.Text.EncoderFallbackBuffer} class.
			 */
			CreateFallbackBuffer(): System.Text.EncoderFallbackBuffer;
		}
	}

	export namespace System.Text {
		/**
		 * Provides a buffer that allows a fallback handler to return an alternate string to an
		 * encoder when it cannot encode an input character.
		 */
		export class EncoderFallbackBuffer {
			/**
			 * When overridden in a derived class, gets the number of characters in the current
			 * {@link System.Text.EncoderFallbackBuffer} object that remain to be processed.
			 */
			readonly Remaining: number;

			/**
			 * When overridden in a derived class, prepares the fallback buffer to handle the
			 * specified surrogate pair.
			 */
			Fallback(
				charUnknownHigh: System.Char,
				charUnknownLow: System.Char,
				index: number,
			): boolean;

			/**
			 * When overridden in a derived class, prepares the fallback buffer to handle the
			 * specified input character.
			 */
			Fallback(
				charUnknown: System.Char,
				index: number,
			): boolean;

			/**
			 * When overridden in a derived class, retrieves the next character in the fallback
			 * buffer.
			 */
			GetNextChar(): System.Char;

			/**
			 * When overridden in a derived class, causes the next call to the
			 * {@link System.Text.EncoderFallbackBuffer.GetNextChar} method to access the data buffer
			 * character position that is prior to the current character position.
			 */
			MovePrevious(): boolean;

			/** Initializes all data and state information pertaining to this fallback buffer. */
			Reset(): void;
		}
	}

	export namespace System.Text {
		/**
		 * The exception that is thrown when an encoder fallback operation fails. This class
		 * cannot be inherited.
		 */
		export class EncoderFallbackException extends System.ArgumentException {
			/**
			 * Initializes a new instance of the {@link System.Text.EncoderFallbackException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Text.EncoderFallbackException} class.
			 * A parameter specifies the error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.Text.EncoderFallbackException} class.
			 * Parameters specify the error message and the inner exception that is the cause of this
			 * exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/** Gets the input character that caused the exception. */
			readonly CharUnknown: System.Char;

			/** Gets the high component character of the surrogate pair that caused the exception. */
			readonly CharUnknownHigh: System.Char;

			/** Gets the low component character of the surrogate pair that caused the exception. */
			readonly CharUnknownLow: System.Char;

			/**
			 * Gets the index position in the input buffer of the character that caused the
			 * exception.
			 */
			readonly Index: number;

			/** Indicates whether the input that caused the exception is a surrogate pair. */
			IsUnknownSurrogate(): boolean;
		}
	}

	export namespace System.Text {
		/**
		 * Provides a failure handling mechanism, called a fallback, for an input character that
		 * cannot be converted to an output byte sequence. The fallback uses a user-specified
		 * replacement string instead of the original input character. This class cannot be
		 * inherited.
		 */
		export class EncoderReplacementFallback extends System.Text.EncoderFallback {
			/**
			 * Initializes a new instance of the {@link System.Text.EncoderReplacementFallback}
			 * class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Text.EncoderReplacementFallback} class
			 * using a specified replacement string.
			 */
			constructor(replacement: string);

			/**
			 * Gets the replacement string that is the value of the
			 * {@link System.Text.EncoderReplacementFallback} object.
			 */
			readonly DefaultString: string;

			/**
			 * Gets the number of characters in the replacement string for the
			 * {@link System.Text.EncoderReplacementFallback} object.
			 */
			readonly MaxCharCount: number;

			/**
			 * Creates a {@link System.Text.EncoderFallbackBuffer} object that is initialized with
			 * the replacement string of this {@link System.Text.EncoderReplacementFallback} object.
			 */
			CreateFallbackBuffer(): System.Text.EncoderFallbackBuffer;

			/**
			 * Indicates whether the value of a specified object is equal to the
			 * {@link System.Text.EncoderReplacementFallback} object.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Retrieves the hash code for the value of the
			 * {@link System.Text.EncoderReplacementFallback} object.
			 */
			GetHashCode(): number;
		}
	}

	export namespace System.Text {
		/**
		 * Represents a substitute input string that is used when the original input character
		 * cannot be encoded. This class cannot be inherited.
		 */
		export class EncoderReplacementFallbackBuffer extends System.Text.EncoderFallbackBuffer {
			/**
			 * Initializes a new instance of the {@link System.Text.EncoderReplacementFallbackBuffer}
			 * class using the value of a {@link System.Text.EncoderReplacementFallback} object.
			 */
			constructor(fallback: System.Text.EncoderReplacementFallback);

			/**
			 * Gets the number of characters in the replacement fallback buffer that remain to be
			 * processed.
			 */
			readonly Remaining: number;

			/**
			 * Indicates whether a replacement string can be used when an input surrogate pair cannot
			 * be encoded, or whether the surrogate pair can be ignored. Parameters specify the
			 * surrogate pair and the index position of the pair in the input.
			 */
			Fallback(
				charUnknownHigh: System.Char,
				charUnknownLow: System.Char,
				index: number,
			): boolean;

			/** Prepares the replacement fallback buffer to use the current replacement string. */
			Fallback(
				charUnknown: System.Char,
				index: number,
			): boolean;

			/** Retrieves the next character in the replacement fallback buffer. */
			GetNextChar(): System.Char;

			/**
			 * Causes the next call to the
			 * {@link System.Text.EncoderReplacementFallbackBuffer.GetNextChar} method to access the
			 * character position in the replacement fallback buffer prior to the current character
			 * position.
			 */
			MovePrevious(): boolean;

			/**
			 * Initializes all internal state information and data in this instance of
			 * {@link System.Text.EncoderReplacementFallbackBuffer}.
			 */
			Reset(): void;
		}
	}

	export namespace System.Text {
		/** Represents a character encoding. */
		export class Encoding implements System.ICloneable {
			/** Gets an encoding for the ASCII (7-bit) character set. */
			static readonly ASCII: System.Text.Encoding;

			/** Gets an encoding for the UTF-16 format that uses the big endian byte order. */
			static readonly BigEndianUnicode: System.Text.Encoding;

			/**
			 * When overridden in a derived class, gets a name for the current encoding that can be
			 * used with mail agent body tags.
			 */
			readonly BodyName: string;

			/**
			 * When overridden in a derived class, gets the code page identifier of the current
			 * {@link System.Text.Encoding}.
			 */
			readonly CodePage: number;

			/**
			 * Gets or sets the {@link System.Text.DecoderFallback} object for the current
			 * {@link System.Text.Encoding} object.
			 */
			DecoderFallback: System.Text.DecoderFallback;

			/** Gets the default encoding for this .NET implementation. */
			static readonly Default: System.Text.Encoding;

			/**
			 * Gets or sets the {@link System.Text.EncoderFallback} object for the current
			 * {@link System.Text.Encoding} object.
			 */
			EncoderFallback: System.Text.EncoderFallback;

			/**
			 * When overridden in a derived class, gets the human-readable description of the current
			 * encoding.
			 */
			readonly EncodingName: string;

			/**
			 * When overridden in a derived class, gets a name for the current encoding that can be
			 * used with mail agent header tags.
			 */
			readonly HeaderName: string;

			/**
			 * When overridden in a derived class, gets a value indicating whether the current
			 * encoding can be used by browser clients for displaying content.
			 */
			readonly IsBrowserDisplay: boolean;

			/**
			 * When overridden in a derived class, gets a value indicating whether the current
			 * encoding can be used by browser clients for saving content.
			 */
			readonly IsBrowserSave: boolean;

			/**
			 * When overridden in a derived class, gets a value indicating whether the current
			 * encoding can be used by mail and news clients for displaying content.
			 */
			readonly IsMailNewsDisplay: boolean;

			/**
			 * When overridden in a derived class, gets a value indicating whether the current
			 * encoding can be used by mail and news clients for saving content.
			 */
			readonly IsMailNewsSave: boolean;

			/**
			 * When overridden in a derived class, gets a value indicating whether the current
			 * encoding is read-only.
			 */
			readonly IsReadOnly: boolean;

			/**
			 * When overridden in a derived class, gets a value indicating whether the current
			 * encoding uses single-byte code points.
			 */
			readonly IsSingleByte: boolean;

			/** Gets an encoding for the Latin1 character set (ISO-8859-1). */
			static readonly Latin1: System.Text.Encoding;

			/**
			 * When overridden in a derived class, returns a span containing the sequence of bytes
			 * that specifies the encoding used.
			 */
			readonly Preamble: System.ReadOnlySpan$1<number>;

			/** Gets an encoding for the UTF-16 format using the little endian byte order. */
			static readonly Unicode: System.Text.Encoding;

			/** Gets an encoding for the UTF-32 format using the little endian byte order. */
			static readonly UTF32: System.Text.Encoding;

			/** Gets an encoding for the UTF-7 format. */
			static readonly UTF7: System.Text.Encoding;

			/** Gets an encoding for the UTF-8 format. */
			static readonly UTF8: System.Text.Encoding;

			/**
			 * When overridden in a derived class, gets the name registered with the Internet
			 * Assigned Numbers Authority (IANA) for the current encoding.
			 */
			readonly WebName: string;

			/**
			 * When overridden in a derived class, gets the Windows operating system code page that
			 * most closely corresponds to the current encoding.
			 */
			readonly WindowsCodePage: number;

			/**
			 * When overridden in a derived class, creates a shallow copy of the current
			 * {@link System.Text.Encoding} object.
			 */
			Clone(): System.Object;

			/** Converts an entire byte array from one encoding to another. */
			static Convert(
				srcEncoding: System.Text.Encoding,
				dstEncoding: System.Text.Encoding,
				bytes: number[],
			): number[];

			/** Converts a range of bytes in a byte array from one encoding to another. */
			static Convert(
				srcEncoding: System.Text.Encoding,
				dstEncoding: System.Text.Encoding,
				bytes: number[],
				index: number,
				count: number,
			): number[];

			/**
			 * Creates a {@link System.IO.Stream} that serves to transcode data between an inner
			 * {@link System.Text.Encoding} and an outer {@link System.Text.Encoding}, similar to
			 * {@link System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])}.
			 */
			static CreateTranscodingStream(
				innerStream: Duplex,
				innerStreamEncoding: System.Text.Encoding,
				outerStreamEncoding: System.Text.Encoding,
				leaveOpen?: boolean,
			): Duplex;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * instance.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * When overridden in a derived class, calculates the number of bytes produced by
			 * encoding all the characters in the specified character array.
			 */
			GetByteCount(chars: System.Char[]): number;

			/**
			 * When overridden in a derived class, calculates the number of bytes produced by
			 * encoding a set of characters from the specified character array.
			 */
			GetByteCount(
				chars: System.Char[],
				index: number,
				count: number,
			): number;

			/**
			 * When overridden in a derived class, calculates the number of bytes produced by
			 * encoding the characters in the specified character span.
			 */
			GetByteCount(chars: System.ReadOnlySpan$1<System.Char>): number;

			/**
			 * When overridden in a derived class, calculates the number of bytes produced by
			 * encoding the characters in the specified string.
			 */
			GetByteCount(s: string): number;

			/**
			 * When overridden in a derived class, calculates the number of bytes produced by
			 * encoding a set of characters from the specified string.
			 */
			GetByteCount(
				s: string,
				index: number,
				count: number,
			): number;

			/**
			 * When overridden in a derived class, encodes all the characters in the specified
			 * character array into a sequence of bytes.
			 */
			GetBytes(chars: System.Char[]): number[];

			/**
			 * When overridden in a derived class, encodes a set of characters from the specified
			 * character array into a sequence of bytes.
			 */
			GetBytes(
				chars: System.Char[],
				index: number,
				count: number,
			): number[];

			/**
			 * When overridden in a derived class, encodes a set of characters from the specified
			 * character array into the specified byte array.
			 */
			GetBytes(
				chars: System.Char[],
				charIndex: number,
				charCount: number,
				bytes: number[],
				byteIndex: number,
			): number;

			/**
			 * When overridden in a derived class, encodes into a span of bytes a set of characters
			 * from the specified read-only span.
			 */
			GetBytes(
				chars: System.ReadOnlySpan$1<System.Char>,
				bytes: System.Span$1<number>,
			): number;

			/**
			 * When overridden in a derived class, encodes all the characters in the specified string
			 * into a sequence of bytes.
			 */
			GetBytes(s: string): number[];

			/**
			 * When overridden in a derived class, encodes into an array of bytes the number of
			 * characters specified by `count` in the specified string, starting from the specified
			 * `index`.
			 */
			GetBytes(
				s: string,
				index: number,
				count: number,
			): number[];

			/**
			 * When overridden in a derived class, encodes a set of characters from the specified
			 * string into the specified byte array.
			 */
			GetBytes(
				s: string,
				charIndex: number,
				charCount: number,
				bytes: number[],
				byteIndex: number,
			): number;

			/**
			 * When overridden in a derived class, calculates the number of characters produced by
			 * decoding all the bytes in the specified byte array.
			 */
			GetCharCount(bytes: number[]): number;

			/**
			 * When overridden in a derived class, calculates the number of characters produced by
			 * decoding a sequence of bytes from the specified byte array.
			 */
			GetCharCount(
				bytes: number[],
				index: number,
				count: number,
			): number;

			/**
			 * When overridden in a derived class, calculates the number of characters produced by
			 * decoding the provided read-only byte span.
			 */
			GetCharCount(bytes: System.ReadOnlySpan$1<number>): number;

			/**
			 * When overridden in a derived class, decodes all the bytes in the specified byte array
			 * into a set of characters.
			 */
			GetChars(bytes: number[]): System.Char[];

			/**
			 * When overridden in a derived class, decodes a sequence of bytes from the specified
			 * byte array into a set of characters.
			 */
			GetChars(
				bytes: number[],
				index: number,
				count: number,
			): System.Char[];

			/**
			 * When overridden in a derived class, decodes a sequence of bytes from the specified
			 * byte array into the specified character array.
			 */
			GetChars(
				bytes: number[],
				byteIndex: number,
				byteCount: number,
				chars: System.Char[],
				charIndex: number,
			): number;

			/**
			 * When overridden in a derived class, decodes all the bytes in the specified read-only
			 * byte span into a character span.
			 */
			GetChars(
				bytes: System.ReadOnlySpan$1<number>,
				chars: System.Span$1<System.Char>,
			): number;

			/**
			 * When overridden in a derived class, obtains a decoder that converts an encoded
			 * sequence of bytes into a sequence of characters.
			 */
			GetDecoder(): System.Text.Decoder;

			/**
			 * When overridden in a derived class, obtains an encoder that converts a sequence of
			 * Unicode characters into an encoded sequence of bytes.
			 */
			GetEncoder(): System.Text.Encoder;

			/** Returns the encoding associated with the specified code page identifier. */
			static GetEncoding(codepage: number): System.Text.Encoding;

			/**
			 * Returns the encoding associated with the specified code page identifier. Parameters
			 * specify an error handler for characters that cannot be encoded and byte sequences that
			 * cannot be decoded.
			 */
			static GetEncoding(
				codepage: number,
				encoderFallback: System.Text.EncoderFallback,
				decoderFallback: System.Text.DecoderFallback,
			): System.Text.Encoding;

			/** Returns the encoding associated with the specified code page name. */
			static GetEncoding(name: string): System.Text.Encoding;

			/**
			 * Returns the encoding associated with the specified code page name. Parameters specify
			 * an error handler for characters that cannot be encoded and byte sequences that cannot
			 * be decoded.
			 */
			static GetEncoding(
				name: string,
				encoderFallback: System.Text.EncoderFallback,
				decoderFallback: System.Text.DecoderFallback,
			): System.Text.Encoding;

			/** Returns an array that contains all encodings. */
			static GetEncodings(): System.Text.EncodingInfo[];

			/** Returns the hash code for the current instance. */
			GetHashCode(): number;

			/**
			 * When overridden in a derived class, calculates the maximum number of bytes produced by
			 * encoding the specified number of characters.
			 */
			GetMaxByteCount(charCount: number): number;

			/**
			 * When overridden in a derived class, calculates the maximum number of characters
			 * produced by decoding the specified number of bytes.
			 */
			GetMaxCharCount(byteCount: number): number;

			/**
			 * When overridden in a derived class, returns a sequence of bytes that specifies the
			 * encoding used.
			 */
			GetPreamble(): number[];

			/**
			 * When overridden in a derived class, decodes all the bytes in the specified byte array
			 * into a string.
			 */
			GetString(bytes: number[]): string;

			/**
			 * When overridden in a derived class, decodes a sequence of bytes from the specified
			 * byte array into a string.
			 */
			GetString(
				bytes: number[],
				index: number,
				count: number,
			): string;

			/**
			 * When overridden in a derived class, decodes all the bytes in the specified byte span
			 * into a string.
			 */
			GetString(bytes: System.ReadOnlySpan$1<number>): string;

			/**
			 * Gets a value indicating whether the current encoding is always normalized, using the
			 * default normalization form.
			 */
			IsAlwaysNormalized(): boolean;

			/**
			 * When overridden in a derived class, gets a value indicating whether the current
			 * encoding is always normalized, using the specified normalization form.
			 */
			IsAlwaysNormalized(form: System.Text.NormalizationForm): boolean;

			/** Registers an encoding provider. */
			static RegisterProvider(provider: System.Text.EncodingProvider): void;

			TryGetBytes(
				chars: System.ReadOnlySpan$1<System.Char>,
				bytes: System.Span$1<number>,
			): number | undefined;

			TryGetChars(
				bytes: System.ReadOnlySpan$1<number>,
				chars: System.Span$1<System.Char>,
			): number | undefined;
		}
	}

	export namespace System.Text {
		/** Provides basic information about an encoding. */
		export class EncodingInfo {
			/** Constructs an {@link System.Text.EncodingInfo} object. */
			constructor(
				provider: System.Text.EncodingProvider,
				codePage: number,
				name: string,
				displayName: string,
			);

			/** Gets the code page identifier of the encoding. */
			readonly CodePage: number;

			/** Gets the human-readable description of the encoding. */
			readonly DisplayName: string;

			/**
			 * Gets the name registered with the Internet Assigned Numbers Authority (IANA) for the
			 * encoding.
			 */
			readonly Name: string;

			/**
			 * Gets a value indicating whether the specified object is equal to the current
			 * {@link System.Text.EncodingInfo} object.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Returns a {@link System.Text.Encoding} object that corresponds to the current
			 * {@link System.Text.EncodingInfo} object.
			 */
			GetEncoding(): System.Text.Encoding;

			/** Returns the hash code for the current {@link System.Text.EncodingInfo} object. */
			GetHashCode(): number;
		}
	}

	export namespace System.Text {
		/**
		 * Provides the base class for an encoding provider, which supplies encodings that are
		 * unavailable on a particular platform.
		 */
		export class EncodingProvider {
			/** Initializes a new instance of the {@link System.Text.EncodingProvider} class. */
			constructor();

			/** Returns the encoding associated with the specified code page identifier. */
			GetEncoding(codepage: number): System.Text.Encoding | undefined;

			/**
			 * Returns the encoding associated with the specified code page identifier. Parameters
			 * specify an error handler for characters that cannot be encoded and byte sequences that
			 * cannot be decoded.
			 */
			GetEncoding(
				codepage: number,
				encoderFallback: System.Text.EncoderFallback,
				decoderFallback: System.Text.DecoderFallback,
			): System.Text.Encoding | undefined;

			/** Returns the encoding with the specified name. */
			GetEncoding(name: string): System.Text.Encoding | undefined;

			/**
			 * Returns the encoding associated with the specified name. Parameters specify an error
			 * handler for characters that cannot be encoded and byte sequences that cannot be
			 * decoded.
			 */
			GetEncoding(
				name: string,
				encoderFallback: System.Text.EncoderFallback,
				decoderFallback: System.Text.DecoderFallback,
			): System.Text.Encoding | undefined;

			/**
			 * Returns an array that contains all the encodings that are supported by the
			 * {@link System.Text.EncodingProvider}.
			 */
			GetEncodings(): Iterable<System.Text.EncodingInfo>;
		}
	}

	export namespace System.Text {
		/** Defines the type of normalization to perform. */
		export enum NormalizationForm {
			/**
			 * Indicates that a Unicode string is normalized using full canonical decomposition,
			 * followed by the replacement of sequences with their primary composites, if possible.
			 */
			FormC = 1,

			/** Indicates that a Unicode string is normalized using full canonical decomposition. */
			FormD = 2,

			/**
			 * Indicates that a Unicode string is normalized using full compatibility decomposition,
			 * followed by the replacement of sequences with their primary composites, if possible.
			 */
			FormKC = 5,

			/**
			 * Indicates that a Unicode string is normalized using full compatibility decomposition.
			 */
			FormKD = 6,
		}
	}

	export namespace System.Text {
		/**
		 * Represents a Unicode scalar value ([ U+0000..U+D7FF ], inclusive; or [
		 * U+E000..U+10FFFF ], inclusive).
		 */
		export class Rune extends System.ValueType implements
			System.IComparable$1<System.Text.Rune>,
			System.IEquatable$1<System.Text.Rune> {
			/** Creates a {@link System.Text.Rune} from the provided UTF-16 code unit. */
			constructor(ch: System.Char);

			/** Creates a {@link System.Text.Rune} from the provided UTF-16 surrogate pair. */
			constructor(
				highSurrogate: System.Char,
				lowSurrogate: System.Char,
			);

			/**
			 * Creates a {@link System.Text.Rune} from the specified 32-bit integer that represents a
			 * Unicode scalar value.
			 */
			constructor(value: number);

			/**
			 * Creates a {@link System.Text.Rune} from the specified 32-bit unsigned integer that
			 * represents a Unicode scalar value.
			 */
			constructor(value: number);

			/**
			 * Gets a value that indicates whether the scalar value associated with this
			 * {@link System.Text.Rune} is within the ASCII encoding range.
			 */
			readonly IsAscii: boolean;

			/**
			 * Gets a value that indicates whether the scalar value associated with this
			 * {@link System.Text.Rune} is within the BMP encoding range.
			 */
			readonly IsBmp: boolean;

			/** Gets the Unicode plane (0 to 16, inclusive) that contains this scalar. */
			readonly Plane: number;

			/**
			 * Gets a {@link System.Text.Rune} instance that represents the Unicode replacement
			 * character U+FFFD.
			 */
			static readonly ReplacementChar: System.Text.Rune;

			/**
			 * Gets the length in code units ( {@link System.Char} ) of the UTF-16 sequence required
			 * to represent this scalar value.
			 */
			readonly Utf16SequenceLength: number;

			/**
			 * Gets the length in code units of the UTF-8 sequence required to represent this scalar
			 * value.
			 */
			readonly Utf8SequenceLength: number;

			/** Gets the Unicode scalar value as an integer. */
			readonly Value: number;

			/** Compares the current instance to the specified {@link System.Text.Rune} instance. */
			CompareTo(other: System.Text.Rune): number;

			static DecodeFromUtf16(source: System.ReadOnlySpan$1<System.Char>): { _result: System.Buffers.OperationStatus, result: System.Text.Rune, charsConsumed: number };

			static DecodeFromUtf8(source: System.ReadOnlySpan$1<number>): { _result: System.Buffers.OperationStatus, result: System.Text.Rune, bytesConsumed: number };

			static DecodeLastFromUtf16(source: System.ReadOnlySpan$1<System.Char>): { _result: System.Buffers.OperationStatus, result: System.Text.Rune, charsConsumed: number };

			static DecodeLastFromUtf8(source: System.ReadOnlySpan$1<number>): { result: System.Buffers.OperationStatus, value: System.Text.Rune, bytesConsumed: number };

			/** Encodes this {@link System.Text.Rune} to a UTF-16 destination buffer. */
			EncodeToUtf16(destination: System.Span$1<System.Char>): number;

			/** Encodes this {@link System.Text.Rune} to a UTF-8 destination buffer. */
			EncodeToUtf8(destination: System.Span$1<number>): number;

			/**
			 * Returns a value that indicates whether the current instance and a specified object are
			 * equal.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether the current instance and a specified rune are
			 * equal.
			 */
			Equals(other: System.Text.Rune): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Gets the numeric value associated with the specified rune. */
			static GetNumericValue(value: System.Text.Rune): number;

			/** Gets the {@link System.Text.Rune} that begins at a specified position in a string. */
			static GetRuneAt(
				input: string,
				index: number,
			): System.Text.Rune;

			/** Gets the Unicode category associated with the specified rune. */
			static GetUnicodeCategory(value: System.Text.Rune): System.Globalization.UnicodeCategory;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as a control
			 * character.
			 */
			static IsControl(value: System.Text.Rune): boolean;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as a decimal
			 * digit.
			 */
			static IsDigit(value: System.Text.Rune): boolean;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as a letter.
			 */
			static IsLetter(value: System.Text.Rune): boolean;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as a letter
			 * or a decimal digit.
			 */
			static IsLetterOrDigit(value: System.Text.Rune): boolean;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as a
			 * lowercase letter.
			 */
			static IsLower(value: System.Text.Rune): boolean;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as a number.
			 */
			static IsNumber(value: System.Text.Rune): boolean;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as a
			 * punctuation mark.
			 */
			static IsPunctuation(value: System.Text.Rune): boolean;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as a
			 * separator character.
			 */
			static IsSeparator(value: System.Text.Rune): boolean;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as a symbol
			 * character.
			 */
			static IsSymbol(value: System.Text.Rune): boolean;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as an
			 * uppercase letter.
			 */
			static IsUpper(value: System.Text.Rune): boolean;

			/**
			 * Returns a value that indicates whether a 32-bit signed integer represents a valid
			 * Unicode scalar value; that is, it is in the range [ U+0000..U+D7FF ], inclusive; or [
			 * U+E000..U+10FFFF ], inclusive.
			 */
			static IsValid(value: number): boolean;

			/**
			 * Returns a value that indicates whether a 32-bit unsigned integer represents a valid
			 * Unicode scalar value; that is, it is in the range [ U+0000..U+D7FF ], inclusive, or [
			 * U+E000..U+10FFFF ], inclusive.
			 */
			static IsValid(value: number): boolean;

			/**
			 * Returns a value that indicates whether the specified rune is categorized as a white
			 * space character.
			 */
			static IsWhiteSpace(value: System.Text.Rune): boolean;

			/**
			 * Returns a copy of the specified {@link System.Text.Rune} converted to lowercase, using
			 * the casing rules of the specified culture.
			 */
			static ToLower(
				value: System.Text.Rune,
				culture: System.Globalization.CultureInfo,
			): System.Text.Rune;

			/**
			 * Returns a copy of the specified {@link System.Text.Rune} converted to lowercase using
			 * the casing rules of the invariant culture.
			 */
			static ToLowerInvariant(value: System.Text.Rune): System.Text.Rune;

			/** Returns the string representation of this {@link System.Text.Rune} instance. */
			ToString(): string;

			/**
			 * Returns a copy of the specified {@link System.Text.Rune} converted to uppercase, using
			 * the casing rules of the specified culture.
			 */
			static ToUpper(
				value: System.Text.Rune,
				culture: System.Globalization.CultureInfo,
			): System.Text.Rune;

			/**
			 * Returns a copy of the specified {@link System.Text.Rune} converted to uppercase using
			 * the casing rules of the invariant culture.
			 */
			static ToUpperInvariant(value: System.Text.Rune): System.Text.Rune;

			static TryCreate(
				highSurrogate: System.Char,
				lowSurrogate: System.Char,
			): System.Text.Rune | undefined;

			static TryCreate(ch: System.Char): System.Text.Rune | undefined;

			static TryCreate(value: number): System.Text.Rune | undefined;

			static TryCreate(value: number): System.Text.Rune | undefined;

			TryEncodeToUtf16(destination: System.Span$1<System.Char>): number | undefined;

			TryEncodeToUtf8(destination: System.Span$1<number>): number | undefined;

			static TryGetRuneAt(
				input: string,
				index: number,
			): System.Text.Rune | undefined;
		}
	}

	export namespace System.Text {
		/** Represents a mutable string of characters. This class cannot be inherited. */
		export class StringBuilder {
			/** Initializes a new instance of the {@link System.Text.StringBuilder} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Text.StringBuilder} class using the
			 * specified capacity.
			 */
			constructor(capacity: number);

			/**
			 * Initializes a new instance of the {@link System.Text.StringBuilder} class that starts
			 * with a specified capacity and can grow to a specified maximum.
			 */
			constructor(
				capacity: number,
				maxCapacity: number,
			);

			/**
			 * Initializes a new instance of the {@link System.Text.StringBuilder} class using the
			 * specified string.
			 */
			constructor(value: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.Text.StringBuilder} class using the
			 * specified string and capacity.
			 */
			constructor(
				value: string | undefined,
				capacity: number,
			);

			/**
			 * Initializes a new instance of the {@link System.Text.StringBuilder} class from the
			 * specified substring and capacity.
			 */
			constructor(
				value: string | undefined,
				startIndex: number,
				length: number,
				capacity: number,
			);

			/**
			 * Gets or sets the maximum number of characters that can be contained in the memory
			 * allocated by the current instance.
			 */
			Capacity: number;

			/** Gets or sets the length of the current {@link System.Text.StringBuilder} object. */
			Length: number;

			/** Gets the maximum capacity of this instance. */
			readonly MaxCapacity: number;

			/** Appends the string representation of a specified Boolean value to this instance. */
			Append(value: boolean): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified 8-bit unsigned integer to this
			 * instance.
			 */
			Append(value: number): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified {@link System.Char} object to this
			 * instance.
			 */
			Append(value: System.Char): System.Text.StringBuilder;

			/**
			 * Appends a specified number of copies of the string representation of a Unicode
			 * character to this instance.
			 */
			Append(
				value: System.Char,
				repeatCount: number,
			): System.Text.StringBuilder;

			/**
			 * Appends the string representation of the Unicode characters in a specified array to
			 * this instance.
			 */
			Append(value: System.Char[] | undefined): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified subarray of Unicode characters to
			 * this instance.
			 */
			Append(
				value: System.Char[] | undefined,
				startIndex: number,
				charCount: number,
			): System.Text.StringBuilder;

			/** Appends the string representation of a specified decimal number to this instance. */
			Append(value: System.Decimal): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified double-precision floating-point
			 * number to this instance.
			 */
			Append(value: number): System.Text.StringBuilder;

			Append(
				provider: System.IFormatProvider | undefined,
				handler: System.Text.StringBuilder.AppendInterpolatedStringHandler,
			): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified 16-bit signed integer to this
			 * instance.
			 */
			Append(value: number): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified 32-bit signed integer to this
			 * instance.
			 */
			Append(value: number): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified 64-bit signed integer to this
			 * instance.
			 */
			Append(value: number): System.Text.StringBuilder;

			/** Appends the string representation of a specified object to this instance. */
			Append(value: System.Object | undefined): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified read-only character memory region to
			 * this instance.
			 */
			Append(value: unknown): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified read-only character span to this
			 * instance.
			 */
			Append(value: System.ReadOnlySpan$1<System.Char>): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified 8-bit signed integer to this
			 * instance.
			 */
			Append(value: number): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified single-precision floating-point
			 * number to this instance.
			 */
			Append(value: number): System.Text.StringBuilder;

			/** Appends a copy of the specified string to this instance. */
			Append(value: string | undefined): System.Text.StringBuilder;

			/** Appends a copy of a specified substring to this instance. */
			Append(
				value: string | undefined,
				startIndex: number,
				count: number,
			): System.Text.StringBuilder;

			/** Appends the string representation of a specified string builder to this instance. */
			Append(value: System.Text.StringBuilder | undefined): System.Text.StringBuilder;

			/** Appends a copy of a substring within a specified string builder to this instance. */
			Append(
				value: System.Text.StringBuilder | undefined,
				startIndex: number,
				count: number,
			): System.Text.StringBuilder;

			Append(handler: System.Text.StringBuilder.AppendInterpolatedStringHandler): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified 16-bit unsigned integer to this
			 * instance.
			 */
			Append(value: number): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified 32-bit unsigned integer to this
			 * instance.
			 */
			Append(value: number): System.Text.StringBuilder;

			/**
			 * Appends the string representation of a specified 64-bit unsigned integer to this
			 * instance.
			 */
			Append(value: number): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of a single argument using a specified format provider.
			 */
			AppendFormat(
				provider: System.IFormatProvider | undefined,
				format: string,
				arg0: System.Object | undefined,
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of either of two arguments using a specified format provider.
			 */
			AppendFormat(
				provider: System.IFormatProvider | undefined,
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of either of three arguments using a specified format provider.
			 */
			AppendFormat(
				provider: System.IFormatProvider | undefined,
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of a corresponding argument in a parameter array using a
			 * specified format provider.
			 */
			AppendFormat(
				provider: System.IFormatProvider | undefined,
				format: string,
				args: System.Object | undefined[],
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of a single argument.
			 */
			AppendFormat(
				format: string,
				arg0: System.Object | undefined,
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of either of two arguments.
			 */
			AppendFormat(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of either of three arguments.
			 */
			AppendFormat(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of a corresponding argument in a parameter array.
			 */
			AppendFormat(
				format: string,
				args: System.Object | undefined[],
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of any of the arguments using a specified format provider.
			 */
			AppendFormat<TArg0>(
				provider: System.IFormatProvider | undefined,
				format: System.Text.CompositeFormat,
				arg0: TArg0,
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of any of the arguments using a specified format provider.
			 */
			AppendFormat<TArg0, TArg1>(
				provider: System.IFormatProvider | undefined,
				format: System.Text.CompositeFormat,
				arg0: TArg0,
				arg1: TArg1,
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of any of the arguments using a specified format provider.
			 */
			AppendFormat<TArg0, TArg1, TArg2>(
				provider: System.IFormatProvider | undefined,
				format: System.Text.CompositeFormat,
				arg0: TArg0,
				arg1: TArg1,
				arg2: TArg2,
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of any of the arguments using a specified format provider.
			 */
			AppendFormat(
				provider: System.IFormatProvider | undefined,
				format: System.Text.CompositeFormat,
				args: System.Object | undefined[],
			): System.Text.StringBuilder;

			/**
			 * Appends the string returned by processing a composite format string, which contains
			 * zero or more format items, to this instance. Each format item is replaced by the
			 * string representation of any of the arguments using a specified format provider.
			 */
			AppendFormat(
				provider: System.IFormatProvider | undefined,
				format: System.Text.CompositeFormat,
				args: System.ReadOnlySpan$1<System.Object | undefined>,
			): System.Text.StringBuilder;

			/**
			 * Concatenates the string representations of the elements in the provided array of
			 * objects, using the specified char separator between each member, then appends the
			 * result to the current instance of the string builder.
			 */
			AppendJoin(
				separator: System.Char,
				values: System.Object | undefined[],
			): System.Text.StringBuilder;

			/**
			 * Concatenates the strings of the provided array, using the specified char separator
			 * between each string, then appends the result to the current instance of the string
			 * builder.
			 */
			AppendJoin(
				separator: System.Char,
				values: string | undefined[],
			): System.Text.StringBuilder;

			/**
			 * Concatenates the string representations of the elements in the provided array of
			 * objects, using the specified separator between each member, then appends the result to
			 * the current instance of the string builder.
			 */
			AppendJoin(
				separator: string | undefined,
				values: System.Object | undefined[],
			): System.Text.StringBuilder;

			/**
			 * Concatenates the strings of the provided array, using the specified separator between
			 * each string, then appends the result to the current instance of the string builder.
			 */
			AppendJoin(
				separator: string | undefined,
				values: string | undefined[],
			): System.Text.StringBuilder;

			/**
			 * Concatenates and appends the members of a collection, using the specified char
			 * separator between each member.
			 */
			AppendJoin<T>(
				separator: System.Char,
				values: Iterable<T>,
			): System.Text.StringBuilder;

			/**
			 * Concatenates and appends the members of a collection, using the specified separator
			 * between each member.
			 */
			AppendJoin<T>(
				separator: string | undefined,
				values: Iterable<T>,
			): System.Text.StringBuilder;

			/**
			 * Appends the default line terminator to the end of the current
			 * {@link System.Text.StringBuilder} object.
			 */
			AppendLine(): System.Text.StringBuilder;

			AppendLine(
				provider: System.IFormatProvider | undefined,
				handler: System.Text.StringBuilder.AppendInterpolatedStringHandler,
			): System.Text.StringBuilder;

			/**
			 * Appends a copy of the specified string followed by the default line terminator to the
			 * end of the current {@link System.Text.StringBuilder} object.
			 */
			AppendLine(value: string | undefined): System.Text.StringBuilder;

			AppendLine(handler: System.Text.StringBuilder.AppendInterpolatedStringHandler): System.Text.StringBuilder;

			/**
			 * Removes all characters from the current {@link System.Text.StringBuilder} instance.
			 */
			Clear(): System.Text.StringBuilder;

			/**
			 * Copies the characters from a specified segment of this instance to a specified segment
			 * of a destination {@link System.Char} array.
			 */
			CopyTo(
				sourceIndex: number,
				destination: System.Char[],
				destinationIndex: number,
				count: number,
			): void;

			/**
			 * Copies the characters from a specified segment of this instance to a destination
			 * {@link System.Char} span.
			 */
			CopyTo(
				sourceIndex: number,
				destination: System.Span$1<System.Char>,
				count: number,
			): void;

			/**
			 * Ensures that the capacity of this instance of {@link System.Text.StringBuilder} is at
			 * least the specified value.
			 */
			EnsureCapacity(capacity: number): number;

			/**
			 * Returns a value indicating whether the characters in this instance are equal to the
			 * characters in a specified read-only character span.
			 */
			Equals(span: System.ReadOnlySpan$1<System.Char>): boolean;

			/** Returns a value indicating whether this instance is equal to a specified object. */
			Equals(sb: System.Text.StringBuilder | undefined): boolean;

			/**
			 * Returns an object that can be used to iterate through the chunks of characters
			 * represented in a `ReadOnlyMemory<Char>` created from this
			 * {@link System.Text.StringBuilder} instance.
			 */
			GetChunks(): System.Text.StringBuilder.ChunkEnumerator;

			/**
			 * Inserts the string representation of a Boolean value into this instance at the
			 * specified character position.
			 */
			Insert(
				index: number,
				value: boolean,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a specified 8-bit unsigned integer into this
			 * instance at the specified character position.
			 */
			Insert(
				index: number,
				value: number,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a specified Unicode character into this instance
			 * at the specified character position.
			 */
			Insert(
				index: number,
				value: System.Char,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a specified array of Unicode characters into this
			 * instance at the specified character position.
			 */
			Insert(
				index: number,
				value: System.Char[] | undefined,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a specified subarray of Unicode characters into
			 * this instance at the specified character position.
			 */
			Insert(
				index: number,
				value: System.Char[] | undefined,
				startIndex: number,
				charCount: number,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a decimal number into this instance at the
			 * specified character position.
			 */
			Insert(
				index: number,
				value: System.Decimal,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a double-precision floating-point number into
			 * this instance at the specified character position.
			 */
			Insert(
				index: number,
				value: number,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a specified 16-bit signed integer into this
			 * instance at the specified character position.
			 */
			Insert(
				index: number,
				value: number,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a specified 32-bit signed integer into this
			 * instance at the specified character position.
			 */
			Insert(
				index: number,
				value: number,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a 64-bit signed integer into this instance at the
			 * specified character position.
			 */
			Insert(
				index: number,
				value: number,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of an object into this instance at the specified
			 * character position.
			 */
			Insert(
				index: number,
				value: System.Object | undefined,
			): System.Text.StringBuilder;

			/**
			 * Inserts the sequence of characters into this instance at the specified character
			 * position.
			 */
			Insert(
				index: number,
				value: System.ReadOnlySpan$1<System.Char>,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a specified 8-bit signed integer into this
			 * instance at the specified character position.
			 */
			Insert(
				index: number,
				value: number,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a single-precision floating point number into
			 * this instance at the specified character position.
			 */
			Insert(
				index: number,
				value: number,
			): System.Text.StringBuilder;

			/** Inserts a string into this instance at the specified character position. */
			Insert(
				index: number,
				value: string | undefined,
			): System.Text.StringBuilder;

			/**
			 * Inserts one or more copies of a specified string into this instance at the specified
			 * character position.
			 */
			Insert(
				index: number,
				value: string | undefined,
				count: number,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a 16-bit unsigned integer into this instance at
			 * the specified character position.
			 */
			Insert(
				index: number,
				value: number,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a 32-bit unsigned integer into this instance at
			 * the specified character position.
			 */
			Insert(
				index: number,
				value: number,
			): System.Text.StringBuilder;

			/**
			 * Inserts the string representation of a 64-bit unsigned integer into this instance at
			 * the specified character position.
			 */
			Insert(
				index: number,
				value: number,
			): System.Text.StringBuilder;

			/** Removes the specified range of characters from this instance. */
			Remove(
				startIndex: number,
				length: number,
			): System.Text.StringBuilder;

			/**
			 * Replaces all occurrences of a specified character in this instance with another
			 * specified character.
			 */
			Replace(
				oldChar: System.Char,
				newChar: System.Char,
			): System.Text.StringBuilder;

			/**
			 * Replaces, within a substring of this instance, all occurrences of a specified
			 * character with another specified character.
			 */
			Replace(
				oldChar: System.Char,
				newChar: System.Char,
				startIndex: number,
				count: number,
			): System.Text.StringBuilder;

			/**
			 * Replaces all occurrences of a specified string in this instance with another specified
			 * string.
			 */
			Replace(
				oldValue: string,
				newValue: string | undefined,
			): System.Text.StringBuilder;

			/**
			 * Replaces, within a substring of this instance, all occurrences of a specified string
			 * with another specified string.
			 */
			Replace(
				oldValue: string,
				newValue: string | undefined,
				startIndex: number,
				count: number,
			): System.Text.StringBuilder;

			/** Converts the value of this instance to a {@link System.String}. */
			ToString(): string;

			/** Converts the value of a substring of this instance to a {@link System.String}. */
			ToString(
				startIndex: number,
				length: number,
			): string;
		}
	}

	export namespace System.Text.StringBuilder {
		export class AppendInterpolatedStringHandler extends System.ValueType {
			constructor(
				literalLength: number,
				formattedCount: number,
				stringBuilder: System.Text.StringBuilder,
			);

			constructor(
				literalLength: number,
				formattedCount: number,
				stringBuilder: System.Text.StringBuilder,
				provider: System.IFormatProvider | undefined,
			);

			AppendFormatted(
				value: System.Object | undefined,
				alignment?: number,
				format?: string,
			): void;

			AppendFormatted(value: System.ReadOnlySpan$1<System.Char>): void;

			AppendFormatted(
				value: System.ReadOnlySpan$1<System.Char>,
				alignment?: number,
				format?: string,
			): void;

			AppendFormatted(value: string | undefined): void;

			AppendFormatted(
				value: string | undefined,
				alignment?: number,
				format?: string,
			): void;

			AppendFormatted<T>(value: T): void;

			AppendFormatted<T>(
				value: T,
				alignment: number,
			): void;

			AppendFormatted<T>(
				value: T,
				alignment: number,
				format: string | undefined,
			): void;

			AppendFormatted<T>(
				value: T,
				format: string | undefined,
			): void;

			AppendLiteral(value: string): void;
		}
	}

	export namespace System.Text.StringBuilder {
		export class ChunkEnumerator extends System.ValueType {
			readonly Current: unknown;

			GetEnumerator(): System.Text.StringBuilder.ChunkEnumerator;

			MoveNext(): boolean;
		}
	}

	export namespace System.Text {
		/**
		 * Provides an enumerator for the {@link System.Text.Rune} values represented by a
		 * string.
		 */
		export class StringRuneEnumerator extends System.ValueType {
			/** Gets the {@link System.Text.Rune} at the current position of the enumerator. */
			readonly Current: System.Text.Rune;

			/** Returns the current enumerator instance. */
			GetEnumerator(): System.Text.StringRuneEnumerator;

			/** Advances the enumerator to the next {@link System.Text.Rune} of the string. */
			MoveNext(): boolean;
		}
	}

	export namespace System.Text.Unicode {
		/**
		 * Provides static methods that convert chunked data between UTF-8 and UTF-16 encodings.
		 */
		export namespace Utf8 {
			export function FromUtf16(
				source: System.ReadOnlySpan$1<System.Char>,
				destination: System.Span$1<number>,
				replaceInvalidSequences?: boolean,
				isFinalBlock?: boolean,
			): { result: System.Buffers.OperationStatus, charsRead: number, bytesWritten: number };

			export function ToUtf16(
				source: System.ReadOnlySpan$1<number>,
				destination: System.Span$1<System.Char>,
				replaceInvalidSequences?: boolean,
				isFinalBlock?: boolean,
			): { result: System.Buffers.OperationStatus, bytesRead: number, charsWritten: number };

			export function TryWrite(
				destination: System.Span$1<number>,
				handler: System.Text.Unicode.Utf8.TryWriteInterpolatedStringHandler,
			): number | undefined;

			export function TryWrite(
				destination: System.Span$1<number>,
				provider: System.IFormatProvider | undefined,
				handler: System.Text.Unicode.Utf8.TryWriteInterpolatedStringHandler,
			): number | undefined;

			/** Validates that the value is well-formed UTF-8. */
			export function IsValid(value: System.ReadOnlySpan$1<number>): boolean;
		}
	}

	export namespace System.Text.Unicode.Utf8 {
		export class TryWriteInterpolatedStringHandler extends System.ValueType {
			constructor(
				literalLength: number,
				formattedCount: number,
				destination: System.Span$1<number>,
			);

			constructor(
				literalLength: number,
				formattedCount: number,
				destination: System.Span$1<number>,
				provider: System.IFormatProvider | undefined,
			);

			AppendLiteral(value: string): boolean;

			AppendFormatted(value: System.ReadOnlySpan$1<System.Char>): boolean;

			AppendFormatted(
				value: System.ReadOnlySpan$1<System.Char>,
				alignment?: number,
				format?: string,
			): boolean;

			AppendFormatted(utf8Value: System.ReadOnlySpan$1<number>): boolean;

			AppendFormatted(
				utf8Value: System.ReadOnlySpan$1<number>,
				alignment?: number,
				format?: string,
			): boolean;

			AppendFormatted<T>(value: T): boolean;

			AppendFormatted<T>(
				value: T,
				format: string | undefined,
			): boolean;

			AppendFormatted<T>(
				value: T,
				alignment: number,
			): boolean;

			AppendFormatted<T>(
				value: T,
				alignment: number,
				format: string | undefined,
			): boolean;

			AppendFormatted(
				value: System.Object | undefined,
				alignment?: number,
				format?: string,
			): boolean;

			AppendFormatted(value: string | undefined): boolean;

			AppendFormatted(
				value: string | undefined,
				alignment?: number,
				format?: string,
			): boolean;
		}
	}

	export namespace System.Security {
		/**
		 * Allows an assembly to be called by partially trusted code. Without this declaration,
		 * only fully trusted callers are able to use the assembly. This class cannot be
		 * inherited.
		 */
		export class AllowPartiallyTrustedCallersAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Security.AllowPartiallyTrustedCallersAttribute} class.
			 */
			constructor();

			/**
			 * Gets or sets the default partial trust visibility for code that is marked with the
			 * {@link System.Security.AllowPartiallyTrustedCallersAttribute} (APTCA) attribute.
			 */
			PartialTrustVisibilityLevel: System.Security.PartialTrustVisibilityLevel;
		}
	}

	export namespace System.Security {
		/** Defines methods implemented by permission types. */
		export interface IPermission extends System.Security.ISecurityEncodable {
			/** Creates and returns an identical copy of the current permission. */
			Copy(): System.Security.IPermission;

			/**
			 * Throws a {@link System.Security.SecurityException} at run time if the security
			 * requirement is not met.
			 */
			Demand(): void;

			/**
			 * Creates and returns a permission that is the intersection of the current permission
			 * and the specified permission.
			 */
			Intersect(target: System.Security.IPermission | undefined): System.Security.IPermission | undefined;

			/** Determines whether the current permission is a subset of the specified permission. */
			IsSubsetOf(target: System.Security.IPermission | undefined): boolean;

			/**
			 * Creates a permission that is the union of the current permission and the specified
			 * permission.
			 */
			Union(target: System.Security.IPermission | undefined): System.Security.IPermission | undefined;
		}
	}

	export namespace System.Security {
		/**
		 * Defines the methods that convert permission object state to and from XML element
		 * representation.
		 */
		export interface ISecurityEncodable {
			/** Reconstructs a security object with a specified state from an XML encoding. */
			FromXml(e: System.Security.SecurityElement): void;

			/** Creates an XML encoding of the security object and its current state. */
			ToXml(): System.Security.SecurityElement | undefined;
		}
	}

	export namespace System.Security {
		/**
		 * Manages the stack walk that determines whether all callers in the call stack have the
		 * required permissions to access a protected resource.
		 */
		export interface IStackWalk {
			/**
			 * Asserts that the calling code can access the resource identified by the current
			 * permission object, even if callers higher in the stack have not been granted
			 * permission to access the resource.
			 */
			Assert(): void;

			/**
			 * Determines at run time whether all callers in the call stack have been granted the
			 * permission specified by the current permission object.
			 */
			Demand(): void;

			/**
			 * Causes every {@link System.Security.IStackWalk.Demand} for the current object that
			 * passes through the calling code to fail.
			 */
			Deny(): void;

			/**
			 * Causes every {@link System.Security.IStackWalk.Demand} for all objects except the
			 * current one that passes through the calling code to fail, even if code higher in the
			 * call stack has been granted permission to access other resources.
			 */
			PermitOnly(): void;
		}
	}

	export namespace System.Security {
		/**
		 * Specifies the default partial-trust visibility for code that is marked with the
		 * {@link System.Security.AllowPartiallyTrustedCallersAttribute} (APTCA) attribute.
		 */
		export enum PartialTrustVisibilityLevel {
			/** The assembly can always be called by partial-trust code. */
			VisibleToAllHosts = 0,

			/**
			 * The assembly has been audited for partial trust, but it is not visible to
			 * partial-trust code in all hosts. To make the assembly visible to partial-trust code,
			 * add it to the {@link System.AppDomainSetup.PartialTrustVisibleAssemblies} property.
			 */
			NotVisibleByDefault = 1,
		}
	}

	export namespace System.Security {
		/** Represents a collection that can contain many different types of permissions. */
		export class PermissionSet implements
			System.Collections.ICollection,
			System.Collections.IEnumerable,
			System.Security.ISecurityEncodable,
			System.Security.IStackWalk {
			/**
			 * Initializes a new instance of the {@link System.Security.PermissionSet} class with the
			 * specified {@link System.Security.Permissions.PermissionState}.
			 */
			constructor(state: System.Security.Permissions.PermissionState);

			/**
			 * Initializes a new instance of the {@link System.Security.PermissionSet} class with
			 * initial values taken from the `permSet` parameter.
			 */
			constructor(permSet: System.Security.PermissionSet | undefined);

			/** Gets the number of permission objects contained in the permission set. */
			readonly Count: number;

			/** Gets a value indicating whether the collection is read-only. */
			readonly IsReadOnly: boolean;

			/** Gets a value indicating whether the collection is guaranteed to be thread safe. */
			readonly IsSynchronized: boolean;

			/** Gets the root object of the current collection. */
			readonly SyncRoot: System.Object;

			/** Adds a specified permission to the {@link System.Security.PermissionSet}. */
			AddPermission(perm: System.Security.IPermission | undefined): System.Security.IPermission | undefined;

			/**
			 * Declares that the calling code can access the resource protected by a permission
			 * demand through the code that calls this method, even if callers higher in the stack
			 * have not been granted permission to access the resource. Using
			 * {@link System.Security.PermissionSet.Assert} can create security vulnerabilities.
			 */
			Assert(): void;

			/**
			 * Gets a value indicating whether the {@link System.Security.PermissionSet} contains
			 * permissions that are not derived from {@link System.Security.CodeAccessPermission}.
			 */
			ContainsNonCodeAccessPermissions(): boolean;

			/**
			 * Converts an encoded {@link System.Security.PermissionSet} from one XML encoding format
			 * to another XML encoding format.
			 */
			static ConvertPermissionSet(
				inFormat: string,
				inData: number[],
				outFormat: string,
			): number[];

			/** Creates a copy of the {@link System.Security.PermissionSet}. */
			Copy(): System.Security.PermissionSet;

			/**
			 * Copies the permission objects of the set to the indicated location in an
			 * {@link System.Array}.
			 */
			CopyTo(
				array: System.Array,
				index: number,
			): void;

			/**
			 * Forces a {@link System.Security.SecurityException} at run time if all callers higher
			 * in the call stack have not been granted the permissions specified by the current
			 * instance.
			 */
			Demand(): void;

			/**
			 * Causes any {@link System.Security.PermissionSet.Demand} that passes through the
			 * calling code for a permission that has an intersection with a permission of a type
			 * contained in the current {@link System.Security.PermissionSet} to fail.
			 */
			Deny(): void;

			/**
			 * Determines whether the specified {@link System.Security.PermissionSet} or
			 * {@link System.Security.NamedPermissionSet} object is equal to the current
			 * {@link System.Security.PermissionSet}.
			 */
			Equals(o: System.Object | undefined): boolean;

			/** Reconstructs a security object with a specified state from an XML encoding. */
			FromXml(et: System.Security.SecurityElement): void;

			/** Returns an enumerator for the permissions of the set. */
			GetEnumerator(): System.Collections.IEnumerator;

			/**
			 * Gets a hash code for the {@link System.Security.PermissionSet} object that is suitable
			 * for use in hashing algorithms and data structures such as a hash table.
			 */
			GetHashCode(): number;

			/** Gets a permission object of the specified type, if it exists in the set. */
			GetPermission(permClass: System.Type | undefined): System.Security.IPermission | undefined;

			/**
			 * Creates and returns a permission set that is the intersection of the current
			 * {@link System.Security.PermissionSet} and the specified
			 * {@link System.Security.PermissionSet}.
			 */
			Intersect(other: System.Security.PermissionSet | undefined): System.Security.PermissionSet | undefined;

			/**
			 * Gets a value indicating whether the {@link System.Security.PermissionSet} is empty.
			 */
			IsEmpty(): boolean;

			/**
			 * Determines whether the current {@link System.Security.PermissionSet} is a subset of
			 * the specified {@link System.Security.PermissionSet}.
			 */
			IsSubsetOf(target: System.Security.PermissionSet | undefined): boolean;

			/** Determines whether the {@link System.Security.PermissionSet} is `Unrestricted`. */
			IsUnrestricted(): boolean;

			/**
			 * Causes any {@link System.Security.PermissionSet.Demand} that passes through the
			 * calling code for any {@link System.Security.PermissionSet} that is not a subset of the
			 * current {@link System.Security.PermissionSet} to fail.
			 */
			PermitOnly(): void;

			/** Removes a permission of a certain type from the set. */
			RemovePermission(permClass: System.Type | undefined): System.Security.IPermission | undefined;

			/**
			 * Causes any previous {@link System.Security.CodeAccessPermission.Assert} for the
			 * current frame to be removed and no longer be in effect.
			 */
			static RevertAssert(): void;

			/**
			 * Sets a permission to the {@link System.Security.PermissionSet}, replacing any existing
			 * permission of the same type.
			 */
			SetPermission(perm: System.Security.IPermission | undefined): System.Security.IPermission | undefined;

			/** Returns a string representation of the {@link System.Security.PermissionSet}. */
			ToString(): string;

			/** Creates an XML encoding of the security object and its current state. */
			ToXml(): System.Security.SecurityElement | undefined;

			/**
			 * Creates a {@link System.Security.PermissionSet} that is the union of the current
			 * {@link System.Security.PermissionSet} and the specified
			 * {@link System.Security.PermissionSet}.
			 */
			Union(other: System.Security.PermissionSet | undefined): System.Security.PermissionSet | undefined;
		}
	}

	export namespace System.Security {
		/** Specifies that code or an assembly performs security-critical operations. */
		export class SecurityCriticalAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Security.SecurityCriticalAttribute}
			 * class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Security.SecurityCriticalAttribute}
			 * class with the specified scope.
			 */
			constructor(scope: System.Security.SecurityCriticalScope);

			/** Gets the scope for the attribute. */
			readonly Scope: System.Security.SecurityCriticalScope;
		}
	}

	export namespace System.Security {
		/** Specifies the scope of a {@link System.Security.SecurityCriticalAttribute}. */
		export enum SecurityCriticalScope {
			/** The attribute applies only to the immediate target. */
			Explicit = 0,

			/** The attribute applies to all code that follows it. */
			Everything = 1,
		}
	}

	export namespace System.Security {
		/**
		 * Represents the XML object model for encoding security objects. This class cannot be
		 * inherited.
		 */
		export class SecurityElement {
			/**
			 * Initializes a new instance of the {@link System.Security.SecurityElement} class with
			 * the specified tag.
			 */
			constructor(tag: string);

			/**
			 * Initializes a new instance of the {@link System.Security.SecurityElement} class with
			 * the specified tag and text.
			 */
			constructor(
				tag: string,
				text: string | undefined,
			);

			/** Gets or sets the attributes of an XML element as name/value pairs. */
			Attributes?: System.Collections.Hashtable;

			/** Gets or sets the array of child elements of the XML element. */
			Children?: System.Collections.ArrayList;

			/** Gets or sets the tag name of an XML element. */
			Tag: string;

			/** Gets or sets the text within an XML element. */
			Text?: string;

			/** Adds a name/value attribute to an XML element. */
			AddAttribute(
				name: string,
				value: string,
			): void;

			/** Adds a child element to the XML element. */
			AddChild(child: System.Security.SecurityElement): void;

			/** Finds an attribute by name in an XML element. */
			Attribute(name: string): string | undefined;

			/**
			 * Creates and returns an identical copy of the current
			 * {@link System.Security.SecurityElement} object.
			 */
			Copy(): System.Security.SecurityElement;

			/** Compares two XML element objects for equality. */
			Equal(other: System.Security.SecurityElement | undefined): boolean;

			/** Replaces invalid XML characters in a string with their valid XML equivalent. */
			static Escape(str: string | undefined): string | undefined;

			/** Creates a security element from an XML-encoded string. */
			static FromString(xml: string): System.Security.SecurityElement | undefined;

			/** Determines whether a string is a valid attribute name. */
			static IsValidAttributeName(name: string | undefined): boolean;

			/** Determines whether a string is a valid attribute value. */
			static IsValidAttributeValue(value: string | undefined): boolean;

			/** Determines whether a string is a valid tag. */
			static IsValidTag(tag: string | undefined): boolean;

			/** Determines whether a string is valid as text within an XML element. */
			static IsValidText(text: string | undefined): boolean;

			/** Finds a child by its tag name. */
			SearchForChildByTag(tag: string): System.Security.SecurityElement | undefined;

			/** Finds a child by its tag name and returns the contained text. */
			SearchForTextOfTag(tag: string): string | undefined;

			/**
			 * Produces a string representation of an XML element and its constituent attributes,
			 * child elements, and text.
			 */
			ToString(): string;
		}
	}

	export namespace System.Security {
		/** The exception that is thrown when a security error is detected. */
		export class SecurityException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.Security.SecurityException} class with
			 * default properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Security.SecurityException} class with
			 * a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.Security.SecurityException} class with
			 * a specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.Security.SecurityException} class with
			 * a specified error message and the permission type that caused the exception to be
			 * thrown.
			 */
			constructor(
				message: string | undefined,
				type: System.Type | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.Security.SecurityException} class with
			 * a specified error message, the permission type that caused the exception to be thrown,
			 * and the permission state.
			 */
			constructor(
				message: string | undefined,
				type: System.Type | undefined,
				state: string | undefined,
			);

			/**
			 * Gets or sets the demanded security permission, permission set, or permission set
			 * collection that failed.
			 */
			Demanded?: System.Object;

			/**
			 * Gets or sets the denied security permission, permission set, or permission set
			 * collection that caused a demand to fail.
			 */
			DenySetInstance?: System.Object;

			/** Gets or sets information about the failed assembly. */
			FailedAssemblyInfo?: System.Reflection.AssemblyName;

			/**
			 * Gets or sets the granted permission set of the assembly that caused the
			 * {@link System.Security.SecurityException}.
			 */
			GrantedSet?: string;

			/** Gets or sets the information about the method associated with the exception. */
			Method?: System.Reflection.MethodInfo;

			/** Gets or sets the state of the permission that threw the exception. */
			PermissionState?: string;

			/** Gets or sets the type of the permission that failed. */
			PermissionType?: System.Type;

			/**
			 * Gets or sets the permission, permission set, or permission set collection that is part
			 * of the permit-only stack frame that caused a security check to fail.
			 */
			PermitOnlySetInstance?: System.Object;

			/**
			 * Gets or sets the refused permission set of the assembly that caused the
			 * {@link System.Security.SecurityException}.
			 */
			RefusedSet?: string;

			/** Gets or sets the URL of the assembly that caused the exception. */
			Url?: string;

			/** Returns a representation of the current {@link System.Security.SecurityException}. */
			ToString(): string;
		}
	}

	export namespace System.Security {
		/**
		 * Indicates the set of security rules the common language runtime should enforce for an
		 * assembly.
		 */
		export class SecurityRulesAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Security.SecurityRulesAttribute} class
			 * using the specified rule set value.
			 */
			constructor(ruleSet: System.Security.SecurityRuleSet);

			/** Gets the rule set to be applied. */
			readonly RuleSet: System.Security.SecurityRuleSet;

			/**
			 * Determines whether fully trusted transparent code should skip Microsoft intermediate
			 * language (MSIL) verification.
			 */
			SkipVerificationInFullTrust: boolean;
		}
	}

	export namespace System.Security {
		/**
		 * Identifies the set of security rules the common language runtime should enforce for an
		 * assembly.
		 */
		export enum SecurityRuleSet {
			/**
			 * Unsupported. Using this value results in a {@link System.IO.FileLoadException} being
			 * thrown.
			 */
			None = 0,

			/**
			 * Indicates that the runtime will enforce level 1 (.NET Framework version 2.0)
			 * transparency rules.
			 */
			Level1 = 1,

			/** Indicates that the runtime will enforce level 2 transparency rules. */
			Level2 = 2,
		}
	}

	export namespace System.Security {
		/**
		 * Identifies types or members as security-critical and safely accessible by transparent
		 * code.
		 */
		export class SecuritySafeCriticalAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Security.SecuritySafeCriticalAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Security {
		/** Specifies that an assembly cannot cause an elevation of privilege. */
		export class SecurityTransparentAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Security.SecurityTransparentAttribute}
			 * class.
			 */
			constructor();
		}
	}

	export namespace System.Security {
		/**
		 * Identifies which of the nonpublic {@link System.Security.SecurityCriticalAttribute}
		 * members are accessible by transparent code within the assembly.
		 */
		export class SecurityTreatAsSafeAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Security.SecurityTreatAsSafeAttribute}
			 * class.
			 */
			constructor();
		}
	}

	export namespace System.Security {
		/**
		 * Allows managed code to call into unmanaged code without a stack walk. This class
		 * cannot be inherited.
		 */
		export class SuppressUnmanagedCodeSecurityAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Security.SuppressUnmanagedCodeSecurityAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Security {
		/** Marks modules containing unverifiable code. This class cannot be inherited. */
		export class UnverifiableCodeAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Security.UnverifiableCodeAttribute}
			 * class.
			 */
			constructor();
		}
	}

	export namespace System.Security {
		/**
		 * The exception that is thrown when the security policy requires code to be type safe
		 * and the verification process is unable to verify that the code is type safe.
		 */
		export class VerificationException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.Security.VerificationException} class
			 * with default properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Security.VerificationException} class
			 * with an explanatory message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.Security.VerificationException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System.Security.Principal {
		/** Defines the basic functionality of an identity object. */
		export interface IIdentity {
			/** Gets the type of authentication used. */
			readonly AuthenticationType?: string;

			/** Gets a value that indicates whether the user has been authenticated. */
			readonly IsAuthenticated: boolean;

			/** Gets the name of the current user. */
			readonly Name?: string;
		}
	}

	export namespace System.Security.Principal {
		/** Defines the basic functionality of a principal object. */
		export interface IPrincipal {
			/** Gets the identity of the current principal. */
			readonly Identity?: System.Security.Principal.IIdentity;

			/** Determines whether the current principal belongs to the specified role. */
			IsInRole(role: string): boolean;
		}
	}

	export namespace System.Security.Principal {
		/**
		 * Specifies how principal and identity objects should be created for an application
		 * domain. The default is `UnauthenticatedPrincipal`.
		 */
		export enum PrincipalPolicy {
			/**
			 * Principal and identity objects for the unauthenticated entity should be created. An
			 * unauthenticated entity has {@link System.Security.Principal.GenericIdentity.Name} set
			 * to the empty string ("") and
			 * {@link System.Security.Principal.GenericIdentity.IsAuthenticated} set to `false`.
			 */
			UnauthenticatedPrincipal = 0,

			/** No principal or identity objects should be created. */
			NoPrincipal = 1,

			/**
			 * Principal and identity objects that reflect the operating system token associated with
			 * the current execution thread should be created, and the associated operating system
			 * groups should be mapped into roles.
			 */
			WindowsPrincipal = 2,
		}
	}

	export namespace System.Security.Principal {
		/**
		 * Defines security impersonation levels. Security impersonation levels govern the degree
		 * to which a server process can act on behalf of a client process.
		 */
		export enum TokenImpersonationLevel {
			/** An impersonation level is not assigned. */
			None = 0,

			/**
			 * The server process cannot obtain identification information about the client, and it
			 * cannot impersonate the client.
			 */
			Anonymous = 1,

			/**
			 * The server process can obtain information about the client, such as security
			 * identifiers and privileges, but it cannot impersonate the client. This is useful for
			 * servers that export their own objects, for example, database products that export
			 * tables and views. Using the retrieved client-security information, the server can make
			 * access-validation decisions without being able to use other services that are using
			 * the client's security context.
			 */
			Identification = 2,

			/**
			 * The server process can impersonate the client's security context on its local system.
			 * The server cannot impersonate the client on remote systems.
			 */
			Impersonation = 3,

			/**
			 * The server process can impersonate the client's security context on remote systems.
			 */
			Delegation = 4,
		}
	}

	export namespace System.Security.Permissions {
		/** Specifies the base attribute class for code access security. */
		export class CodeAccessSecurityAttribute extends System.Security.Permissions.SecurityAttribute {
		}
	}

	export namespace System.Security.Permissions {
		/**
		 * Specifies whether a permission should have all or no access to resources at creation.
		 */
		export enum PermissionState {
			/** No access to the resource protected by the permission. */
			None = 0,

			/** Full access to the resource protected by the permission. */
			Unrestricted = 1,
		}
	}

	export namespace System.Security.Permissions {
		/** Specifies the security actions that can be performed using declarative security. */
		export enum SecurityAction {
			/**
			 * All callers higher in the call stack are required to have been granted the permission
			 * specified by the current permission object.
			 */
			Demand = 2,

			/**
			 * The calling code can access the resource identified by the current permission object,
			 * even if callers higher in the stack have not been granted permission to access the
			 * resource (see Using the Assert Method).
			 */
			Assert = 3,

			/**
			 * The ability to access the resource specified by the current permission object is
			 * denied to callers, even if they have been granted permission to access it (see Using
			 * the Deny Method).
			 */
			Deny = 4,

			/**
			 * Only the resources specified by this permission object can be accessed, even if the
			 * code has been granted permission to access other resources.
			 */
			PermitOnly = 5,

			/**
			 * The immediate caller is required to have been granted the specified permission. Do not
			 * use in the .NET Framework 4. For full trust, use
			 * {@link System.Security.SecurityCriticalAttribute} instead; for partial trust, use
			 * {@link System.Security.Permissions.SecurityAction.Demand}.
			 */
			LinkDemand = 6,

			/**
			 * The derived class inheriting the class or overriding a method is required to have been
			 * granted the specified permission.
			 */
			InheritanceDemand = 7,

			/**
			 * The request for the minimum permissions required for code to run. This action can only
			 * be used within the scope of the assembly.
			 */
			RequestMinimum = 8,

			/**
			 * The request for additional permissions that are optional (not required to run). This
			 * request implicitly refuses all other permissions not specifically requested. This
			 * action can only be used within the scope of the assembly.
			 */
			RequestOptional = 9,

			/**
			 * The request that permissions that might be misused will not be granted to the calling
			 * code. This action can only be used within the scope of the assembly.
			 */
			RequestRefuse = 10,
		}
	}

	export namespace System.Security.Permissions {
		/**
		 * Specifies the base attribute class for declarative security from which
		 * {@link System.Security.Permissions.CodeAccessSecurityAttribute} is derived.
		 */
		export class SecurityAttribute extends System.Attribute {
			/** Gets or sets a security action. */
			Action: System.Security.Permissions.SecurityAction;

			/**
			 * Gets or sets a value indicating whether full (unrestricted) permission to the resource
			 * protected by the attribute is declared.
			 */
			Unrestricted: boolean;

			/**
			 * When overridden in a derived class, creates a permission object that can then be
			 * serialized into binary form and persistently stored along with the
			 * {@link System.Security.Permissions.SecurityAction} in an assembly's metadata.
			 */
			CreatePermission(): System.Security.IPermission | undefined;
		}
	}

	export namespace System.Security.Permissions {
		/**
		 * Allows security actions for {@link System.Security.Permissions.SecurityPermission} to
		 * be applied to code using declarative security. This class cannot be inherited.
		 */
		export class SecurityPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Security.Permissions.SecurityPermissionAttribute} class with the
			 * specified {@link System.Security.Permissions.SecurityAction}.
			 */
			constructor(action: System.Security.Permissions.SecurityAction);

			/**
			 * Gets or sets a value indicating whether permission to assert that all this code's
			 * callers have the requisite permission for the operation is declared.
			 */
			Assertion: boolean;

			/**
			 * Gets or sets a value that indicates whether code has permission to perform binding
			 * redirection in the application configuration file.
			 */
			BindingRedirects: boolean;

			/**
			 * Gets or sets a value indicating whether permission to manipulate
			 * {@link System.AppDomain} is declared.
			 */
			ControlAppDomain: boolean;

			/**
			 * Gets or sets a value indicating whether permission to alter or manipulate domain
			 * security policy is declared.
			 */
			ControlDomainPolicy: boolean;

			/**
			 * Gets or sets a value indicating whether permission to alter or manipulate evidence is
			 * declared.
			 */
			ControlEvidence: boolean;

			/**
			 * Gets or sets a value indicating whether permission to view and manipulate security
			 * policy is declared.
			 */
			ControlPolicy: boolean;

			/**
			 * Gets or sets a value indicating whether permission to manipulate the current principal
			 * is declared.
			 */
			ControlPrincipal: boolean;

			/**
			 * Gets or sets a value indicating whether permission to manipulate threads is declared.
			 */
			ControlThread: boolean;

			/** Gets or sets a value indicating whether permission to execute code is declared. */
			Execution: boolean;

			/**
			 * Gets or sets all permission flags comprising the
			 * {@link System.Security.Permissions.SecurityPermission} permissions.
			 */
			Flags: System.Security.Permissions.SecurityPermissionFlag;

			/**
			 * Gets or sets a value indicating whether code can plug into the common language runtime
			 * infrastructure, such as adding Remoting Context Sinks, Envoy Sinks and Dynamic Sinks.
			 */
			Infrastructure: boolean;

			/**
			 * Gets or sets a value indicating whether code can configure remoting types and
			 * channels.
			 */
			RemotingConfiguration: boolean;

			/**
			 * Gets or sets a value indicating whether code can use a serialization formatter to
			 * serialize or deserialize an object.
			 */
			SerializationFormatter: boolean;

			/**
			 * Gets or sets a value indicating whether permission to bypass code verification is
			 * declared.
			 */
			SkipVerification: boolean;

			/**
			 * Gets or sets a value indicating whether permission to call unmanaged code is declared.
			 */
			UnmanagedCode: boolean;

			/** Creates and returns a new {@link System.Security.Permissions.SecurityPermission}. */
			CreatePermission(): System.Security.IPermission | undefined;
		}
	}

	export namespace System.Security.Permissions {
		/** Specifies access flags for the security permission object. */
		export enum SecurityPermissionFlag {
			/** No security access. */
			NoFlags = 0,

			/**
			 * Ability to assert that all this code's callers have the requisite permission for the
			 * operation.
			 */
			Assertion = 1,

			/**
			 * Ability to call unmanaged code. Since unmanaged code potentially allows other
			 * permissions to be bypassed, this is a dangerous permission that should only be granted
			 * to highly trusted code. It is used for such applications as calling native code using
			 * PInvoke or using COM interop.
			 */
			UnmanagedCode = 2,

			/**
			 * Ability to skip verification of code in this assembly. Code that is unverifiable can
			 * be run if this permission is granted. This is a powerful permission that should be
			 * granted only to highly trusted code. This flag has no effect when used dynamically
			 * with stack modifiers such as {@link System.Security.CodeAccessPermission.Deny},
			 * {@link System.Security.CodeAccessPermission.Assert}, and
			 * {@link System.Security.CodeAccessPermission.PermitOnly}.
			 */
			SkipVerification = 4,

			/**
			 * Permission for the code to run. Without this permission, managed code will not be
			 * executed. This flag has no effect when used dynamically with stack modifiers such as
			 * {@link System.Security.CodeAccessPermission.Deny},
			 * {@link System.Security.CodeAccessPermission.Assert}, and
			 * {@link System.Security.CodeAccessPermission.PermitOnly}.
			 */
			Execution = 8,

			/** Ability to use certain advanced operations on threads. */
			ControlThread = 16,

			/**
			 * Ability to provide evidence, including the ability to alter the evidence provided by
			 * the common language runtime. This is a powerful permission that should only be granted
			 * to highly trusted code.
			 */
			ControlEvidence = 32,

			/**
			 * Ability to view and modify policy. This is a powerful permission that should only be
			 * granted to highly trusted code.
			 */
			ControlPolicy = 64,

			/** Ability to provide serialization services. Used by serialization formatters. */
			SerializationFormatter = 128,

			/** Ability to specify domain policy. */
			ControlDomainPolicy = 256,

			/** Ability to manipulate the principal object. */
			ControlPrincipal = 512,

			/** Ability to create and manipulate an {@link System.AppDomain}. */
			ControlAppDomain = 1024,

			/** Permission to configure Remoting types and channels. */
			RemotingConfiguration = 2048,

			/**
			 * Permission to plug code into the common language runtime infrastructure, such as
			 * adding Remoting Context Sinks, Envoy Sinks and Dynamic Sinks.
			 */
			Infrastructure = 4096,

			/**
			 * Permission to perform explicit binding redirection in the application configuration
			 * file. This includes redirection of .NET assemblies that have been unified as well as
			 * other assemblies found outside .NET.
			 */
			BindingRedirects = 8192,

			/** The unrestricted state of the permission. */
			AllFlags = 16383,
		}
	}

	export namespace System.Security.Cryptography {
		/**
		 * The exception that is thrown when an error occurs during a cryptographic operation.
		 */
		export class CryptographicException extends System.SystemException {
			/**
			 * Initializes a new instance of the
			 * {@link System.Security.Cryptography.CryptographicException} class with default
			 * properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Security.Cryptography.CryptographicException} class with the specified
			 * `HRESULT` error code.
			 */
			constructor(hr: number);

			/**
			 * Initializes a new instance of the
			 * {@link System.Security.Cryptography.CryptographicException} class with a specified
			 * error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Security.Cryptography.CryptographicException} class with a specified
			 * error message and a reference to the inner exception that is the cause of this
			 * exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Security.Cryptography.CryptographicException} class with a specified
			 * error message in the specified format.
			 */
			constructor(
				format: string,
				insert: string | undefined,
			);
		}
	}

	export namespace System.Runtime {
		/**
		 * The exception that is thrown when there are multiple incompatible interface methods
		 * overriding another method.
		 */
		export class AmbiguousImplementationException extends System.Exception {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.AmbiguousImplementationException} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.AmbiguousImplementationException} class with a specified error
			 * message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.AmbiguousImplementationException} class with a specified error
			 * message and a reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System.Runtime {
		/** Specifies patch band information for targeted patching of .NET. */
		export class AssemblyTargetedPatchBandAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.AssemblyTargetedPatchBandAttribute} class.
			 */
			constructor(targetedPatchBand: string);

			/** Gets the patch band. */
			readonly TargetedPatchBand: string;
		}
	}

	export namespace System.Runtime {
		/** Enables code to be run and aborted asynchronously. */
		export namespace ControlledExecution {
			/** Runs code that can be aborted asynchronously. */
			export function Run(
				action: () => void,
				cancellationToken: AbortSignal,
			): void;
		}
	}

	export namespace System.Runtime {
		/**
		 * Represents a dependent garbage-collection handle. The handle will conditionally keep a
		 * dependent object instance alive as long as a target object instance is alive as well,
		 * without representing a strong reference to the target instance.
		 */
		export class DependentHandle extends System.ValueType implements IDisposable {
			/**
			 * Initializes a new instance of the {@link System.Runtime.DependentHandle} struct with
			 * the specified arguments.
			 */
			constructor(
				target: System.Object | undefined,
				dependent: System.Object | undefined,
			);

			/** Gets or sets the dependent object instance for the current handle. */
			Dependent?: System.Object;

			/**
			 * Gets a value indicating whether this instance was constructed with
			 * {@link System.Runtime.DependentHandle.#ctor(System.Object,System.Object)} and has not
			 * yet been disposed.
			 */
			readonly IsAllocated: boolean;

			/**
			 * Gets or sets the target object instance for the current handle. The target can only be
			 * set to a `null` value once the {@link System.Runtime.DependentHandle} instance has
			 * been created. Doing so will cause {@link System.Runtime.DependentHandle.Dependent} to
			 * start returning `null` as well, and to become eligible for collection even if the
			 * previous target is still alive.
			 */
			Target?: System.Object;

			/**
			 * Gets the values of both {@link System.Runtime.DependentHandle.Target} and
			 * {@link System.Runtime.DependentHandle.Dependent} (if available) as an atomic
			 * operation. That is, even if {@link System.Runtime.DependentHandle.Target} is
			 * concurrently set to `null`, calling this method will either return `null` for both
			 * target and dependent, or return both previous values. If
			 * {@link System.Runtime.DependentHandle.Target} and
			 * {@link System.Runtime.DependentHandle.Dependent} were used sequentially in this
			 * scenario instead, it would be possible to sometimes successfully retrieve the previous
			 * target, but then fail to get the dependent.
			 */
			readonly TargetAndDependent: [System.Object | undefined, System.Object | undefined];

			/**
			 * Performs application-defined tasks associated with freeing, releasing, or resetting
			 * unmanaged resources.
			 */
			dispose(): void;
		}
	}

	export namespace System.Runtime {
		/**
		 * Indicates whether the next blocking garbage collection compacts the large object heap
		 * (LOH).
		 */
		export enum GCLargeObjectHeapCompactionMode {
			/** The large object heap (LOH) is not compacted. */
			Default = 1,

			/**
			 * The large object heap (LOH) will be compacted during the next blocking generation 2
			 * garbage collection.
			 */
			CompactOnce = 2,
		}
	}

	export namespace System.Runtime {
		/** Adjusts the time that the garbage collector intrudes in your application. */
		export enum GCLatencyMode {
			/**
			 * Disables garbage collection concurrency and reclaims objects in a batch call. This is
			 * the most intrusive mode. This mode is designed for maximum throughput at the expense
			 * of responsiveness.
			 */
			Batch = 0,

			/**
			 * Enables garbage collection concurrency and reclaims objects while the application is
			 * running. This is the default mode for garbage collection on a workstation and is less
			 * intrusive than {@link System.Runtime.GCLatencyMode.Batch}. It balances responsiveness
			 * with throughput. This mode is equivalent to garbage collection on a workstation that
			 * is concurrent.
			 */
			Interactive = 1,

			/**
			 * Enables garbage collection that is more conservative in reclaiming objects. Full
			 * collections occur only if the system is under memory pressure, whereas generation 0
			 * and generation 1 collections might occur more frequently. This mode is not available
			 * for the server garbage collector.
			 */
			LowLatency = 2,

			/**
			 * Enables garbage collection that tries to minimize latency over an extended period. The
			 * collector tries to perform only generation 0, generation 1, and concurrent generation
			 * 2 collections. Full blocking collections may still occur if the system is under memory
			 * pressure.
			 */
			SustainedLowLatency = 3,

			/**
			 * Indicates that garbage collection is suspended while the app is executing a critical
			 * path. {@link System.Runtime.GCLatencyMode.NoGCRegion} is a read-only value; that is,
			 * you cannot assign the {@link System.Runtime.GCLatencyMode.NoGCRegion} value to the
			 * {@link System.Runtime.GCSettings.LatencyMode} property. You specify the no GC region
			 * latency mode by calling the {@link System.GC.TryStartNoGCRegion} method and terminate
			 * it by calling the {@link System.GC.EndNoGCRegion} method.
			 */
			NoGCRegion = 4,
		}
	}

	export namespace System.Runtime {
		/** Specifies the garbage collection settings for the current process. */
		export namespace GCSettings {
			/** Gets a value that indicates whether server garbage collection is enabled. */
			export const IsServerGC: boolean;

			/**
			 * Gets or sets a value that indicates whether a full blocking garbage collection
			 * compacts the large object heap (LOH).
			 */
			export var LargeObjectHeapCompactionMode: System.Runtime.GCLargeObjectHeapCompactionMode;

			/** Gets or sets the current latency mode for garbage collection. */
			export var LatencyMode: System.Runtime.GCLatencyMode;
		}
	}

	export namespace System.Runtime {
		/**
		 * Provides information about the Just In Time compiler. This class cannot be inherited.
		 */
		export namespace JitInfo {
			/**
			 * Gets the amount of time the JIT Compiler has spent compiling methods. If
			 * `currentThread` is `true`, then this value is scoped to the current thread; otherwise,
			 * this is a global value.
			 */
			export function GetCompilationTime(currentThread?: boolean): number;

			/**
			 * Gets the number of bytes of intermediate language that have been compiled. If
			 * `currentThread` is `true`, then this value is scoped to the current thread; otherwise,
			 * this is a global value.
			 */
			export function GetCompiledILBytes(currentThread?: boolean): number;

			/**
			 * Gets the number of methods that have been compiled. If `currentThread` is `true`, then
			 * this value is scoped to the current thread; otherwise, this is a global value.
			 */
			export function GetCompiledMethodCount(currentThread?: boolean): number;
		}
	}

	export namespace System.Runtime {
		/**
		 * Checks for sufficient memory resources before executing an operation. This class
		 * cannot be inherited.
		 */
		export class MemoryFailPoint extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements IDisposable {
			/**
			 * Initializes a new instance of the {@link System.Runtime.MemoryFailPoint} class,
			 * specifying the amount of memory required for successful execution.
			 */
			constructor(sizeInMegabytes: number);

			/** Releases all resources used by the {@link System.Runtime.MemoryFailPoint}. */
			dispose(): void;
		}
	}

	export namespace System.Runtime {
		/**
		 * Improves the startup performance of application domains in applications that require
		 * the just-in-time (JIT) compiler by performing background compilation of methods that
		 * are likely to be executed, based on profiles created during previous compilations.
		 */
		export namespace ProfileOptimization {
			/**
			 * Enables optimization profiling for the current application domain, and sets the folder
			 * where the optimization profile files are stored. On a single-core computer, the method
			 * is ignored.
			 */
			export function SetProfileRoot(directoryPath: string): void;

			/**
			 * Starts just-in-time (JIT) compilation of the methods that were previously recorded in
			 * the specified profile file, on a background thread. Starts the process of recording
			 * current method use, which later overwrites the specified profile file.
			 */
			export function StartProfile(profile: string | undefined): void;
		}
	}

	export namespace System.Runtime {
		/**
		 * Indicates that the .NET class library method to which this attribute is applied is
		 * unlikely to be affected by servicing releases, and therefore is eligible to be inlined
		 * across Native Image Generator (NGen) images.
		 */
		export class TargetedPatchingOptOutAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.TargetedPatchingOptOutAttribute} class.
			 */
			constructor(reason: string);

			/**
			 * Gets the reason why the method to which this attribute is applied is considered to be
			 * eligible for inlining across Native Image Generator (NGen) images.
			 */
			readonly Reason: string;
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Defines the compatibility guarantee of a component, type, or type member that may span
		 * multiple versions.
		 */
		export class ComponentGuaranteesAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.ComponentGuaranteesAttribute} class with a value that
			 * indicates a library, type, or member's guaranteed level of compatibility across
			 * multiple versions.
			 */
			constructor(guarantees: System.Runtime.Versioning.ComponentGuaranteesOptions);

			/**
			 * Gets a value that indicates the guaranteed level of compatibility of a library, type,
			 * or type member that spans multiple versions.
			 */
			readonly Guarantees: System.Runtime.Versioning.ComponentGuaranteesOptions;
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Describes the compatibility guarantee of a component, type, or type member that may
		 * span multiple versions.
		 */
		export enum ComponentGuaranteesOptions {
			/**
			 * The developer does not guarantee compatibility across versions. Consumers of the
			 * component, type, or member can expect future versions to break the existing client.
			 */
			None = 0,

			/**
			 * The developer promises multi-version exchange compatibility for the type. Consumers of
			 * the type can expect compatibility across future versions and can use the type in all
			 * their interfaces. Versioning problems cannot be fixed by side-by-side execution.
			 */
			Exchange = 1,

			/**
			 * The developer promises stable compatibility across versions. Consumers of the type can
			 * expect that future versions will not break the existing client. However, if they do
			 * and if the client has not used the type in its interfaces, side-by-side execution may
			 * fix the problem.
			 */
			Stable = 2,

			/**
			 * The component has been tested to work when more than one version of the assembly is
			 * loaded into the same application domain. Future versions can break compatibility.
			 * However, when such breaking changes are made, the old version is not modified but
			 * continues to exist alongside the new version.
			 */
			SideBySide = 4,
		}
	}

	export namespace System.Runtime.Versioning {
		/** Represents the name of a version of .NET. */
		export class FrameworkName implements System.IEquatable$1<System.Runtime.Versioning.FrameworkName> {
			/**
			 * Initializes a new instance of the {@link System.Runtime.Versioning.FrameworkName}
			 * class from a string that contains information about a version of .NET.
			 */
			constructor(frameworkName: string);

			/**
			 * Initializes a new instance of the {@link System.Runtime.Versioning.FrameworkName}
			 * class from a string and a {@link System.Version} object that identify a .NET version.
			 */
			constructor(
				identifier: string,
				version: System.Version,
			);

			/**
			 * Initializes a new instance of the {@link System.Runtime.Versioning.FrameworkName}
			 * class from a string, a {@link System.Version} object that identifies a .NET version,
			 * and a profile name.
			 */
			constructor(
				identifier: string,
				version: System.Version,
				profile: string | undefined,
			);

			/** Gets the full name of this {@link System.Runtime.Versioning.FrameworkName} object. */
			readonly FullName: string;

			/**
			 * Gets the identifier of this {@link System.Runtime.Versioning.FrameworkName} object.
			 */
			readonly Identifier: string;

			/**
			 * Gets the profile name of this {@link System.Runtime.Versioning.FrameworkName} object.
			 */
			readonly Profile: string;

			/** Gets the version of this {@link System.Runtime.Versioning.FrameworkName} object. */
			readonly Version: System.Version;

			/**
			 * Returns a value that indicates whether this
			 * {@link System.Runtime.Versioning.FrameworkName} instance represents the same .NET
			 * version as a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a value that indicates whether this
			 * {@link System.Runtime.Versioning.FrameworkName} instance represents the same .NET
			 * version as a specified {@link System.Runtime.Versioning.FrameworkName} instance.
			 */
			Equals(other: System.Runtime.Versioning.FrameworkName | undefined): boolean;

			/**
			 * Returns the hash code for the {@link System.Runtime.Versioning.FrameworkName} object.
			 */
			GetHashCode(): number;

			/**
			 * Returns the string representation of this
			 * {@link System.Runtime.Versioning.FrameworkName} object.
			 */
			ToString(): string;
		}
	}

	export namespace System.Runtime.Versioning {
		/** Marks APIs that were obsoleted in a given operating system version. */
		export class ObsoletedOSPlatformAttribute extends System.Runtime.Versioning.OSPlatformAttribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.ObsoletedOSPlatformAttribute} class for the specified
			 * obsoleted OS platform.
			 */
			constructor(platformName: string);

			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.ObsoletedOSPlatformAttribute} attribute class for the
			 * specified obsoleted OS platform with an additional message.
			 */
			constructor(
				platformName: string,
				message: string | undefined,
			);

			/** Gets the optional additional message provided for the attribute. */
			readonly Message?: string;

			/** Gets or sets the URL for corresponding documentation. */
			Url?: string;
		}
	}

	export namespace System.Runtime.Versioning {
		/** Base type for all platform-specific API attributes. */
		export class OSPlatformAttribute extends System.Attribute {
			/** Gets the name and optional version of the platform that the attribute applies to. */
			readonly PlatformName: string;
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Indicates that an API is in preview. This attribute allows call sites to be flagged
		 * with a diagnostic that indicates that a preview feature is used. Authors can use this
		 * attribute to ship preview features in their assemblies.
		 */
		export class RequiresPreviewFeaturesAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.RequiresPreviewFeaturesAttribute} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.RequiresPreviewFeaturesAttribute} class with the
			 * specified message.
			 */
			constructor(message: string | undefined);

			/** Gets the optional message associated with this attribute instance. */
			readonly Message?: string;

			/** Gets or sets the optional URL associated with this attribute instance. */
			Url?: string;
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Specifies the resource consumed by the member of a class. This class cannot be
		 * inherited.
		 */
		export class ResourceConsumptionAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.ResourceConsumptionAttribute} class specifying the
			 * scope of the consumed resource.
			 */
			constructor(resourceScope: System.Runtime.Versioning.ResourceScope);

			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.ResourceConsumptionAttribute} class specifying the
			 * scope of the consumed resource and the scope of how it is consumed.
			 */
			constructor(
				resourceScope: System.Runtime.Versioning.ResourceScope,
				consumptionScope: System.Runtime.Versioning.ResourceScope,
			);

			/** Gets the consumption scope for this member. */
			readonly ConsumptionScope: System.Runtime.Versioning.ResourceScope;

			/** Gets the resource scope for the consumed resource. */
			readonly ResourceScope: System.Runtime.Versioning.ResourceScope;
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Specifies the resource exposure for a member of a class. This class cannot be
		 * inherited.
		 */
		export class ResourceExposureAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.ResourceExposureAttribute} class with the specified
			 * exposure level.
			 */
			constructor(exposureLevel: System.Runtime.Versioning.ResourceScope);

			/** Gets the resource exposure scope. */
			readonly ResourceExposureLevel: System.Runtime.Versioning.ResourceScope;
		}
	}

	export namespace System.Runtime.Versioning {
		/** Identifies the scope of a sharable resource. */
		export enum ResourceScope {
			/** There is no shared state. */
			None = 0,

			/** The state is shared by objects within the machine. */
			Machine = 1,

			/** The state is shared within a process. */
			Process = 2,

			/** The state is shared by objects within an {@link System.AppDomain}. */
			AppDomain = 4,

			/** The state is shared by objects within a library. */
			Library = 8,

			/** The resource is visible to only the type. */
			Private = 16,

			/** The resource is visible at an assembly scope. */
			Assembly = 32,
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Indicates that an API is supported for a specified platform or operating system. If a
		 * version is specified, the API cannot be called from an earlier version. Multiple
		 * attributes can be applied to indicate support on multiple operating systems.
		 */
		export class SupportedOSPlatformAttribute extends System.Runtime.Versioning.OSPlatformAttribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.SupportedOSPlatformAttribute} attribute class for the
			 * specified supported OS platform.
			 */
			constructor(platformName: string);
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Annotates a custom guard field, property or method with a supported platform name and
		 * optional version. Multiple attributes can be applied to indicate guard for multiple
		 * supported platforms.
		 */
		export class SupportedOSPlatformGuardAttribute extends System.Runtime.Versioning.OSPlatformAttribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.SupportedOSPlatformGuardAttribute} attribute class
			 * for the specified supported OS platform.
			 */
			constructor(platformName: string);
		}
	}

	export namespace System.Runtime.Versioning {
		/** Identifies the version of .NET that a particular assembly was compiled against. */
		export class TargetFrameworkAttribute extends System.Attribute {
			/**
			 * Initializes an instance of the
			 * {@link System.Runtime.Versioning.TargetFrameworkAttribute} class by specifying the
			 * .NET version against which an assembly was built.
			 */
			constructor(frameworkName: string);

			/** Gets the display name of the .NET version against which an assembly was built. */
			FrameworkDisplayName?: string;

			/**
			 * Gets the name of the .NET version against which a particular assembly was compiled.
			 */
			readonly FrameworkName: string;
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Specifies the operating system that a project targets, for example, Windows or iOS.
		 */
		export class TargetPlatformAttribute extends System.Runtime.Versioning.OSPlatformAttribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.TargetPlatformAttribute} attribute class for the
			 * specified target OS platform.
			 */
			constructor(platformName: string);
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Marks APIs that were removed or are unsupported in a given operating system version.
		 */
		export class UnsupportedOSPlatformAttribute extends System.Runtime.Versioning.OSPlatformAttribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.UnsupportedOSPlatformAttribute} attribute class for
			 * the specified unsupported OS platform.
			 */
			constructor(platformName: string);

			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.UnsupportedOSPlatformAttribute} attribute class for
			 * the specified unsupported OS platform with an additional message.
			 */
			constructor(
				platformName: string,
				message: string | undefined,
			);

			/** Gets the optional additional message provided for the attribute. */
			readonly Message?: string;
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Annotates the custom guard field, property or method with an unsupported platform name
		 * and optional version. Multiple attributes can be applied to indicate guard for
		 * multiple unsupported platforms.
		 */
		export class UnsupportedOSPlatformGuardAttribute extends System.Runtime.Versioning.OSPlatformAttribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute} attribute class
			 * for the specified unsupported OS platform.
			 */
			constructor(platformName: string);
		}
	}

	export namespace System.Runtime.Versioning {
		/**
		 * Provides methods to aid developers in writing version-safe code. This class cannot be
		 * inherited.
		 */
		export namespace VersioningHelper {
			/**
			 * Returns a version-safe name based on the specified resource name and the intended
			 * resource consumption source.
			 */
			export function MakeVersionSafeName(
				name: string | undefined,
				_from: System.Runtime.Versioning.ResourceScope,
				to: System.Runtime.Versioning.ResourceScope,
			): string;

			/**
			 * Returns a version-safe name based on the specified resource name, the intended
			 * resource consumption scope, and the type using the resource.
			 */
			export function MakeVersionSafeName(
				name: string | undefined,
				_from: System.Runtime.Versioning.ResourceScope,
				to: System.Runtime.Versioning.ResourceScope,
				type: System.Type | undefined,
			): string;
		}
	}

	export namespace System.Runtime.Remoting {
		/**
		 * Wraps marshal-by-value object references, allowing them to be returned through an
		 * indirection.
		 */
		export class ObjectHandle extends System.MarshalByRefObject {
			/**
			 * Initializes an instance of the {@link System.Runtime.Remoting.ObjectHandle} class,
			 * wrapping the given object `o`.
			 */
			constructor(o: System.Object | undefined);

			/** Returns the wrapped object. */
			Unwrap(): System.Object | undefined;
		}
	}

	export namespace System.Runtime.InteropServices {
		/** Represents a wrapper class for handle resources. */
		export class CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements IDisposable {
			/** Gets a value indicating whether the handle is closed. */
			readonly IsClosed: boolean;

			/**
			 * When overridden in a derived class, gets a value indicating whether the handle value
			 * is invalid.
			 */
			readonly IsInvalid: boolean;

			/** Marks the handle for releasing and freeing resources. */
			Close(): void;

			/**
			 * Releases all resources used by the
			 * {@link System.Runtime.InteropServices.CriticalHandle}.
			 */
			dispose(): void;

			/** Marks a handle as invalid. */
			SetHandleAsInvalid(): void;
		}
	}

	export namespace System.Runtime.InteropServices {
		/**
		 * Represents a wrapper class for operating system handles. This class must be inherited.
		 */
		export class SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements IDisposable {
			/** Gets a value indicating whether the handle is closed. */
			readonly IsClosed: boolean;

			/**
			 * When overridden in a derived class, gets a value indicating whether the handle value
			 * is invalid.
			 */
			readonly IsInvalid: boolean;

			/** Marks the handle for releasing and freeing resources. */
			Close(): void;

			DangerousAddRef(success: boolean): void;

			/**
			 * Returns the value of the {@link System.Runtime.InteropServices.SafeHandle.handle}
			 * field.
			 */
			DangerousGetHandle(): System.IntPtr;

			/**
			 * Manually decrements the reference counter on a
			 * {@link System.Runtime.InteropServices.SafeHandle} instance.
			 */
			DangerousRelease(): void;

			/**
			 * Releases all resources used by the {@link System.Runtime.InteropServices.SafeHandle}
			 * class.
			 */
			dispose(): void;

			/** Marks a handle as no longer used. */
			SetHandleAsInvalid(): void;
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling {
		/**
		 * Specifies that this marshaller entry-point type is a contiguous collection marshaller.
		 */
		export class ContiguousCollectionMarshallerAttribute extends System.Attribute {
			/** Constructs a default instance of the attribute. */
			constructor();
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling {
		/** Indicates an entry point type for defining a marshaller. */
		export class CustomMarshallerAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute} class.
			 */
			constructor(
				managedType: System.Type,
				marshalMode: System.Runtime.InteropServices.Marshalling.MarshalMode,
				marshallerType: System.Type,
			);

			/** Gets the managed type to marshal. */
			readonly ManagedType: System.Type;

			/** Gets the marshalling mode this attribute applies to. */
			readonly MarshalMode: System.Runtime.InteropServices.Marshalling.MarshalMode;

			/** Gets the type used for marshalling. */
			readonly MarshallerType: System.Type;
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute {
		export class GenericPlaceholder extends System.ValueType {
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling {
		/** Represents the different marshalling modes. */
		export enum MarshalMode {
			/**
			 * All modes. A marshaller specified with this mode will be used if there's no specific
			 * marshaller for a given usage mode.
			 */
			Default = 0,

			/** By-value and in parameters in managed-to-unmanaged scenarios, like P/Invoke. */
			ManagedToUnmanagedIn = 1,

			/** ref parameters in managed-to-unmanaged scenarios, like P/Invoke. */
			ManagedToUnmanagedRef = 2,

			/** out parameters in managed-to-unmanaged scenarios, like P/Invoke. */
			ManagedToUnmanagedOut = 3,

			/**
			 * By-value and in parameters in unmanaged-to-managed scenarios, like Reverse P/Invoke.
			 */
			UnmanagedToManagedIn = 4,

			/** ref parameters in unmanaged-to-managed scenarios, like Reverse P/Invoke. */
			UnmanagedToManagedRef = 5,

			/** out parameters in unmanaged-to-managed scenarios, like Reverse P/Invoke. */
			UnmanagedToManagedOut = 6,

			/** Elements of arrays passed with in or by-value in interop scenarios. */
			ElementIn = 7,

			/**
			 * Elements of arrays passed with ref or passed by-value with both
			 * {@link System.Runtime.InteropServices.InAttribute} and
			 * {@link System.Runtime.InteropServices.OutAttribute} in interop scenarios.
			 */
			ElementRef = 8,

			/**
			 * Elements of arrays passed with out or passed by-value with only
			 * {@link System.Runtime.InteropServices.OutAttribute} in interop scenarios.
			 */
			ElementOut = 9,
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling {
		/**
		 * Attribute used to provide a default custom marshaller type for a given managed type.
		 */
		export class NativeMarshallingAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of
			 * {@link System.Runtime.InteropServices.Marshalling.NativeMarshallingAttribute} that
			 * provides a native marshalling type.
			 */
			constructor(nativeType: System.Type);

			/**
			 * Gets the marshaller type used to convert the attributed type from managed to native
			 * code.
			 */
			readonly NativeType: System.Type;
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling {
		/**
		 * [Generic type factory] Supports marshalling a {@link System.ReadOnlySpan<>} from
		 * managed value to a contiguous native array of the unmanaged values of the elements.
		 */
		export function ReadOnlySpanMarshaller$(T: IType, TUnmanagedElement: IType): typeof ReadOnlySpanMarshaller$2<any, any>;

		/**
		 * Supports marshalling a {@link System.ReadOnlySpan<>} from managed value to a
		 * contiguous native array of the unmanaged values of the elements.
		 */
		export class ReadOnlySpanMarshaller$2<T, TUnmanagedElement> {
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling.ReadOnlySpanMarshaller {
		export function ManagedToUnmanagedIn$(T: IType, TUnmanagedElement: IType): typeof ManagedToUnmanagedIn$2<any, any>;

		export class ManagedToUnmanagedIn$2<T, TUnmanagedElement> extends System.ValueType {
			static readonly BufferSize: number;

			FromManaged(
				managed: System.ReadOnlySpan$1<T>,
				buffer: System.Span$1<TUnmanagedElement>,
			): void;

			GetManagedValuesSource(): System.ReadOnlySpan$1<T>;

			GetUnmanagedValuesDestination(): System.Span$1<TUnmanagedElement>;

			GetPinnableReference(): TUnmanagedElement;

			Free(): void;

			static GetPinnableReference(managed: System.ReadOnlySpan$1<any>): any;
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling.ReadOnlySpanMarshaller {
		export function UnmanagedToManagedOut$(T: IType, TUnmanagedElement: IType): typeof UnmanagedToManagedOut$2<any, any>;

		export class UnmanagedToManagedOut$2<T, TUnmanagedElement> {
			static GetManagedValuesSource(managed: System.ReadOnlySpan$1<any>): System.ReadOnlySpan$1<any>;
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling {
		/**
		 * [Generic type factory] Marshals {@link System.Runtime.InteropServices.SafeHandle}
		 * -derived types following the lifetime rules for
		 * {@link System.Runtime.InteropServices.SafeHandle} objects.
		 */
		export function SafeHandleMarshaller$(T: IType): typeof SafeHandleMarshaller$1<any>;

		/**
		 * Marshals {@link System.Runtime.InteropServices.SafeHandle} -derived types following
		 * the lifetime rules for {@link System.Runtime.InteropServices.SafeHandle} objects.
		 */
		export class SafeHandleMarshaller$1<T> {
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling.SafeHandleMarshaller {
		export function ManagedToUnmanagedIn$(T: IType): typeof ManagedToUnmanagedIn$1<any>;

		export class ManagedToUnmanagedIn$1<T> extends System.ValueType {
			FromManaged(handle: T): void;

			ToUnmanaged(): System.IntPtr;

			Free(): void;
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling.SafeHandleMarshaller {
		export function ManagedToUnmanagedRef$(T: IType): typeof ManagedToUnmanagedRef$1<any>;

		export class ManagedToUnmanagedRef$1<T> extends System.ValueType {
			constructor();

			FromManaged(handle: T): void;

			ToUnmanaged(): System.IntPtr;

			FromUnmanaged(value: System.IntPtr): void;

			OnInvoked(): void;

			ToManagedFinally(): T;

			Free(): void;
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling.SafeHandleMarshaller {
		export function ManagedToUnmanagedOut$(T: IType): typeof ManagedToUnmanagedOut$1<any>;

		export class ManagedToUnmanagedOut$1<T> extends System.ValueType {
			constructor();

			FromUnmanaged(value: System.IntPtr): void;

			ToManaged(): T;

			Free(): void;
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling {
		/**
		 * [Generic type factory] Supports marshalling a {@link System.Span<>} from managed value
		 * to a contiguous native array of the unmanaged values of the elements.
		 */
		export function SpanMarshaller$(T: IType, TUnmanagedElement: IType): typeof SpanMarshaller$2<any, any>;

		/**
		 * Supports marshalling a {@link System.Span<>} from managed value to a contiguous native
		 * array of the unmanaged values of the elements.
		 */
		export class SpanMarshaller$2<T, TUnmanagedElement> {
			/** Gets a span of the managed collection elements. */
			static GetManagedValuesSource(managed: System.Span$1<any>): System.ReadOnlySpan$1<any>;

			/** Gets a span of the space where the managed collection elements should be stored. */
			static GetManagedValuesDestination(managed: System.Span$1<any>): System.Span$1<any>;
		}
	}

	export namespace System.Runtime.InteropServices.Marshalling.SpanMarshaller {
		export function ManagedToUnmanagedIn$(T: IType, TUnmanagedElement: IType): typeof ManagedToUnmanagedIn$2<any, any>;

		export class ManagedToUnmanagedIn$2<T, TUnmanagedElement> extends System.ValueType {
			static readonly BufferSize: number;

			FromManaged(
				managed: System.Span$1<T>,
				buffer: System.Span$1<TUnmanagedElement>,
			): void;

			GetManagedValuesSource(): System.ReadOnlySpan$1<T>;

			GetUnmanagedValuesDestination(): System.Span$1<TUnmanagedElement>;

			GetPinnableReference(): TUnmanagedElement;

			Free(): void;

			static GetPinnableReference(managed: System.Span$1<any>): any;
		}
	}

	export namespace System.Runtime.ExceptionServices {
		/** Represents an exception whose state is captured at a certain point in code. */
		export class ExceptionDispatchInfo {
			/** Gets the exception that's represented by the current instance. */
			readonly SourceException: System.Exception;

			/**
			 * Creates an {@link System.Runtime.ExceptionServices.ExceptionDispatchInfo} object that
			 * represents the specified exception at the current point in code.
			 */
			static Capture(source: System.Exception): System.Runtime.ExceptionServices.ExceptionDispatchInfo;

			/**
			 * Stores the current stack trace into the specified {@link System.Exception} instance.
			 */
			static SetCurrentStackTrace(source: System.Exception): System.Exception;

			/**
			 * Stores the provided stack trace into the specified {@link System.Exception} instance.
			 */
			static SetRemoteStackTrace(
				source: System.Exception,
				stackTrace: string,
			): System.Exception;

			/**
			 * Throws the exception that's represented by the current
			 * {@link System.Runtime.ExceptionServices.ExceptionDispatchInfo} object, after restoring
			 * the state that was saved when the exception was captured.
			 */
			Throw(): void;

			/**
			 * Throws the source exception, maintaining the original Watson information and
			 * augmenting rather than replacing the original stack trace.
			 */
			static Throw(source: System.Exception): void;
		}
	}

	export namespace System.Runtime.ExceptionServices {
		/**
		 * Provides data for the notification event that is raised when a managed exception first
		 * occurs, before the common language runtime begins searching for event handlers.
		 */
		export class FirstChanceExceptionEventArgs extends System.EventArgs {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs} class with a
			 * specified exception.
			 */
			constructor(exception: System.Exception);

			/**
			 * The managed exception object that corresponds to the exception thrown in managed code.
			 */
			readonly Exception: System.Exception;
		}
	}

	export namespace System.Runtime.ExceptionServices {
		/** Enables managed code to handle exceptions that indicate a corrupted process state. */
		export class HandleProcessCorruptedStateExceptionsAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute}
			 * class.
			 */
			constructor();
		}
	}

	export namespace System.Runtime.ConstrainedExecution {
		/** Specifies a method's behavior when called within a constrained execution region. */
		export enum Cer {
			/**
			 * The method, type, or assembly has no concept of a CER. It does not take advantage of
			 * CER guarantees.
			 */
			None = 0,

			/**
			 * In the face of exceptional conditions, the method might fail. In this case, the method
			 * will report back to the calling method whether it succeeded or failed. The method must
			 * have a CER around the method body to ensure that it can report the return value.
			 */
			MayFail = 1,

			/**
			 * In the face of exceptional conditions, the method is guaranteed to succeed. You should
			 * always construct a CER around the method that is called, even when it is called from
			 * within a non-CER region. A method is successful if it accomplishes what is intended.
			 * For example, marking {@link System.Collections.ArrayList.Count} with
			 * ReliabilityContractAttribute(Cer.Success) implies that when it is run under a CER, it
			 * always returns a count of the number of elements in the
			 * {@link System.Collections.ArrayList} and it can never leave the internal fields in an
			 * undetermined state.
			 */
			Success = 2,
		}
	}

	export namespace System.Runtime.ConstrainedExecution {
		/** Specifies a reliability contract. */
		export enum Consistency {
			/**
			 * In the face of exceptional conditions, the CLR makes no guarantees regarding state
			 * consistency; that is, the condition might corrupt the process.
			 */
			MayCorruptProcess = 0,

			/**
			 * In the face of exceptional conditions, the common language runtime (CLR) makes no
			 * guarantees regarding state consistency in the current application domain.
			 */
			MayCorruptAppDomain = 1,

			/**
			 * In the face of exceptional conditions, the method is guaranteed to limit state
			 * corruption to the current instance.
			 */
			MayCorruptInstance = 2,

			/**
			 * In the face of exceptional conditions, the method is guaranteed not to corrupt state.
			 * (This does not guarantee that the method will never fail; however, it does guarantee
			 * that such a failure will never corrupt state.)
			 */
			WillNotCorruptState = 3,
		}
	}

	export namespace System.Runtime.ConstrainedExecution {
		/** Ensures that all finalization code in derived classes is marked as critical. */
		export class CriticalFinalizerObject {
		}
	}

	export namespace System.Runtime.ConstrainedExecution {
		/**
		 * Instructs the native image generation service to prepare a method for inclusion in a
		 * constrained execution region (CER).
		 */
		export class PrePrepareMethodAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Runtime.ConstrainedExecution {
		/**
		 * Defines a contract for reliability between the author of some code, and the developers
		 * who have a dependency on that code.
		 */
		export class ReliabilityContractAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Runtime.ConstrainedExecution.ReliabilityContractAttribute} class with
			 * the specified {@link System.Runtime.ConstrainedExecution.Consistency} guarantee and
			 * {@link System.Runtime.ConstrainedExecution.Cer} value.
			 */
			constructor(
				consistencyGuarantee: System.Runtime.ConstrainedExecution.Consistency,
				cer: System.Runtime.ConstrainedExecution.Cer,
			);

			/**
			 * Gets the value that determines the behavior of a method, type, or assembly when called
			 * under a Constrained Execution Region (CER).
			 */
			readonly Cer: System.Runtime.ConstrainedExecution.Cer;

			/**
			 * Gets the value of the {@link System.Runtime.ConstrainedExecution.Consistency}
			 * reliability contract.
			 */
			readonly ConsistencyGuarantee: System.Runtime.ConstrainedExecution.Consistency;
		}
	}

	export namespace System.Resources {
		/** Provides the base functionality for reading data from resource files. */
		export interface IResourceReader extends
			System.Collections.IEnumerable,
			IDisposable {
			/** Closes the resource reader after releasing any resources associated with it. */
			Close(): void;

			/** Returns a dictionary enumerator of the resources for this reader. */
			GetEnumerator(): System.Collections.IDictionaryEnumerator;
		}
	}

	export namespace System.Resources {
		/**
		 * The exception that is thrown if the main assembly does not contain the resources for
		 * the neutral culture, and an appropriate satellite assembly is missing.
		 */
		export class MissingManifestResourceException extends System.SystemException {
			/**
			 * Initializes a new instance of the
			 * {@link System.Resources.MissingManifestResourceException} class with default
			 * properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Resources.MissingManifestResourceException} class with the specified
			 * error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Resources.MissingManifestResourceException} class with a specified error
			 * message and a reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System.Resources {
		/**
		 * The exception that is thrown when the satellite assembly for the resources of the
		 * default culture is missing.
		 */
		export class MissingSatelliteAssemblyException extends System.SystemException {
			/**
			 * Initializes a new instance of the
			 * {@link System.Resources.MissingSatelliteAssemblyException} class with default
			 * properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Resources.MissingSatelliteAssemblyException} class with the specified
			 * error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Resources.MissingSatelliteAssemblyException} class with a specified
			 * error message and a reference to the inner exception that is the cause of this
			 * exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Resources.MissingSatelliteAssemblyException} class with a specified
			 * error message and the name of a neutral culture.
			 */
			constructor(
				message: string | undefined,
				cultureName: string | undefined,
			);

			/** Gets the name of the default culture. */
			readonly CultureName?: string;
		}
	}

	export namespace System.Resources {
		/**
		 * Informs the resource manager of an app's default culture. This class cannot be
		 * inherited.
		 */
		export class NeutralResourcesLanguageAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Resources.NeutralResourcesLanguageAttribute} class.
			 */
			constructor(cultureName: string);

			/**
			 * Initializes a new instance of the
			 * {@link System.Resources.NeutralResourcesLanguageAttribute} class with the specified
			 * ultimate resource fallback location.
			 */
			constructor(
				cultureName: string,
				location: System.Resources.UltimateResourceFallbackLocation,
			);

			/** Gets the culture name. */
			readonly CultureName: string;

			/**
			 * Gets the location for the {@link System.Resources.ResourceManager} class to use to
			 * retrieve neutral resources by using the resource fallback process.
			 */
			readonly Location: System.Resources.UltimateResourceFallbackLocation;
		}
	}

	export namespace System.Resources {
		/**
		 * Represents a resource manager that provides convenient access to culture-specific
		 * resources at run time.
		 */
		export class ResourceManager {
			/**
			 * Initializes a new instance of the {@link System.Resources.ResourceManager} class that
			 * looks up resources contained in files with the specified root name in the given
			 * assembly.
			 */
			constructor(
				baseName: string,
				assembly: System.Reflection.Assembly,
			);

			/**
			 * Initializes a new instance of the {@link System.Resources.ResourceManager} class that
			 * uses a specified {@link System.Resources.ResourceSet} class to look up resources
			 * contained in files with the specified root name in the given assembly.
			 */
			constructor(
				baseName: string,
				assembly: System.Reflection.Assembly,
				usingResourceSet: System.Type | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.Resources.ResourceManager} class that
			 * looks up resources in satellite assemblies based on information from the specified
			 * type object.
			 */
			constructor(resourceSource: System.Type);

			/**
			 * Gets the root name of the resource files that the
			 * {@link System.Resources.ResourceManager} searches for resources.
			 */
			readonly BaseName: string;

			/**
			 * Gets or sets a value that indicates whether the resource manager allows
			 * case-insensitive resource lookups in the
			 * {@link System.Resources.ResourceManager.GetString(System.String)} and
			 * {@link System.Resources.ResourceManager.GetObject(System.String)} methods.
			 */
			IgnoreCase: boolean;

			/**
			 * Gets the type of the resource set object that the resource manager uses to construct a
			 * {@link System.Resources.ResourceSet} object.
			 */
			readonly ResourceSetType: System.Type;

			/**
			 * Returns a {@link System.Resources.ResourceManager} object that searches a specific
			 * directory instead of an assembly manifest for resources.
			 */
			static CreateFileBasedResourceManager(
				baseName: string,
				resourceDir: string,
				usingResourceSet: System.Type | undefined,
			): System.Resources.ResourceManager;

			/** Returns the value of the specified non-string resource. */
			GetObject(name: string): System.Object | undefined;

			/**
			 * Gets the value of the specified non-string resource localized for the specified
			 * culture.
			 */
			GetObject(
				name: string,
				culture: System.Globalization.CultureInfo | undefined,
			): System.Object | undefined;

			/** Retrieves the resource set for a particular culture. */
			GetResourceSet(
				culture: System.Globalization.CultureInfo,
				createIfNotExists: boolean,
				tryParents: boolean,
			): System.Resources.ResourceSet | undefined;

			/** Returns an unmanaged memory stream object from the specified resource. */
			GetStream(name: string): System.IO.UnmanagedMemoryStream | undefined;

			/**
			 * Returns an unmanaged memory stream object from the specified resource, using the
			 * specified culture.
			 */
			GetStream(
				name: string,
				culture: System.Globalization.CultureInfo | undefined,
			): System.IO.UnmanagedMemoryStream | undefined;

			/** Returns the value of the specified string resource. */
			GetString(name: string): string | undefined;

			/** Returns the value of the string resource localized for the specified culture. */
			GetString(
				name: string,
				culture: System.Globalization.CultureInfo | undefined,
			): string | undefined;

			/**
			 * Tells the resource manager to call the {@link System.Resources.ResourceSet.Close}
			 * method on all {@link System.Resources.ResourceSet} objects and release all resources.
			 */
			ReleaseAllResources(): void;
		}
	}

	export namespace System.Resources {
		/**
		 * Enumerates the resources in a binary resources (.resources) file by reading sequential
		 * resource name/value pairs.
		 */
		export class ResourceReader implements
			IDisposable {
			/**
			 * Initializes a new instance of the {@link System.Resources.ResourceReader} class for
			 * the specified stream.
			 */
			constructor(stream: Duplex);

			/**
			 * Initializes a new instance of the {@link System.Resources.ResourceReader} class for
			 * the specified named resource file.
			 */
			constructor(fileName: string);

			/**
			 * Releases all operating system resources associated with this
			 * {@link System.Resources.ResourceReader} object.
			 */
			Close(): void;

			/**
			 * Releases all resources used by the current instance of the
			 * {@link System.Resources.ResourceReader} class.
			 */
			dispose(): void;

			/** Returns an enumerator for this {@link System.Resources.ResourceReader} object. */
			GetEnumerator(): System.Collections.IDictionaryEnumerator;

			GetResourceData(resourceName: string): { resourceType: string, resourceData: number[] };
		}
	}

	export namespace System.Resources {
		/**
		 * Stores all the resources localized for one particular culture, ignoring all other
		 * cultures, including any fallback rules.
		 */
		export class ResourceSet implements
			IDisposable {
			/**
			 * Creates a new instance of the {@link System.Resources.ResourceSet} class using the
			 * system default {@link System.Resources.ResourceReader} that reads resources from the
			 * given stream.
			 */
			constructor(stream: Duplex);

			/**
			 * Creates a new instance of the {@link System.Resources.ResourceSet} class using the
			 * specified resource reader.
			 */
			constructor(reader: System.Resources.IResourceReader);

			/**
			 * Creates a new instance of the {@link System.Resources.ResourceSet} class using the
			 * system default {@link System.Resources.ResourceReader} that opens and reads resources
			 * from the given file.
			 */
			constructor(fileName: string);

			/**
			 * Closes and releases any resources used by this {@link System.Resources.ResourceSet}.
			 */
			Close(): void;

			/**
			 * Disposes of the resources (other than memory) used by the current instance of
			 * {@link System.Resources.ResourceSet}.
			 */
			dispose(): void;

			/**
			 * Returns the preferred resource reader class for this kind of
			 * {@link System.Resources.ResourceSet}.
			 */
			GetDefaultReader(): System.Type;

			/**
			 * Returns the preferred resource writer class for this kind of
			 * {@link System.Resources.ResourceSet}.
			 */
			GetDefaultWriter(): System.Type;

			/**
			 * Returns an {@link System.Collections.IDictionaryEnumerator} that can iterate through
			 * the {@link System.Resources.ResourceSet}.
			 */
			GetEnumerator(): System.Collections.IDictionaryEnumerator;

			/** Searches for a resource object with the specified name. */
			GetObject(name: string): System.Object | undefined;

			/**
			 * Searches for a resource object with the specified name in a case-insensitive manner,
			 * if requested.
			 */
			GetObject(
				name: string,
				ignoreCase: boolean,
			): System.Object | undefined;

			/** Searches for a {@link System.String} resource with the specified name. */
			GetString(name: string): string | undefined;

			/**
			 * Searches for a {@link System.String} resource with the specified name in a
			 * case-insensitive manner, if requested.
			 */
			GetString(
				name: string,
				ignoreCase: boolean,
			): string | undefined;
		}
	}

	export namespace System.Resources {
		/**
		 * Instructs a {@link System.Resources.ResourceManager} object to ask for a particular
		 * version of a satellite assembly.
		 */
		export class SatelliteContractVersionAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Resources.SatelliteContractVersionAttribute} class.
			 */
			constructor(version: string);

			/** Gets the version of the satellite assemblies with the required resources. */
			readonly Version: string;
		}
	}

	export namespace System.Resources {
		/**
		 * Specifies whether a {@link System.Resources.ResourceManager} object looks for the
		 * resources of the app's default culture in the main assembly or in a satellite
		 * assembly.
		 */
		export enum UltimateResourceFallbackLocation {
			/** Fallback resources are located in the main assembly. */
			MainAssembly = 0,

			/** Fallback resources are located in a satellite assembly. */
			Satellite = 1,
		}
	}

	export namespace System.Reflection {
		/**
		 * The exception that is thrown when binding to a member results in more than one member
		 * matching the binding criteria. This class cannot be inherited.
		 */
		export class AmbiguousMatchException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AmbiguousMatchException}
			 * class with an empty message string and the root cause exception set to `null`.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Reflection.AmbiguousMatchException}
			 * class with its message string set to the given message and the root cause exception
			 * set to `null`.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.Reflection.AmbiguousMatchException}
			 * class with a specified error message and a reference to the inner exception that is
			 * the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System.Reflection {
		/**
		 * Represents an assembly, which is a reusable, versionable, and self-describing building
		 * block of a common language runtime application.
		 */
		export class Assembly implements System.Reflection.ICustomAttributeProvider {
			/**
			 * Gets the location of the assembly as specified originally, for example, in an
			 * {@link System.Reflection.AssemblyName} object.
			 */
			readonly CodeBase?: string;

			/** Gets a collection that contains this assembly's custom attributes. */
			readonly CustomAttributes: Iterable<System.Reflection.CustomAttributeData>;

			/** Gets a collection of the types defined in this assembly. */
			readonly DefinedTypes: Iterable<System.Reflection.TypeInfo>;

			/** Gets the entry point of this assembly. */
			readonly EntryPoint?: System.Reflection.MethodInfo;

			/** Gets the URI, including escape characters, that represents the codebase. */
			readonly EscapedCodeBase: string;

			/**
			 * Gets a collection of the public types defined in this assembly that are visible
			 * outside the assembly.
			 */
			readonly ExportedTypes: Iterable<System.Type>;

			/** Gets the display name of the assembly. */
			readonly FullName?: string;

			/**
			 * Gets a value indicating whether the assembly was loaded from the global assembly cache
			 * (.NET Framework only).
			 */
			readonly GlobalAssemblyCache: boolean;

			/** Gets the host context with which the assembly was loaded. */
			readonly HostContext: number;

			/**
			 * Gets a string representing the version of the common language runtime (CLR) saved in
			 * the file containing the manifest.
			 */
			readonly ImageRuntimeVersion: string;

			/**
			 * Gets a value that indicates whether this assembly is held in a collectible
			 * {@link System.Runtime.Loader.AssemblyLoadContext}.
			 */
			readonly IsCollectible: boolean;

			/**
			 * Gets a value that indicates whether the current assembly was generated dynamically in
			 * the current process by using reflection emit.
			 */
			readonly IsDynamic: boolean;

			/**
			 * Gets a value that indicates whether the current assembly is loaded with full trust.
			 */
			readonly IsFullyTrusted: boolean;

			/** Gets the full path or UNC location of the loaded file that contains the manifest. */
			readonly Location: string;

			/** Gets the module that contains the manifest for the current assembly. */
			readonly ManifestModule: System.Reflection.Module;

			/** Gets a collection that contains the modules in this assembly. */
			readonly Modules: Iterable<System.Reflection.Module>;

			/**
			 * Gets a {@link System.Boolean} value indicating whether this assembly was loaded into
			 * the reflection-only context.
			 */
			readonly ReflectionOnly: boolean;

			/**
			 * Gets a value that indicates which set of security rules the common language runtime
			 * (CLR) enforces for this assembly.
			 */
			readonly SecurityRuleSet: System.Security.SecurityRuleSet;

			/**
			 * Locates the specified type from this assembly and creates an instance of it using the
			 * system activator, using case-sensitive search.
			 */
			CreateInstance(typeName: string): System.Object | undefined;

			/**
			 * Locates the specified type from this assembly and creates an instance of it using the
			 * system activator, with optional case-sensitive search.
			 */
			CreateInstance(
				typeName: string,
				ignoreCase: boolean,
			): System.Object | undefined;

			/**
			 * Locates the specified type from this assembly and creates an instance of it using the
			 * system activator, with optional case-sensitive search and having the specified
			 * culture, arguments, and binding and activation attributes.
			 */
			CreateInstance(
				typeName: string,
				ignoreCase: boolean,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				args: System.Object[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				activationAttributes: System.Object[] | undefined,
			): System.Object | undefined;

			/** Creates the name of a type qualified by the display name of its assembly. */
			static CreateQualifiedName(
				assemblyName: string | undefined,
				typeName: string | undefined,
			): string;

			/** Determines whether this assembly and the specified object are equal. */
			Equals(o: System.Object | undefined): boolean;

			/** Gets the currently loaded assembly in which the specified type is defined. */
			static GetAssembly(type: System.Type): System.Reflection.Assembly | undefined;

			/**
			 * Returns the {@link System.Reflection.Assembly} of the method that invoked the
			 * currently executing method.
			 */
			static GetCallingAssembly(): System.Reflection.Assembly;

			/** Gets all the custom attributes for this assembly. */
			GetCustomAttributes(inherit: boolean): System.Object[];

			/** Gets the custom attributes for this assembly as specified by type. */
			GetCustomAttributes(
				attributeType: System.Type,
				inherit: boolean,
			): System.Object[];

			/**
			 * Returns information about the attributes that have been applied to the current
			 * {@link System.Reflection.Assembly}, expressed as
			 * {@link System.Reflection.CustomAttributeData} objects.
			 */
			GetCustomAttributesData(): System.Reflection.CustomAttributeData[];

			/**
			 * Gets the process executable in the default application domain. In other application
			 * domains, this is the first executable that was executed by
			 * {@link System.AppDomain.ExecuteAssembly(System.String)}.
			 */
			static GetEntryAssembly(): System.Reflection.Assembly | undefined;

			/** Gets the assembly that contains the code that is currently executing. */
			static GetExecutingAssembly(): System.Reflection.Assembly;

			/**
			 * Gets the public types defined in this assembly that are visible outside the assembly.
			 */
			GetExportedTypes(): System.Type[];

			/**
			 * Gets a {@link System.IO.FileStream} for the specified file in the file table of the
			 * manifest of this assembly.
			 */
			GetFile(name: string): System.IO.FileStream | undefined;

			/** Gets the files in the file table of an assembly manifest. */
			GetFiles(): System.IO.FileStream[];

			/**
			 * Gets the files in the file table of an assembly manifest, specifying whether to
			 * include resource modules.
			 */
			GetFiles(getResourceModules: boolean): System.IO.FileStream[];

			GetForwardedTypes(): System.Type[];

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Gets all the loaded modules that are part of this assembly. */
			GetLoadedModules(): System.Reflection.Module[];

			/**
			 * Gets all the loaded modules that are part of this assembly, specifying whether to
			 * include resource modules.
			 */
			GetLoadedModules(getResourceModules: boolean): System.Reflection.Module[];

			/** Returns information about how the given resource has been persisted. */
			GetManifestResourceInfo(resourceName: string): System.Reflection.ManifestResourceInfo | undefined;

			/** Returns the names of all the resources in this assembly. */
			GetManifestResourceNames(): string[];

			/** Loads the specified manifest resource from this assembly. */
			GetManifestResourceStream(name: string): Duplex | undefined;

			/**
			 * Loads the specified manifest resource, scoped by the namespace of the specified type,
			 * from this assembly.
			 */
			GetManifestResourceStream(
				type: System.Type,
				name: string,
			): Duplex | undefined;

			/** Gets the specified module in this assembly. */
			GetModule(name: string): System.Reflection.Module | undefined;

			/** Gets all the modules that are part of this assembly. */
			GetModules(): System.Reflection.Module[];

			/**
			 * Gets all the modules that are part of this assembly, specifying whether to include
			 * resource modules.
			 */
			GetModules(getResourceModules: boolean): System.Reflection.Module[];

			/** Gets an {@link System.Reflection.AssemblyName} for this assembly. */
			GetName(): System.Reflection.AssemblyName;

			/**
			 * Gets an {@link System.Reflection.AssemblyName} for this assembly, setting the codebase
			 * as specified by `copiedName`.
			 */
			GetName(copiedName: boolean): System.Reflection.AssemblyName;

			/**
			 * Gets the {@link System.Reflection.AssemblyName} objects for all the assemblies
			 * referenced by this assembly.
			 */
			GetReferencedAssemblies(): System.Reflection.AssemblyName[];

			/** Gets the satellite assembly for the specified culture. */
			GetSatelliteAssembly(culture: System.Globalization.CultureInfo): System.Reflection.Assembly;

			/** Gets the specified version of the satellite assembly for the specified culture. */
			GetSatelliteAssembly(
				culture: System.Globalization.CultureInfo,
				version: System.Version | undefined,
			): System.Reflection.Assembly;

			/**
			 * Gets the {@link System.Type} object with the specified name in the assembly instance.
			 */
			GetType(name: string): System.Type | undefined;

			/**
			 * Gets the {@link System.Type} object with the specified name in the assembly instance
			 * and optionally throws an exception if the type is not found.
			 */
			GetType(
				name: string,
				throwOnError: boolean,
			): System.Type | undefined;

			/**
			 * Gets the {@link System.Type} object with the specified name in the assembly instance,
			 * with the options of ignoring the case, and of throwing an exception if the type is not
			 * found.
			 */
			GetType(
				name: string,
				throwOnError: boolean,
				ignoreCase: boolean,
			): System.Type | undefined;

			/** Gets all types defined in this assembly. */
			GetTypes(): System.Type[];

			/** Indicates whether or not a specified attribute has been applied to the assembly. */
			IsDefined(
				attributeType: System.Type,
				inherit: boolean,
			): boolean;

			/**
			 * Loads the assembly with a common object file format (COFF)-based image containing an
			 * emitted assembly. The assembly is loaded into the application domain of the caller.
			 */
			static Load(rawAssembly: number[]): System.Reflection.Assembly;

			/**
			 * Loads the assembly with a common object file format (COFF)-based image containing an
			 * emitted assembly, optionally including symbols for the assembly. The assembly is
			 * loaded into the application domain of the caller.
			 */
			static Load(
				rawAssembly: number[],
				rawSymbolStore: number[] | undefined,
			): System.Reflection.Assembly;

			/** Loads an assembly given its {@link System.Reflection.AssemblyName}. */
			static Load(assemblyRef: System.Reflection.AssemblyName): System.Reflection.Assembly;

			/** Loads an assembly with the specified name. */
			static Load(assemblyString: string): System.Reflection.Assembly;

			/** Loads the contents of an assembly file on the specified path. */
			static LoadFile(path: string): System.Reflection.Assembly;

			/** Loads an assembly given its file name or path. */
			static LoadFrom(assemblyFile: string): System.Reflection.Assembly;

			/** Loads an assembly given its file name or path, hash value, and hash algorithm. */
			static LoadFrom(
				assemblyFile: string,
				hashValue: number[] | undefined,
				hashAlgorithm: System.Configuration.Assemblies.AssemblyHashAlgorithm,
			): System.Reflection.Assembly;

			/**
			 * Loads the module, internal to this assembly, with a common object file format
			 * (COFF)-based image containing an emitted module, or a resource file.
			 */
			LoadModule(
				moduleName: string,
				rawModule: number[] | undefined,
			): System.Reflection.Module;

			/**
			 * Loads the module, internal to this assembly, with a common object file format
			 * (COFF)-based image containing an emitted module, or a resource file. The raw bytes
			 * representing the symbols for the module are also loaded.
			 */
			LoadModule(
				moduleName: string,
				rawModule: number[] | undefined,
				rawSymbolStore: number[] | undefined,
			): System.Reflection.Module;

			/**
			 * Loads an assembly from the application directory or from the global assembly cache
			 * using a partial name.
			 */
			static LoadWithPartialName(partialName: string): System.Reflection.Assembly | undefined;

			/**
			 * Loads the assembly from a common object file format (COFF)-based image containing an
			 * emitted assembly. The assembly is loaded into the reflection-only context of the
			 * caller's application domain.
			 */
			static ReflectionOnlyLoad(rawAssembly: number[]): System.Reflection.Assembly;

			/** Loads an assembly into the reflection-only context, given its display name. */
			static ReflectionOnlyLoad(assemblyString: string): System.Reflection.Assembly;

			/** Loads an assembly into the reflection-only context, given its path. */
			static ReflectionOnlyLoadFrom(assemblyFile: string): System.Reflection.Assembly;

			/** Returns the full name of the assembly, also known as the display name. */
			ToString(): string;

			/** Loads an assembly into the load-from context, bypassing some security checks. */
			static UnsafeLoadFrom(assemblyFile: string): System.Reflection.Assembly;
		}
	}

	export namespace System.Reflection {
		/**
		 * Specifies an algorithm to hash all files in an assembly. This class cannot be
		 * inherited.
		 */
		export class AssemblyAlgorithmIdAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.AssemblyAlgorithmIdAttribute} class with the specified hash
			 * algorithm, using one of the members of
			 * {@link System.Configuration.Assemblies.AssemblyHashAlgorithm} to represent the hash
			 * algorithm.
			 */
			constructor(algorithmId: System.Configuration.Assemblies.AssemblyHashAlgorithm);

			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.AssemblyAlgorithmIdAttribute} class with the specified hash
			 * algorithm, using an unsigned integer to represent the hash algorithm.
			 */
			constructor(algorithmId: number);

			/** Gets the hash algorithm of an assembly manifest's contents. */
			readonly AlgorithmId: number;
		}
	}

	export namespace System.Reflection {
		/** Defines a company name custom attribute for an assembly manifest. */
		export class AssemblyCompanyAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyCompanyAttribute}
			 * class.
			 */
			constructor(company: string);

			/** Gets company name information. */
			readonly Company: string;
		}
	}

	export namespace System.Reflection {
		/** Specifies the build configuration, such as retail or debug, for an assembly. */
		export class AssemblyConfigurationAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.AssemblyConfigurationAttribute} class.
			 */
			constructor(configuration: string);

			/** Gets assembly configuration information. */
			readonly Configuration: string;
		}
	}

	export namespace System.Reflection {
		/** Provides information about the type of code contained in an assembly. */
		export enum AssemblyContentType {
			/** The assembly contains .NET code. */
			Default = 0,

			/** The assembly contains Windows Runtime code. */
			WindowsRuntime = 1,
		}
	}

	export namespace System.Reflection {
		/** Defines a copyright custom attribute for an assembly manifest. */
		export class AssemblyCopyrightAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyCopyrightAttribute}
			 * class.
			 */
			constructor(copyright: string);

			/** Gets copyright information. */
			readonly Copyright: string;
		}
	}

	export namespace System.Reflection {
		/** Specifies which culture the assembly supports. */
		export class AssemblyCultureAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyCultureAttribute}
			 * class with the culture supported by the assembly being attributed.
			 */
			constructor(culture: string);

			/** Gets the supported culture of the attributed assembly. */
			readonly Culture: string;
		}
	}

	export namespace System.Reflection {
		/** Defines a friendly default alias for an assembly manifest. */
		export class AssemblyDefaultAliasAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.AssemblyDefaultAliasAttribute} class.
			 */
			constructor(defaultAlias: string);

			/** Gets default alias information. */
			readonly DefaultAlias: string;
		}
	}

	export namespace System.Reflection {
		/** Specifies that the assembly is not fully signed when created. */
		export class AssemblyDelaySignAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyDelaySignAttribute}
			 * class.
			 */
			constructor(delaySign: boolean);

			/** Gets a value indicating the state of the attribute. */
			readonly DelaySign: boolean;
		}
	}

	export namespace System.Reflection {
		/** Provides a text description for an assembly. */
		export class AssemblyDescriptionAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.AssemblyDescriptionAttribute} class.
			 */
			constructor(description: string);

			/** Gets assembly description information. */
			readonly Description: string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Instructs a compiler to use a specific version number for the Win32 file version
		 * resource. The Win32 file version is not required to be the same as the assembly's
		 * version number.
		 */
		export class AssemblyFileVersionAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.AssemblyFileVersionAttribute} class, specifying the file
			 * version.
			 */
			constructor(version: string);

			/** Gets the Win32 file version resource name. */
			readonly Version: string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Specifies a bitwise combination of {@link System.Reflection.AssemblyNameFlags} flags
		 * for an assembly, describing just-in-time (JIT) compiler options, whether the assembly
		 * is retargetable, and whether it has a full or tokenized public key. This class cannot
		 * be inherited.
		 */
		export class AssemblyFlagsAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyFlagsAttribute}
			 * class with the specified combination of {@link System.Reflection.AssemblyNameFlags}
			 * flags, cast as an integer value.
			 */
			constructor(assemblyFlags: number);

			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyFlagsAttribute}
			 * class with the specified combination of {@link System.Reflection.AssemblyNameFlags}
			 * flags.
			 */
			constructor(assemblyFlags: System.Reflection.AssemblyNameFlags);

			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyFlagsAttribute}
			 * class with the specified combination of {@link System.Reflection.AssemblyNameFlags}
			 * flags, cast as an unsigned integer value.
			 */
			constructor(flags: number);

			/**
			 * Gets an integer value representing the combination of
			 * {@link System.Reflection.AssemblyNameFlags} flags specified when this attribute
			 * instance was created.
			 */
			readonly AssemblyFlags: number;

			/**
			 * Gets an unsigned integer value representing the combination of
			 * {@link System.Reflection.AssemblyNameFlags} flags specified when this attribute
			 * instance was created.
			 */
			readonly Flags: number;
		}
	}

	export namespace System.Reflection {
		/** Defines additional version information for an assembly manifest. */
		export class AssemblyInformationalVersionAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.AssemblyInformationalVersionAttribute} class.
			 */
			constructor(informationalVersion: string);

			/** Gets version information. */
			readonly InformationalVersion: string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Specifies the name of a file containing the key pair used to generate a strong name.
		 */
		export class AssemblyKeyFileAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the `AssemblyKeyFileAttribute` class with the name of
			 * the file containing the key pair to generate a strong name for the assembly being
			 * attributed.
			 */
			constructor(keyFile: string);

			/**
			 * Gets the name of the file containing the key pair used to generate a strong name for
			 * the attributed assembly.
			 */
			readonly KeyFile: string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Specifies the name of a key container within the CSP containing the key pair used to
		 * generate a strong name.
		 */
		export class AssemblyKeyNameAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyKeyNameAttribute}
			 * class with the name of the container holding the key pair used to generate a strong
			 * name for the assembly being attributed.
			 */
			constructor(keyName: string);

			/**
			 * Gets the name of the container having the key pair that is used to generate a strong
			 * name for the attributed assembly.
			 */
			readonly KeyName: string;
		}
	}

	export namespace System.Reflection {
		/** Defines a key/value metadata pair for the decorated assembly. */
		export class AssemblyMetadataAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyMetadataAttribute}
			 * class by using the specified metadata key and value.
			 */
			constructor(
				key: string,
				value: string | undefined,
			);

			/** Gets the metadata key. */
			readonly Key: string;

			/** Gets the metadata value. */
			readonly Value?: string;
		}
	}

	export namespace System.Reflection {
		/** Describes an assembly's unique identity in full. */
		export class AssemblyName implements System.ICloneable {
			/** Initializes a new instance of the {@link System.Reflection.AssemblyName} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyName} class with
			 * the specified display name.
			 */
			constructor(assemblyName: string);

			/** Gets or sets the location of the assembly as a URL. */
			CodeBase?: string;

			/** Gets or sets a value that indicates what type of content the assembly contains. */
			ContentType: System.Reflection.AssemblyContentType;

			/** Gets or sets the culture supported by the assembly. */
			CultureInfo?: System.Globalization.CultureInfo;

			/** Gets or sets the name of the culture associated with the assembly. */
			CultureName?: string;

			/** Gets the URI, including escape characters, that represents the codebase. */
			readonly EscapedCodeBase?: string;

			/** Gets or sets the attributes of the assembly. */
			Flags: System.Reflection.AssemblyNameFlags;

			/** Gets the full name of the assembly, also known as the display name. */
			readonly FullName: string;

			/** Gets or sets the hash algorithm used by the assembly manifest. */
			HashAlgorithm: System.Configuration.Assemblies.AssemblyHashAlgorithm;

			/**
			 * Gets or sets the public and private cryptographic key pair that is used to create a
			 * strong name signature for the assembly.
			 */
			KeyPair?: System.Reflection.StrongNameKeyPair;

			/**
			 * Gets or sets the simple name of the assembly. This is usually, but not necessarily,
			 * the file name of the manifest file of the assembly, minus its extension.
			 */
			Name?: string;

			/**
			 * Gets or sets a value that identifies the processor and bits-per-word of the platform
			 * targeted by an executable.
			 */
			ProcessorArchitecture: System.Reflection.ProcessorArchitecture;

			/** Gets or sets the major, minor, build, and revision numbers of the assembly. */
			Version?: System.Version;

			/**
			 * Gets or sets the information related to the assembly's compatibility with other
			 * assemblies.
			 */
			VersionCompatibility: System.Configuration.Assemblies.AssemblyVersionCompatibility;

			/** Makes a copy of this {@link System.Reflection.AssemblyName} object. */
			Clone(): System.Object;

			/** Gets the {@link System.Reflection.AssemblyName} for a given file. */
			static GetAssemblyName(assemblyFile: string): System.Reflection.AssemblyName;

			/** Gets the public key of the assembly. */
			GetPublicKey(): number[] | undefined;

			/**
			 * Gets the public key token, which is the last 8 bytes of the SHA-1 hash of the public
			 * key under which the application or assembly is signed.
			 */
			GetPublicKeyToken(): number[] | undefined;

			/**
			 * Implements the {@link System.Runtime.Serialization.ISerializable} interface and is
			 * called back by the deserialization event when deserialization is complete.
			 */
			OnDeserialization(sender: System.Object | undefined): void;

			/**
			 * Returns a value indicating whether two assembly names are the same. The comparison is
			 * based on the simple assembly names.
			 */
			static ReferenceMatchesDefinition(
				reference: System.Reflection.AssemblyName | undefined,
				definition: System.Reflection.AssemblyName | undefined,
			): boolean;

			/** Sets the public key identifying the assembly. */
			SetPublicKey(publicKey: number[] | undefined): void;

			/**
			 * Sets the public key token, which is the last 8 bytes of the SHA-1 hash of the public
			 * key under which the application or assembly is signed.
			 */
			SetPublicKeyToken(publicKeyToken: number[] | undefined): void;

			/** Returns the full name of the assembly, also known as the display name. */
			ToString(): string;
		}
	}

	export namespace System.Reflection {
		/** Provides information about an {@link System.Reflection.Assembly} reference. */
		export enum AssemblyNameFlags {
			/** Specifies that no flags are in effect. */
			None = 0,

			/**
			 * Specifies that a public key is formed from the full public key rather than the public
			 * key token.
			 */
			PublicKey = 1,

			/**
			 * Specifies that the assembly can be retargeted at runtime to an assembly from a
			 * different publisher. This value supports the .NET Framework infrastructure and is not
			 * intended to be used directly from your code.
			 */
			Retargetable = 256,

			/**
			 * Specifies that just-in-time (JIT) compiler optimization is disabled for the assembly.
			 * This is the exact opposite of the meaning that is suggested by the member name.
			 */
			EnableJITcompileOptimizer = 16384,

			/** Specifies that just-in-time (JIT) compiler tracking is enabled for the assembly. */
			EnableJITcompileTracking = 32768,
		}
	}

	export namespace System.Reflection {
		/** Provides a remotable version of the `AssemblyName`. */
		export class AssemblyNameProxy extends System.MarshalByRefObject {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyNameProxy} class.
			 */
			constructor();

			/** Gets the `AssemblyName` for a given file. */
			GetAssemblyName(assemblyFile: string): System.Reflection.AssemblyName;
		}
	}

	export namespace System.Reflection {
		/** Defines a product name custom attribute for an assembly manifest. */
		export class AssemblyProductAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyProductAttribute}
			 * class.
			 */
			constructor(product: string);

			/** Gets product name information. */
			readonly Product: string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Provides migration from an older, simpler strong name key to a larger key with a
		 * stronger hashing algorithm.
		 */
		export class AssemblySignatureKeyAttribute extends System.Attribute {
			/**
			 * Creates a new instance of the {@link System.Reflection.AssemblySignatureKeyAttribute}
			 * class by using the specified public key and countersignature.
			 */
			constructor(
				publicKey: string,
				countersignature: string,
			);

			/** Gets the countersignature for the strong name for this assembly. */
			readonly Countersignature: string;

			/** Gets the public key for the strong name used to sign the assembly. */
			readonly PublicKey: string;
		}
	}

	export namespace System.Reflection {
		/** Specifies a description for an assembly. */
		export class AssemblyTitleAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyTitleAttribute}
			 * class.
			 */
			constructor(title: string);

			/** Gets assembly title information. */
			readonly Title: string;
		}
	}

	export namespace System.Reflection {
		/** Defines a trademark custom attribute for an assembly manifest. */
		export class AssemblyTrademarkAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.AssemblyTrademarkAttribute}
			 * class.
			 */
			constructor(trademark: string);

			/** Gets trademark information. */
			readonly Trademark: string;
		}
	}

	export namespace System.Reflection {
		/** Specifies the version of the assembly being attributed. */
		export class AssemblyVersionAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the `AssemblyVersionAttribute` class with the version
			 * number of the assembly being attributed.
			 */
			constructor(version: string);

			/** Gets the version number of the attributed assembly. */
			readonly Version: string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Selects a member from a list of candidates, and performs type conversion from actual
		 * argument type to formal argument type.
		 */
		export class Binder {
			/** Selects a field from the given set of fields, based on the specified criteria. */
			BindToField(
				bindingAttr: System.Reflection.BindingFlags,
				match: System.Reflection.FieldInfo[],
				value: System.Object,
				culture: System.Globalization.CultureInfo | undefined,
			): System.Reflection.FieldInfo;

			BindToMethod(
				bindingAttr: System.Reflection.BindingFlags,
				match: System.Reflection.MethodBase[],
				args: System.Object[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				names: string[] | undefined,
			): { result: System.Reflection.MethodBase, args: System.Object[], state?: System.Object };

			/** Changes the type of the given `Object` to the given `Type`. */
			ChangeType(
				value: System.Object,
				type: System.Type,
				culture: System.Globalization.CultureInfo | undefined,
			): System.Object;

			ReorderArgumentArray(
				args: System.Object[],
				state: System.Object,
			): void;

			/** Selects a method from the given set of methods, based on the argument type. */
			SelectMethod(
				bindingAttr: System.Reflection.BindingFlags,
				match: System.Reflection.MethodBase[],
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.MethodBase | undefined;

			/**
			 * Selects a property from the given set of properties, based on the specified criteria.
			 */
			SelectProperty(
				bindingAttr: System.Reflection.BindingFlags,
				match: System.Reflection.PropertyInfo[],
				returnType: System.Type | undefined,
				indexes: System.Type[] | undefined,
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.PropertyInfo | undefined;
		}
	}

	export namespace System.Reflection {
		/**
		 * Specifies flags that control binding and the way in which the search for members and
		 * types is conducted by reflection.
		 */
		export enum BindingFlags {
			/** Specifies that no binding flags are defined. */
			Default = 0,

			/** Specifies that the case of the member name should not be considered when binding. */
			IgnoreCase = 1,

			/**
			 * Specifies that only members declared at the level of the supplied type's hierarchy
			 * should be considered. Inherited members are not considered.
			 */
			DeclaredOnly = 2,

			/** Specifies that instance members are to be included in the search. */
			Instance = 4,

			/** Specifies that static members are to be included in the search. */
			Static = 8,

			/** Specifies that public members are to be included in the search. */
			Public = 16,

			/** Specifies that non-public members are to be included in the search. */
			NonPublic = 32,

			/**
			 * Specifies that public and protected static members up the hierarchy should be
			 * returned. Private static members in inherited classes are not returned. Static members
			 * include fields, methods, events, and properties. Nested types are not returned.
			 */
			FlattenHierarchy = 64,

			/**
			 * Specifies that a method is to be invoked. This must not be a constructor or a type
			 * initializer.    This flag is passed to an `InvokeMember` method to invoke a method.
			 */
			InvokeMethod = 256,

			/**
			 * Specifies that reflection should create an instance of the specified type. Calls the
			 * constructor that matches the given arguments. The supplied member name is ignored. If
			 * the type of lookup is not specified, (Instance | Public) will apply. It is not
			 * possible to call a type initializer.    This flag is passed to an `InvokeMember`
			 * method to invoke a constructor.
			 */
			CreateInstance = 512,

			/**
			 * Specifies that the value of the specified field should be returned.    This flag is
			 * passed to an `InvokeMember` method to get a field value.
			 */
			GetField = 1024,

			/**
			 * Specifies that the value of the specified field should be set.    This flag is passed
			 * to an `InvokeMember` method to set a field value.
			 */
			SetField = 2048,

			/**
			 * Specifies that the value of the specified property should be returned.    This flag is
			 * passed to an `InvokeMember` method to invoke a property getter.
			 */
			GetProperty = 4096,

			/**
			 * Specifies that the value of the specified property should be set. For COM properties,
			 * specifying this binding flag is equivalent to specifying `PutDispProperty` and
			 * `PutRefDispProperty`.    This flag is passed to an `InvokeMember` method to invoke a
			 * property setter.
			 */
			SetProperty = 8192,

			/**
			 * Specifies that the `PROPPUT` member on a COM object should be invoked. `PROPPUT`
			 * specifies a property-setting function that uses a value. Use `PutDispProperty` if a
			 * property has both `PROPPUT` and `PROPPUTREF` and you need to distinguish which one is
			 * called.
			 */
			PutDispProperty = 16384,

			/**
			 * Specifies that the `PROPPUTREF` member on a COM object should be invoked. `PROPPUTREF`
			 * specifies a property-setting function that uses a reference instead of a value. Use
			 * `PutRefDispProperty` if a property has both `PROPPUT` and `PROPPUTREF` and you need to
			 * distinguish which one is called.
			 */
			PutRefDispProperty = 32768,

			/**
			 * Specifies that types of the supplied arguments must exactly match the types of the
			 * corresponding formal parameters. Reflection throws an exception if the caller supplies
			 * a non-null `Binder` object, since that implies that the caller is supplying
			 * `BindToXXX` implementations that will pick the appropriate method. The default binder
			 * ignores this flag, while custom binders can implement the semantics of this flag.
			 */
			ExactBinding = 65536,

			/** Not implemented. */
			SuppressChangeType = 131072,

			/**
			 * Returns the set of members whose parameter count matches the number of supplied
			 * arguments. This binding flag is used for methods with parameters that have default
			 * values and methods with variable arguments (varargs). This flag should only be used
			 * with
			 * {@link System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])}.
			 *   Parameters with default values are used only in calls where trailing arguments are
			 * omitted. They must be the last arguments.
			 */
			OptionalParamBinding = 262144,

			/** Used in COM interop to specify that the return value of the member can be ignored. */
			IgnoreReturn = 16777216,

			DoNotWrapExceptions = 33554432,
		}
	}

	export namespace System.Reflection {
		/** Defines the valid calling conventions for a method. */
		export enum CallingConventions {
			/**
			 * Specifies the default calling convention as determined by the common language runtime.
			 * Use this calling convention for static methods. For instance or virtual methods use
			 * `HasThis`.
			 */
			Standard = 1,

			/** Specifies the calling convention for methods with variable arguments. */
			VarArgs = 2,

			/**
			 * Specifies that either the `Standard` or the `VarArgs` calling convention may be used.
			 */
			Any = 3,

			/**
			 * Specifies an instance or virtual method (not a static method). At run-time, the called
			 * method is passed a pointer to the target object as its first argument (the `this`
			 * pointer). The signature stored in metadata does not include the type of this first
			 * argument, because the method is known and its owner class can be discovered from
			 * metadata.
			 */
			HasThis = 32,

			/**
			 * Specifies that the signature is a function-pointer signature, representing a call to
			 * an instance or virtual method (not a static method). If `ExplicitThis` is set,
			 * `HasThis` must also be set. The first argument passed to the called method is still a
			 * `this` pointer, but the type of the first argument is now unknown. Therefore, a token
			 * that describes the type (or class) of the `this` pointer is explicitly stored into its
			 * metadata signature.
			 */
			ExplicitThis = 64,
		}
	}

	export namespace System.Reflection {
		/**
		 * Discovers the attributes of a class constructor and provides access to constructor
		 * metadata.
		 */
		export class ConstructorInfo extends System.Reflection.MethodBase implements System.Reflection.ICustomAttributeProvider {
			/**
			 * Gets a {@link System.Reflection.MemberTypes} value indicating that this member is a
			 * constructor.
			 */
			readonly MemberType: System.Reflection.MemberTypes;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Invokes the constructor reflected by the instance that has the specified parameters,
			 * providing default values for the parameters not commonly used.
			 */
			Invoke(parameters: System.Object | undefined[] | undefined): System.Object;

			/**
			 * When implemented in a derived class, invokes the constructor reflected by this
			 * `ConstructorInfo` with the specified arguments, under the constraints of the specified
			 * `Binder`.
			 */
			Invoke(
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				parameters: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
			): System.Object;

			/**
			 * Invokes the method or constructor represented by the current instance, using the
			 * specified parameters.
			 */
			Invoke(
				obj: System.Object | undefined,
				parameters: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * When overridden in a derived class, invokes the reflected method or constructor with
			 * the given parameters.
			 */
			Invoke(
				obj: System.Object | undefined,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				parameters: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
			): System.Object | undefined;
		}
	}

	export namespace System.Reflection {
		/**
		 * Provides methods to invoke the method specified by the provided
		 * {@link System.Reflection.ConstructorInfo}.
		 */
		export class ConstructorInvoker {
			/** Invokes the constructor using the specified arguments. */
			Invoke(_arguments: System.Span$1<System.Object | undefined>): System.Object;

			/** Invokes the constructor. */
			Invoke(): System.Object;

			/** Invokes the constructor using the specified arguments. */
			Invoke(arg1: System.Object | undefined): System.Object;

			/** Invokes the constructor using the specified arguments. */
			Invoke(
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): System.Object;

			/** Invokes the constructor using the specified arguments. */
			Invoke(
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
				arg3: System.Object | undefined,
			): System.Object;

			/** Invokes the constructor using the specified arguments. */
			Invoke(
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
				arg3: System.Object | undefined,
				arg4: System.Object | undefined,
			): System.Object;

			/** Creates a new instance of {@link System.Reflection.ConstructorInvoker}. */
			static Create(constructor: System.Reflection.ConstructorInfo): System.Reflection.ConstructorInvoker;
		}
	}

	export namespace System.Reflection {
		/**
		 * Provides access to custom attribute data for assemblies, modules, types, members and
		 * parameters that are loaded into the reflection-only context.
		 */
		export class CustomAttributeData {
			/** Gets the type of the attribute. */
			readonly AttributeType: System.Type;

			/**
			 * Gets a {@link System.Reflection.ConstructorInfo} object that represents the
			 * constructor that would have initialized the custom attribute.
			 */
			readonly Constructor: System.Reflection.ConstructorInfo;

			/**
			 * Gets the list of positional arguments specified for the attribute instance represented
			 * by the {@link System.Reflection.CustomAttributeData} object.
			 */
			readonly ConstructorArguments: System.Reflection.CustomAttributeTypedArgument[];

			/**
			 * Gets the list of named arguments specified for the attribute instance represented by
			 * the {@link System.Reflection.CustomAttributeData} object.
			 */
			readonly NamedArguments: System.Reflection.CustomAttributeNamedArgument[];

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns a list of {@link System.Reflection.CustomAttributeData} objects representing
			 * data about the attributes that have been applied to the target assembly.
			 */
			static GetCustomAttributes(target: System.Reflection.Assembly): System.Reflection.CustomAttributeData[];

			/**
			 * Returns a list of {@link System.Reflection.CustomAttributeData} objects representing
			 * data about the attributes that have been applied to the target member.
			 */
			static GetCustomAttributes(target: System.Reflection.MemberInfo): System.Reflection.CustomAttributeData[];

			/**
			 * Returns a list of {@link System.Reflection.CustomAttributeData} objects representing
			 * data about the attributes that have been applied to the target module.
			 */
			static GetCustomAttributes(target: System.Reflection.Module): System.Reflection.CustomAttributeData[];

			/**
			 * Returns a list of {@link System.Reflection.CustomAttributeData} objects representing
			 * data about the attributes that have been applied to the target parameter.
			 */
			static GetCustomAttributes(target: System.Reflection.ParameterInfo): System.Reflection.CustomAttributeData[];

			/** Serves as a hash function for a particular type. */
			GetHashCode(): number;

			/** Returns a string representation of the custom attribute. */
			ToString(): string;
		}
	}

	export namespace System.Reflection {
		/** Contains static methods for retrieving custom attributes. */
		export namespace CustomAttributeExtensions {
			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * assembly.
			 */
			export function GetCustomAttribute(
				element: System.Reflection.Assembly,
				attributeType: System.Type,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * member.
			 */
			export function GetCustomAttribute(
				element: System.Reflection.MemberInfo,
				attributeType: System.Type,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * member, and optionally inspects the ancestors of that member.
			 */
			export function GetCustomAttribute(
				element: System.Reflection.MemberInfo,
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * module.
			 */
			export function GetCustomAttribute(
				element: System.Reflection.Module,
				attributeType: System.Type,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * parameter.
			 */
			export function GetCustomAttribute(
				element: System.Reflection.ParameterInfo,
				attributeType: System.Type,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * parameter, and optionally inspects the ancestors of that parameter.
			 */
			export function GetCustomAttribute(
				element: System.Reflection.ParameterInfo,
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * assembly.
			 */
			export function GetCustomAttribute<T>(element: System.Reflection.Assembly): T;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * member.
			 */
			export function GetCustomAttribute<T>(element: System.Reflection.MemberInfo): T;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * member, and optionally inspects the ancestors of that member.
			 */
			export function GetCustomAttribute<T>(
				element: System.Reflection.MemberInfo,
				inherit: boolean,
			): T;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * module.
			 */
			export function GetCustomAttribute<T>(element: System.Reflection.Module): T;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * parameter.
			 */
			export function GetCustomAttribute<T>(element: System.Reflection.ParameterInfo): T;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * parameter, and optionally inspects the ancestors of that parameter.
			 */
			export function GetCustomAttribute<T>(
				element: System.Reflection.ParameterInfo,
				inherit: boolean,
			): T;
		}
	}

	export namespace System.Reflection {
		/** Extension methods from {@link System.Reflection.CustomAttributeExtensions} */
		export interface Assembly {
			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * assembly.
			 */
			GetCustomAttribute(attributeType: System.Type): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * assembly.
			 */
			GetCustomAttribute<T>(): T;
		}
	}

	export namespace System.Reflection {
		/** Extension methods from {@link System.Reflection.CustomAttributeExtensions} */
		export interface MemberInfo {
			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * member.
			 */
			GetCustomAttribute(attributeType: System.Type): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * member, and optionally inspects the ancestors of that member.
			 */
			GetCustomAttribute(
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * member.
			 */
			GetCustomAttribute<T>(): T;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * member, and optionally inspects the ancestors of that member.
			 */
			GetCustomAttribute<T>(inherit: boolean): T;
		}
	}

	export namespace System.Reflection {
		/** Extension methods from {@link System.Reflection.CustomAttributeExtensions} */
		export interface Module {
			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * module.
			 */
			GetCustomAttribute(attributeType: System.Type): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * module.
			 */
			GetCustomAttribute<T>(): T;
		}
	}

	export namespace System.Reflection {
		/** Extension methods from {@link System.Reflection.CustomAttributeExtensions} */
		export interface ParameterInfo {
			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * parameter.
			 */
			GetCustomAttribute(attributeType: System.Type): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * parameter, and optionally inspects the ancestors of that parameter.
			 */
			GetCustomAttribute(
				attributeType: System.Type,
				inherit: boolean,
			): System.Attribute | undefined;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * parameter.
			 */
			GetCustomAttribute<T>(): T;

			/**
			 * Retrieves a custom attribute of a specified type that is applied to a specified
			 * parameter, and optionally inspects the ancestors of that parameter.
			 */
			GetCustomAttribute<T>(inherit: boolean): T;
		}
	}

	export namespace System.Reflection {
		/**
		 * The exception that is thrown when the binary format of a custom attribute is invalid.
		 */
		export class CustomAttributeFormatException extends System.FormatException {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.CustomAttributeFormatException} class with the default
			 * properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.CustomAttributeFormatException} class with the specified
			 * message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.CustomAttributeFormatException} class with a specified error
			 * message and a reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System.Reflection {
		/** Represents a named argument of a custom attribute in the reflection-only context. */
		export class CustomAttributeNamedArgument extends System.ValueType implements System.IEquatable$1<System.Reflection.CustomAttributeNamedArgument> {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.CustomAttributeNamedArgument} class, which represents the
			 * specified field or property of the custom attribute, and specifies the value of the
			 * field or property.
			 */
			constructor(
				memberInfo: System.Reflection.MemberInfo,
				value: System.Object | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.CustomAttributeNamedArgument} class, which represents the
			 * specified field or property of the custom attribute, and specifies a
			 * {@link System.Reflection.CustomAttributeTypedArgument} object that describes the type
			 * and value of the field or property.
			 */
			constructor(
				memberInfo: System.Reflection.MemberInfo,
				typedArgument: System.Reflection.CustomAttributeTypedArgument,
			);

			/** Gets a value that indicates whether the named argument is a field. */
			readonly IsField: boolean;

			/** Gets the attribute member that would be used to set the named argument. */
			readonly MemberInfo: System.Reflection.MemberInfo;

			/**
			 * Gets the name of the attribute member that would be used to set the named argument.
			 */
			readonly MemberName: string;

			/**
			 * Gets a {@link System.Reflection.CustomAttributeTypedArgument} structure that can be
			 * used to obtain the type and value of the current named argument.
			 */
			readonly TypedValue: System.Reflection.CustomAttributeTypedArgument;

			/**
			 * Indicates whether the current instance is equal to another instance of the same type.
			 */
			Equals(other: System.Reflection.CustomAttributeNamedArgument): boolean;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Returns a string that consists of the argument name, the equal sign, and a string
			 * representation of the argument value.
			 */
			ToString(): string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Represents an argument of a custom attribute in the reflection-only context, or an
		 * element of an array argument.
		 */
		export class CustomAttributeTypedArgument extends System.ValueType implements System.IEquatable$1<System.Reflection.CustomAttributeTypedArgument> {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.CustomAttributeTypedArgument} class with the specified value.
			 */
			constructor(value: System.Object);

			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.CustomAttributeTypedArgument} class with the specified type
			 * and value.
			 */
			constructor(
				argumentType: System.Type,
				value: System.Object | undefined,
			);

			/** Gets the type of the argument or of the array argument element. */
			readonly ArgumentType: System.Type;

			/**
			 * Gets the value of the argument for a simple argument or for an element of an array
			 * argument; gets a collection of values for an array argument.
			 */
			readonly Value?: System.Object;

			/** Indicates whether this instance and a specified object are equal. */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Indicates whether the current instance is equal to another instance of the same type.
			 */
			Equals(other: System.Reflection.CustomAttributeTypedArgument): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Returns a string consisting of the argument name, the equal sign, and a string
			 * representation of the argument value.
			 */
			ToString(): string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Defines the member of a type that is the default member used by
		 * {@link System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])}.
		 */
		export class DefaultMemberAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.DefaultMemberAttribute}
			 * class.
			 */
			constructor(memberName: string);

			/** Gets the name from the attribute. */
			readonly MemberName: string;
		}
	}

	export namespace System.Reflection {
		/** Specifies the attributes of an event. */
		export enum EventAttributes {
			/** Specifies that the event has no attributes. */
			None = 0,

			/** Specifies that the event is special in a way described by the name. */
			SpecialName = 512,

			/** Specifies a reserved flag for common language runtime use only. */
			ReservedMask = 1024,

			/** Specifies that the common language runtime should check name encoding. */
			RTSpecialName = 1024,
		}
	}

	export namespace System.Reflection {
		/** Discovers the attributes of an event and provides access to event metadata. */
		export class EventInfo extends System.Reflection.MemberInfo implements System.Reflection.ICustomAttributeProvider {
			/**
			 * Gets the {@link System.Reflection.MethodInfo} object for the
			 * {@link System.Reflection.EventInfo.AddEventHandler(System.Object,System.Delegate)}
			 * method of the event, including non-public methods.
			 */
			readonly AddMethod?: System.Reflection.MethodInfo;

			/** Gets the attributes for this event. */
			readonly Attributes: System.Reflection.EventAttributes;

			/**
			 * Gets the `Type` object of the underlying event-handler delegate associated with this
			 * event.
			 */
			readonly EventHandlerType?: System.Type;

			/** Gets a value indicating whether the event is multicast. */
			readonly IsMulticast: boolean;

			/** Gets a value indicating whether the `EventInfo` has a name with a special meaning. */
			readonly IsSpecialName: boolean;

			/**
			 * Gets a {@link System.Reflection.MemberTypes} value indicating that this member is an
			 * event.
			 */
			readonly MemberType: System.Reflection.MemberTypes;

			/**
			 * Gets the method that is called when the event is raised, including non-public methods.
			 */
			readonly RaiseMethod?: System.Reflection.MethodInfo;

			/**
			 * Gets the `MethodInfo` object for removing a method of the event, including non-public
			 * methods.
			 */
			readonly RemoveMethod?: System.Reflection.MethodInfo;

			/** Adds an event handler to an event source. */
			AddEventHandler(
				target: System.Object | undefined,
				handler: System.Delegate | undefined,
			): void;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the method used to add an event handler delegate to the event source. */
			GetAddMethod(): System.Reflection.MethodInfo | undefined;

			/**
			 * When overridden in a derived class, retrieves the `MethodInfo` object for the
			 * {@link System.Reflection.EventInfo.AddEventHandler(System.Object,System.Delegate)}
			 * method of the event, specifying whether to return non-public methods.
			 */
			GetAddMethod(nonPublic: boolean): System.Reflection.MethodInfo | undefined;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Returns the public methods that have been associated with an event in metadata using
			 * the `.other` directive.
			 */
			GetOtherMethods(): System.Reflection.MethodInfo[];

			/**
			 * Returns the methods that have been associated with the event in metadata using the
			 * `.other` directive, specifying whether to include non-public methods.
			 */
			GetOtherMethods(nonPublic: boolean): System.Reflection.MethodInfo[];

			/** Returns the method that is called when the event is raised. */
			GetRaiseMethod(): System.Reflection.MethodInfo | undefined;

			/**
			 * When overridden in a derived class, returns the method that is called when the event
			 * is raised, specifying whether to return non-public methods.
			 */
			GetRaiseMethod(nonPublic: boolean): System.Reflection.MethodInfo | undefined;

			/** Returns the method used to remove an event handler delegate from the event source. */
			GetRemoveMethod(): System.Reflection.MethodInfo | undefined;

			/**
			 * When overridden in a derived class, retrieves the `MethodInfo` object for removing a
			 * method of the event, specifying whether to return non-public methods.
			 */
			GetRemoveMethod(nonPublic: boolean): System.Reflection.MethodInfo | undefined;

			/** Removes an event handler from an event source. */
			RemoveEventHandler(
				target: System.Object | undefined,
				handler: System.Delegate | undefined,
			): void;
		}
	}

	export namespace System.Reflection {
		/** Represents a clause in a structured exception-handling block. */
		export class ExceptionHandlingClause {
			/** Gets the type of exception handled by this clause. */
			readonly CatchType?: System.Type;

			/**
			 * Gets the offset within the method body, in bytes, of the user-supplied filter code.
			 */
			readonly FilterOffset: number;

			/**
			 * Gets a value indicating whether this exception-handling clause is a finally clause, a
			 * type-filtered clause, or a user-filtered clause.
			 */
			readonly Flags: System.Reflection.ExceptionHandlingClauseOptions;

			/** Gets the length, in bytes, of the body of this exception-handling clause. */
			readonly HandlerLength: number;

			/**
			 * Gets the offset within the method body, in bytes, of this exception-handling clause.
			 */
			readonly HandlerOffset: number;

			/**
			 * The total length, in bytes, of the try block that includes this exception-handling
			 * clause.
			 */
			readonly TryLength: number;

			/**
			 * The offset within the method, in bytes, of the try block that includes this
			 * exception-handling clause.
			 */
			readonly TryOffset: number;

			/** A string representation of the exception-handling clause. */
			ToString(): string;
		}
	}

	export namespace System.Reflection {
		/** Identifies kinds of exception-handling clauses. */
		export enum ExceptionHandlingClauseOptions {
			/** The clause accepts all exceptions that derive from a specified type. */
			Clause = 0,

			/**
			 * The clause contains user-specified instructions that determine whether the exception
			 * should be ignored (that is, whether normal execution should resume), be handled by the
			 * associated handler, or be passed on to the next clause.
			 */
			Filter = 1,

			/**
			 * The clause is executed whenever the try block exits, whether through normal control
			 * flow or because of an unhandled exception.
			 */
			Finally = 2,

			/**
			 * The clause is executed if an exception occurs, but not on completion of normal control
			 * flow.
			 */
			Fault = 4,
		}
	}

	export namespace System.Reflection {
		/** Specifies flags that describe the attributes of a field. */
		export enum FieldAttributes {
			/** Specifies that the field cannot be referenced. */
			PrivateScope = 0,

			/** Specifies that the field is accessible only by the parent type. */
			Private = 1,

			/** Specifies that the field is accessible only by subtypes in this assembly. */
			FamANDAssem = 2,

			/** Specifies that the field is accessible throughout the assembly. */
			Assembly = 3,

			/** Specifies that the field is accessible only by type and subtypes. */
			Family = 4,

			/**
			 * Specifies that the field is accessible by subtypes anywhere, as well as throughout
			 * this assembly.
			 */
			FamORAssem = 5,

			/**
			 * Specifies that the field is accessible by any member for whom this scope is visible.
			 */
			Public = 6,

			/** Specifies the access level of a given field. */
			FieldAccessMask = 7,

			/** Specifies that the field represents the defined type, or else it is per-instance. */
			Static = 16,

			/**
			 * Specifies that the field is initialized only, and can be set only in the body of a
			 * constructor.
			 */
			InitOnly = 32,

			/**
			 * Specifies that the field's value is a compile-time (static or early bound) constant.
			 * Any attempt to set it throws a {@link System.FieldAccessException}.
			 */
			Literal = 64,

			/** Specifies that the field does not have to be serialized when the type is remoted. */
			NotSerialized = 128,

			/**
			 * Specifies that the field has a relative virtual address (RVA). The RVA is the location
			 * of the method body in the current image, as an address relative to the start of the
			 * image file in which it is located.
			 */
			HasFieldRVA = 256,

			/** Specifies a special method, with the name describing how the method is special. */
			SpecialName = 512,

			/**
			 * Specifies that the common language runtime (metadata internal APIs) should check the
			 * name encoding.
			 */
			RTSpecialName = 1024,

			/** Specifies that the field has marshaling information. */
			HasFieldMarshal = 4096,

			/** Reserved for future use. */
			PinvokeImpl = 8192,

			/** Specifies that the field has a default value. */
			HasDefault = 32768,

			/** Reserved. */
			ReservedMask = 38144,
		}
	}

	export namespace System.Reflection {
		/** Discovers the attributes of a field and provides access to field metadata. */
		export class FieldInfo extends System.Reflection.MemberInfo implements System.Reflection.ICustomAttributeProvider {
			/** Gets the attributes associated with this field. */
			readonly Attributes: System.Reflection.FieldAttributes;

			/**
			 * Gets a `RuntimeFieldHandle`, which is a handle to the internal metadata representation
			 * of a field.
			 */
			readonly FieldHandle: System.RuntimeFieldHandle;

			/** Gets the type of this field object. */
			readonly FieldType: System.Type;

			/**
			 * Gets a value indicating whether the potential visibility of this field is described by
			 * {@link System.Reflection.FieldAttributes.Assembly} ; that is, the field is visible at
			 * most to other types in the same assembly, and is not visible to derived types outside
			 * the assembly.
			 */
			readonly IsAssembly: boolean;

			/**
			 * Gets a value indicating whether the visibility of this field is described by
			 * {@link System.Reflection.FieldAttributes.Family} ; that is, the field is visible only
			 * within its class and derived classes.
			 */
			readonly IsFamily: boolean;

			/**
			 * Gets a value indicating whether the visibility of this field is described by
			 * {@link System.Reflection.FieldAttributes.FamANDAssem} ; that is, the field can be
			 * accessed from derived classes, but only if they are in the same assembly.
			 */
			readonly IsFamilyAndAssembly: boolean;

			/**
			 * Gets a value indicating whether the potential visibility of this field is described by
			 * {@link System.Reflection.FieldAttributes.FamORAssem} ; that is, the field can be
			 * accessed by derived classes wherever they are, and by classes in the same assembly.
			 */
			readonly IsFamilyOrAssembly: boolean;

			/**
			 * Gets a value indicating whether the field can only be set in the body of the
			 * constructor.
			 */
			readonly IsInitOnly: boolean;

			/**
			 * Gets a value indicating whether the value is written at compile time and cannot be
			 * changed.
			 */
			readonly IsLiteral: boolean;

			/** Gets a value indicating whether this field has the `NotSerialized` attribute. */
			readonly IsNotSerialized: boolean;

			/**
			 * Gets a value indicating whether the corresponding `PinvokeImpl` attribute is set in
			 * {@link System.Reflection.FieldAttributes}.
			 */
			readonly IsPinvokeImpl: boolean;

			/** Gets a value indicating whether the field is private. */
			readonly IsPrivate: boolean;

			/** Gets a value indicating whether the field is public. */
			readonly IsPublic: boolean;

			/**
			 * Gets a value that indicates whether the current field is security-critical or
			 * security-safe-critical at the current trust level.
			 */
			readonly IsSecurityCritical: boolean;

			/**
			 * Gets a value that indicates whether the current field is security-safe-critical at the
			 * current trust level.
			 */
			readonly IsSecuritySafeCritical: boolean;

			/**
			 * Gets a value that indicates whether the current field is transparent at the current
			 * trust level.
			 */
			readonly IsSecurityTransparent: boolean;

			/**
			 * Gets a value indicating whether the corresponding `SpecialName` attribute is set in
			 * the {@link System.Reflection.FieldAttributes} enumerator.
			 */
			readonly IsSpecialName: boolean;

			/** Gets a value indicating whether the field is static. */
			readonly IsStatic: boolean;

			/**
			 * Gets a {@link System.Reflection.MemberTypes} value indicating that this member is a
			 * field.
			 */
			readonly MemberType: System.Reflection.MemberTypes;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Gets a {@link System.Reflection.FieldInfo} for the field represented by the specified
			 * handle.
			 */
			static GetFieldFromHandle(handle: System.RuntimeFieldHandle): System.Reflection.FieldInfo;

			/**
			 * Gets a {@link System.Reflection.FieldInfo} for the field represented by the specified
			 * handle, for the specified generic type.
			 */
			static GetFieldFromHandle(
				handle: System.RuntimeFieldHandle,
				declaringType: System.RuntimeTypeHandle,
			): System.Reflection.FieldInfo;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Gets the modified type of this field object. */
			GetModifiedFieldType(): System.Type;

			/** Gets an array of types that identify the optional custom modifiers of the field. */
			GetOptionalCustomModifiers(): System.Type[];

			/** Returns a literal value associated with the field by a compiler. */
			GetRawConstantValue(): System.Object | undefined;

			/**
			 * Gets an array of types that identify the required custom modifiers of the property.
			 */
			GetRequiredCustomModifiers(): System.Type[];

			/**
			 * When overridden in a derived class, returns the value of a field supported by a given
			 * object.
			 */
			GetValue(obj: System.Object | undefined): System.Object | undefined;

			/** Returns the value of a field supported by a given object. */
			GetValueDirect(obj: System.TypedReference): System.Object | undefined;

			/** Sets the value of the field supported by the given object. */
			SetValue(
				obj: System.Object | undefined,
				value: System.Object | undefined,
			): void;

			/**
			 * When overridden in a derived class, sets the value of the field supported by the given
			 * object.
			 */
			SetValue(
				obj: System.Object | undefined,
				value: System.Object | undefined,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				culture: System.Globalization.CultureInfo | undefined,
			): void;

			/** Sets the value of the field supported by the given object. */
			SetValueDirect(
				obj: System.TypedReference,
				value: System.Object,
			): void;
		}
	}

	export namespace System.Reflection {
		/** Describes the constraints on a generic type parameter of a generic type or method. */
		export enum GenericParameterAttributes {
			/** There are no special flags. */
			None = 0,

			/**
			 * The generic type parameter is covariant. A covariant type parameter can appear as the
			 * result type of a method, the type of a read-only field, a declared base type, or an
			 * implemented interface.
			 */
			Covariant = 1,

			/**
			 * The generic type parameter is contravariant. A contravariant type parameter can appear
			 * as a parameter type in method signatures.
			 */
			Contravariant = 2,

			/**
			 * Selects the combination of all variance flags. This value is the result of using
			 * logical OR to combine the following flags:
			 * {@link System.Reflection.GenericParameterAttributes.Contravariant} and
			 * {@link System.Reflection.GenericParameterAttributes.Covariant}.
			 */
			VarianceMask = 3,

			/**
			 * A type can be substituted for the generic type parameter only if it is a reference
			 * type.
			 */
			ReferenceTypeConstraint = 4,

			/**
			 * A type can be substituted for the generic type parameter only if it is a value type
			 * and is not nullable.
			 */
			NotNullableValueTypeConstraint = 8,

			/**
			 * A type can be substituted for the generic type parameter only if it has a
			 * parameterless constructor.
			 */
			DefaultConstructorConstraint = 16,

			/**
			 * Selects the combination of all special constraint flags. This value is the result of
			 * using logical OR to combine the following flags:
			 * {@link System.Reflection.GenericParameterAttributes.DefaultConstructorConstraint},
			 * {@link System.Reflection.GenericParameterAttributes.ReferenceTypeConstraint}, and
			 * {@link System.Reflection.GenericParameterAttributes.NotNullableValueTypeConstraint}.
			 */
			SpecialConstraintMask = 28,
		}
	}

	export namespace System.Reflection {
		/** Provides custom attributes for reflection objects that support them. */
		export interface ICustomAttributeProvider {
			/**
			 * Returns an array of all of the custom attributes defined on this member, excluding
			 * named attributes, or an empty array if there are no custom attributes.
			 */
			GetCustomAttributes(inherit: boolean): System.Object[];

			/**
			 * Returns an array of custom attributes defined on this member, identified by type, or
			 * an empty array if there are no custom attributes of that type.
			 */
			GetCustomAttributes(
				attributeType: System.Type,
				inherit: boolean,
			): System.Object[];

			/**
			 * Indicates whether one or more instance of `attributeType` is defined on this member.
			 */
			IsDefined(
				attributeType: System.Type,
				inherit: boolean,
			): boolean;
		}
	}

	export namespace System.Reflection {
		/** Identifies the platform targeted by an executable. */
		export enum ImageFileMachine {
			/** Targets a 32-bit Intel processor. */
			I386 = 332,

			/** Targets an ARM processor. */
			ARM = 452,

			/** Targets a 64-bit Intel processor. */
			IA64 = 512,

			/** Targets a 64-bit AMD processor. */
			AMD64 = 34404,
		}
	}

	export namespace System.Reflection {
		/**
		 * Retrieves the mapping of an interface into the actual methods on a class that
		 * implements that interface.
		 */
		export class InterfaceMapping extends System.ValueType {
		}
	}

	export namespace System.Reflection {
		/** Contains methods for converting {@link System.Type} objects. */
		export namespace IntrospectionExtensions {
			/**
			 * Returns the {@link System.Reflection.TypeInfo} representation of the specified type.
			 */
			export function GetTypeInfo(type: System.Type): System.Reflection.TypeInfo;
		}
	}

	export namespace System {
		/** Extension methods from {@link System.Reflection.IntrospectionExtensions} */
		export interface Type {
			/**
			 * Returns the {@link System.Reflection.TypeInfo} representation of the specified type.
			 */
			GetTypeInfo(): System.Reflection.TypeInfo;
		}
	}

	export namespace System.Reflection {
		/**
		 * The exception that is thrown in
		 * {@link System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)}
		 * when the filter criteria is not valid for the type of filter you are using.
		 */
		export class InvalidFilterCriteriaException extends System.ApplicationException {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.InvalidFilterCriteriaException} class with the default
			 * properties.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.InvalidFilterCriteriaException} class with the given HRESULT
			 * and message string.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.InvalidFilterCriteriaException} class with a specified error
			 * message and a reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System.Reflection {
		/** Interoperates with the IDispatch interface. */
		export interface IReflect {
			/**
			 * Gets the underlying type that represents the {@link System.Reflection.IReflect}
			 * object.
			 */
			readonly UnderlyingSystemType: System.Type;

			/**
			 * Returns the {@link System.Reflection.FieldInfo} object that corresponds to the
			 * specified field and binding flag.
			 */
			GetField(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.FieldInfo | undefined;

			/**
			 * Returns an array of {@link System.Reflection.FieldInfo} objects that correspond to all
			 * fields of the current class.
			 */
			GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];

			/**
			 * Retrieves an array of {@link System.Reflection.MemberInfo} objects corresponding to
			 * all public members or to all members that match a specified name.
			 */
			GetMember(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.MemberInfo[];

			/**
			 * Retrieves an array of {@link System.Reflection.MemberInfo} objects that correspond
			 * either to all public members or to all members of the current class.
			 */
			GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];

			/**
			 * Retrieves a {@link System.Reflection.MethodInfo} object that corresponds to a
			 * specified method under specified search constraints.
			 */
			GetMethod(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.MethodInfo | undefined;

			/**
			 * Retrieves a {@link System.Reflection.MethodInfo} object corresponding to a specified
			 * method, using a {@link System.Type} array to choose from among overloaded methods.
			 */
			GetMethod(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.MethodInfo | undefined;

			/**
			 * Retrieves an array of {@link System.Reflection.MethodInfo} objects with all public
			 * methods or all methods of the current class.
			 */
			GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];

			/**
			 * Retrieves an array of {@link System.Reflection.PropertyInfo} objects corresponding to
			 * all public properties or to all properties of the current class.
			 */
			GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];

			/**
			 * Retrieves a {@link System.Reflection.PropertyInfo} object corresponding to a specified
			 * property under specified search constraints.
			 */
			GetProperty(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.PropertyInfo | undefined;

			/**
			 * Retrieves a {@link System.Reflection.PropertyInfo} object that corresponds to a
			 * specified property with specified search constraints.
			 */
			GetProperty(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				returnType: System.Type | undefined,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.PropertyInfo | undefined;

			/** Invokes a specified member. */
			InvokeMember(
				name: string,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				target: System.Object | undefined,
				args: System.Object | undefined[] | undefined,
				modifiers: System.Reflection.ParameterModifier[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				namedParameters: string[] | undefined,
			): System.Object | undefined;
		}
	}

	export namespace System.Reflection {
		/** Represents a type that you can reflect over. */
		export interface IReflectableType {
			/** Retrieves an object that represents this type. */
			GetTypeInfo(): System.Reflection.TypeInfo;
		}
	}

	export namespace System.Reflection {
		/**
		 * Discovers the attributes of a local variable and provides access to local variable
		 * metadata.
		 */
		export class LocalVariableInfo {
			/**
			 * Gets a {@link System.Boolean} value that indicates whether the object referred to by
			 * the local variable is pinned in memory.
			 */
			readonly IsPinned: boolean;

			/** Gets the index of the local variable within the method body. */
			readonly LocalIndex: number;

			/** Gets the type of the local variable. */
			readonly LocalType: System.Type;

			/** Returns a user-readable string that describes the local variable. */
			ToString(): string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Provides access to manifest resources, which are XML files that describe application
		 * dependencies.
		 */
		export class ManifestResourceInfo {
			/**
			 * Initializes a new instance of the {@link System.Reflection.ManifestResourceInfo} class
			 * for a resource that is contained by the specified assembly and file, and that has the
			 * specified location.
			 */
			constructor(
				containingAssembly: System.Reflection.Assembly | undefined,
				containingFileName: string | undefined,
				resourceLocation: System.Reflection.ResourceLocation,
			);

			/**
			 * Gets the name of the file that contains the manifest resource, if it is not the same
			 * as the manifest file.
			 */
			readonly FileName?: string;

			/** Gets the containing assembly for the manifest resource. */
			readonly ReferencedAssembly?: System.Reflection.Assembly;

			/** Gets the manifest resource's location. */
			readonly ResourceLocation: System.Reflection.ResourceLocation;
		}
	}

	export namespace System.Reflection {
		/**
		 * Represents a delegate that is used to filter a list of members represented in an array
		 * of {@link System.Reflection.MemberInfo} objects.
		 */
		export interface MemberFilter { (
			m: System.Reflection.MemberInfo,
			filterCriteria: System.Object | undefined,
		): boolean; }
	}

	export namespace System.Reflection {
		/**
		 * Obtains information about the attributes of a member and provides access to member
		 * metadata.
		 */
		export class MemberInfo implements System.Reflection.ICustomAttributeProvider {
			/** Gets a collection that contains this member's custom attributes. */
			readonly CustomAttributes: Iterable<System.Reflection.CustomAttributeData>;

			/** Gets the class that declares this member. */
			readonly DeclaringType?: System.Type;

			/**
			 * Gets a value that indicates whether this {@link System.Reflection.MemberInfo} object
			 * is part of an assembly held in a collectible
			 * {@link System.Runtime.Loader.AssemblyLoadContext}.
			 */
			readonly IsCollectible: boolean;

			/**
			 * When overridden in a derived class, gets a {@link System.Reflection.MemberTypes} value
			 * indicating the type of the member - method, constructor, event, and so on.
			 */
			readonly MemberType: System.Reflection.MemberTypes;

			/** Gets a value that identifies a metadata element. */
			readonly MetadataToken: number;

			/**
			 * Gets the module in which the type that declares the member represented by the current
			 * {@link System.Reflection.MemberInfo} is defined.
			 */
			readonly Module: System.Reflection.Module;

			/** Gets the name of the current member. */
			readonly Name: string;

			/** Gets the class object that was used to obtain this instance of `MemberInfo`. */
			readonly ReflectedType?: System.Type;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * When overridden in a derived class, returns an array of all custom attributes applied
			 * to this member.
			 */
			GetCustomAttributes(inherit: boolean): System.Object[];

			/**
			 * When overridden in a derived class, returns an array of custom attributes applied to
			 * this member and identified by {@link System.Type}.
			 */
			GetCustomAttributes(
				attributeType: System.Type,
				inherit: boolean,
			): System.Object[];

			/**
			 * Returns a list of {@link System.Reflection.CustomAttributeData} objects representing
			 * data about the attributes that have been applied to the target member.
			 */
			GetCustomAttributesData(): System.Reflection.CustomAttributeData[];

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;

			/**
			 * When overridden in a derived class, indicates whether one or more attributes of the
			 * specified type or of its derived types is applied to this member.
			 */
			IsDefined(
				attributeType: System.Type,
				inherit: boolean,
			): boolean;
		}
	}

	export namespace System.Reflection {
		/**
		 * Marks each type of member that is defined as a derived class of
		 * {@link System.Reflection.MemberInfo}.
		 */
		export enum MemberTypes {
			/** Specifies that the member is a constructor. */
			Constructor = 1,

			/** Specifies that the member is an event. */
			Event = 2,

			/** Specifies that the member is a field. */
			Field = 4,

			/** Specifies that the member is a method. */
			Method = 8,

			/** Specifies that the member is a property. */
			Property = 16,

			/** Specifies that the member is a type. */
			TypeInfo = 32,

			/** Specifies that the member is a custom member type. */
			Custom = 64,

			/** Specifies that the member is a nested type. */
			NestedType = 128,

			/** Specifies all member types. */
			All = 191,
		}
	}

	export namespace System.Reflection {
		/**
		 * Specifies flags for method attributes. These flags are defined in the corhdr.h file.
		 */
		export enum MethodAttributes {
			/** Indicates that the member cannot be referenced. */
			PrivateScope = 0,

			/**
			 * Indicates that the method will reuse an existing slot in the vtable. This is the
			 * default behavior.
			 */
			ReuseSlot = 0,

			/** Indicates that the method is accessible only to the current class. */
			Private = 1,

			/**
			 * Indicates that the method is accessible to members of this type and its derived types
			 * that are in this assembly only.
			 */
			FamANDAssem = 2,

			/** Indicates that the method is accessible to any class of this assembly. */
			Assembly = 3,

			/**
			 * Indicates that the method is accessible only to members of this class and its derived
			 * classes.
			 */
			Family = 4,

			/**
			 * Indicates that the method is accessible to derived classes anywhere, as well as to any
			 * class in the assembly.
			 */
			FamORAssem = 5,

			/**
			 * Indicates that the method is accessible to any object for which this object is in
			 * scope.
			 */
			Public = 6,

			/** Retrieves accessibility information. */
			MemberAccessMask = 7,

			/** Indicates that the managed method is exported by thunk to unmanaged code. */
			UnmanagedExport = 8,

			/**
			 * Indicates that the method is defined on the type; otherwise, it is defined per
			 * instance.
			 */
			Static = 16,

			/** Indicates that the method cannot be overridden. */
			Final = 32,

			/** Indicates that the method is virtual. */
			Virtual = 64,

			/** Indicates that the method hides by name and signature; otherwise, by name only. */
			HideBySig = 128,

			/** Indicates that the method always gets a new slot in the vtable. */
			NewSlot = 256,

			/** Retrieves vtable attributes. */
			VtableLayoutMask = 256,

			/** Indicates that the method can only be overridden when it is also accessible. */
			CheckAccessOnOverride = 512,

			/** Indicates that the class does not provide an implementation of this method. */
			Abstract = 1024,

			/**
			 * Indicates that the method is special. The name describes how this method is special.
			 */
			SpecialName = 2048,

			/** Indicates that the common language runtime checks the name encoding. */
			RTSpecialName = 4096,

			/**
			 * Indicates that the method implementation is forwarded through PInvoke (Platform
			 * Invocation Services).
			 */
			PinvokeImpl = 8192,

			/**
			 * Indicates that the method has security associated with it. Reserved flag for runtime
			 * use only.
			 */
			HasSecurity = 16384,

			/**
			 * Indicates that the method calls another method containing security code. Reserved flag
			 * for runtime use only.
			 */
			RequireSecObject = 32768,

			/** Indicates a reserved flag for runtime use only. */
			ReservedMask = 53248,
		}
	}

	export namespace System.Reflection {
		/** Provides information about methods and constructors. */
		export class MethodBase extends System.Reflection.MemberInfo implements System.Reflection.ICustomAttributeProvider {
			/** Gets the attributes associated with this method. */
			readonly Attributes: System.Reflection.MethodAttributes;

			/** Gets a value indicating the calling conventions for this method. */
			readonly CallingConvention: System.Reflection.CallingConventions;

			/**
			 * Gets a value indicating whether the generic method contains unassigned generic type
			 * parameters.
			 */
			readonly ContainsGenericParameters: boolean;

			/** Gets a value indicating whether the method is abstract. */
			readonly IsAbstract: boolean;

			/**
			 * Gets a value indicating whether the potential visibility of this method or constructor
			 * is described by {@link System.Reflection.MethodAttributes.Assembly} ; that is, the
			 * method or constructor is visible at most to other types in the same assembly, and is
			 * not visible to derived types outside the assembly.
			 */
			readonly IsAssembly: boolean;

			readonly IsConstructedGenericMethod: boolean;

			/** Gets a value indicating whether the method is a constructor. */
			readonly IsConstructor: boolean;

			/**
			 * Gets a value indicating whether the visibility of this method or constructor is
			 * described by {@link System.Reflection.MethodAttributes.Family} ; that is, the method
			 * or constructor is visible only within its class and derived classes.
			 */
			readonly IsFamily: boolean;

			/**
			 * Gets a value indicating whether the visibility of this method or constructor is
			 * described by {@link System.Reflection.MethodAttributes.FamANDAssem} ; that is, the
			 * method or constructor can be called by derived classes, but only if they are in the
			 * same assembly.
			 */
			readonly IsFamilyAndAssembly: boolean;

			/**
			 * Gets a value indicating whether the potential visibility of this method or constructor
			 * is described by {@link System.Reflection.MethodAttributes.FamORAssem} ; that is, the
			 * method or constructor can be called by derived classes wherever they are, and by
			 * classes in the same assembly.
			 */
			readonly IsFamilyOrAssembly: boolean;

			/** Gets a value indicating whether this method is `final`. */
			readonly IsFinal: boolean;

			/** Gets a value indicating whether the method is generic. */
			readonly IsGenericMethod: boolean;

			/** Gets a value indicating whether the method is a generic method definition. */
			readonly IsGenericMethodDefinition: boolean;

			/**
			 * Gets a value indicating whether only a member of the same kind with exactly the same
			 * signature is hidden in the derived class.
			 */
			readonly IsHideBySig: boolean;

			/** Gets a value indicating whether this member is private. */
			readonly IsPrivate: boolean;

			/** Gets a value indicating whether this is a public method. */
			readonly IsPublic: boolean;

			/**
			 * Gets a value that indicates whether the current method or constructor is
			 * security-critical or security-safe-critical at the current trust level, and therefore
			 * can perform critical operations.
			 */
			readonly IsSecurityCritical: boolean;

			/**
			 * Gets a value that indicates whether the current method or constructor is
			 * security-safe-critical at the current trust level; that is, whether it can perform
			 * critical operations and can be accessed by transparent code.
			 */
			readonly IsSecuritySafeCritical: boolean;

			/**
			 * Gets a value that indicates whether the current method or constructor is transparent
			 * at the current trust level, and therefore cannot perform critical operations.
			 */
			readonly IsSecurityTransparent: boolean;

			/** Gets a value indicating whether this method has a special name. */
			readonly IsSpecialName: boolean;

			/** Gets a value indicating whether the method is `static`. */
			readonly IsStatic: boolean;

			/** Gets a value indicating whether the method is `virtual`. */
			readonly IsVirtual: boolean;

			/** Gets a handle to the internal metadata representation of a method. */
			readonly MethodHandle: System.RuntimeMethodHandle;

			/**
			 * Gets the {@link System.Reflection.MethodImplAttributes} flags that specify the
			 * attributes of a method implementation.
			 */
			readonly MethodImplementationFlags: System.Reflection.MethodImplAttributes;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns a `MethodBase` object representing the currently executing method. */
			static GetCurrentMethod(): System.Reflection.MethodBase | undefined;

			/**
			 * Returns an array of {@link System.Type} objects that represent the type arguments of a
			 * generic method or the type parameters of a generic method definition.
			 */
			GetGenericArguments(): System.Type[];

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * When overridden in a derived class, gets a {@link System.Reflection.MethodBody} object
			 * that provides access to the MSIL stream, local variables, and exceptions for the
			 * current method.
			 */
			GetMethodBody(): System.Reflection.MethodBody | undefined;

			/**
			 * Gets method information by using the method's internal metadata representation
			 * (handle).
			 */
			static GetMethodFromHandle(handle: System.RuntimeMethodHandle): System.Reflection.MethodBase | undefined;

			/**
			 * Gets a {@link System.Reflection.MethodBase} object for the constructor or method
			 * represented by the specified handle, for the specified generic type.
			 */
			static GetMethodFromHandle(
				handle: System.RuntimeMethodHandle,
				declaringType: System.RuntimeTypeHandle,
			): System.Reflection.MethodBase | undefined;

			/**
			 * When overridden in a derived class, returns the
			 * {@link System.Reflection.MethodImplAttributes} flags.
			 */
			GetMethodImplementationFlags(): System.Reflection.MethodImplAttributes;

			/**
			 * When overridden in a derived class, gets the parameters of the specified method or
			 * constructor.
			 */
			GetParameters(): System.Reflection.ParameterInfo[];

			/**
			 * Invokes the method or constructor represented by the current instance, using the
			 * specified parameters.
			 */
			Invoke(
				obj: System.Object | undefined,
				parameters: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * When overridden in a derived class, invokes the reflected method or constructor with
			 * the given parameters.
			 */
			Invoke(
				obj: System.Object | undefined,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				parameters: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
			): System.Object | undefined;
		}
	}

	export namespace System.Reflection {
		/** Provides access to the metadata and MSIL for the body of a method. */
		export class MethodBody {
			/** Gets a list that includes all the exception-handling clauses in the method body. */
			readonly ExceptionHandlingClauses: System.Reflection.ExceptionHandlingClause[];

			/**
			 * Gets a value indicating whether local variables in the method body are initialized to
			 * the default values for their types.
			 */
			readonly InitLocals: boolean;

			/**
			 * Gets a metadata token for the signature that describes the local variables for the
			 * method in metadata.
			 */
			readonly LocalSignatureMetadataToken: number;

			/** Gets the list of local variables declared in the method body. */
			readonly LocalVariables: System.Reflection.LocalVariableInfo[];

			/**
			 * Gets the maximum number of items on the operand stack when the method is executing.
			 */
			readonly MaxStackSize: number;

			/** Returns the MSIL for the method body, as an array of bytes. */
			GetILAsByteArray(): number[] | undefined;
		}
	}

	export namespace System.Reflection {
		/** Specifies flags for the attributes of a method implementation. */
		export enum MethodImplAttributes {
			/**
			 * Specifies that the method implementation is in Microsoft intermediate language (MSIL).
			 */
			IL = 0,

			/** Specifies that the method is implemented in managed code. */
			Managed = 0,

			/** Specifies that the method implementation is native. */
			Native = 1,

			/**
			 * Specifies that the method implementation is in Optimized Intermediate Language
			 * (OPTIL).
			 */
			OPTIL = 2,

			/** Specifies flags about code type. */
			CodeTypeMask = 3,

			/** Specifies that the method implementation is provided by the runtime. */
			Runtime = 3,

			/** Specifies whether the method is implemented in managed or unmanaged code. */
			ManagedMask = 4,

			/** Specifies that the method is implemented in unmanaged code. */
			Unmanaged = 4,

			/** Specifies that the method cannot be inlined. */
			NoInlining = 8,

			/** Specifies that the method is not defined. */
			ForwardRef = 16,

			/**
			 * Specifies that the method is single-threaded through the body. Static methods (
				 * `Shared` in Visual Basic) lock on the type, whereas instance methods lock on the
				 * instance. You can also use the C# lock statement or the Visual Basic SyncLock
				 * statement for this purpose.
				 */
				Synchronized = 32,

				/**
				 * Specifies that the method is not optimized by the just-in-time (JIT) compiler or by
				 * native code generation (see Ngen.exe) when debugging possible code generation
				 * problems.
				 */
				NoOptimization = 64,

				/** Specifies that the method signature is exported exactly as declared. */
				PreserveSig = 128,

				/** Specifies that the method should be inlined wherever possible. */
				AggressiveInlining = 256,

				/** Specifies that the method should be optimized whenever possible. */
				AggressiveOptimization = 512,

				/** Specifies an internal call. */
				InternalCall = 4096,

				/** Specifies a range check value. */
				MaxMethodImplVal = 65535,
			}
		}

		export namespace System.Reflection {
			/** Discovers the attributes of a method and provides access to method metadata. */
			export class MethodInfo extends System.Reflection.MethodBase implements System.Reflection.ICustomAttributeProvider {
				/**
				 * Gets a {@link System.Reflection.MemberTypes} value indicating that this member is a
				 * method.
				 */
				readonly MemberType: System.Reflection.MemberTypes;

			/**
			 * Gets a {@link System.Reflection.ParameterInfo} object that contains information about
			 * the return type of the method, such as whether the return type has custom modifiers.
			 */
			readonly ReturnParameter: System.Reflection.ParameterInfo;

			/** Gets the return type of this method. */
			readonly ReturnType: System.Type;

			/** Gets the custom attributes for the return type. */
			readonly ReturnTypeCustomAttributes: System.Reflection.ICustomAttributeProvider;

			/** Creates a delegate of the specified type from this method. */
			CreateDelegate(delegateType: System.Type): System.Delegate;

			/**
			 * Creates a delegate of the specified type with the specified target from this method.
			 */
			CreateDelegate(
				delegateType: System.Type,
				target: System.Object | undefined,
			): System.Delegate;

			/** Creates a delegate of type  from this method. */
			CreateDelegate<T>(): T;

			/** Creates a delegate of type  with the specified target from this method. */
			CreateDelegate<T>(target: System.Object | undefined): T;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * When overridden in a derived class, returns the {@link System.Reflection.MethodInfo}
			 * object for the method on the direct or indirect base class in which the method
			 * represented by this instance was first declared.
			 */
			GetBaseDefinition(): System.Reflection.MethodInfo;

			/**
			 * Returns an array of {@link System.Type} objects that represent the type arguments of a
			 * generic method or the type parameters of a generic method definition.
			 */
			GetGenericArguments(): System.Type[];

			/**
			 * Returns a {@link System.Reflection.MethodInfo} object that represents a generic method
			 * definition from which the current method can be constructed.
			 */
			GetGenericMethodDefinition(): System.Reflection.MethodInfo;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * Substitutes the elements of an array of types for the type parameters of the current
			 * generic method definition, and returns a {@link System.Reflection.MethodInfo} object
			 * representing the resulting constructed method.
			 */
			MakeGenericMethod(typeArguments: System.Type[]): System.Reflection.MethodInfo;
		}
	}

	export namespace System.Reflection {
		/**
		 * Provides methods to invoke the method specified by the provided
		 * {@link System.Reflection.MethodBase}.
		 */
		export class MethodInvoker {
			/** Invokes the method using the specified arguments. */
			Invoke(
				obj: System.Object | undefined,
				_arguments: System.Span$1<System.Object | undefined>,
			): System.Object | undefined;

			/** Invokes the method using the specified arguments. */
			Invoke(obj: System.Object | undefined): System.Object | undefined;

			/** Invokes the method using the specified arguments. */
			Invoke(
				obj: System.Object | undefined,
				arg1: System.Object | undefined,
			): System.Object | undefined;

			/** Invokes the method using the specified arguments. */
			Invoke(
				obj: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): System.Object | undefined;

			/** Invokes the method using the specified arguments. */
			Invoke(
				obj: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
				arg3: System.Object | undefined,
			): System.Object | undefined;

			/** Invokes the method using the specified arguments. */
			Invoke(
				obj: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
				arg3: System.Object | undefined,
				arg4: System.Object | undefined,
			): System.Object | undefined;

			/** Creates a new instance of {@link System.Reflection.MethodInvoker}. */
			static Create(method: System.Reflection.MethodBase): System.Reflection.MethodInvoker;
		}
	}

	export namespace System.Reflection {
		/** Represents a missing {@link System.Object}. This class cannot be inherited. */
		export class Missing {
		}
	}

	export namespace System.Reflection {
		/** Performs reflection on a module. */
		export class Module implements System.Reflection.ICustomAttributeProvider {
			/**
			 * Gets the appropriate {@link System.Reflection.Assembly} for this instance of
			 * {@link System.Reflection.Module}.
			 */
			readonly Assembly: System.Reflection.Assembly;

			/** Gets a collection that contains this module's custom attributes. */
			readonly CustomAttributes: Iterable<System.Reflection.CustomAttributeData>;

			/** Gets a string representing the fully qualified name and path to this module. */
			readonly FullyQualifiedName: string;

			/** Gets the metadata stream version. */
			readonly MDStreamVersion: number;

			/** Gets a token that identifies the module in metadata. */
			readonly MetadataToken: number;

			/** Gets a handle for the module. */
			readonly ModuleHandle: System.ModuleHandle;

			/**
			 * Gets a universally unique identifier (UUID) that can be used to distinguish between
			 * two versions of a module.
			 */
			readonly ModuleVersionId: string;

			/** Gets a `String` representing the name of the module with the path removed. */
			readonly Name: string;

			/** Gets a string representing the name of the module. */
			readonly ScopeName: string;

			/** Determines whether this module and the specified object are equal. */
			Equals(o: System.Object | undefined): boolean;

			/** Returns an array of classes accepted by the given filter and filter criteria. */
			FindTypes(
				filter: System.Reflection.TypeFilter | undefined,
				filterCriteria: System.Object | undefined,
			): System.Type[];

			/** Returns all custom attributes. */
			GetCustomAttributes(inherit: boolean): System.Object[];

			/** Gets custom attributes of the specified type. */
			GetCustomAttributes(
				attributeType: System.Type,
				inherit: boolean,
			): System.Object[];

			/**
			 * Returns a list of {@link System.Reflection.CustomAttributeData} objects for the
			 * current module, which can be used in the reflection-only context.
			 */
			GetCustomAttributesData(): System.Reflection.CustomAttributeData[];

			/** Returns a field having the specified name. */
			GetField(name: string): System.Reflection.FieldInfo | undefined;

			/** Returns a field having the specified name and binding attributes. */
			GetField(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.FieldInfo | undefined;

			/** Returns the global fields defined on the module. */
			GetFields(): System.Reflection.FieldInfo[];

			/**
			 * Returns the global fields defined on the module that match the specified binding
			 * flags.
			 */
			GetFields(bindingFlags: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/** Returns a method having the specified name. */
			GetMethod(name: string): System.Reflection.MethodInfo | undefined;

			/**
			 * Returns a method having the specified name, binding information, calling convention,
			 * and parameter types and modifiers.
			 */
			GetMethod(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				callConvention: System.Reflection.CallingConventions,
				types: System.Type[],
				modifiers: System.Reflection.ParameterModifier[] | undefined,
			): System.Reflection.MethodInfo | undefined;

			/** Returns a method having the specified name and parameter types. */
			GetMethod(
				name: string,
				types: System.Type[],
			): System.Reflection.MethodInfo | undefined;

			/** Returns the global methods defined on the module. */
			GetMethods(): System.Reflection.MethodInfo[];

			/**
			 * Returns the global methods defined on the module that match the specified binding
			 * flags.
			 */
			GetMethods(bindingFlags: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];

			GetPEKind(): { peKind: System.Reflection.PortableExecutableKinds, machine: System.Reflection.ImageFileMachine };

			/** Returns the specified type, performing a case-sensitive search. */
			GetType(className: string): System.Type | undefined;

			/**
			 * Returns the specified type, searching the module with the specified case sensitivity.
			 */
			GetType(
				className: string,
				ignoreCase: boolean,
			): System.Type | undefined;

			/**
			 * Returns the specified type, specifying whether to make a case-sensitive search of the
			 * module and whether to throw an exception if the type cannot be found.
			 */
			GetType(
				className: string,
				throwOnError: boolean,
				ignoreCase: boolean,
			): System.Type | undefined;

			/** Returns all the types defined within this module. */
			GetTypes(): System.Type[];

			/**
			 * Returns a value that indicates whether the specified attribute type has been applied
			 * to this module.
			 */
			IsDefined(
				attributeType: System.Type,
				inherit: boolean,
			): boolean;

			/** Gets a value indicating whether the object is a resource. */
			IsResource(): boolean;

			/** Returns the field identified by the specified metadata token. */
			ResolveField(metadataToken: number): System.Reflection.FieldInfo | undefined;

			/**
			 * Returns the field identified by the specified metadata token, in the context defined
			 * by the specified generic type parameters.
			 */
			ResolveField(
				metadataToken: number,
				genericTypeArguments: System.Type[] | undefined,
				genericMethodArguments: System.Type[] | undefined,
			): System.Reflection.FieldInfo | undefined;

			/** Returns the type or member identified by the specified metadata token. */
			ResolveMember(metadataToken: number): System.Reflection.MemberInfo | undefined;

			/**
			 * Returns the type or member identified by the specified metadata token, in the context
			 * defined by the specified generic type parameters.
			 */
			ResolveMember(
				metadataToken: number,
				genericTypeArguments: System.Type[] | undefined,
				genericMethodArguments: System.Type[] | undefined,
			): System.Reflection.MemberInfo | undefined;

			/** Returns the method or constructor identified by the specified metadata token. */
			ResolveMethod(metadataToken: number): System.Reflection.MethodBase | undefined;

			/**
			 * Returns the method or constructor identified by the specified metadata token, in the
			 * context defined by the specified generic type parameters.
			 */
			ResolveMethod(
				metadataToken: number,
				genericTypeArguments: System.Type[] | undefined,
				genericMethodArguments: System.Type[] | undefined,
			): System.Reflection.MethodBase | undefined;

			/** Returns the signature blob identified by a metadata token. */
			ResolveSignature(metadataToken: number): number[];

			/** Returns the string identified by the specified metadata token. */
			ResolveString(metadataToken: number): string;

			/** Returns the type identified by the specified metadata token. */
			ResolveType(metadataToken: number): System.Type;

			/**
			 * Returns the type identified by the specified metadata token, in the context defined by
			 * the specified generic type parameters.
			 */
			ResolveType(
				metadataToken: number,
				genericTypeArguments: System.Type[] | undefined,
				genericMethodArguments: System.Type[] | undefined,
			): System.Type;

			/** Returns the name of the module. */
			ToString(): string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Represents the method that will handle the
		 * {@link System.Reflection.Assembly.ModuleResolve} event of an
		 * {@link System.Reflection.Assembly}.
		 */
		export interface ModuleResolveEventHandler { (
			sender: System.Object,
			e: System.ResolveEventArgs,
		): System.Reflection.Module; }
	}

	export namespace System.Reflection {
		/** Represents nullability information. */
		export class NullabilityInfo {
			/** Gets the nullability information for the element type of the array. */
			readonly ElementType?: System.Reflection.NullabilityInfo;

			/** Gets the nullability information for each type parameter. */
			readonly GenericTypeArguments: System.Reflection.NullabilityInfo[];

			/** Gets the nullability read state of the member. */
			readonly ReadState: System.Reflection.NullabilityState;

			/** Gets the type of the member or generic parameter to which this instance belongs. */
			readonly Type: System.Type;

			/** Gets the nullability write state of the member. */
			readonly WriteState: System.Reflection.NullabilityState;
		}
	}

	export namespace System.Reflection {
		/**
		 * Provides APIs for populating nullability information and context from reflection
		 * members: {@link System.Reflection.ParameterInfo}, {@link System.Reflection.FieldInfo},
		 * {@link System.Reflection.PropertyInfo}, and {@link System.Reflection.EventInfo}.
		 */
		export class NullabilityInfoContext {
			/**
			 * Initializes a new instance of the {@link System.Reflection.NullabilityInfoContext}
			 * class.
			 */
			constructor();

			/**
			 * Populates a {@link System.Reflection.NullabilityInfo} for the given
			 * {@link System.Reflection.EventInfo}. If the nullablePublicOnly feature is set for an
			 * assembly, like it does in the .NET SDK, the private and/or internal member's
			 * nullability attributes are omitted, and the API will return the
			 * {@link System.Reflection.NullabilityState.Unknown} state.
			 */
			Create(eventInfo: System.Reflection.EventInfo): System.Reflection.NullabilityInfo;

			/**
			 * Populates a {@link System.Reflection.NullabilityInfo} for the given
			 * {@link System.Reflection.FieldInfo}. If the nullablePublicOnly feature is set for an
			 * assembly, like it does in the .NET SDK, the private and/or internal member's
			 * nullability attributes are omitted, and the API will return the
			 * {@link System.Reflection.NullabilityState.Unknown} state.
			 */
			Create(fieldInfo: System.Reflection.FieldInfo): System.Reflection.NullabilityInfo;

			/**
			 * Populates a {@link System.Reflection.NullabilityInfo} for the given
			 * {@link System.Reflection.ParameterInfo}. If the nullablePublicOnly feature is set for
			 * an assembly, like it does in the .NET SDK, the private and/or internal member's
			 * nullability attributes are omitted, and the API will return the
			 * {@link System.Reflection.NullabilityState.Unknown} state.
			 */
			Create(parameterInfo: System.Reflection.ParameterInfo): System.Reflection.NullabilityInfo;

			/**
			 * Populates a {@link System.Reflection.NullabilityInfo} for the given
			 * {@link System.Reflection.PropertyInfo}. If the nullablePublicOnly feature is set for
			 * an assembly, like it does in the .NET SDK, the private and/or internal member's
			 * nullability attributes are omitted, and the API will return the
			 * {@link System.Reflection.NullabilityState.Unknown} state.
			 */
			Create(propertyInfo: System.Reflection.PropertyInfo): System.Reflection.NullabilityInfo;
		}
	}

	export namespace System.Reflection {
		/** Describes nullability states. */
		export enum NullabilityState {
			/** Nullability context not enabled (oblivious). */
			Unknown = 0,

			/** Non-nullable value or reference type. */
			NotNull = 1,

			/** Nullable value or reference type. */
			Nullable = 2,
		}
	}

	export namespace System.Reflection {
		/**
		 * Instructs obfuscation tools to use their standard obfuscation rules for the
		 * appropriate assembly type.
		 */
		export class ObfuscateAssemblyAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.ObfuscateAssemblyAttribute}
			 * class, specifying whether the assembly to be obfuscated is public or private.
			 */
			constructor(assemblyIsPrivate: boolean);

			/**
			 * Gets a {@link System.Boolean} value indicating whether the assembly was marked
			 * private.
			 */
			readonly AssemblyIsPrivate: boolean;

			/**
			 * Gets or sets a {@link System.Boolean} value indicating whether the obfuscation tool
			 * should remove the attribute after processing.
			 */
			StripAfterObfuscation: boolean;
		}
	}

	export namespace System.Reflection {
		/**
		 * Instructs obfuscation tools to take the specified actions for an assembly, type, or
		 * member.
		 */
		export class ObfuscationAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Reflection.ObfuscationAttribute}
			 * class.
			 */
			constructor();

			/**
			 * Gets or sets a {@link System.Boolean} value indicating whether the attribute of a type
			 * is to apply to the members of the type.
			 */
			ApplyToMembers: boolean;

			/**
			 * Gets or sets a {@link System.Boolean} value indicating whether the obfuscation tool
			 * should exclude the type or member from obfuscation.
			 */
			Exclude: boolean;

			/**
			 * Gets or sets a string value that is recognized by the obfuscation tool, and which
			 * specifies processing options.
			 */
			Feature?: string;

			/**
			 * Gets or sets a {@link System.Boolean} value indicating whether the obfuscation tool
			 * should remove this attribute after processing.
			 */
			StripAfterObfuscation: boolean;
		}
	}

	export namespace System.Reflection {
		/**
		 * Defines the attributes that can be associated with a parameter. These are defined in
		 * CorHdr.h.
		 */
		export enum ParameterAttributes {
			/** Specifies that there is no parameter attribute. */
			None = 0,

			/** Specifies that the parameter is an input parameter. */
			In = 1,

			/** Specifies that the parameter is an output parameter. */
			Out = 2,

			/** Specifies that the parameter is a locale identifier (lcid). */
			Lcid = 4,

			/** Specifies that the parameter is a return value. */
			Retval = 8,

			/** Specifies that the parameter is optional. */
			Optional = 16,

			/** Specifies that the parameter has a default value. */
			HasDefault = 4096,

			/** Specifies that the parameter has field marshaling information. */
			HasFieldMarshal = 8192,

			/** Reserved. */
			Reserved3 = 16384,

			/** Reserved. */
			Reserved4 = 32768,

			/** Specifies that the parameter is reserved. */
			ReservedMask = 61440,
		}
	}

	export namespace System.Reflection {
		/** Discovers the attributes of a parameter and provides access to parameter metadata. */
		export class ParameterInfo implements System.Reflection.ICustomAttributeProvider {
			/** Gets the attributes for this parameter. */
			readonly Attributes: System.Reflection.ParameterAttributes;

			/** Gets a collection that contains this parameter's custom attributes. */
			readonly CustomAttributes: Iterable<System.Reflection.CustomAttributeData>;

			/** Gets a value indicating the default value if the parameter has a default value. */
			readonly DefaultValue?: System.Object;

			/** Gets a value that indicates whether this parameter has a default value. */
			readonly HasDefaultValue: boolean;

			/** Gets a value indicating whether this is an input parameter. */
			readonly IsIn: boolean;

			/** Gets a value indicating whether this parameter is a locale identifier (lcid). */
			readonly IsLcid: boolean;

			/** Gets a value indicating whether this parameter is optional. */
			readonly IsOptional: boolean;

			/** Gets a value indicating whether this is an output parameter. */
			readonly IsOut: boolean;

			/** Gets a value indicating whether this is a `Retval` parameter. */
			readonly IsRetval: boolean;

			/** Gets a value indicating the member in which the parameter is implemented. */
			readonly Member: System.Reflection.MemberInfo;

			/** Gets a value that identifies this parameter in metadata. */
			readonly MetadataToken: number;

			/** Gets the name of the parameter. */
			readonly Name?: string;

			/** Gets the `Type` of this parameter. */
			readonly ParameterType: System.Type;

			/** Gets the zero-based position of the parameter in the formal parameter list. */
			readonly Position: number;

			/** Gets a value indicating the default value if the parameter has a default value. */
			readonly RawDefaultValue?: System.Object;

			/** Gets all the custom attributes defined on this parameter. */
			GetCustomAttributes(inherit: boolean): System.Object[];

			/**
			 * Gets the custom attributes of the specified type or its derived types that are applied
			 * to this parameter.
			 */
			GetCustomAttributes(
				attributeType: System.Type,
				inherit: boolean,
			): System.Object[];

			/**
			 * Returns a list of {@link System.Reflection.CustomAttributeData} objects for the
			 * current parameter, which can be used in the reflection-only context.
			 */
			GetCustomAttributesData(): System.Reflection.CustomAttributeData[];

			/** Gets the modified type of this parameter object. */
			GetModifiedParameterType(): System.Type;

			/** Gets the optional custom modifiers of the parameter. */
			GetOptionalCustomModifiers(): System.Type[];

			/** Gets the required custom modifiers of the parameter. */
			GetRequiredCustomModifiers(): System.Type[];

			/**
			 * Determines whether the custom attribute of the specified type or its derived types is
			 * applied to this parameter.
			 */
			IsDefined(
				attributeType: System.Type,
				inherit: boolean,
			): boolean;

			/** Gets the parameter type and name represented as a string. */
			ToString(): string;
		}
	}

	export namespace System.Reflection {
		/**
		 * Attaches a modifier to parameters so that binding can work with parameter signatures
		 * in which the types have been modified.
		 */
		export class ParameterModifier extends System.ValueType {
			/**
			 * Initializes a new instance of the {@link System.Reflection.ParameterModifier}
			 * structure representing the specified number of parameters.
			 */
			constructor(parameterCount: number);
		}
	}

	export namespace System.Reflection {
		/** Provides a wrapper class for pointers. */
		export class Pointer {
			/**
			 * Returns a value that indicates whether the current object is equal to a specified
			 * object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for the current object. */
			GetHashCode(): number;
		}
	}

	export namespace System.Reflection {
		/** Identifies the nature of the code in an executable file. */
		export enum PortableExecutableKinds {
			/** The file is not in portable executable (PE) file format. */
			NotAPortableExecutableImage = 0,

			/**
			 * The executable contains only Microsoft intermediate language (MSIL), and is therefore
			 * neutral with respect to 32-bit or 64-bit platforms.
			 */
			ILOnly = 1,

			/**
			 * The executable can be run on a 32-bit platform, or in the 32-bit Windows on Windows
			 * (WOW) environment on a 64-bit platform.
			 */
			Required32Bit = 2,

			/** The executable requires a 64-bit platform. */
			PE32Plus = 4,

			/** The executable contains pure unmanaged code. */
			Unmanaged32Bit = 8,

			/**
			 * The executable is platform-agnostic but should be run on a 32-bit platform whenever
			 * possible.
			 */
			Preferred32Bit = 16,
		}
	}

	export namespace System.Reflection {
		/**
		 * Identifies the processor and bits-per-word of the platform targeted by an executable.
		 */
		export enum ProcessorArchitecture {
			/** An unknown or unspecified combination of processor and bits-per-word. */
			None = 0,

			/** Neutral with respect to processor and bits-per-word. */
			MSIL = 1,

			/**
			 * A 32-bit Intel processor, either native or in the Windows on Windows environment on a
			 * 64-bit platform (WOW64).
			 */
			X86 = 2,

			/** A 64-bit Intel Itanium processor only. */
			IA64 = 3,

			/** A 64-bit processor based on the x64 architecture. */
			Amd64 = 4,

			/** An ARM processor. */
			Arm = 5,
		}
	}

	export namespace System.Reflection {
		/**
		 * Defines the attributes that can be associated with a property. These attribute values
		 * are defined in corhdr.h.
		 */
		export enum PropertyAttributes {
			/** Specifies that no attributes are associated with a property. */
			None = 0,

			/**
			 * Specifies that the property is special, with the name describing how the property is
			 * special.
			 */
			SpecialName = 512,

			/** Specifies that the metadata internal APIs check the name encoding. */
			RTSpecialName = 1024,

			/** Specifies that the property has a default value. */
			HasDefault = 4096,

			/** Reserved. */
			Reserved2 = 8192,

			/** Reserved. */
			Reserved3 = 16384,

			/** Reserved. */
			Reserved4 = 32768,

			/** Specifies a flag reserved for runtime use only. */
			ReservedMask = 62464,
		}
	}

	export namespace System.Reflection {
		/** Discovers the attributes of a property and provides access to property metadata. */
		export class PropertyInfo extends System.Reflection.MemberInfo implements System.Reflection.ICustomAttributeProvider {
			/** Gets the attributes for this property. */
			readonly Attributes: System.Reflection.PropertyAttributes;

			/** Gets a value indicating whether the property can be read. */
			readonly CanRead: boolean;

			/** Gets a value indicating whether the property can be written to. */
			readonly CanWrite: boolean;

			/** Gets the `get` accessor for this property. */
			readonly GetMethod?: System.Reflection.MethodInfo;

			/** Gets a value indicating whether the property is the special name. */
			readonly IsSpecialName: boolean;

			/**
			 * Gets a {@link System.Reflection.MemberTypes} value indicating that this member is a
			 * property.
			 */
			readonly MemberType: System.Reflection.MemberTypes;

			/** Gets the type of this property. */
			readonly PropertyType: System.Type;

			/** Gets the `set` accessor for this property. */
			readonly SetMethod?: System.Reflection.MethodInfo;

			/**
			 * Returns a value that indicates whether this instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Returns an array whose elements reflect the public `get` and `set` accessors of the
			 * property reflected by the current instance.
			 */
			GetAccessors(): System.Reflection.MethodInfo[];

			/**
			 * Returns an array whose elements reflect the public and, if specified, non-public `get`
			 * and `set` accessors of the property reflected by the current instance.
			 */
			GetAccessors(nonPublic: boolean): System.Reflection.MethodInfo[];

			/** Returns a literal value associated with the property by a compiler. */
			GetConstantValue(): System.Object | undefined;

			/** Returns the public `get` accessor for this property. */
			GetGetMethod(): System.Reflection.MethodInfo | undefined;

			/**
			 * When overridden in a derived class, returns the public or non-public `get` accessor
			 * for this property.
			 */
			GetGetMethod(nonPublic: boolean): System.Reflection.MethodInfo | undefined;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;

			/**
			 * When overridden in a derived class, returns an array of all the index parameters for
			 * the property.
			 */
			GetIndexParameters(): System.Reflection.ParameterInfo[];

			/**
			 * Returns an array of types representing the optional custom modifiers of the property.
			 */
			GetOptionalCustomModifiers(): System.Type[];

			/** Returns a literal value associated with the property by a compiler. */
			GetRawConstantValue(): System.Object | undefined;

			/** Gets the modified type of this property object. */
			GetModifiedPropertyType(): System.Type;

			/**
			 * Returns an array of types representing the required custom modifiers of the property.
			 */
			GetRequiredCustomModifiers(): System.Type[];

			/** Returns the public `set` accessor for this property. */
			GetSetMethod(): System.Reflection.MethodInfo | undefined;

			/** When overridden in a derived class, returns the `set` accessor for this property. */
			GetSetMethod(nonPublic: boolean): System.Reflection.MethodInfo | undefined;

			/** Returns the property value of a specified object. */
			GetValue(obj: System.Object | undefined): System.Object | undefined;

			/**
			 * Returns the property value of a specified object with optional index values for
			 * indexed properties.
			 */
			GetValue(
				obj: System.Object | undefined,
				index: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * When overridden in a derived class, returns the property value of a specified object
			 * that has the specified binding, index, and culture-specific information.
			 */
			GetValue(
				obj: System.Object | undefined,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				index: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
			): System.Object | undefined;

			/** Sets the property value of a specified object. */
			SetValue(
				obj: System.Object | undefined,
				value: System.Object | undefined,
			): void;

			/**
			 * Sets the property value of a specified object with optional index values for index
			 * properties.
			 */
			SetValue(
				obj: System.Object | undefined,
				value: System.Object | undefined,
				index: System.Object | undefined[] | undefined,
			): void;

			/**
			 * When overridden in a derived class, sets the property value for a specified object
			 * that has the specified binding, index, and culture-specific information.
			 */
			SetValue(
				obj: System.Object | undefined,
				value: System.Object | undefined,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				index: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
			): void;
		}
	}

	export namespace System.Reflection {
		/** Represents a context that can provide reflection objects. */
		export class ReflectionContext {
			/**
			 * Gets the representation of the type of the specified object in this reflection
			 * context.
			 */
			GetTypeForObject(value: System.Object): System.Reflection.TypeInfo;

			/**
			 * Gets the representation, in this reflection context, of an assembly that is
			 * represented by an object from another reflection context.
			 */
			MapAssembly(assembly: System.Reflection.Assembly): System.Reflection.Assembly;

			/**
			 * Gets the representation, in this reflection context, of a type represented by an
			 * object from another reflection context.
			 */
			MapType(type: System.Reflection.TypeInfo): System.Reflection.TypeInfo;
		}
	}

	export namespace System.Reflection {
		/**
		 * The exception that is thrown by the {@link System.Reflection.Module.GetTypes} method
		 * if any of the classes in a module cannot be loaded. This class cannot be inherited.
		 */
		export class ReflectionTypeLoadException extends System.SystemException {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.ReflectionTypeLoadException} class with the given classes and
			 * their associated exceptions.
			 */
			constructor(
				classes: System.Type | undefined[] | undefined,
				exceptions: System.Exception | undefined[] | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.ReflectionTypeLoadException} class with the given classes,
			 * their associated exceptions, and exception descriptions.
			 */
			constructor(
				classes: System.Type | undefined[] | undefined,
				exceptions: System.Exception | undefined[] | undefined,
				message: string | undefined,
			);

			/** Gets the array of exceptions thrown by the class loader. */
			readonly LoaderExceptions: System.Exception | undefined[];

			/** Gets the error message for this exception. */
			readonly Message: string;

			/** Gets the array of classes that were defined in the module and loaded. */
			readonly Types: System.Type | undefined[];

			/**
			 * Returns the fully qualified name of this exception and the messages for all the loader
			 * exceptions.
			 */
			ToString(): string;
		}
	}

	export namespace System.Reflection {
		/** Specifies the attributes for a manifest resource. */
		export enum ResourceAttributes {
			/** A mask used to retrieve public manifest resources. */
			Public = 1,

			/** A mask used to retrieve private manifest resources. */
			Private = 2,
		}
	}

	export namespace System.Reflection {
		/** Specifies the resource location. */
		export enum ResourceLocation {
			/** Specifies an embedded (that is, non-linked) resource. */
			Embedded = 1,

			/** Specifies that the resource is contained in another assembly. */
			ContainedInAnotherAssembly = 2,

			/** Specifies that the resource is contained in the manifest file. */
			ContainedInManifestFile = 4,
		}
	}

	export namespace System.Reflection {
		/** Provides methods that retrieve information about types at run time. */
		export namespace RuntimeReflectionExtensions {
			/** Gets an object that represents the method represented by the specified delegate. */
			export function GetMethodInfo(del: System.Delegate): System.Reflection.MethodInfo;

			/**
			 * Retrieves an object that represents the specified method on the direct or indirect
			 * base class where the method was first declared.
			 */
			export function GetRuntimeBaseDefinition(method: System.Reflection.MethodInfo): System.Reflection.MethodInfo | undefined;

			/** Retrieves an object that represents the specified event. */
			export function GetRuntimeEvent(
				type: System.Type,
				name: string,
			): System.Reflection.EventInfo | undefined;

			/** Retrieves a collection that represents all the events defined on a specified type. */
			export function GetRuntimeEvents(type: System.Type): Iterable<System.Reflection.EventInfo>;

			/** Retrieves an object that represents a specified field. */
			export function GetRuntimeField(
				type: System.Type,
				name: string,
			): System.Reflection.FieldInfo | undefined;

			/** Retrieves a collection that represents all the fields defined on a specified type. */
			export function GetRuntimeFields(type: System.Type): Iterable<System.Reflection.FieldInfo>;

			/** Returns an interface mapping for the specified type and the specified interface. */
			export function GetRuntimeInterfaceMap(
				typeInfo: System.Reflection.TypeInfo,
				interfaceType: System.Type,
			): System.Reflection.InterfaceMapping;

			/** Retrieves an object that represents a specified method. */
			export function GetRuntimeMethod(
				type: System.Type,
				name: string,
				parameters: System.Type[],
			): System.Reflection.MethodInfo | undefined;

			/** Retrieves a collection that represents all methods defined on a specified type. */
			export function GetRuntimeMethods(type: System.Type): Iterable<System.Reflection.MethodInfo>;

			/**
			 * Retrieves a collection that represents all the properties defined on a specified type.
			 */
			export function GetRuntimeProperties(type: System.Type): Iterable<System.Reflection.PropertyInfo>;

			/** Retrieves an object that represents a specified property. */
			export function GetRuntimeProperty(
				type: System.Type,
				name: string,
			): System.Reflection.PropertyInfo | undefined;
		}
	}

	export namespace System {
		/** Extension methods from {@link System.Reflection.RuntimeReflectionExtensions} */
		export interface Delegate {
			/** Gets an object that represents the method represented by the specified delegate. */
			GetMethodInfo(): System.Reflection.MethodInfo;
		}
	}

	export namespace System.Reflection {
		/** Extension methods from {@link System.Reflection.RuntimeReflectionExtensions} */
		export interface MethodInfo {
			/**
			 * Retrieves an object that represents the specified method on the direct or indirect
			 * base class where the method was first declared.
			 */
			GetRuntimeBaseDefinition(): System.Reflection.MethodInfo | undefined;
		}
	}

	export namespace System {
		/** Extension methods from {@link System.Reflection.RuntimeReflectionExtensions} */
		export interface Type {
			/** Retrieves an object that represents the specified event. */
			GetRuntimeEvent(name: string): System.Reflection.EventInfo | undefined;

			/** Retrieves a collection that represents all the events defined on a specified type. */
			GetRuntimeEvents(): Iterable<System.Reflection.EventInfo>;

			/** Retrieves an object that represents a specified field. */
			GetRuntimeField(name: string): System.Reflection.FieldInfo | undefined;

			/** Retrieves a collection that represents all the fields defined on a specified type. */
			GetRuntimeFields(): Iterable<System.Reflection.FieldInfo>;

			/** Retrieves an object that represents a specified method. */
			GetRuntimeMethod(
				name: string,
				parameters: System.Type[],
			): System.Reflection.MethodInfo | undefined;

			/** Retrieves a collection that represents all methods defined on a specified type. */
			GetRuntimeMethods(): Iterable<System.Reflection.MethodInfo>;

			/**
			 * Retrieves a collection that represents all the properties defined on a specified type.
			 */
			GetRuntimeProperties(): Iterable<System.Reflection.PropertyInfo>;

			/** Retrieves an object that represents a specified property. */
			GetRuntimeProperty(name: string): System.Reflection.PropertyInfo | undefined;
		}
	}

	export namespace System.Reflection {
		/** Extension methods from {@link System.Reflection.RuntimeReflectionExtensions} */
		export interface TypeInfo {
			/** Returns an interface mapping for the specified type and the specified interface. */
			GetRuntimeInterfaceMap(interfaceType: System.Type): System.Reflection.InterfaceMapping;
		}
	}

	export namespace System.Reflection {
		/**
		 * Encapsulates access to a public or private key pair used to sign strong name
		 * assemblies.
		 */
		export class StrongNameKeyPair {
			/**
			 * Initializes a new instance of the {@link System.Reflection.StrongNameKeyPair} class,
			 * building the key pair from a `byte` array.
			 */
			constructor(keyPairArray: number[]);

			/**
			 * Initializes a new instance of the {@link System.Reflection.StrongNameKeyPair} class,
			 * building the key pair from a `FileStream`.
			 */
			constructor(keyPairFile: System.IO.FileStream);

			/**
			 * Initializes a new instance of the {@link System.Reflection.StrongNameKeyPair} class,
			 * building the key pair from a `String`.
			 */
			constructor(keyPairContainer: string);

			/** Gets the public part of the public key or public key token of the key pair. */
			readonly PublicKey: number[];
		}
	}

	export namespace System.Reflection {
		/**
		 * Represents the exception that is thrown when an attempt is made to invoke an invalid
		 * target.
		 */
		export class TargetException extends System.ApplicationException {
			/**
			 * Initializes a new instance of the {@link System.Reflection.TargetException} class with
			 * an empty message and the root cause of the exception.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Reflection.TargetException} class with
			 * the given message and the root cause exception.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.Reflection.TargetException} class with
			 * a specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System.Reflection {
		/**
		 * The exception that is thrown by methods invoked through reflection. This class cannot
		 * be inherited.
		 */
		export class TargetInvocationException extends System.ApplicationException {
			/**
			 * Initializes a new instance of the {@link System.Reflection.TargetInvocationException}
			 * class with a reference to the inner exception that is the cause of this exception.
			 */
			constructor(inner: System.Exception | undefined);

			/**
			 * Initializes a new instance of the {@link System.Reflection.TargetInvocationException}
			 * class with a specified error message and a reference to the inner exception that is
			 * the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System.Reflection {
		/**
		 * The exception that is thrown when the number of parameters for an invocation does not
		 * match the number expected. This class cannot be inherited.
		 */
		export class TargetParameterCountException extends System.ApplicationException {
			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.TargetParameterCountException} class with an empty message
			 * string and the root cause of the exception.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.TargetParameterCountException} class with its message string
			 * set to the given message and the root cause exception.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Reflection.TargetParameterCountException} class with a specified error
			 * message and a reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);
		}
	}

	export namespace System.Reflection {
		/** Specifies type attributes. */
		export enum TypeAttributes {
			/** LPTSTR is interpreted as ANSI. */
			AnsiClass = 0,

			/**
			 * Specifies that class fields are automatically laid out by the common language runtime.
			 */
			AutoLayout = 0,

			/** Specifies that the type is a class. */
			Class = 0,

			/** Specifies that the class is not public. */
			NotPublic = 0,

			/** Specifies that the class is public. */
			Public = 1,

			/** Specifies that the class is nested with public visibility. */
			NestedPublic = 2,

			/** Specifies that the class is nested with private visibility. */
			NestedPrivate = 3,

			/**
			 * Specifies that the class is nested with family visibility, and is thus accessible only
			 * by methods within its own type and any derived types.
			 */
			NestedFamily = 4,

			/**
			 * Specifies that the class is nested with assembly visibility, and is thus accessible
			 * only by methods within its assembly.
			 */
			NestedAssembly = 5,

			/**
			 * Specifies that the class is nested with assembly and family visibility, and is thus
			 * accessible only by methods lying in the intersection of its family and assembly.
			 */
			NestedFamANDAssem = 6,

			/**
			 * Specifies that the class is nested with family or assembly visibility, and is thus
			 * accessible only by methods lying in the union of its family and assembly.
			 */
			NestedFamORAssem = 7,

			/** Specifies type visibility information. */
			VisibilityMask = 7,

			/**
			 * Specifies that class fields are laid out sequentially, in the order that the fields
			 * were emitted to the metadata.
			 */
			SequentialLayout = 8,

			/** Specifies that class fields are laid out at the specified offsets. */
			ExplicitLayout = 16,

			/** Specifies class layout information. */
			LayoutMask = 24,

			/**
			 * Specifies class semantics information; the current class is contextful (else agile).
			 */
			ClassSemanticsMask = 32,

			/** Specifies that the type is an interface. */
			Interface = 32,

			/** Specifies that the type is abstract. */
			Abstract = 128,

			/** Specifies that the class is concrete and cannot be extended. */
			Sealed = 256,

			/** Specifies that the class is special in a way denoted by the name. */
			SpecialName = 1024,

			/** Runtime should check name encoding. */
			RTSpecialName = 2048,

			/** Specifies that the class or interface is imported from another module. */
			Import = 4096,

			/** Specifies that the class can be serialized. */
			Serializable = 8192,

			/** Specifies a Windows Runtime type. */
			WindowsRuntime = 16384,

			/** LPTSTR is interpreted as UNICODE. */
			UnicodeClass = 65536,

			/** LPTSTR is interpreted automatically. */
			AutoClass = 131072,

			/**
			 * LPSTR is interpreted by some implementation-specific means, which includes the
			 * possibility of throwing a {@link System.NotSupportedException}. Not used in the
			 * Microsoft implementation of the .NET Framework.
			 */
			CustomFormatClass = 196608,

			/** Used to retrieve string information for native interoperability. */
			StringFormatMask = 196608,

			/** Type has security associate with it. */
			HasSecurity = 262144,

			/** Attributes reserved for runtime use. */
			ReservedMask = 264192,

			/**
			 * Specifies that calling static methods of the type does not force the system to
			 * initialize the type.
			 */
			BeforeFieldInit = 1048576,

			/**
			 * Used to retrieve non-standard encoding information for native interop. The meaning of
			 * the values of these 2 bits is unspecified. Not used in the Microsoft implementation of
			 * the .NET Framework.
			 */
			CustomFormatMask = 12582912,
		}
	}

	export namespace System.Reflection {
		/** Wraps a {@link System.Type} object and delegates methods to that `Type`. */
		export class TypeDelegator extends System.Reflection.TypeInfo implements
			System.Reflection.ICustomAttributeProvider,
			System.Reflection.IReflect {
			/**
			 * Initializes a new instance of the {@link System.Reflection.TypeDelegator} class
			 * specifying the encapsulating instance.
			 */
			constructor(delegatingType: System.Type);

			/** Gets the assembly of the implemented type. */
			readonly Assembly: System.Reflection.Assembly;

			/** Gets the assembly's fully qualified name. */
			readonly AssemblyQualifiedName?: string;

			/** Gets the base type for the current type. */
			readonly BaseType?: System.Type;

			/** Gets the fully qualified name of the implemented type. */
			readonly FullName?: string;

			/** Gets the GUID (globally unique identifier) of the implemented type. */
			readonly GUID: string;

			readonly IsByRefLike: boolean;

			/**
			 * Gets the {@link System.Reflection.MemberInfo.IsCollectible} value for this object's
			 * {@link System.Reflection.TypeDelegator.typeImpl}, which indicates whether this object,
			 * which is a {@link System.Reflection.MemberInfo} implementation, is part of an assembly
			 * held in a collectible {@link System.Runtime.Loader.AssemblyLoadContext}.
			 */
			readonly IsCollectible: boolean;

			/**
			 * Gets a value that indicates whether this object represents a constructed generic type.
			 */
			readonly IsConstructedGenericType: boolean;

			/**
			 * Gets a value that indicates whether the current {@link System.Type} is a function
			 * pointer.
			 */
			readonly IsFunctionPointer: boolean;

			readonly IsGenericMethodParameter: boolean;

			readonly IsGenericTypeParameter: boolean;

			readonly IsSZArray: boolean;

			readonly IsTypeDefinition: boolean;

			/**
			 * Gets a value that indicates whether the current {@link System.Type} is an unmanaged
			 * function pointer.
			 */
			readonly IsUnmanagedFunctionPointer: boolean;

			readonly IsVariableBoundArray: boolean;

			/** Gets a value that identifies this entity in metadata. */
			readonly MetadataToken: number;

			/** Gets the module that contains the implemented type. */
			readonly Module: System.Reflection.Module;

			/** Gets the name of the implemented type, with the path removed. */
			readonly Name: string;

			/** Gets the namespace of the implemented type. */
			readonly Namespace?: string;

			/** Gets a handle to the internal metadata representation of an implemented type. */
			readonly TypeHandle: System.RuntimeTypeHandle;

			/** Gets the underlying {@link System.Type} that represents the implemented type. */
			readonly UnderlyingSystemType: System.Type;

			/**
			 * Returns an array of {@link System.Reflection.ConstructorInfo} objects representing
			 * constructors defined for the type wrapped by the current
			 * {@link System.Reflection.TypeDelegator}.
			 */
			GetConstructors(bindingAttr: System.Reflection.BindingFlags): System.Reflection.ConstructorInfo[];

			/**
			 * Returns all the custom attributes defined for this type, specifying whether to search
			 * the type's inheritance chain.
			 */
			GetCustomAttributes(inherit: boolean): System.Object[];

			/** Returns an array of custom attributes identified by type. */
			GetCustomAttributes(
				attributeType: System.Type,
				inherit: boolean,
			): System.Object[];

			/**
			 * Returns the {@link System.Type} of the object encompassed or referred to by the
			 * current array, pointer or ByRef.
			 */
			GetElementType(): System.Type | undefined;

			/** Returns the specified event. */
			GetEvent(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.EventInfo | undefined;

			/**
			 * Returns an array of {@link System.Reflection.EventInfo} objects representing all the
			 * public events declared or inherited by the current `TypeDelegator`.
			 */
			GetEvents(): System.Reflection.EventInfo[];

			/**
			 * Returns the events specified in `bindingAttr` that are declared or inherited by the
			 * current `TypeDelegator`.
			 */
			GetEvents(bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo[];

			/**
			 * Returns a {@link System.Reflection.FieldInfo} object representing the field with the
			 * specified name.
			 */
			GetField(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.FieldInfo | undefined;

			/**
			 * Returns an array of {@link System.Reflection.FieldInfo} objects representing the data
			 * fields defined for the type wrapped by the current
			 * {@link System.Reflection.TypeDelegator}.
			 */
			GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];

			/**
			 * When overridden in a derived class, returns the calling conventions of the current
			 * function pointer {@link System.Type}.
			 */
			GetFunctionPointerCallingConventions(): System.Type[];

			/**
			 * When overridden in a derived class, returns the parameter types of the current
			 * function pointer {@link System.Type}.
			 */
			GetFunctionPointerParameterTypes(): System.Type[];

			/**
			 * When overridden in a derived class, returns the return type of the current function
			 * pointer {@link System.Type}.
			 */
			GetFunctionPointerReturnType(): System.Type;

			/**
			 * Returns the specified interface implemented by the type wrapped by the current
			 * {@link System.Reflection.TypeDelegator}.
			 */
			GetInterface(
				name: string,
				ignoreCase: boolean,
			): System.Type | undefined;

			/** Returns an interface mapping for the specified interface type. */
			GetInterfaceMap(interfaceType: System.Type): System.Reflection.InterfaceMapping;

			/** Returns all the interfaces implemented on the current class and its base classes. */
			GetInterfaces(): System.Type[];

			/**
			 * Returns members (properties, methods, constructors, fields, events, and nested types)
			 * specified by the given `name`, `type`, and `bindingAttr`.
			 */
			GetMember(
				name: string,
				type: System.Reflection.MemberTypes,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.MemberInfo[];

			/** Returns members specified by `bindingAttr`. */
			GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];

			/**
			 * Searches for the {@link System.Reflection.MemberInfo} on the current
			 * {@link System.Type} that matches the specified {@link System.Reflection.MemberInfo}.
			 */
			GetMemberWithSameMetadataDefinitionAs(member: System.Reflection.MemberInfo): System.Reflection.MemberInfo;

			/**
			 * Returns an array of {@link System.Reflection.MethodInfo} objects representing
			 * specified methods of the type wrapped by the current
			 * {@link System.Reflection.TypeDelegator}.
			 */
			GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];

			/**
			 * Returns a nested type specified by `name` and in `bindingAttr` that are declared or
			 * inherited by the type represented by the current
			 * {@link System.Reflection.TypeDelegator}.
			 */
			GetNestedType(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Type | undefined;

			/**
			 * Returns the nested types specified in `bindingAttr` that are declared or inherited by
			 * the type wrapped by the current {@link System.Reflection.TypeDelegator}.
			 */
			GetNestedTypes(bindingAttr: System.Reflection.BindingFlags): System.Type[];

			/**
			 * Returns an array of {@link System.Reflection.PropertyInfo} objects representing
			 * properties of the type wrapped by the current {@link System.Reflection.TypeDelegator}.
			 */
			GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];

			/**
			 * Invokes the specified member. The method that is to be invoked must be accessible and
			 * provide the most specific match with the specified argument list, under the
			 * constraints of the specified binder and invocation attributes.
			 */
			InvokeMember(
				name: string,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				target: System.Object | undefined,
				args: System.Object | undefined[] | undefined,
				modifiers: System.Reflection.ParameterModifier[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
				namedParameters: string[] | undefined,
			): System.Object | undefined;

			/**
			 * Returns a value that indicates whether the specified type can be assigned to this
			 * type.
			 */
			IsAssignableFrom(typeInfo: System.Reflection.TypeInfo | undefined): boolean;

			/** Indicates whether a custom attribute identified by `attributeType` is defined. */
			IsDefined(
				attributeType: System.Type,
				inherit: boolean,
			): boolean;

			/** Returns all the public constructors defined for the current {@link System.Type}. */
			GetConstructors(): System.Reflection.ConstructorInfo[];

			/**
			 * Returns the {@link System.Reflection.EventInfo} object representing the specified
			 * public event.
			 */
			GetEvent(name: string): System.Reflection.EventInfo | undefined;

			/** Searches for the public field with the specified name. */
			GetField(name: string): System.Reflection.FieldInfo | undefined;

			/** Returns all the public fields of the current {@link System.Type}. */
			GetFields(): System.Reflection.FieldInfo[];

			/** Searches for the interface with the specified name. */
			GetInterface(name: string): System.Type | undefined;

			/** Searches for the public members with the specified name. */
			GetMember(name: string): System.Reflection.MemberInfo[];

			/** Searches for the specified members, using the specified binding constraints. */
			GetMember(
				name: string,
				bindingAttr: System.Reflection.BindingFlags,
			): System.Reflection.MemberInfo[];

			/** Returns all the public members of the current {@link System.Type}. */
			GetMembers(): System.Reflection.MemberInfo[];

			/** Returns all the public methods of the current {@link System.Type}. */
			GetMethods(): System.Reflection.MethodInfo[];

			/** Searches for the public nested type with the specified name. */
			GetNestedType(name: string): System.Type | undefined;

			/** Returns the public types nested in the current {@link System.Type}. */
			GetNestedTypes(): System.Type[];

			/** Returns all the public properties of the current {@link System.Type}. */
			GetProperties(): System.Reflection.PropertyInfo[];

			/**
			 * Invokes the specified member, using the specified binding constraints and matching the
			 * specified argument list.
			 */
			InvokeMember(
				name: string,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				target: System.Object | undefined,
				args: System.Object | undefined[] | undefined,
			): System.Object | undefined;

			/**
			 * Invokes the specified member, using the specified binding constraints and matching the
			 * specified argument list and culture.
			 */
			InvokeMember(
				name: string,
				invokeAttr: System.Reflection.BindingFlags,
				binder: System.Reflection.Binder | undefined,
				target: System.Object | undefined,
				args: System.Object | undefined[] | undefined,
				culture: System.Globalization.CultureInfo | undefined,
			): System.Object | undefined;

			/**
			 * Determines whether an instance of a specified type `c` can be assigned to a variable
			 * of the current type.
			 */
			IsAssignableFrom(c: System.Type | undefined): boolean;
		}
	}

	export namespace System.Reflection {
		/** Filters the classes represented in an array of {@link System.Type} objects. */
		export interface TypeFilter { (
			m: System.Type,
			filterCriteria: System.Object | undefined,
		): boolean; }
	}

	export namespace System.Reflection {
		/**
		 * Represents type declarations for class types, interface types, array types, value
		 * types, enumeration types, type parameters, generic type definitions, and open or
		 * closed constructed generic types.
		 */
		export class TypeInfo extends System.Type implements
			System.Reflection.ICustomAttributeProvider,
			System.Reflection.IReflect {
			/** Gets a collection of the constructors declared by the current type. */
			readonly DeclaredConstructors: Iterable<System.Reflection.ConstructorInfo>;

			/** Gets a collection of the events defined by the current type. */
			readonly DeclaredEvents: Iterable<System.Reflection.EventInfo>;

			/** Gets a collection of the fields defined by the current type. */
			readonly DeclaredFields: Iterable<System.Reflection.FieldInfo>;

			/** Gets a collection of the members defined by the current type. */
			readonly DeclaredMembers: Iterable<System.Reflection.MemberInfo>;

			/** Gets a collection of the methods defined by the current type. */
			readonly DeclaredMethods: Iterable<System.Reflection.MethodInfo>;

			/** Gets a collection of the nested types defined by the current type. */
			readonly DeclaredNestedTypes: Iterable<System.Reflection.TypeInfo>;

			/** Gets a collection of the properties defined by the current type. */
			readonly DeclaredProperties: Iterable<System.Reflection.PropertyInfo>;

			/** Gets an array of the generic type parameters of the current instance. */
			readonly GenericTypeParameters: System.Type[];

			/** Gets a collection of the interfaces implemented by the current type. */
			readonly ImplementedInterfaces: Iterable<System.Type>;

			/** Returns the current type as a {@link System.Type} object. */
			AsType(): System.Type;

			/**
			 * Returns an object that represents the specified event declared by the current type.
			 */
			GetDeclaredEvent(name: string): System.Reflection.EventInfo | undefined;

			/**
			 * Returns an object that represents the specified field declared by the current type.
			 */
			GetDeclaredField(name: string): System.Reflection.FieldInfo | undefined;

			/**
			 * Returns an object that represents the specified method declared by the current type.
			 */
			GetDeclaredMethod(name: string): System.Reflection.MethodInfo | undefined;

			/**
			 * Returns a collection that contains all methods declared on the current type that match
			 * the specified name.
			 */
			GetDeclaredMethods(name: string): Iterable<System.Reflection.MethodInfo>;

			/**
			 * Returns an object that represents the specified nested type declared by the current
			 * type.
			 */
			GetDeclaredNestedType(name: string): System.Reflection.TypeInfo | undefined;

			/**
			 * Returns an object that represents the specified property declared by the current type.
			 */
			GetDeclaredProperty(name: string): System.Reflection.PropertyInfo | undefined;

			/**
			 * Returns a value that indicates whether the specified type can be assigned to the
			 * current type.
			 */
			IsAssignableFrom(typeInfo: System.Reflection.TypeInfo | undefined): boolean;

			/**
			 * Determines whether an instance of a specified type `c` can be assigned to a variable
			 * of the current type.
			 */
			IsAssignableFrom(c: System.Type | undefined): boolean;
		}
	}

	export namespace System.Numerics {
		/**
		 * Provides utility methods for intrinsic bit-twiddling operations. The methods use
		 * hardware intrinsics when available on the underlying platform; otherwise, they use
		 * optimized software fallbacks.
		 */
		export namespace BitOperations {
			/** Evaluates whether the specified {@link System.Int32} value is a power of two. */
			export function IsPow2(value: number): boolean;

			/** Evaluates whether the specified {@link System.Int64} value is a power of two. */
			export function IsPow2(value: number): boolean;

			/** Determines whether the specified integral value is a power of 2. */
			export function IsPow2(value: System.IntPtr): boolean;

			/** Evaluates whether the specified {@link System.UInt32} value is a power of two. */
			export function IsPow2(value: number): boolean;

			/** Evaluates whether the specified {@link System.UInt64} value is a power of two. */
			export function IsPow2(value: number): boolean;

			/** Determines whether the specified integral value is a power of 2. */
			export function IsPow2(value: System.UIntPtr): boolean;

			/** Counts the number of leading zero bits in an unsigned 32-bit integer mask. */
			export function LeadingZeroCount(value: number): number;

			/** Counts the number of leading zero bits in an unsigned 64-bit integer mask. */
			export function LeadingZeroCount(value: number): number;

			/**
			 * Counts the number of leading zero bits in a mask. Similar in behavior to the x86
			 * instruction LZCNT.
			 */
			export function LeadingZeroCount(value: System.UIntPtr): number;

			/** Returns the integer (floor) log of the specified value, base 2. */
			export function Log2(value: number): number;

			/** Returns the integer (floor) log of the specified value, base 2. */
			export function Log2(value: number): number;

			/** Returns the integer (floor) log of the specified value, base 2. */
			export function Log2(value: System.UIntPtr): number;

			/** Returns the population count (number of bits set) of a mask. */
			export function PopCount(value: number): number;

			/**
			 * Returns the population count (number of bits set) of an unsigned 64-bit integer mask.
			 */
			export function PopCount(value: number): number;

			/**
			 * Returns the population count (number of bits set) of a mask. Similar in behavior to
			 * the x86 instruction POPCNT.
			 */
			export function PopCount(value: System.UIntPtr): number;

			/** Rotates the specified value left by the specified number of bits. */
			export function RotateLeft(
				value: number,
				offset: number,
			): number;

			/** Rotates the specified value left by the specified number of bits. */
			export function RotateLeft(
				value: number,
				offset: number,
			): number;

			/**
			 * Rotates the specified value left by the specified number of bits. Similar in behavior
			 * to the x86 instruction ROL.
			 */
			export function RotateLeft(
				value: System.UIntPtr,
				offset: number,
			): System.UIntPtr;

			/** Rotates the specified value right by the specified number of bits. */
			export function RotateRight(
				value: number,
				offset: number,
			): number;

			/** Rotates the specified value right by the specified number of bits. */
			export function RotateRight(
				value: number,
				offset: number,
			): number;

			/**
			 * Rotates the specified value right by the specified number of bits. Similar in behavior
			 * to the x86 instruction ROR.
			 */
			export function RotateRight(
				value: System.UIntPtr,
				offset: number,
			): System.UIntPtr;

			/** Rounds the specified {@link System.UInt32} value up to a power of two. */
			export function RoundUpToPowerOf2(value: number): number;

			/** Rounds the specified {@link System.UInt64} value up to a power of two. */
			export function RoundUpToPowerOf2(value: number): number;

			/** Rounds the given integral value up to a power of 2. */
			export function RoundUpToPowerOf2(value: System.UIntPtr): System.UIntPtr;

			/** Counts the number of trailing zero bits in an 32-bit integer value mask. */
			export function TrailingZeroCount(value: number): number;

			/** Counts the number of trailing zero bits in a 64-bit integer value mask. */
			export function TrailingZeroCount(value: number): number;

			/**
			 * Counts the number of trailing zero bits in a mask. Similar in behavior to the x86
			 * instruction TZCNT.
			 */
			export function TrailingZeroCount(value: System.IntPtr): number;

			/** Counts the number of trailing zero bits in an unsigned 32-bit integer value mask. */
			export function TrailingZeroCount(value: number): number;

			/** Count the number of trailing zero bits in an unsigned 64-bit integer value mask. */
			export function TrailingZeroCount(value: number): number;

			/**
			 * Counts the number of trailing zero bits in a mask. Similar in behavior to the x86
			 * instruction TZCNT.
			 */
			export function TrailingZeroCount(value: System.UIntPtr): number;

			/** Accumulates the CRC (Cyclic redundancy check) checksum. */
			export function Crc32C(
				crc: number,
				data: number,
			): number;

			/** Accumulates the CRC (Cyclic redundancy check) checksum. */
			export function Crc32C(
				crc: number,
				data: number,
			): number;

			/** Accumulates the CRC (Cyclic redundancy check) checksum. */
			export function Crc32C(
				crc: number,
				data: number,
			): number;

			/** Accumulates the CRC (Cyclic redundancy check) checksum. */
			export function Crc32C(
				crc: number,
				data: number,
			): number;
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines a mechanism for computing the sum of two values. */
		export function IAdditionOperators$(TSelf: IType, TOther: IType, TResult: IType): IType;

		/** Defines a mechanism for computing the sum of two values. */
		export interface IAdditionOperators$3<TSelf, TOther, TResult> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for getting the additive identity of a
		 * given type.
		 */
		export function IAdditiveIdentity$(TSelf: IType, TResult: IType): IType;

		/** Defines a mechanism for getting the additive identity of a given type. */
		export interface IAdditiveIdentity$2<TSelf, TResult> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines an IEEE 754 floating-point type that is represented in
		 * a base-2 format.
		 */
		export function IBinaryFloatingPointIeee754$(TSelf: IType): IType;

		/** Defines an IEEE 754 floating-point type that is represented in a base-2 format. */
		export interface IBinaryFloatingPointIeee754$1<TSelf> extends
			System.IComparable$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IBinaryNumber$1<TSelf>,
			System.Numerics.IBitwiseOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IComparisonOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IModulusOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.INumber$1<TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf>,
			System.Numerics.IExponentialFunctions$1<TSelf>,
			System.Numerics.IFloatingPointConstants$1<TSelf>,
			System.Numerics.IFloatingPoint$1<TSelf>,
			System.Numerics.ISignedNumber$1<TSelf>,
			System.Numerics.IFloatingPointIeee754$1<TSelf>,
			System.Numerics.IHyperbolicFunctions$1<TSelf>,
			System.Numerics.ILogarithmicFunctions$1<TSelf>,
			System.Numerics.IPowerFunctions$1<TSelf>,
			System.Numerics.IRootFunctions$1<TSelf>,
			System.Numerics.ITrigonometricFunctions$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines an integer type that is represented in a base-2 format.
		 */
		export function IBinaryInteger$(TSelf: IType): IType;

		/** Defines an integer type that is represented in a base-2 format. */
		export interface IBinaryInteger$1<TSelf> extends
			System.IComparable$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IBinaryNumber$1<TSelf>,
			System.Numerics.IBitwiseOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IComparisonOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IModulusOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.INumber$1<TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf>,
			System.Numerics.IShiftOperators$3<TSelf, number, TSelf> {
			/**
			 * Gets the number of bytes that will be written as part of
			 * {@link System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)}.
			 */
			GetByteCount(): number;

			/**
			 * Gets the length, in bits, of the shortest two's complement representation of the
			 * current value.
			 */
			GetShortestBitLength(): number;

			TryWriteBigEndian(destination: System.Span$1<number>): number | undefined;

			TryWriteLittleEndian(destination: System.Span$1<number>): number | undefined;

			/** Writes the current value, in big-endian format, to a given array. */
			WriteBigEndian(destination: number[]): number;

			/** Writes the current value, in big-endian format, to a given array. */
			WriteBigEndian(
				destination: number[],
				startIndex: number,
			): number;

			/** Writes the current value, in big-endian format, to a given span. */
			WriteBigEndian(destination: System.Span$1<number>): number;

			/** Writes the current value, in little-endian format, to a given array. */
			WriteLittleEndian(destination: number[]): number;

			/**
			 * Writes the current value, in little-endian format, to a specified array starting at a
			 * specified index.
			 */
			WriteLittleEndian(
				destination: number[],
				startIndex: number,
			): number;

			/** Writes the current value, in little-endian format, to a given span. */
			WriteLittleEndian(destination: System.Span$1<number>): number;
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines a number that is represented in a base-2 format. */
		export function IBinaryNumber$(TSelf: IType): IType;

		/** Defines a number that is represented in a base-2 format. */
		export interface IBinaryNumber$1<TSelf> extends
			System.IComparable$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IBitwiseOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IComparisonOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IModulusOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.INumber$1<TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for performing bitwise operations over two
		 * values.
		 */
		export function IBitwiseOperators$(TSelf: IType, TOther: IType, TResult: IType): IType;

		/** Defines a mechanism for performing bitwise operations over two values. */
		export interface IBitwiseOperators$3<TSelf, TOther, TResult> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for comparing two values to determine
		 * relative order.
		 */
		export function IComparisonOperators$(TSelf: IType, TOther: IType, TResult: IType): IType;

		/** Defines a mechanism for comparing two values to determine relative order. */
		export interface IComparisonOperators$3<TSelf, TOther, TResult> extends System.Numerics.IEqualityOperators$3<TSelf, TOther, TResult> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines a mechanism for decrementing a given value. */
		export function IDecrementOperators$(TSelf: IType): IType;

		/** Defines a mechanism for decrementing a given value. */
		export interface IDecrementOperators$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for computing the quotient of two values.
		 */
		export function IDivisionOperators$(TSelf: IType, TOther: IType, TResult: IType): IType;

		/** Defines a mechanism for computing the quotient of two values. */
		export interface IDivisionOperators$3<TSelf, TOther, TResult> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for comparing two values to determine
		 * equality.
		 */
		export function IEqualityOperators$(TSelf: IType, TOther: IType, TResult: IType): IType;

		/** Defines a mechanism for comparing two values to determine equality. */
		export interface IEqualityOperators$3<TSelf, TOther, TResult> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines support for exponential functions. */
		export function IExponentialFunctions$(TSelf: IType): IType;

		/** Defines support for exponential functions. */
		export interface IExponentialFunctions$1<TSelf> extends
			System.Numerics.IFloatingPointConstants$1<TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines support for floating-point constants. */
		export function IFloatingPointConstants$(TSelf: IType): IType;

		/** Defines support for floating-point constants. */
		export interface IFloatingPointConstants$1<TSelf> extends
			System.Numerics.INumberBase$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines an IEEE 754 floating-point type. */
		export function IFloatingPointIeee754$(TSelf: IType): IType;

		/** Defines an IEEE 754 floating-point type. */
		export interface IFloatingPointIeee754$1<TSelf> extends
			System.IComparable$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IComparisonOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IExponentialFunctions$1<TSelf>,
			System.Numerics.IFloatingPointConstants$1<TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf>,
			System.Numerics.IFloatingPoint$1<TSelf>,
			System.Numerics.IModulusOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.INumber$1<TSelf>,
			System.Numerics.ISignedNumber$1<TSelf>,
			System.Numerics.IHyperbolicFunctions$1<TSelf>,
			System.Numerics.ILogarithmicFunctions$1<TSelf>,
			System.Numerics.IPowerFunctions$1<TSelf>,
			System.Numerics.IRootFunctions$1<TSelf>,
			System.Numerics.ITrigonometricFunctions$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines a floating-point type. */
		export function IFloatingPoint$(TSelf: IType): IType;

		/** Defines a floating-point type. */
		export interface IFloatingPoint$1<TSelf> extends
			System.IComparable$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IComparisonOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IFloatingPointConstants$1<TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf>,
			System.Numerics.IModulusOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.INumber$1<TSelf>,
			System.Numerics.ISignedNumber$1<TSelf> {
			/**
			 * Gets the number of bytes that will be written as part of
			 * {@link System.Numerics.IFloatingPoint`1.TryWriteExponentLittleEndian(System.Span{System.Byte},System.Int32@)}.
			 */
			GetExponentByteCount(): number;

			/**
			 * Gets the length, in bits, of the shortest two's complement representation of the
			 * current exponent.
			 */
			GetExponentShortestBitLength(): number;

			/** Gets the length, in bits, of the current significand. */
			GetSignificandBitLength(): number;

			/**
			 * Gets the number of bytes that will be written as part of
			 * {@link System.Numerics.IFloatingPoint`1.TryWriteSignificandLittleEndian(System.Span{System.Byte},System.Int32@)}.
			 */
			GetSignificandByteCount(): number;

			TryWriteExponentBigEndian(destination: System.Span$1<number>): number | undefined;

			TryWriteExponentLittleEndian(destination: System.Span$1<number>): number | undefined;

			TryWriteSignificandBigEndian(destination: System.Span$1<number>): number | undefined;

			TryWriteSignificandLittleEndian(destination: System.Span$1<number>): number | undefined;

			/** Writes the current exponent, in big-endian format, to a given array. */
			WriteExponentBigEndian(destination: number[]): number;

			/** Writes the current exponent, in big-endian format, to a given array. */
			WriteExponentBigEndian(
				destination: number[],
				startIndex: number,
			): number;

			/** Writes the current exponent, in big-endian format, to a given span. */
			WriteExponentBigEndian(destination: System.Span$1<number>): number;

			/** Writes the current exponent, in little-endian format, to a given array. */
			WriteExponentLittleEndian(destination: number[]): number;

			/** Writes the current exponent, in little-endian format, to a given array. */
			WriteExponentLittleEndian(
				destination: number[],
				startIndex: number,
			): number;

			/** Writes the current exponent, in little-endian format, to a given span. */
			WriteExponentLittleEndian(destination: System.Span$1<number>): number;

			/** Writes the current significand, in big-endian format, to a given array. */
			WriteSignificandBigEndian(destination: number[]): number;

			/** Writes the current significand, in big-endian format, to a given array. */
			WriteSignificandBigEndian(
				destination: number[],
				startIndex: number,
			): number;

			/** Writes the current significand, in big-endian format, to a given span. */
			WriteSignificandBigEndian(destination: System.Span$1<number>): number;

			/** Writes the current significand, in little-endian format, to a given array. */
			WriteSignificandLittleEndian(destination: number[]): number;

			/** Writes the current significand, in little-endian format, to a given array. */
			WriteSignificandLittleEndian(
				destination: number[],
				startIndex: number,
			): number;

			/** Writes the current significand, in little-endian format, to a given span. */
			WriteSignificandLittleEndian(destination: System.Span$1<number>): number;
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines support for hyperbolic functions. */
		export function IHyperbolicFunctions$(TSelf: IType): IType;

		/** Defines support for hyperbolic functions. */
		export interface IHyperbolicFunctions$1<TSelf> extends
			System.Numerics.IFloatingPointConstants$1<TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines a mechanism for incrementing a given value. */
		export function IIncrementOperators$(TSelf: IType): IType;

		/** Defines a mechanism for incrementing a given value. */
		export interface IIncrementOperators$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines support for logarithmic functions. */
		export function ILogarithmicFunctions$(TSelf: IType): IType;

		/** Defines support for logarithmic functions. */
		export interface ILogarithmicFunctions$1<TSelf> extends
			System.Numerics.IFloatingPointConstants$1<TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for getting the minimum and maximum value
		 * of a type.
		 */
		export function IMinMaxValue$(TSelf: IType): IType;

		/** Defines a mechanism for getting the minimum and maximum value of a type. */
		export interface IMinMaxValue$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for computing the modulus or remainder of
		 * two values.
		 */
		export function IModulusOperators$(TSelf: IType, TOther: IType, TResult: IType): IType;

		/** Defines a mechanism for computing the modulus or remainder of two values. */
		export interface IModulusOperators$3<TSelf, TOther, TResult> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for getting the multiplicative identity of
		 * a given type.
		 */
		export function IMultiplicativeIdentity$(TSelf: IType, TResult: IType): IType;

		/** Defines a mechanism for getting the multiplicative identity of a given type. */
		export interface IMultiplicativeIdentity$2<TSelf, TResult> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for computing the product of two values.
		 */
		export function IMultiplyOperators$(TSelf: IType, TOther: IType, TResult: IType): IType;

		/** Defines a mechanism for computing the product of two values. */
		export interface IMultiplyOperators$3<TSelf, TOther, TResult> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines the base of other number types. */
		export function INumberBase$(TSelf: IType): IType;

		/** Defines the base of other number types. */
		export interface INumberBase$1<TSelf> extends
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines a number type. */
		export function INumber$(TSelf: IType): IType;

		/** Defines a number type. */
		export interface INumber$1<TSelf> extends
			System.IComparable$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IComparisonOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IModulusOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines support for power functions. */
		export function IPowerFunctions$(TSelf: IType): IType;

		/** Defines support for power functions. */
		export interface IPowerFunctions$1<TSelf> extends
			System.Numerics.INumberBase$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines support for root functions. */
		export function IRootFunctions$(TSelf: IType): IType;

		/** Defines support for root functions. */
		export interface IRootFunctions$1<TSelf> extends
			System.Numerics.IFloatingPointConstants$1<TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines a mechanism for shifting a value by another value. */
		export function IShiftOperators$(TSelf: IType, TOther: IType, TResult: IType): IType;

		/** Defines a mechanism for shifting a value by another value. */
		export interface IShiftOperators$3<TSelf, TOther, TResult> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a number type which can represent both positive and
		 * negative values.
		 */
		export function ISignedNumber$(TSelf: IType): IType;

		/** Defines a number type which can represent both positive and negative values. */
		export interface ISignedNumber$1<TSelf> extends
			System.Numerics.INumberBase$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for computing the difference of two values.
		 */
		export function ISubtractionOperators$(TSelf: IType, TOther: IType, TResult: IType): IType;

		/** Defines a mechanism for computing the difference of two values. */
		export interface ISubtractionOperators$3<TSelf, TOther, TResult> {
		}
	}

	export namespace System.Numerics {
		/** [Generic type factory] Defines support for trigonometric functions. */
		export function ITrigonometricFunctions$(TSelf: IType): IType;

		/** Defines support for trigonometric functions. */
		export interface ITrigonometricFunctions$1<TSelf> extends
			System.Numerics.IFloatingPointConstants$1<TSelf>,
			System.Numerics.INumberBase$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for computing the unary negation of a
		 * value.
		 */
		export function IUnaryNegationOperators$(TSelf: IType, TResult: IType): IType;

		/** Defines a mechanism for computing the unary negation of a value. */
		export interface IUnaryNegationOperators$2<TSelf, TResult> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a mechanism for computing the unary plus of a value.
		 */
		export function IUnaryPlusOperators$(TSelf: IType, TResult: IType): IType;

		/** Defines a mechanism for computing the unary plus of a value. */
		export interface IUnaryPlusOperators$2<TSelf, TResult> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Defines a number type that can only represent positive values.
		 */
		export function IUnsignedNumber$(TSelf: IType): IType;

		/** Defines a number type that can only represent positive values. */
		export interface IUnsignedNumber$1<TSelf> extends
			System.Numerics.INumberBase$1<TSelf>,
			System.IEquatable$1<TSelf>,
			System.IFormattable,
			System.IParsable$1<TSelf>,
			System.ISpanParsable$1<TSelf>,
			System.Numerics.IAdditionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IAdditiveIdentity$2<TSelf, TSelf>,
			System.Numerics.IDecrementOperators$1<TSelf>,
			System.Numerics.IDivisionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IEqualityOperators$3<TSelf, TSelf, boolean>,
			System.Numerics.IIncrementOperators$1<TSelf>,
			System.Numerics.IMultiplicativeIdentity$2<TSelf, TSelf>,
			System.Numerics.IMultiplyOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.ISubtractionOperators$3<TSelf, TSelf, TSelf>,
			System.Numerics.IUnaryNegationOperators$2<TSelf, TSelf>,
			System.Numerics.IUnaryPlusOperators$2<TSelf, TSelf>,
			System.IUtf8SpanFormattable,
			System.IUtf8SpanParsable$1<TSelf> {
		}
	}

	export namespace System.Numerics {
		/**
		 * [Generic type factory] Represents a comparison operation that compares floating-point
		 * numbers with IEEE 754 totalOrder semantic.
		 */
		export function TotalOrderIeee754Comparer$(T: IType): typeof TotalOrderIeee754Comparer$1<any>;

		/**
		 * Represents a comparison operation that compares floating-point numbers with IEEE 754
		 * totalOrder semantic.
		 */
		export class TotalOrderIeee754Comparer$1<T> extends System.ValueType implements
			System.IEquatable$1<System.Numerics.TotalOrderIeee754Comparer$1<T>> {
			/**
			 * Compares two numbers with IEEE 754 totalOrder semantic and returns a value indicating
			 * whether one is less than, equal to, or greater than the other.
			 */
			Compare(
				x: T,
				y: T,
			): number;

			/** Indicates whether the current object is equal to another object of the same type. */
			Equals(other: System.Numerics.TotalOrderIeee754Comparer$1<T>): boolean;

			Equals(obj: System.Object | undefined): boolean;

			/** Determines whether the specified numbers are equal. */
			Equals(
				x: T,
				y: T,
			): boolean;

			GetHashCode(): number;

			/** Returns a hash code for the specified number. */
			GetHashCode(obj: T): number;
		}
	}

	export namespace System.Net {
		/** Provides methods for encoding and decoding URLs when processing Web requests. */
		export namespace WebUtility {
			/**
			 * Converts a string that has been HTML-encoded for HTTP transmission into a decoded
			 * string.
			 */
			export function HtmlDecode(value: string | undefined): string | undefined;

			/**
			 * Converts a string that has been HTML-encoded into a decoded string, and sends the
			 * decoded string to a {@link System.IO.TextWriter} output stream.
			 */
			export function HtmlDecode(
				value: string | undefined,
				output: System.IO.TextWriter,
			): void;

			/** Converts a string to an HTML-encoded string. */
			export function HtmlEncode(value: string | undefined): string | undefined;

			/**
			 * Converts a string into an HTML-encoded string, and returns the output as a
			 * {@link System.IO.TextWriter} stream of output.
			 */
			export function HtmlEncode(
				value: string | undefined,
				output: System.IO.TextWriter,
			): void;

			/**
			 * Converts a string that has been encoded for transmission in a URL into a decoded
			 * string.
			 */
			export function UrlDecode(encodedValue: string | undefined): string | undefined;

			/**
			 * Converts an encoded byte array that has been encoded for transmission in a URL into a
			 * decoded byte array.
			 */
			export function UrlDecodeToBytes(
				encodedValue: number[] | undefined,
				offset: number,
				count: number,
			): number[] | undefined;

			/** Converts a text string into a URL-encoded string. */
			export function UrlEncode(value: string | undefined): string | undefined;

			/** Converts a byte array into a URL-encoded byte array. */
			export function UrlEncodeToBytes(
				value: number[] | undefined,
				offset: number,
				count: number,
			): number[] | undefined;
		}
	}

	export namespace System.IO {
		/** Reads primitive data types as binary values in a specific encoding. */
		export class BinaryReader implements IDisposable {
			/**
			 * Initializes a new instance of the {@link System.IO.BinaryReader} class based on the
			 * specified stream and using UTF-8 encoding.
			 */
			constructor(input: Duplex);

			/**
			 * Initializes a new instance of the {@link System.IO.BinaryReader} class based on the
			 * specified stream and character encoding.
			 */
			constructor(
				input: Duplex,
				encoding: System.Text.Encoding,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.BinaryReader} class based on the
			 * specified stream and character encoding, and optionally leaves the stream open.
			 */
			constructor(
				input: Duplex,
				encoding: System.Text.Encoding,
				leaveOpen: boolean,
			);

			/** Exposes access to the underlying stream of the {@link System.IO.BinaryReader}. */
			readonly BaseStream: Duplex;

			/** Closes the current reader and the underlying stream. */
			Close(): void;

			/**
			 * Releases all resources used by the current instance of the
			 * {@link System.IO.BinaryReader} class.
			 */
			dispose(): void;

			/**
			 * Returns the next available character and does not advance the byte or character
			 * position.
			 */
			PeekChar(): number;

			/**
			 * Reads characters from the underlying stream and advances the current position of the
			 * stream in accordance with the `Encoding` used and the specific character being read
			 * from the stream.
			 */
			Read(): number;

			/**
			 * Reads the specified number of bytes from the stream, starting from a specified point
			 * in the byte array.
			 */
			Read(
				buffer: number[],
				index: number,
				count: number,
			): number;

			/**
			 * Reads the specified number of characters from the stream, starting from a specified
			 * point in the character array.
			 */
			Read(
				buffer: System.Char[],
				index: number,
				count: number,
			): number;

			/**
			 * Reads a sequence of bytes from the current stream and advances the position within the
			 * stream by the number of bytes read.
			 */
			Read(buffer: System.Span$1<number>): number;

			/**
			 * Reads, from the current stream, the same number of characters as the length of the
			 * provided buffer, writes them in the provided buffer, and advances the current position
			 * in accordance with the `Encoding` used and the specific character being read from the
			 * stream.
			 */
			Read(buffer: System.Span$1<System.Char>): number;

			/** Reads in a 32-bit integer in compressed format. */
			Read7BitEncodedInt(): number;

			/** Reads a number 7 bits at a time. */
			Read7BitEncodedInt64(): number;

			/**
			 * Reads a `Boolean` value from the current stream and advances the current position of
			 * the stream by one byte.
			 */
			ReadBoolean(): boolean;

			/**
			 * Reads the next byte from the current stream and advances the current position of the
			 * stream by one byte.
			 */
			ReadByte(): number;

			/**
			 * Reads the specified number of bytes from the current stream into a byte array and
			 * advances the current position by that number of bytes.
			 */
			ReadBytes(count: number): number[];

			/**
			 * Reads the next character from the current stream and advances the current position of
			 * the stream in accordance with the `Encoding` used and the specific character being
			 * read from the stream.
			 */
			ReadChar(): System.Char;

			/**
			 * Reads the specified number of characters from the current stream, returns the data in
			 * a character array, and advances the current position in accordance with the `Encoding`
			 * used and the specific character being read from the stream.
			 */
			ReadChars(count: number): System.Char[];

			/**
			 * Reads a decimal value from the current stream and advances the current position of the
			 * stream by sixteen bytes.
			 */
			ReadDecimal(): System.Decimal;

			/**
			 * Reads an 8-byte floating point value from the current stream and advances the current
			 * position of the stream by eight bytes.
			 */
			ReadDouble(): number;

			/**
			 * Reads a 2-byte floating point value from the current stream and advances the current
			 * position of the stream by two bytes.
			 */
			ReadHalf(): System.Half;

			/**
			 * Reads a 2-byte signed integer from the current stream and advances the current
			 * position of the stream by two bytes.
			 */
			ReadInt16(): number;

			/**
			 * Reads a 4-byte signed integer from the current stream and advances the current
			 * position of the stream by four bytes.
			 */
			ReadInt32(): number;

			/**
			 * Reads an 8-byte signed integer from the current stream and advances the current
			 * position of the stream by eight bytes.
			 */
			ReadInt64(): number;

			/**
			 * Reads a signed byte from this stream and advances the current position of the stream
			 * by one byte.
			 */
			ReadSByte(): number;

			/**
			 * Reads a 4-byte floating point value from the current stream and advances the current
			 * position of the stream by four bytes.
			 */
			ReadSingle(): number;

			/**
			 * Reads a string from the current stream. The string is prefixed with the length,
			 * encoded as an integer seven bits at a time.
			 */
			ReadString(): string;

			/**
			 * Reads a 2-byte unsigned integer from the current stream using little-endian encoding
			 * and advances the position of the stream by two bytes.
			 */
			ReadUInt16(): number;

			/**
			 * Reads a 4-byte unsigned integer from the current stream and advances the position of
			 * the stream by four bytes.
			 */
			ReadUInt32(): number;

			/**
			 * Reads an 8-byte unsigned integer from the current stream and advances the position of
			 * the stream by eight bytes.
			 */
			ReadUInt64(): number;
		}
	}

	export namespace System.IO {
		/**
		 * Writes primitive types in binary to a stream and supports writing strings in a
		 * specific encoding.
		 */
		export class BinaryWriter implements
			System.IAsyncDisposable,
			IDisposable {
			/**
			 * Initializes a new instance of the {@link System.IO.BinaryWriter} class based on the
			 * specified stream and using UTF-8 encoding.
			 */
			constructor(output: Duplex);

			/**
			 * Initializes a new instance of the {@link System.IO.BinaryWriter} class based on the
			 * specified stream and character encoding.
			 */
			constructor(
				output: Duplex,
				encoding: System.Text.Encoding,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.BinaryWriter} class based on the
			 * specified stream and character encoding, and optionally leaves the stream open.
			 */
			constructor(
				output: Duplex,
				encoding: System.Text.Encoding,
				leaveOpen: boolean,
			);

			/** Gets the underlying stream of the {@link System.IO.BinaryWriter}. */
			readonly BaseStream: Duplex;

			/** Closes the current {@link System.IO.BinaryWriter} and the underlying stream. */
			Close(): void;

			/**
			 * Releases all resources used by the current instance of the
			 * {@link System.IO.BinaryWriter} class.
			 */
			dispose(): void;

			/**
			 * Asynchronously releases all resources used by the current instance of the
			 * {@link System.IO.BinaryWriter} class.
			 */
			DisposeAsync(): Promise<void>;

			/**
			 * Clears all buffers for the current writer and causes any buffered data to be written
			 * to the underlying device.
			 */
			Flush(): void;

			/** Sets the position within the current stream. */
			Seek(
				offset: number,
				origin: System.IO.SeekOrigin,
			): number;

			/**
			 * Writes a one-byte `Boolean` value to the current stream, with 0 representing `false`
			 * and 1 representing `true`.
			 */
			Write(value: boolean): void;

			/**
			 * Writes an unsigned byte to the current stream and advances the stream position by one
			 * byte.
			 */
			Write(value: number): void;

			/** Writes a byte array to the underlying stream. */
			Write(buffer: number[]): void;

			/** Writes a region of a byte array to the current stream. */
			Write(
				buffer: number[],
				index: number,
				count: number,
			): void;

			/**
			 * Writes a Unicode character to the current stream and advances the current position of
			 * the stream in accordance with the `Encoding` used and the specific characters being
			 * written to the stream.
			 */
			Write(ch: System.Char): void;

			/**
			 * Writes a character array to the current stream and advances the current position of
			 * the stream in accordance with the `Encoding` used and the specific characters being
			 * written to the stream.
			 */
			Write(chars: System.Char[]): void;

			/**
			 * Writes a section of a character array to the current stream, and advances the current
			 * position of the stream in accordance with the `Encoding` used and perhaps the specific
			 * characters being written to the stream.
			 */
			Write(
				chars: System.Char[],
				index: number,
				count: number,
			): void;

			/**
			 * Writes a decimal value to the current stream and advances the stream position by
			 * sixteen bytes.
			 */
			Write(value: System.Decimal): void;

			/**
			 * Writes an eight-byte floating-point value to the current stream and advances the
			 * stream position by eight bytes.
			 */
			Write(value: number): void;

			/**
			 * Writes an two-byte floating-point value to the current stream and advances the stream
			 * position by two bytes.
			 */
			Write(value: System.Half): void;

			/**
			 * Writes a two-byte signed integer to the current stream and advances the stream
			 * position by two bytes.
			 */
			Write(value: number): void;

			/**
			 * Writes a four-byte signed integer to the current stream and advances the stream
			 * position by four bytes.
			 */
			Write(value: number): void;

			/**
			 * Writes an eight-byte signed integer to the current stream and advances the stream
			 * position by eight bytes.
			 */
			Write(value: number): void;

			/** Writes a span of bytes to the current stream. */
			Write(buffer: System.ReadOnlySpan$1<number>): void;

			/**
			 * Writes a span of characters to the current stream, and advances the current position
			 * of the stream in accordance with the `Encoding` used and perhaps the specific
			 * characters being written to the stream.
			 */
			Write(chars: System.ReadOnlySpan$1<System.Char>): void;

			/**
			 * Writes a signed byte to the current stream and advances the stream position by one
			 * byte.
			 */
			Write(value: number): void;

			/**
			 * Writes a four-byte floating-point value to the current stream and advances the stream
			 * position by four bytes.
			 */
			Write(value: number): void;

			/**
			 * Writes a length-prefixed string to this stream in the current encoding of the
			 * {@link System.IO.BinaryWriter}, and advances the current position of the stream in
			 * accordance with the encoding used and the specific characters being written to the
			 * stream.
			 */
			Write(value: string): void;

			/**
			 * Writes a two-byte unsigned integer to the current stream and advances the stream
			 * position by two bytes.
			 */
			Write(value: number): void;

			/**
			 * Writes a four-byte unsigned integer to the current stream and advances the stream
			 * position by four bytes.
			 */
			Write(value: number): void;

			/**
			 * Writes an eight-byte unsigned integer to the current stream and advances the stream
			 * position by eight bytes.
			 */
			Write(value: number): void;

			/** Writes a 32-bit integer in a compressed format. */
			Write7BitEncodedInt(value: number): void;

			/** Writes out a number 7 bits at a time. */
			Write7BitEncodedInt64(value: number): void;
		}
	}

	export namespace System.IO {
		/**
		 * Adds a buffering layer to read and write operations on another stream. This class
		 * cannot be inherited.
		 */
		export class BufferedStream extends Duplex {
			/**
			 * Initializes a new instance of the {@link System.IO.BufferedStream} class with a
			 * default buffer size of 4096 bytes.
			 */
			constructor(stream: Duplex);

			/**
			 * Initializes a new instance of the {@link System.IO.BufferedStream} class with the
			 * specified buffer size.
			 */
			constructor(
				stream: Duplex,
				bufferSize: number,
			);
		}
	}

	export namespace System.IO {
		/**
		 * Exposes static methods for creating, moving, and enumerating through directories and
		 * subdirectories. This class cannot be inherited.
		 */
		export namespace Directory {
			/**
			 * Creates all directories and subdirectories in the specified path unless they already
			 * exist.
			 */
			export function CreateDirectory(path: string): System.IO.DirectoryInfo;

			/**
			 * Creates all directories and subdirectories in the specified path with the specified
			 * permissions unless they already exist.
			 */
			export function CreateDirectory(
				path: string,
				unixCreateMode: System.IO.UnixFileMode,
			): System.IO.DirectoryInfo;

			/**
			 * Creates a directory symbolic link identified by `path` that points to `pathToTarget`.
			 */
			export function CreateSymbolicLink(
				path: string,
				pathToTarget: string,
			): System.IO.FileSystemInfo;

			/**
			 * Creates a uniquely named, empty directory in the current user's temporary directory.
			 */
			export function CreateTempSubdirectory(prefix?: string): System.IO.DirectoryInfo;

			/** Deletes an empty directory from a specified path. */
			export function Delete(path: string): void;

			/**
			 * Deletes the specified directory and, if indicated, any subdirectories and files in the
			 * directory.
			 */
			export function Delete(
				path: string,
				recursive: boolean,
			): void;

			/** Returns an enumerable collection of directory full names in a specified path. */
			export function EnumerateDirectories(path: string): Iterable<string>;

			/**
			 * Returns an enumerable collection of directory full names that match a search pattern
			 * in a specified path.
			 */
			export function EnumerateDirectories(
				path: string,
				searchPattern: string,
			): Iterable<string>;

			/**
			 * Returns an enumerable collection of the directory full names that match a search
			 * pattern in a specified path, and optionally searches subdirectories.
			 */
			export function EnumerateDirectories(
				path: string,
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): Iterable<string>;

			/**
			 * Returns an enumerable collection of directory full names that match a search pattern
			 * in a specified path, and optionally searches subdirectories.
			 */
			export function EnumerateDirectories(
				path: string,
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): Iterable<string>;

			/** Returns an enumerable collection of full file names in a specified path. */
			export function EnumerateFiles(path: string): Iterable<string>;

			/**
			 * Returns an enumerable collection of full file names that match a search pattern in a
			 * specified path.
			 */
			export function EnumerateFiles(
				path: string,
				searchPattern: string,
			): Iterable<string>;

			/**
			 * Returns an enumerable collection of full file names that match a search pattern and
			 * enumeration options in a specified path, and optionally searches subdirectories.
			 */
			export function EnumerateFiles(
				path: string,
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): Iterable<string>;

			/**
			 * Returns an enumerable collection of full file names that match a search pattern in a
			 * specified path, and optionally searches subdirectories.
			 */
			export function EnumerateFiles(
				path: string,
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): Iterable<string>;

			/**
			 * Returns an enumerable collection of file names and directory names in a specified
			 * path.
			 */
			export function EnumerateFileSystemEntries(path: string): Iterable<string>;

			/**
			 * Returns an enumerable collection of file names and directory names that match a search
			 * pattern in a specified path.
			 */
			export function EnumerateFileSystemEntries(
				path: string,
				searchPattern: string,
			): Iterable<string>;

			/**
			 * Returns an enumerable collection of file names and directory names that match a search
			 * pattern and enumeration options in a specified path.
			 */
			export function EnumerateFileSystemEntries(
				path: string,
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): Iterable<string>;

			/**
			 * Returns an enumerable collection of file names and directory names that match a search
			 * pattern in a specified path, and optionally searches subdirectories.
			 */
			export function EnumerateFileSystemEntries(
				path: string,
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): Iterable<string>;

			/** Determines whether the given path refers to an existing directory on disk. */
			export function Exists(path: string | undefined): boolean;

			/** Gets the creation date and time of a directory. */
			export function GetCreationTime(path: string): js.DateTime;

			/**
			 * Gets the creation date and time, in Coordinated Universal Time (UTC) format, of a
			 * directory.
			 */
			export function GetCreationTimeUtc(path: string): js.DateTime;

			/** Gets the current working directory of the application. */
			export function GetCurrentDirectory(): string;

			/**
			 * Returns the names of subdirectories (including their paths) in the specified
			 * directory.
			 */
			export function GetDirectories(path: string): string[];

			/**
			 * Returns the names of subdirectories (including their paths) that match the specified
			 * search pattern in the specified directory.
			 */
			export function GetDirectories(
				path: string,
				searchPattern: string,
			): string[];

			/**
			 * Returns the names of subdirectories (including their paths) that match the specified
			 * search pattern and enumeration options in the specified directory.
			 */
			export function GetDirectories(
				path: string,
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): string[];

			/**
			 * Returns the names of the subdirectories (including their paths) that match the
			 * specified search pattern in the specified directory, and optionally searches
			 * subdirectories.
			 */
			export function GetDirectories(
				path: string,
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): string[];

			/** Returns the volume information, root information, or both for the specified path. */
			export function GetDirectoryRoot(path: string): string;

			/** Returns the names of files (including their paths) in the specified directory. */
			export function GetFiles(path: string): string[];

			/**
			 * Returns the names of files (including their paths) that match the specified search
			 * pattern in the specified directory.
			 */
			export function GetFiles(
				path: string,
				searchPattern: string,
			): string[];

			/**
			 * Returns the names of files (including their paths) that match the specified search
			 * pattern and enumeration options in the specified directory.
			 */
			export function GetFiles(
				path: string,
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): string[];

			/**
			 * Returns the names of files (including their paths) that match the specified search
			 * pattern in the specified directory, using a value to determine whether to search
			 * subdirectories.
			 */
			export function GetFiles(
				path: string,
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): string[];

			/** Returns the names of all files and subdirectories in a specified path. */
			export function GetFileSystemEntries(path: string): string[];

			/**
			 * Returns an array of file names and directory names that match a search pattern in a
			 * specified path.
			 */
			export function GetFileSystemEntries(
				path: string,
				searchPattern: string,
			): string[];

			/**
			 * Returns an array of file names and directory names that match a search pattern and
			 * enumeration options in a specified path.
			 */
			export function GetFileSystemEntries(
				path: string,
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): string[];

			/**
			 * Returns an array of all the file names and directory names that match a search pattern
			 * in a specified path, and optionally searches subdirectories.
			 */
			export function GetFileSystemEntries(
				path: string,
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): string[];

			/** Returns the date and time the specified file or directory was last accessed. */
			export function GetLastAccessTime(path: string): js.DateTime;

			/**
			 * Returns the date and time, in Coordinated Universal Time (UTC) format, that the
			 * specified file or directory was last accessed.
			 */
			export function GetLastAccessTimeUtc(path: string): js.DateTime;

			/** Returns the date and time the specified file or directory was last written to. */
			export function GetLastWriteTime(path: string): js.DateTime;

			/**
			 * Returns the date and time, in Coordinated Universal Time (UTC) format, that the
			 * specified file or directory was last written to.
			 */
			export function GetLastWriteTimeUtc(path: string): js.DateTime;

			/**
			 * Retrieves the names of the logical drives on this computer in the form "&lt;drive
			 * letter&gt;:\".
			 */
			export function GetLogicalDrives(): string[];

			/**
			 * Retrieves the parent directory of the specified path, including both absolute and
			 * relative paths.
			 */
			export function GetParent(path: string): System.IO.DirectoryInfo | undefined;

			/** Moves a file or a directory and its contents to a new location. */
			export function Move(
				sourceDirName: string,
				destDirName: string,
			): void;

			/** Gets the target of the specified directory link. */
			export function ResolveLinkTarget(
				linkPath: string,
				returnFinalTarget: boolean,
			): System.IO.FileSystemInfo | undefined;

			/** Sets the creation date and time for the specified file or directory. */
			export function SetCreationTime(
				path: string,
				creationTime: js.DateTime,
			): void;

			/**
			 * Sets the creation date and time, in Coordinated Universal Time (UTC) format, for the
			 * specified file or directory.
			 */
			export function SetCreationTimeUtc(
				path: string,
				creationTimeUtc: js.DateTime,
			): void;

			/** Sets the application's current working directory to the specified directory. */
			export function SetCurrentDirectory(path: string): void;

			/** Sets the date and time the specified file or directory was last accessed. */
			export function SetLastAccessTime(
				path: string,
				lastAccessTime: js.DateTime,
			): void;

			/**
			 * Sets the date and time, in Coordinated Universal Time (UTC) format, that the specified
			 * file or directory was last accessed.
			 */
			export function SetLastAccessTimeUtc(
				path: string,
				lastAccessTimeUtc: js.DateTime,
			): void;

			/** Sets the date and time a directory was last written to. */
			export function SetLastWriteTime(
				path: string,
				lastWriteTime: js.DateTime,
			): void;

			/**
			 * Sets the date and time, in Coordinated Universal Time (UTC) format, that a directory
			 * was last written to.
			 */
			export function SetLastWriteTimeUtc(
				path: string,
				lastWriteTimeUtc: js.DateTime,
			): void;
		}
	}

	export namespace System.IO {
		/**
		 * Exposes instance methods for creating, moving, and enumerating through directories and
		 * subdirectories. This class cannot be inherited.
		 */
		export class DirectoryInfo extends System.IO.FileSystemInfo {
			/**
			 * Initializes a new instance of the {@link System.IO.DirectoryInfo} class on the
			 * specified path.
			 */
			constructor(path: string);

			/** Gets a value indicating whether the directory exists. */
			readonly Exists: boolean;

			/** Gets the name of this {@link System.IO.DirectoryInfo} instance. */
			readonly Name: string;

			/** Gets the parent directory of a specified subdirectory. */
			readonly Parent?: System.IO.DirectoryInfo;

			/** Gets the root portion of the directory. */
			readonly Root: System.IO.DirectoryInfo;

			/** Creates a directory. */
			Create(): void;

			/**
			 * Creates a subdirectory or subdirectories on the specified path. The specified path can
			 * be relative to this instance of the {@link System.IO.DirectoryInfo} class.
			 */
			CreateSubdirectory(path: string): System.IO.DirectoryInfo;

			/** Deletes this {@link System.IO.DirectoryInfo} if it is empty. */
			Delete(): void;

			/**
			 * Deletes this instance of a {@link System.IO.DirectoryInfo}, specifying whether to
			 * delete subdirectories and files.
			 */
			Delete(recursive: boolean): void;

			/**
			 * Returns an enumerable collection of directory information in the current directory.
			 */
			EnumerateDirectories(): Iterable<System.IO.DirectoryInfo>;

			/**
			 * Returns an enumerable collection of directory information that matches a specified
			 * search pattern.
			 */
			EnumerateDirectories(searchPattern: string): Iterable<System.IO.DirectoryInfo>;

			/**
			 * Returns an enumerable collection of directory information that matches the specified
			 * search pattern and enumeration options.
			 */
			EnumerateDirectories(
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): Iterable<System.IO.DirectoryInfo>;

			/**
			 * Returns an enumerable collection of directory information that matches a specified
			 * search pattern and search subdirectory option.
			 */
			EnumerateDirectories(
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): Iterable<System.IO.DirectoryInfo>;

			/** Returns an enumerable collection of file information in the current directory. */
			EnumerateFiles(): Iterable<System.IO.FileInfo>;

			/**
			 * Returns an enumerable collection of file information that matches a search pattern.
			 */
			EnumerateFiles(searchPattern: string): Iterable<System.IO.FileInfo>;

			/**
			 * Returns an enumerable collection of file information that matches the specified search
			 * pattern and enumeration options.
			 */
			EnumerateFiles(
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): Iterable<System.IO.FileInfo>;

			/**
			 * Returns an enumerable collection of file information that matches a specified search
			 * pattern and search subdirectory option.
			 */
			EnumerateFiles(
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): Iterable<System.IO.FileInfo>;

			/**
			 * Returns an enumerable collection of file system information in the current directory.
			 */
			EnumerateFileSystemInfos(): Iterable<System.IO.FileSystemInfo>;

			/**
			 * Returns an enumerable collection of file system information that matches a specified
			 * search pattern.
			 */
			EnumerateFileSystemInfos(searchPattern: string): Iterable<System.IO.FileSystemInfo>;

			/**
			 * Returns an enumerable collection of file system information that matches the specified
			 * search pattern and enumeration options.
			 */
			EnumerateFileSystemInfos(
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): Iterable<System.IO.FileSystemInfo>;

			/**
			 * Returns an enumerable collection of file system information that matches a specified
			 * search pattern and search subdirectory option.
			 */
			EnumerateFileSystemInfos(
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): Iterable<System.IO.FileSystemInfo>;

			/** Returns the subdirectories of the current directory. */
			GetDirectories(): System.IO.DirectoryInfo[];

			/**
			 * Returns an array of directories in the current {@link System.IO.DirectoryInfo}
			 * matching the given search criteria.
			 */
			GetDirectories(searchPattern: string): System.IO.DirectoryInfo[];

			/**
			 * Returns an array of directories in the current {@link System.IO.DirectoryInfo}
			 * matching the specified search pattern and enumeration options.
			 */
			GetDirectories(
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): System.IO.DirectoryInfo[];

			/**
			 * Returns an array of directories in the current {@link System.IO.DirectoryInfo}
			 * matching the given search criteria and using a value to determine whether to search
			 * subdirectories.
			 */
			GetDirectories(
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): System.IO.DirectoryInfo[];

			/** Returns a file list from the current directory. */
			GetFiles(): System.IO.FileInfo[];

			/** Returns a file list from the current directory matching the given search pattern. */
			GetFiles(searchPattern: string): System.IO.FileInfo[];

			/**
			 * Returns a file list from the current directory matching the specified search pattern
			 * and enumeration options.
			 */
			GetFiles(
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): System.IO.FileInfo[];

			/**
			 * Returns a file list from the current directory matching the given search pattern and
			 * using a value to determine whether to search subdirectories.
			 */
			GetFiles(
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): System.IO.FileInfo[];

			/**
			 * Returns an array of strongly typed {@link System.IO.FileSystemInfo} entries
			 * representing all the files and subdirectories in a directory.
			 */
			GetFileSystemInfos(): System.IO.FileSystemInfo[];

			/**
			 * Retrieves an array of strongly typed {@link System.IO.FileSystemInfo} objects
			 * representing the files and subdirectories that match the specified search criteria.
			 */
			GetFileSystemInfos(searchPattern: string): System.IO.FileSystemInfo[];

			/**
			 * Retrieves an array of strongly typed {@link System.IO.FileSystemInfo} objects
			 * representing the files and subdirectories that match the specified search pattern and
			 * enumeration options.
			 */
			GetFileSystemInfos(
				searchPattern: string,
				enumerationOptions: System.IO.EnumerationOptions,
			): System.IO.FileSystemInfo[];

			/**
			 * Retrieves an array of {@link System.IO.FileSystemInfo} objects that represent the
			 * files and subdirectories matching the specified search criteria.
			 */
			GetFileSystemInfos(
				searchPattern: string,
				searchOption: System.IO.SearchOption,
			): System.IO.FileSystemInfo[];

			/** Moves a {@link System.IO.DirectoryInfo} instance and its contents to a new path. */
			MoveTo(destDirName: string): void;

			/**
			 * Returns the original path that was passed to the {@link System.IO.DirectoryInfo}
			 * constructor. Use the {@link System.IO.DirectoryInfo.FullName} or
			 * {@link System.IO.DirectoryInfo.Name} properties for the full path or file/directory
			 * name instead of this method.
			 */
			ToString(): string;
		}
	}

	export namespace System.IO {
		/** The exception that is thrown when part of a file or directory cannot be found. */
		export class DirectoryNotFoundException extends System.IO.IOException {
			/**
			 * Initializes a new instance of the {@link System.IO.DirectoryNotFoundException} class
			 * with its message string set to a system-supplied message and its HRESULT set to
			 * COR_E_DIRECTORYNOTFOUND.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.IO.DirectoryNotFoundException} class
			 * with its message string set to `message` and its HRESULT set to
			 * COR_E_DIRECTORYNOTFOUND.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.IO.DirectoryNotFoundException} class
			 * with a specified error message and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System.IO {
		/** The exception that is thrown when reading is attempted past the end of a stream. */
		export class EndOfStreamException extends System.IO.IOException {
			/**
			 * Initializes a new instance of the {@link System.IO.EndOfStreamException} class with
			 * its message string set to a system-supplied message and its HRESULT set to
			 * COR_E_ENDOFSTREAM.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.IO.EndOfStreamException} class with
			 * its message string set to `message` and its HRESULT set to COR_E_ENDOFSTREAM.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.IO.EndOfStreamException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System.IO {
		/** Provides file and directory enumeration options. */
		export class EnumerationOptions {
			/**
			 * Initializes a new instance of the {@link System.IO.EnumerationOptions} class with the
			 * recommended default options.
			 */
			constructor();

			/** Gets or sets the attributes to skip. */
			AttributesToSkip: System.IO.FileAttributes;

			/** Gets or sets the suggested buffer size, in bytes. */
			BufferSize: number;

			/**
			 * Gets or sets a value that indicates whether to skip files or directories when access
			 * is denied (for example, {@link System.UnauthorizedAccessException} or
			 * {@link System.Security.SecurityException} ).
			 */
			IgnoreInaccessible: boolean;

			/** Gets or sets the case-matching behavior. */
			MatchCasing: System.IO.MatchCasing;

			/** Gets or sets the match type. */
			MatchType: System.IO.MatchType;

			/**
			 * Gets or sets a value that indicates the maximum directory depth to recurse while
			 * enumerating, when {@link System.IO.EnumerationOptions.RecurseSubdirectories} is set to
			 * `true`.
			 */
			MaxRecursionDepth: number;

			/**
			 * Gets or sets a value that indicates whether to recurse into subdirectories while
			 * enumerating.
			 */
			RecurseSubdirectories: boolean;

			/**
			 * Gets or sets a value that indicates whether to return the special directory entries
			 * "." and "..".
			 */
			ReturnSpecialDirectories: boolean;
		}
	}

	export namespace System.IO {
		/**
		 * Provides static methods for the creation, copying, deletion, moving, and opening of a
		 * single file, and aids in the creation of {@link System.IO.FileStream} objects.
		 */
		export namespace File {
			/**
			 * Appends lines to a file, and then closes the file. If the specified file does not
			 * exist, this method creates a file, writes the specified lines to the file, and then
			 * closes the file.
			 */
			export function AppendAllLines(
				path: string,
				contents: Iterable<string>,
			): void;

			/**
			 * Appends lines to a file by using a specified encoding, and then closes the file. If
			 * the specified file does not exist, this method creates a file, writes the specified
			 * lines to the file, and then closes the file.
			 */
			export function AppendAllLines(
				path: string,
				contents: Iterable<string>,
				encoding: System.Text.Encoding,
			): void;

			/**
			 * Asynchronously appends lines to a file by using a specified encoding, and then closes
			 * the file. If the specified file does not exist, this method creates a file, writes the
			 * specified lines to the file, and then closes the file.
			 */
			export function AppendAllLinesAsync(
				path: string,
				contents: Iterable<string>,
				encoding: System.Text.Encoding,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously appends lines to a file, and then closes the file. If the specified
			 * file does not exist, this method creates a file, writes the specified lines to the
			 * file, and then closes the file.
			 */
			export function AppendAllLinesAsync(
				path: string,
				contents: Iterable<string>,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Opens a file, appends the specified string to the file, and then closes the file. If
			 * the file does not exist, this method creates a file, writes the specified string to
			 * the file, then closes the file.
			 */
			export function AppendAllText(
				path: string,
				contents: string | undefined,
			): void;

			/**
			 * Appends the specified string to the file using the specified encoding, creating the
			 * file if it does not already exist.
			 */
			export function AppendAllText(
				path: string,
				contents: string | undefined,
				encoding: System.Text.Encoding,
			): void;

			/**
			 * Asynchronously opens a file or creates the file if it does not already exist, appends
			 * the specified string to the file using the specified encoding, and then closes the
			 * file.
			 */
			export function AppendAllTextAsync(
				path: string,
				contents: string | undefined,
				encoding: System.Text.Encoding,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously opens a file or creates a file if it does not already exist, appends
			 * the specified string to the file, and then closes the file.
			 */
			export function AppendAllTextAsync(
				path: string,
				contents: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a {@link System.IO.StreamWriter} that appends UTF-8 encoded text to an
			 * existing file, or to a new file if the specified file does not exist.
			 */
			export function AppendText(path: string): System.IO.StreamWriter;

			/**
			 * Copies an existing file to a new file. Overwriting a file of the same name is not
			 * allowed.
			 */
			export function Copy(
				sourceFileName: string,
				destFileName: string,
			): void;

			/**
			 * Copies an existing file to a new file. Overwriting a file of the same name is allowed.
			 */
			export function Copy(
				sourceFileName: string,
				destFileName: string,
				overwrite: boolean,
			): void;

			/** Creates or overwrites a file in the specified path. */
			export function Create(path: string): System.IO.FileStream;

			/** Creates or overwrites a file in the specified path, specifying a buffer size. */
			export function Create(
				path: string,
				bufferSize: number,
			): System.IO.FileStream;

			/**
			 * Creates or overwrites a file in the specified path, specifying a buffer size and
			 * options that describe how to create or overwrite the file.
			 */
			export function Create(
				path: string,
				bufferSize: number,
				options: System.IO.FileOptions,
			): System.IO.FileStream;

			/** Creates a file symbolic link identified by `path` that points to `pathToTarget`. */
			export function CreateSymbolicLink(
				path: string,
				pathToTarget: string,
			): System.IO.FileSystemInfo;

			/**
			 * Creates or opens a file for writing UTF-8 encoded text. If the file already exists,
			 * its contents are overwritten.
			 */
			export function CreateText(path: string): System.IO.StreamWriter;

			/**
			 * Decrypts a file that was encrypted by the current account using the
			 * {@link System.IO.File.Encrypt(System.String)} method.
			 */
			export function Decrypt(path: string): void;

			/** Deletes the specified file. */
			export function Delete(path: string): void;

			/** Encrypts a file so that only the account used to encrypt the file can decrypt it. */
			export function Encrypt(path: string): void;

			/** Determines whether the specified file exists. */
			export function Exists(path: string | undefined): boolean;

			/**
			 * Gets the specified {@link System.IO.FileAttributes} of the file or directory
			 * associated with `fileHandle`.
			 */
			export function GetAttributes(fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle): System.IO.FileAttributes;

			/** Gets the {@link System.IO.FileAttributes} of the file on the path. */
			export function GetAttributes(path: string): System.IO.FileAttributes;

			/** Returns the creation time of the specified file or directory. */
			export function GetCreationTime(fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle): js.DateTime;

			/** Returns the creation date and time of the specified file or directory. */
			export function GetCreationTime(path: string): js.DateTime;

			/**
			 * Returns the creation date and time, in Coordinated Universal Time (UTC), of the
			 * specified file or directory.
			 */
			export function GetCreationTimeUtc(fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle): js.DateTime;

			/**
			 * Returns the creation date and time, in Coordinated Universal Time (UTC), of the
			 * specified file or directory.
			 */
			export function GetCreationTimeUtc(path: string): js.DateTime;

			/** Returns the last access date and time of the specified file or directory. */
			export function GetLastAccessTime(fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle): js.DateTime;

			/** Returns the date and time the specified file or directory was last accessed. */
			export function GetLastAccessTime(path: string): js.DateTime;

			/**
			 * Returns the last access date and time, in Coordinated Universal Time (UTC), of the
			 * specified file or directory.
			 */
			export function GetLastAccessTimeUtc(fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle): js.DateTime;

			/**
			 * Returns the date and time, in Coordinated Universal Time (UTC), that the specified
			 * file or directory was last accessed.
			 */
			export function GetLastAccessTimeUtc(path: string): js.DateTime;

			/** Returns the last write date and time of the specified file or directory. */
			export function GetLastWriteTime(fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle): js.DateTime;

			/** Returns the date and time the specified file or directory was last written to. */
			export function GetLastWriteTime(path: string): js.DateTime;

			/**
			 * Returns the last write date and time, in Coordinated Universal Time (UTC), of the
			 * specified file or directory.
			 */
			export function GetLastWriteTimeUtc(fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle): js.DateTime;

			/**
			 * Returns the date and time, in Coordinated Universal Time (UTC), that the specified
			 * file or directory was last written to.
			 */
			export function GetLastWriteTimeUtc(path: string): js.DateTime;

			/** Gets the {@link System.IO.UnixFileMode} of the specified file handle. */
			export function GetUnixFileMode(fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle): System.IO.UnixFileMode;

			/** Gets the {@link System.IO.UnixFileMode} of the file on the path. */
			export function GetUnixFileMode(path: string): System.IO.UnixFileMode;

			/**
			 * Moves a specified file to a new location, providing the option to specify a new file
			 * name.
			 */
			export function Move(
				sourceFileName: string,
				destFileName: string,
			): void;

			/**
			 * Moves a specified file to a new location, providing the options to specify a new file
			 * name and to overwrite the destination file if it already exists.
			 */
			export function Move(
				sourceFileName: string,
				destFileName: string,
				overwrite: boolean,
			): void;

			/**
			 * Opens a {@link System.IO.FileStream} on the specified path with read/write access with
			 * no sharing.
			 */
			export function Open(
				path: string,
				mode: System.IO.FileMode,
			): System.IO.FileStream;

			/**
			 * Opens a {@link System.IO.FileStream} on the specified path, with the specified mode
			 * and access with no sharing.
			 */
			export function Open(
				path: string,
				mode: System.IO.FileMode,
				access: System.IO.FileAccess,
			): System.IO.FileStream;

			/**
			 * Opens a {@link System.IO.FileStream} on the specified path, having the specified mode
			 * with read, write, or read/write access and the specified sharing option.
			 */
			export function Open(
				path: string,
				mode: System.IO.FileMode,
				access: System.IO.FileAccess,
				share: System.IO.FileShare,
			): System.IO.FileStream;

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class with the
			 * specified path, creation mode, read/write and sharing permission, the access other
			 * FileStreams can have to the same file, the buffer size, additional file options and
			 * the allocation size.
			 */
			export function Open(
				path: string,
				options: System.IO.FileStreamOptions,
			): System.IO.FileStream;

			/**
			 * Initializes a new instance of the {@link Microsoft.Win32.SafeHandles.SafeFileHandle}
			 * class with the specified path, creation mode, read/write and sharing permission, the
			 * access other SafeFileHandles can have to the same file, additional file options and
			 * the allocation size.
			 */
			export function OpenHandle(
				path: string,
				mode?: System.IO.FileMode,
				access?: System.IO.FileAccess,
				share?: System.IO.FileShare,
				options?: System.IO.FileOptions,
				preallocationSize?: number,
			): Microsoft.Win32.SafeHandles.SafeFileHandle;

			/** Opens an existing file for reading. */
			export function OpenRead(path: string): System.IO.FileStream;

			/** Opens an existing UTF-8 encoded text file for reading. */
			export function OpenText(path: string): System.IO.StreamReader;

			/** Opens an existing file or creates a new file for writing. */
			export function OpenWrite(path: string): System.IO.FileStream;

			/**
			 * Opens a binary file, reads the contents of the file into a byte array, and then closes
			 * the file.
			 */
			export function ReadAllBytes(path: string): number[];

			/**
			 * Asynchronously opens a binary file, reads the contents of the file into a byte array,
			 * and then closes the file.
			 */
			export function ReadAllBytesAsync(
				path: string,
				cancellationToken?: AbortSignal,
			): Promise<number[]>;

			/** Opens a text file, reads all lines of the file, and then closes the file. */
			export function ReadAllLines(path: string): string[];

			/**
			 * Opens a file, reads all lines of the file with the specified encoding, and then closes
			 * the file.
			 */
			export function ReadAllLines(
				path: string,
				encoding: System.Text.Encoding,
			): string[];

			/**
			 * Asynchronously opens a text file, reads all lines of the file with the specified
			 * encoding, and then closes the file.
			 */
			export function ReadAllLinesAsync(
				path: string,
				encoding: System.Text.Encoding,
				cancellationToken?: AbortSignal,
			): Promise<string[]>;

			/**
			 * Asynchronously opens a text file, reads all lines of the file, and then closes the
			 * file.
			 */
			export function ReadAllLinesAsync(
				path: string,
				cancellationToken?: AbortSignal,
			): Promise<string[]>;

			/** Opens a text file, reads all the text in the file, and then closes the file. */
			export function ReadAllText(path: string): string;

			/**
			 * Opens a file, reads all text in the file with the specified encoding, and then closes
			 * the file.
			 */
			export function ReadAllText(
				path: string,
				encoding: System.Text.Encoding,
			): string;

			/**
			 * Asynchronously opens a text file, reads all text in the file with the specified
			 * encoding, and then closes the file.
			 */
			export function ReadAllTextAsync(
				path: string,
				encoding: System.Text.Encoding,
				cancellationToken?: AbortSignal,
			): Promise<string>;

			/**
			 * Asynchronously opens a text file, reads all the text in the file, and then closes the
			 * file.
			 */
			export function ReadAllTextAsync(
				path: string,
				cancellationToken?: AbortSignal,
			): Promise<string>;

			/** Reads the lines of a file. */
			export function ReadLines(path: string): Iterable<string>;

			/** Read the lines of a file that has a specified encoding. */
			export function ReadLines(
				path: string,
				encoding: System.Text.Encoding,
			): Iterable<string>;

			/** Asynchronously reads the lines of a file. */
			export function ReadLinesAsync(
				path: string,
				cancellationToken?: AbortSignal,
			): AsyncIterable<string>;

			/** Asynchronously reads the lines of a file that has a specified encoding. */
			export function ReadLinesAsync(
				path: string,
				encoding: System.Text.Encoding,
				cancellationToken?: AbortSignal,
			): AsyncIterable<string>;

			/**
			 * Replaces the contents of a specified file with the contents of another file, deleting
			 * the original file, and creating a backup of the replaced file.
			 */
			export function Replace(
				sourceFileName: string,
				destinationFileName: string,
				destinationBackupFileName: string | undefined,
			): void;

			/**
			 * Replaces the contents of a specified file with the contents of another file, deleting
			 * the original file, and creating a backup of the replaced file and optionally ignores
			 * merge errors.
			 */
			export function Replace(
				sourceFileName: string,
				destinationFileName: string,
				destinationBackupFileName: string | undefined,
				ignoreMetadataErrors: boolean,
			): void;

			/** Gets the target of the specified file link. */
			export function ResolveLinkTarget(
				linkPath: string,
				returnFinalTarget: boolean,
			): System.IO.FileSystemInfo | undefined;

			/**
			 * Sets the specified {@link System.IO.FileAttributes} of the file or directory
			 * associated with `fileHandle`.
			 */
			export function SetAttributes(
				fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				fileAttributes: System.IO.FileAttributes,
			): void;

			/**
			 * Sets the specified {@link System.IO.FileAttributes} of the file on the specified path.
			 */
			export function SetAttributes(
				path: string,
				fileAttributes: System.IO.FileAttributes,
			): void;

			/** Sets the date and time the file or directory was created. */
			export function SetCreationTime(
				fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				creationTime: js.DateTime,
			): void;

			/** Sets the date and time the file was created. */
			export function SetCreationTime(
				path: string,
				creationTime: js.DateTime,
			): void;

			/**
			 * Sets the date and time, in Coordinated Universal Time (UTC), that the file or
			 * directory was created.
			 */
			export function SetCreationTimeUtc(
				fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				creationTimeUtc: js.DateTime,
			): void;

			/**
			 * Sets the date and time, in Coordinated Universal Time (UTC), that the file was
			 * created.
			 */
			export function SetCreationTimeUtc(
				path: string,
				creationTimeUtc: js.DateTime,
			): void;

			/** Sets the date and time the specified file or directory was last accessed. */
			export function SetLastAccessTime(
				fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				lastAccessTime: js.DateTime,
			): void;

			/** Sets the date and time the specified file was last accessed. */
			export function SetLastAccessTime(
				path: string,
				lastAccessTime: js.DateTime,
			): void;

			/**
			 * Sets the date and time, in Coordinated Universal Time (UTC), that the specified file
			 * or directory was last accessed.
			 */
			export function SetLastAccessTimeUtc(
				fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				lastAccessTimeUtc: js.DateTime,
			): void;

			/**
			 * Sets the date and time, in Coordinated Universal Time (UTC), that the specified file
			 * was last accessed.
			 */
			export function SetLastAccessTimeUtc(
				path: string,
				lastAccessTimeUtc: js.DateTime,
			): void;

			/** Sets the date and time that the specified file or directory was last written to. */
			export function SetLastWriteTime(
				fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				lastWriteTime: js.DateTime,
			): void;

			/** Sets the date and time that the specified file was last written to. */
			export function SetLastWriteTime(
				path: string,
				lastWriteTime: js.DateTime,
			): void;

			/**
			 * Sets the date and time, in Coordinated Universal Time (UTC), that the specified file
			 * or directory was last written to.
			 */
			export function SetLastWriteTimeUtc(
				fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				lastWriteTimeUtc: js.DateTime,
			): void;

			/**
			 * Sets the date and time, in Coordinated Universal Time (UTC), that the specified file
			 * was last written to.
			 */
			export function SetLastWriteTimeUtc(
				path: string,
				lastWriteTimeUtc: js.DateTime,
			): void;

			/** Sets the specified {@link System.IO.UnixFileMode} of the specified file handle. */
			export function SetUnixFileMode(
				fileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				mode: System.IO.UnixFileMode,
			): void;

			/**
			 * Sets the specified {@link System.IO.UnixFileMode} of the file on the specified path.
			 */
			export function SetUnixFileMode(
				path: string,
				mode: System.IO.UnixFileMode,
			): void;

			/**
			 * Creates a new file, writes the specified byte array to the file, and then closes the
			 * file. If the target file already exists, it is overwritten.
			 */
			export function WriteAllBytes(
				path: string,
				bytes: number[],
			): void;

			/**
			 * Asynchronously creates a new file, writes the specified byte array to the file, and
			 * then closes the file. If the target file already exists, it is overwritten.
			 */
			export function WriteAllBytesAsync(
				path: string,
				bytes: number[],
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a new file, writes a collection of strings to the file, and then closes the
			 * file.
			 */
			export function WriteAllLines(
				path: string,
				contents: Iterable<string>,
			): void;

			/**
			 * Creates a new file by using the specified encoding, writes a collection of strings to
			 * the file, and then closes the file.
			 */
			export function WriteAllLines(
				path: string,
				contents: Iterable<string>,
				encoding: System.Text.Encoding,
			): void;

			/**
			 * Creates a new file, write the specified string array to the file, and then closes the
			 * file.
			 */
			export function WriteAllLines(
				path: string,
				contents: string[],
			): void;

			/**
			 * Creates a new file, writes the specified string array to the file by using the
			 * specified encoding, and then closes the file.
			 */
			export function WriteAllLines(
				path: string,
				contents: string[],
				encoding: System.Text.Encoding,
			): void;

			/**
			 * Asynchronously creates a new file, write the specified lines to the file by using the
			 * specified encoding, and then closes the file.
			 */
			export function WriteAllLinesAsync(
				path: string,
				contents: Iterable<string>,
				encoding: System.Text.Encoding,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously creates a new file, writes the specified lines to the file, and then
			 * closes the file.
			 */
			export function WriteAllLinesAsync(
				path: string,
				contents: Iterable<string>,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Creates a new file, writes the specified string to the file, and then closes the file.
			 * If the target file already exists, it is overwritten.
			 */
			export function WriteAllText(
				path: string,
				contents: string | undefined,
			): void;

			/**
			 * Creates a new file, writes the specified string to the file using the specified
			 * encoding, and then closes the file. If the target file already exists, it is
			 * overwritten.
			 */
			export function WriteAllText(
				path: string,
				contents: string | undefined,
				encoding: System.Text.Encoding,
			): void;

			/**
			 * Asynchronously creates a new file, writes the specified string to the file using the
			 * specified encoding, and then closes the file. If the target file already exists, it is
			 * overwritten.
			 */
			export function WriteAllTextAsync(
				path: string,
				contents: string | undefined,
				encoding: System.Text.Encoding,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously creates a new file, writes the specified string to the file, and then
			 * closes the file. If the target file already exists, it is overwritten.
			 */
			export function WriteAllTextAsync(
				path: string,
				contents: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;
		}
	}

	export namespace System.IO {
		/** Defines constants for read, write, or read/write access to a file. */
		export enum FileAccess {
			/**
			 * Read access to the file. Data can be read from the file. Combine with `Write` for
			 * read/write access.
			 */
			Read = 1,

			/**
			 * Write access to the file. Data can be written to the file. Combine with `Read` for
			 * read/write access.
			 */
			Write = 2,

			/** Read and write access to the file. Data can be written to and read from the file. */
			ReadWrite = 3,
		}
	}

	export namespace System.IO {
		/** Provides attributes for files and directories. */
		export enum FileAttributes {
			None = 0,

			/**
			 * The file is read-only. `ReadOnly` is supported on Windows, Linux, and macOS. On Linux
			 * and macOS, changing the `ReadOnly` flag is a permissions operation.
			 */
			ReadOnly = 1,

			/**
			 * The file is hidden, and thus is not included in an ordinary directory listing.
			 * `Hidden` is supported on Windows, Linux, and macOS.
			 */
			Hidden = 2,

			/**
			 * The file is a system file. That is, the file is part of the operating system or is
			 * used exclusively by the operating system.
			 */
			System = 4,

			/** The file is a directory. `Directory` is supported on Windows, Linux, and macOS. */
			Directory = 16,

			/**
			 * This file is marked to be included in incremental backup operation. Windows sets this
			 * attribute whenever the file is modified, and backup software should clear it when
			 * processing the file during incremental backup.
			 */
			Archive = 32,

			/** Reserved for future use. */
			Device = 64,

			/**
			 * The file is a standard file that has no special attributes. This attribute is valid
			 * only if it is used alone. `Normal` is supported on Windows, Linux, and macOS.
			 */
			Normal = 128,

			/**
			 * The file is temporary. A temporary file contains data that is needed while an
			 * application is executing but is not needed after the application is finished. File
			 * systems try to keep all the data in memory for quicker access rather than flushing the
			 * data back to mass storage. A temporary file should be deleted by the application as
			 * soon as it is no longer needed.
			 */
			Temporary = 256,

			/**
			 * The file is a sparse file. Sparse files are typically large files whose data consists
			 * of mostly zeros.
			 */
			SparseFile = 512,

			/**
			 * The file contains a reparse point, which is a block of user-defined data associated
			 * with a file or a directory. `ReparsePoint` is supported on Windows, Linux, and macOS.
			 */
			ReparsePoint = 1024,

			/** The file is compressed. */
			Compressed = 2048,

			/** The file is offline. The data of the file is not immediately available. */
			Offline = 4096,

			/** The file will not be indexed by the operating system's content indexing service. */
			NotContentIndexed = 8192,

			/**
			 * The file or directory is encrypted. For a file, this means that all data in the file
			 * is encrypted. For a directory, this means that encryption is the default for newly
			 * created files and directories.
			 */
			Encrypted = 16384,

			/**
			 * The file or directory includes data integrity support. When this value is applied to a
			 * file, all data streams in the file have integrity support. When this value is applied
			 * to a directory, all new files and subdirectories within that directory, by default,
			 * include integrity support.
			 */
			IntegrityStream = 32768,

			/**
			 * The file or directory is excluded from the data integrity scan. When this value is
			 * applied to a directory, by default, all new files and subdirectories within that
			 * directory are excluded from data integrity.
			 */
			NoScrubData = 131072,
		}
	}

	export namespace System.IO {
		/**
		 * Provides properties and instance methods for the creation, copying, deletion, moving,
		 * and opening of files, and aids in the creation of {@link System.IO.FileStream}
		 * objects. This class cannot be inherited.
		 */
		export class FileInfo extends System.IO.FileSystemInfo {
			/**
			 * Initializes a new instance of the {@link System.IO.FileInfo} class, which acts as a
			 * wrapper for a file path.
			 */
			constructor(fileName: string);

			/** Gets an instance of the parent directory. */
			readonly Directory?: System.IO.DirectoryInfo;

			/** Gets a string representing the directory's full path. */
			readonly DirectoryName?: string;

			/** Gets a value indicating whether a file exists. */
			readonly Exists: boolean;

			/** Gets or sets a value that determines if the current file is read only. */
			IsReadOnly: boolean;

			/** Gets the size, in bytes, of the current file. */
			readonly Length: number;

			/** Gets the name of the file. */
			readonly Name: string;

			/**
			 * Creates a {@link System.IO.StreamWriter} that appends text to the file represented by
			 * this instance of the {@link System.IO.FileInfo}.
			 */
			AppendText(): System.IO.StreamWriter;

			/**
			 * Copies an existing file to a new file, disallowing the overwriting of an existing
			 * file.
			 */
			CopyTo(destFileName: string): System.IO.FileInfo;

			/**
			 * Copies an existing file to a new file, allowing the overwriting of an existing file.
			 */
			CopyTo(
				destFileName: string,
				overwrite: boolean,
			): System.IO.FileInfo;

			/** Creates a file. */
			Create(): System.IO.FileStream;

			/** Creates a {@link System.IO.StreamWriter} that writes a new text file. */
			CreateText(): System.IO.StreamWriter;

			/**
			 * Decrypts a file that was encrypted by the current account using the
			 * {@link System.IO.FileInfo.Encrypt} method.
			 */
			Decrypt(): void;

			/** Permanently deletes a file. */
			Delete(): void;

			/** Encrypts a file so that only the account used to encrypt the file can decrypt it. */
			Encrypt(): void;

			/**
			 * Moves a specified file to a new location, providing the option to specify a new file
			 * name.
			 */
			MoveTo(destFileName: string): void;

			/**
			 * Moves a specified file to a new location, providing the options to specify a new file
			 * name and to overwrite the destination file if it already exists.
			 */
			MoveTo(
				destFileName: string,
				overwrite: boolean,
			): void;

			/** Opens a file in the specified mode. */
			Open(mode: System.IO.FileMode): System.IO.FileStream;

			/** Opens a file in the specified mode with read, write, or read/write access. */
			Open(
				mode: System.IO.FileMode,
				access: System.IO.FileAccess,
			): System.IO.FileStream;

			/**
			 * Opens a file in the specified mode with read, write, or read/write access and the
			 * specified sharing option.
			 */
			Open(
				mode: System.IO.FileMode,
				access: System.IO.FileAccess,
				share: System.IO.FileShare,
			): System.IO.FileStream;

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class with the
			 * specified creation mode, read/write and sharing permission, the access other
			 * FileStreams can have to the same file, the buffer size, additional file options and
			 * the allocation size.
			 */
			Open(options: System.IO.FileStreamOptions): System.IO.FileStream;

			/** Creates a read-only {@link System.IO.FileStream}. */
			OpenRead(): System.IO.FileStream;

			/**
			 * Creates a {@link System.IO.StreamReader} with UTF8 encoding that reads from an
			 * existing text file.
			 */
			OpenText(): System.IO.StreamReader;

			/** Creates a write-only {@link System.IO.FileStream}. */
			OpenWrite(): System.IO.FileStream;

			/**
			 * Replaces the contents of a specified file with the file described by the current
			 * {@link System.IO.FileInfo} object, deleting the original file, and creating a backup
			 * of the replaced file.
			 */
			Replace(
				destinationFileName: string,
				destinationBackupFileName: string | undefined,
			): System.IO.FileInfo;

			/**
			 * Replaces the contents of a specified file with the file described by the current
			 * {@link System.IO.FileInfo} object, deleting the original file, and creating a backup
			 * of the replaced file.  Also specifies whether to ignore merge errors.
			 */
			Replace(
				destinationFileName: string,
				destinationBackupFileName: string | undefined,
				ignoreMetadataErrors: boolean,
			): System.IO.FileInfo;
		}
	}

	export namespace System.IO {
		/**
		 * The exception that is thrown when a managed assembly is found but cannot be loaded.
		 */
		export class FileLoadException extends System.IO.IOException {
			/**
			 * Initializes a new instance of the {@link System.IO.FileLoadException} class, setting
			 * the {@link System.Exception.Message} property of the new instance to a system-supplied
			 * message that describes the error, such as "Could not load the specified file." This
			 * message takes into account the current system culture.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.IO.FileLoadException} class with the
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.IO.FileLoadException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				inner: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileLoadException} class with a
			 * specified error message and the name of the file that could not be loaded.
			 */
			constructor(
				message: string | undefined,
				fileName: string | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileLoadException} class with a
			 * specified error message, the name of the file that could not be loaded, and a
			 * reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				fileName: string | undefined,
				inner: System.Exception | undefined,
			);

			/** Gets the name of the file that causes this exception. */
			readonly FileName?: string;

			/** Gets the log file that describes why an assembly load failed. */
			readonly FusionLog?: string;

			/** Gets the error message and the name of the file that caused this exception. */
			readonly Message: string;

			/**
			 * Returns the fully qualified name of the current exception, and possibly the error
			 * message, the name of the inner exception, and the stack trace.
			 */
			ToString(): string;
		}
	}

	export namespace System.IO {
		/** Specifies how the operating system should open a file. */
		export enum FileMode {
			/**
			 * Specifies that the operating system should create a new file. This requires
			 * {@link System.Security.Permissions.FileIOPermissionAccess.Write} permission. If the
			 * file already exists, an {@link System.IO.IOException} exception is thrown.
			 */
			CreateNew = 1,

			/**
			 * Specifies that the operating system should create a new file. If the file already
			 * exists, it will be overwritten. This requires
			 * {@link System.Security.Permissions.FileIOPermissionAccess.Write} permission.
			 * `FileMode.Create` is equivalent to requesting that if the file does not exist, use
			 * {@link System.IO.FileMode.CreateNew} ; otherwise, use
			 * {@link System.IO.FileMode.Truncate}. If the file already exists but is a hidden file,
			 * an {@link System.UnauthorizedAccessException} exception is thrown.
			 */
			Create = 2,

			/**
			 * Specifies that the operating system should open an existing file. The ability to open
			 * the file is dependent on the value specified by the {@link System.IO.FileAccess}
			 * enumeration. A {@link System.IO.FileNotFoundException} exception is thrown if the file
			 * does not exist.
			 */
			Open = 3,

			/**
			 * Specifies that the operating system should open a file if it exists; otherwise, a new
			 * file should be created. If the file is opened with `FileAccess.Read`,
			 * {@link System.Security.Permissions.FileIOPermissionAccess.Read} permission is
			 * required. If the file access is `FileAccess.Write`,
			 * {@link System.Security.Permissions.FileIOPermissionAccess.Write} permission is
			 * required. If the file is opened with `FileAccess.ReadWrite`, both
			 * {@link System.Security.Permissions.FileIOPermissionAccess.Read} and
			 * {@link System.Security.Permissions.FileIOPermissionAccess.Write} permissions are
			 * required.
			 */
			OpenOrCreate = 4,

			/**
			 * Specifies that the operating system should open an existing file. When the file is
			 * opened, it should be truncated so that its size is zero bytes. This requires
			 * {@link System.Security.Permissions.FileIOPermissionAccess.Write} permission. Attempts
			 * to read from a file opened with `FileMode.Truncate` cause an
			 * {@link System.ArgumentException} exception.
			 */
			Truncate = 5,

			/**
			 * Opens the file if it exists and seeks to the end of the file, or creates a new file.
			 * This requires {@link System.Security.Permissions.FileIOPermissionAccess.Append}
			 * permission. `FileMode.Append` can be used only in conjunction with `FileAccess.Write`.
			 * Trying to seek to a position before the end of the file throws an
			 * {@link System.IO.IOException} exception, and any attempt to read fails and throws a
			 * {@link System.NotSupportedException} exception.
			 */
			Append = 6,
		}
	}

	export namespace System.IO {
		/**
		 * The exception that is thrown when an attempt to access a file that does not exist on
		 * disk fails.
		 */
		export class FileNotFoundException extends System.IO.IOException {
			/**
			 * Initializes a new instance of the {@link System.IO.FileNotFoundException} class with
			 * its message string set to a system-supplied message.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.IO.FileNotFoundException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.IO.FileNotFoundException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileNotFoundException} class with a
			 * specified error message, and the file name that cannot be found.
			 */
			constructor(
				message: string | undefined,
				fileName: string | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileNotFoundException} class with a
			 * specified error message, the file name that cannot be found, and a reference to the
			 * inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				fileName: string | undefined,
				innerException: System.Exception | undefined,
			);

			/** Gets the name of the file that cannot be found. */
			readonly FileName?: string;

			/** Gets the log file that describes why loading of an assembly failed. */
			readonly FusionLog?: string;

			/** Gets the error message that explains the reason for the exception. */
			readonly Message: string;

			/**
			 * Returns the fully qualified name of this exception and possibly the error message, the
			 * name of the inner exception, and the stack trace.
			 */
			ToString(): string;
		}
	}

	export namespace System.IO {
		/** Represents advanced options for creating a {@link System.IO.FileStream} object. */
		export enum FileOptions {
			/**
			 * Indicates that the system should write through any intermediate cache and go directly
			 * to disk.
			 */
			WriteThrough = -2147483648,

			/**
			 * Indicates that no additional options should be used when creating a
			 * {@link System.IO.FileStream} object.
			 */
			None = 0,

			/**
			 * Indicates that a file is encrypted and can be decrypted only by using the same user
			 * account used for encryption.
			 */
			Encrypted = 16384,

			/** Indicates that a file is automatically deleted when it is no longer in use. */
			DeleteOnClose = 67108864,

			/**
			 * Indicates that the file is to be accessed sequentially from beginning to end. The
			 * system can use this as a hint to optimize file caching. If an application moves the
			 * file pointer for random access, optimum caching may not occur; however, correct
			 * operation is still guaranteed. Specifying this flag can increase performance in some
			 * cases.
			 */
			SequentialScan = 134217728,

			/**
			 * Indicates that the file is accessed randomly. The system can use this as a hint to
			 * optimize file caching.
			 */
			RandomAccess = 268435456,

			/** Indicates that a file can be used for asynchronous reading and writing. */
			Asynchronous = 1073741824,
		}
	}

	export namespace System.IO {
		/**
		 * Contains constants for controlling the kind of access other operations can have to the
		 * same file.
		 */
		export enum FileShare {
			/**
			 * Declines sharing of the current file. Any request to open the file (by this process or
			 * another process) will fail until the file is closed.
			 */
			None = 0,

			/**
			 * Allows subsequent opening of the file for reading. If this flag is not specified, any
			 * request to open the file for reading (by this process or another process) will fail
			 * until the file is closed. However, even if this flag is specified, additional
			 * permissions might still be needed to access the file.
			 */
			Read = 1,

			/**
			 * Allows subsequent opening of the file for writing. If this flag is not specified, any
			 * request to open the file for writing (by this process or another process) will fail
			 * until the file is closed. However, even if this flag is specified, additional
			 * permissions might still be needed to access the file.
			 */
			Write = 2,

			/**
			 * Allows subsequent opening of the file for reading or writing. If this flag is not
			 * specified, any request to open the file for reading or writing (by this process or
			 * another process) will fail until the file is closed. However, even if this flag is
			 * specified, additional permissions might still be needed to access the file.
			 */
			ReadWrite = 3,

			/** Allows subsequent deleting of a file. */
			Delete = 4,

			/**
			 * Makes the file handle inheritable by child processes. This is not directly supported
			 * by Win32.
			 */
			Inheritable = 16,
		}
	}

	export namespace System.IO {
		/**
		 * Provides a {@link System.IO.Stream} for a file, supporting both synchronous and
		 * asynchronous read and write operations.
		 */
		export class FileStream extends Duplex {
			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class for the specified
			 * file handle, with the specified read/write permission.
			 */
			constructor(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				access: System.IO.FileAccess,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class for the specified
			 * file handle, with the specified read/write permission, and buffer size.
			 */
			constructor(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				access: System.IO.FileAccess,
				bufferSize: number,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class for the specified
			 * file handle, with the specified read/write permission, buffer size, and synchronous or
			 * asynchronous state.
			 */
			constructor(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				access: System.IO.FileAccess,
				bufferSize: number,
				isAsync: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class for the specified
			 * file handle, with the specified read/write permission.
			 */
			constructor(
				handle: System.IntPtr,
				access: System.IO.FileAccess,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class for the specified
			 * file handle, with the specified read/write permission and `FileStream` instance
			 * ownership.
			 */
			constructor(
				handle: System.IntPtr,
				access: System.IO.FileAccess,
				ownsHandle: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class for the specified
			 * file handle, with the specified read/write permission, `FileStream` instance
			 * ownership, and buffer size.
			 */
			constructor(
				handle: System.IntPtr,
				access: System.IO.FileAccess,
				ownsHandle: boolean,
				bufferSize: number,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class for the specified
			 * file handle, with the specified read/write permission, `FileStream` instance
			 * ownership, buffer size, and synchronous or asynchronous state.
			 */
			constructor(
				handle: System.IntPtr,
				access: System.IO.FileAccess,
				ownsHandle: boolean,
				bufferSize: number,
				isAsync: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class with the
			 * specified path and creation mode.
			 */
			constructor(
				path: string,
				mode: System.IO.FileMode,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class with the
			 * specified path, creation mode, and read/write permission.
			 */
			constructor(
				path: string,
				mode: System.IO.FileMode,
				access: System.IO.FileAccess,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class with the
			 * specified path, creation mode, read/write permission, and sharing permission.
			 */
			constructor(
				path: string,
				mode: System.IO.FileMode,
				access: System.IO.FileAccess,
				share: System.IO.FileShare,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class with the
			 * specified path, creation mode, read/write and sharing permission, and buffer size.
			 */
			constructor(
				path: string,
				mode: System.IO.FileMode,
				access: System.IO.FileAccess,
				share: System.IO.FileShare,
				bufferSize: number,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class with the
			 * specified path, creation mode, read/write and sharing permission, buffer size, and
			 * synchronous or asynchronous state.
			 */
			constructor(
				path: string,
				mode: System.IO.FileMode,
				access: System.IO.FileAccess,
				share: System.IO.FileShare,
				bufferSize: number,
				useAsync: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class with the
			 * specified path, creation mode, read/write and sharing permission, the access other
			 * FileStreams can have to the same file, the buffer size, and additional file options.
			 */
			constructor(
				path: string,
				mode: System.IO.FileMode,
				access: System.IO.FileAccess,
				share: System.IO.FileShare,
				bufferSize: number,
				options: System.IO.FileOptions,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.FileStream} class with the
			 * specified path, creation mode, read/write and sharing permission, buffer size,
			 * additional file options, preallocation size, and the access other FileStreams can have
			 * to the same file.
			 */
			constructor(
				path: string,
				options: System.IO.FileStreamOptions,
			);
		}
	}

	export namespace System.IO {
		/** Defines a variety of configuration options for {@link System.IO.FileStream}. */
		export class FileStreamOptions {
			/** Initializes a {@link System.IO.FileStreamOptions} instance with default values. */
			constructor();

			/**
			 * A bitwise combination of the enumeration values that determines how the file can be
			 * accessed by the {@link System.IO.FileStream} object. This also determines the values
			 * returned by the {@link System.IO.FileStream.CanRead} and
			 * {@link System.IO.FileStream.CanWrite} properties of the {@link System.IO.FileStream}
			 * object.
			 */
			Access: System.IO.FileAccess;

			/**
			 * The size of the buffer used by {@link System.IO.FileStream} for buffering. The default
			 * buffer size is 4096. 0 or 1 means that buffering should be disabled. Negative values
			 * are not allowed.
			 */
			BufferSize: number;

			/** One of the enumeration values that determines how to open or create the file. */
			Mode: System.IO.FileMode;

			/**
			 * A bitwise combination of the enumeration values that specifies additional file
			 * options. The default value is {@link System.IO.FileOptions.None}, which indicates
			 * synchronous IO.
			 */
			Options: System.IO.FileOptions;

			/**
			 * The initial allocation size in bytes for the file. A positive value is effective only
			 * when a regular file is being created or overwritten (
				 * {@link System.IO.FileMode.Create} or {@link System.IO.FileMode.CreateNew} ). Negative
				 * values are not allowed. In other cases (including the default 0 value), it's ignored.
				 * This value is a hint and is not a strong guarantee. It is not supported on Web
				 * Assembly (WASM) and FreeBSD (the value is ignored). For Windows, Linux and macOS we
				 * will try to preallocate the disk space to fill the requested allocation size. If that
				 * turns out to be impossible, the operation is going to throw an exception. The final
				 * file length (EOF) will be determined by the number of bytes written to the file.
				 */
				PreallocationSize: number;

			/**
			 * A bitwise combination of the enumeration values that determines how the file will be
			 * shared by processes. The default value is {@link System.IO.FileShare.Read}.
			 */
			Share: System.IO.FileShare;

			/** Gets or sets the Unix file mode used when a new file is created. */
			UnixCreateMode?: System.IO.UnixFileMode;
		}
	}

	export namespace System.IO {
		/**
		 * Provides the base class for both {@link System.IO.FileInfo} and
		 * {@link System.IO.DirectoryInfo} objects.
		 */
		export class FileSystemInfo extends System.MarshalByRefObject {
			/** Gets or sets the attributes for the current file or directory. */
			Attributes: System.IO.FileAttributes;

			/** Gets or sets the creation time of the current file or directory. */
			CreationTime: js.DateTime;

			/**
			 * Gets or sets the creation time, in coordinated universal time (UTC), of the current
			 * file or directory.
			 */
			CreationTimeUtc: js.DateTime;

			/** Gets a value indicating whether the file or directory exists. */
			readonly Exists: boolean;

			/**
			 * Gets the extension part of the file name, including the leading dot . even if it is
			 * the entire file name, or an empty string if no extension is present.
			 */
			readonly Extension: string;

			/** Gets the full path of the directory or file. */
			readonly FullName: string;

			/** Gets or sets the time the current file or directory was last accessed. */
			LastAccessTime: js.DateTime;

			/**
			 * Gets or sets the time, in coordinated universal time (UTC), that the current file or
			 * directory was last accessed.
			 */
			LastAccessTimeUtc: js.DateTime;

			/** Gets or sets the time when the current file or directory was last written to. */
			LastWriteTime: js.DateTime;

			/**
			 * Gets or sets the time, in coordinated universal time (UTC), when the current file or
			 * directory was last written to.
			 */
			LastWriteTimeUtc: js.DateTime;

			/**
			 * Gets the target path of the link located in {@link System.IO.FileSystemInfo.FullName},
			 * or `null` if this {@link System.IO.FileSystemInfo} instance doesn't represent a link.
			 */
			readonly LinkTarget?: string;

			/**
			 * For files, gets the name of the file. For directories, gets the name of the last
			 * directory in the hierarchy if a hierarchy exists. Otherwise, the `Name` property gets
			 * the name of the directory.
			 */
			readonly Name: string;

			/** Gets or sets the Unix file mode for the current file or directory. */
			UnixFileMode: System.IO.UnixFileMode;

			/**
			 * Creates a symbolic link located in {@link System.IO.FileSystemInfo.FullName} that
			 * points to the specified `pathToTarget`.
			 */
			CreateAsSymbolicLink(pathToTarget: string): void;

			/** Deletes a file or directory. */
			Delete(): void;

			/** Refreshes the state of the object. */
			Refresh(): void;

			/** Gets the target of the specified link. */
			ResolveLinkTarget(returnFinalTarget: boolean): System.IO.FileSystemInfo | undefined;

			/**
			 * Returns the original path. Use the {@link System.IO.FileSystemInfo.FullName} or
			 * {@link System.IO.FileSystemInfo.Name} properties for the full path or file/directory
			 * name.
			 */
			ToString(): string;
		}
	}

	export namespace System.IO {
		/** Specifies whether the underlying handle is inheritable by child processes. */
		export enum HandleInheritability {
			/** Specifies that the handle is not inheritable by child processes. */
			None = 0,

			/** Specifies that the handle is inheritable by child processes. */
			Inheritable = 1,
		}
	}

	export namespace System.IO {
		/** The exception that is thrown when a data stream is in an invalid format. */
		export class InvalidDataException extends System.SystemException {
			/** Initializes a new instance of the {@link System.IO.InvalidDataException} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.IO.InvalidDataException} class with a
			 * specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.IO.InvalidDataException} class with a
			 * reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System.IO {
		/** The exception that is thrown when an I/O error occurs. */
		export class IOException extends System.SystemException {
			/**
			 * Initializes a new instance of the {@link System.IO.IOException} class with its message
			 * string set to the empty string (""), its HRESULT set to COR_E_IO, and its inner
			 * exception set to a null reference.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.IO.IOException} class with its message
			 * string set to `message`, its HRESULT set to COR_E_IO, and its inner exception set to
			 * `null`.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.IO.IOException} class with a specified
			 * error message and a reference to the inner exception that is the cause of this
			 * exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.IOException} class with its message
			 * string set to `message` and its HRESULT user-defined.
			 */
			constructor(
				message: string | undefined,
				hresult: number,
			);
		}
	}

	export namespace System.IO {
		/** Specifies the type of character casing to match. */
		export enum MatchCasing {
			/** Matches using the default casing for the given platform. */
			PlatformDefault = 0,

			/** Matches respecting character casing. */
			CaseSensitive = 1,

			/** Matches ignoring character casing. */
			CaseInsensitive = 2,
		}
	}

	export namespace System.IO {
		/** Specifies the type of wildcard matching to use. */
		export enum MatchType {
			/**
			 * Matches using '*' and '?' wildcards. * matches from zero to any amount of characters.
			 * ? matches exactly one character. *.* matches any name with a period in it (with
			 * {@link System.IO.MatchType.Win32}, this would match all items).
			 */
			Simple = 0,

			/**
			 * Match using Win32 DOS style matching semantics. '*', '?', '&lt;', '&gt;', and '"' are
			 * all considered wildcards. Matches in a traditional DOS / Windows command prompt way.
			 * *.* matches all files. ? matches collapse to periods. file.??t will match file.t ,
			 * file.at , and file.txt .
			 */
			Win32 = 1,
		}
	}

	export namespace System.IO {
		/** Creates a stream whose backing store is memory. */
		export class MemoryStream extends Duplex {
			/**
			 * Initializes a new instance of the {@link System.IO.MemoryStream} class with an
			 * expandable capacity initialized to zero.
			 */
			constructor();

			/**
			 * Initializes a new non-resizable instance of the {@link System.IO.MemoryStream} class
			 * based on the specified byte array.
			 */
			constructor(buffer: number[]);

			/**
			 * Initializes a new non-resizable instance of the {@link System.IO.MemoryStream} class
			 * based on the specified byte array with the {@link System.IO.MemoryStream.CanWrite}
			 * property set as specified.
			 */
			constructor(
				buffer: number[],
				writable: boolean,
			);

			/**
			 * Initializes a new non-resizable instance of the {@link System.IO.MemoryStream} class
			 * based on the specified region (index) of a byte array.
			 */
			constructor(
				buffer: number[],
				index: number,
				count: number,
			);

			/**
			 * Initializes a new non-resizable instance of the {@link System.IO.MemoryStream} class
			 * based on the specified region of a byte array, with the
			 * {@link System.IO.MemoryStream.CanWrite} property set as specified.
			 */
			constructor(
				buffer: number[],
				index: number,
				count: number,
				writable: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.MemoryStream} class based on the
			 * specified region of a byte array, with the {@link System.IO.MemoryStream.CanWrite}
			 * property set as specified, and the ability to call
			 * {@link System.IO.MemoryStream.GetBuffer} set as specified.
			 */
			constructor(
				buffer: number[],
				index: number,
				count: number,
				writable: boolean,
				publiclyVisible: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.MemoryStream} class with an
			 * expandable capacity initialized as specified.
			 */
			constructor(capacity: number);
		}
	}

	export namespace System.IO {
		/**
		 * Performs operations on {@link System.String} instances that contain file or directory
		 * path information. These operations are performed in a cross-platform manner.
		 */
		export namespace Path {
			/** Changes the extension of a path string. */
			export function ChangeExtension(
				path: string | undefined,
				extension: string | undefined,
			): string | undefined;

			/** Combines two strings into a path. */
			export function Combine(
				path1: string,
				path2: string,
			): string;

			/** Combines three strings into a path. */
			export function Combine(
				path1: string,
				path2: string,
				path3: string,
			): string;

			/** Combines four strings into a path. */
			export function Combine(
				path1: string,
				path2: string,
				path3: string,
				path4: string,
			): string;

			/** Combines an array of strings into a path. */
			export function Combine(paths: string[]): string;

			/**
			 * Returns a value that indicates whether the path, specified as a read-only span, ends
			 * in a directory separator.
			 */
			export function EndsInDirectorySeparator(path: System.ReadOnlySpan$1<System.Char>): boolean;

			/**
			 * Returns a value that indicates whether the specified path ends in a directory
			 * separator.
			 */
			export function EndsInDirectorySeparator(path: string | undefined): boolean;

			/** Determines whether the specified file or directory exists. */
			export function Exists(path: string | undefined): boolean;

			/**
			 * Returns the directory information for the specified path represented by a character
			 * span.
			 */
			export function GetDirectoryName(path: System.ReadOnlySpan$1<System.Char>): System.ReadOnlySpan$1<System.Char>;

			/** Returns the directory information for the specified path. */
			export function GetDirectoryName(path: string | undefined): string | undefined;

			/**
			 * Returns the extension of a file path that is represented by a read-only character
			 * span.
			 */
			export function GetExtension(path: System.ReadOnlySpan$1<System.Char>): System.ReadOnlySpan$1<System.Char>;

			/** Returns the extension (including the period ".") of the specified path string. */
			export function GetExtension(path: string | undefined): string | undefined;

			/**
			 * Returns the file name and extension of a file path that is represented by a read-only
			 * character span.
			 */
			export function GetFileName(path: System.ReadOnlySpan$1<System.Char>): System.ReadOnlySpan$1<System.Char>;

			/** Returns the file name and extension of the specified path string. */
			export function GetFileName(path: string | undefined): string | undefined;

			/**
			 * Returns the file name without the extension of a file path that is represented by a
			 * read-only character span.
			 */
			export function GetFileNameWithoutExtension(path: System.ReadOnlySpan$1<System.Char>): System.ReadOnlySpan$1<System.Char>;

			/** Returns the file name of the specified path string without the extension. */
			export function GetFileNameWithoutExtension(path: string | undefined): string | undefined;

			/** Returns the absolute path for the specified path string. */
			export function GetFullPath(path: string): string;

			/** Returns an absolute path from a relative path and a fully qualified base path. */
			export function GetFullPath(
				path: string,
				basePath: string,
			): string;

			/** Gets an array containing the characters that are not allowed in file names. */
			export function GetInvalidFileNameChars(): System.Char[];

			/** Gets an array containing the characters that are not allowed in path names. */
			export function GetInvalidPathChars(): System.Char[];

			/**
			 * Gets the root directory information from the path contained in the specified character
			 * span.
			 */
			export function GetPathRoot(path: System.ReadOnlySpan$1<System.Char>): System.ReadOnlySpan$1<System.Char>;

			/**
			 * Gets the root directory information from the path contained in the specified string.
			 */
			export function GetPathRoot(path: string | undefined): string | undefined;

			/** Returns a random folder name or file name. */
			export function GetRandomFileName(): string;

			/** Returns a relative path from one path to another. */
			export function GetRelativePath(
				relativeTo: string,
				path: string,
			): string;

			/**
			 * Creates a uniquely named, zero-byte temporary file on disk and returns the full path
			 * of that file.
			 */
			export function GetTempFileName(): string;

			/** Returns the path of the current user's temporary folder. */
			export function GetTempPath(): string;

			/**
			 * Determines whether the path represented by the specified character span includes a
			 * file name extension.
			 */
			export function HasExtension(path: System.ReadOnlySpan$1<System.Char>): boolean;

			/** Determines whether a path includes a file name extension. */
			export function HasExtension(path: string | undefined): boolean;

			/**
			 * Returns a value that indicates whether the file path represented by the specified
			 * character span is fixed to a specific drive or UNC path.
			 */
			export function IsPathFullyQualified(path: System.ReadOnlySpan$1<System.Char>): boolean;

			/**
			 * Returns a value that indicates whether the specified file path is fixed to a specific
			 * drive or UNC path.
			 */
			export function IsPathFullyQualified(path: string): boolean;

			/**
			 * Returns a value that indicates whether the specified character span that represents a
			 * file path contains a root.
			 */
			export function IsPathRooted(path: System.ReadOnlySpan$1<System.Char>): boolean;

			/** Returns a value indicating whether the specified path string contains a root. */
			export function IsPathRooted(path: string | undefined): boolean;

			/** Concatenates two path components into a single path. */
			export function Join(
				path1: System.ReadOnlySpan$1<System.Char>,
				path2: System.ReadOnlySpan$1<System.Char>,
			): string;

			/** Concatenates three path components into a single path. */
			export function Join(
				path1: System.ReadOnlySpan$1<System.Char>,
				path2: System.ReadOnlySpan$1<System.Char>,
				path3: System.ReadOnlySpan$1<System.Char>,
			): string;

			/** Concatenates four path components into a single path. */
			export function Join(
				path1: System.ReadOnlySpan$1<System.Char>,
				path2: System.ReadOnlySpan$1<System.Char>,
				path3: System.ReadOnlySpan$1<System.Char>,
				path4: System.ReadOnlySpan$1<System.Char>,
			): string;

			/** Concatenates two paths into a single path. */
			export function Join(
				path1: string | undefined,
				path2: string | undefined,
			): string;

			/** Concatenates three paths into a single path. */
			export function Join(
				path1: string | undefined,
				path2: string | undefined,
				path3: string | undefined,
			): string;

			/** Concatenates four paths into a single path. */
			export function Join(
				path1: string | undefined,
				path2: string | undefined,
				path3: string | undefined,
				path4: string | undefined,
			): string;

			/** Concatenates an array of paths into a single path. */
			export function Join(paths: string | undefined[]): string;

			/** Trims one trailing directory separator beyond the root of the specified path. */
			export function TrimEndingDirectorySeparator(path: System.ReadOnlySpan$1<System.Char>): System.ReadOnlySpan$1<System.Char>;

			/** Trims one trailing directory separator beyond the root of the specified path. */
			export function TrimEndingDirectorySeparator(path: string): string;

			export function TryJoin(
				path1: System.ReadOnlySpan$1<System.Char>,
				path2: System.ReadOnlySpan$1<System.Char>,
				path3: System.ReadOnlySpan$1<System.Char>,
				destination: System.Span$1<System.Char>,
			): number | undefined;

			export function TryJoin(
				path1: System.ReadOnlySpan$1<System.Char>,
				path2: System.ReadOnlySpan$1<System.Char>,
				destination: System.Span$1<System.Char>,
			): number | undefined;
		}
	}

	export namespace System.IO {
		/**
		 * The exception that is thrown when a path or fully qualified file name is longer than
		 * the system-defined maximum length.
		 */
		export class PathTooLongException extends System.IO.IOException {
			/**
			 * Initializes a new instance of the {@link System.IO.PathTooLongException} class with
			 * its HRESULT set to COR_E_PATHTOOLONG.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.IO.PathTooLongException} class with
			 * its message string set to `message` and its HRESULT set to COR_E_PATHTOOLONG.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.IO.PathTooLongException} class with a
			 * specified error message and a reference to the inner exception that is the cause of
			 * this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System.IO {
		/** Provides offset-based APIs for reading and writing files in a thread-safe manner. */
		export namespace RandomAccess {
			/** Flushes the operating system buffers for the given file to disk. */
			export function FlushToDisk(handle: Microsoft.Win32.SafeHandles.SafeFileHandle): void;

			/** Gets the length of the file in bytes. */
			export function GetLength(handle: Microsoft.Win32.SafeHandles.SafeFileHandle): number;

			/** Sets the length of the file to the given value. */
			export function SetLength(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				length: number,
			): void;

			/** Reads a sequence of bytes from given file at given offset. */
			export function Read(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				buffers: readonly Uint8Array[],
				fileOffset: number,
			): number;

			/** Reads a sequence of bytes from given file at given offset. */
			export function Read(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				buffer: System.Span$1<number>,
				fileOffset: number,
			): number;

			/** Reads a sequence of bytes from given file at given offset. */
			export function ReadAsync(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				buffers: readonly Uint8Array[],
				fileOffset: number,
				cancellationToken?: AbortSignal,
			): Promise<number>;

			/** Reads a sequence of bytes from given file at given offset. */
			export function ReadAsync(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				buffer: Uint8Array,
				fileOffset: number,
				cancellationToken?: AbortSignal,
			): Promise<number>;

			/** Writes a sequence of bytes from given buffers to given file at given offset. */
			export function Write(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				buffers: readonly Uint8Array[],
				fileOffset: number,
			): void;

			/** Writes a sequence of bytes from given buffer to given file at given offset. */
			export function Write(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				buffer: System.ReadOnlySpan$1<number>,
				fileOffset: number,
			): void;

			/** Writes a sequence of bytes from given buffers to given file at given offset. */
			export function WriteAsync(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				buffers: readonly Uint8Array[],
				fileOffset: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** Writes a sequence of bytes from given buffer to given file at given offset. */
			export function WriteAsync(
				handle: Microsoft.Win32.SafeHandles.SafeFileHandle,
				buffer: Uint8Array,
				fileOffset: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;
		}
	}

	export namespace System.IO {
		/**
		 * Specifies whether to search the current directory, or the current directory and all
		 * subdirectories.
		 */
		export enum SearchOption {
			/** Includes only the current directory in a search operation. */
			TopDirectoryOnly = 0,

			/**
			 * Includes the current directory and all its subdirectories in a search operation. This
			 * option includes reparse points such as mounted drives and symbolic links in the
			 * search.
			 */
			AllDirectories = 1,
		}
	}

	export namespace System.IO {
		/** Specifies the position in a stream to use for seeking. */
		export enum SeekOrigin {
			/** Specifies the beginning of a stream. */
			Begin = 0,

			/** Specifies the current position within a stream. */
			Current = 1,

			/** Specifies the end of a stream. */
			End = 2,
		}
	}

	export namespace System.IO {
		/** Provides a generic view of a sequence of bytes. This is an abstract class. */
		export class Stream extends System.MarshalByRefObject implements
			System.IAsyncDisposable,
			IDisposable {
			/**
			 * When overridden in a derived class, gets a value indicating whether the current stream
			 * supports reading.
			 */
			readonly CanRead: boolean;

			/**
			 * When overridden in a derived class, gets a value indicating whether the current stream
			 * supports seeking.
			 */
			readonly CanSeek: boolean;

			/** Gets a value that determines whether the current stream can time out. */
			readonly CanTimeout: boolean;

			/**
			 * When overridden in a derived class, gets a value indicating whether the current stream
			 * supports writing.
			 */
			readonly CanWrite: boolean;

			/** When overridden in a derived class, gets the length in bytes of the stream. */
			readonly Length: number;

			/**
			 * When overridden in a derived class, gets or sets the position within the current
			 * stream.
			 */
			Position: number;

			/**
			 * Gets or sets a value, in milliseconds, that determines how long the stream will
			 * attempt to read before timing out.
			 */
			ReadTimeout: number;

			/**
			 * Gets or sets a value, in milliseconds, that determines how long the stream will
			 * attempt to write before timing out.
			 */
			WriteTimeout: number;

			/**
			 * Closes the current stream and releases any resources (such as sockets and file
			 * handles) associated with the current stream. Instead of calling this method, ensure
			 * that the stream is properly disposed.
			 */
			Close(): void;

			/**
			 * Reads the bytes from the current stream and writes them to another stream. Both
			 * streams positions are advanced by the number of bytes copied.
			 */
			CopyTo(destination: Duplex): void;

			/**
			 * Reads the bytes from the current stream and writes them to another stream, using a
			 * specified buffer size. Both streams positions are advanced by the number of bytes
			 * copied.
			 */
			CopyTo(
				destination: Duplex,
				bufferSize: number,
			): void;

			/**
			 * Asynchronously reads the bytes from the current stream and writes them to another
			 * stream. Both streams positions are advanced by the number of bytes copied.
			 */
			CopyToAsync(destination: Duplex): Promise<void>;

			/**
			 * Asynchronously reads the bytes from the current stream and writes them to another
			 * stream, using a specified buffer size. Both streams positions are advanced by the
			 * number of bytes copied.
			 */
			CopyToAsync(
				destination: Duplex,
				bufferSize: number,
			): Promise<void>;

			/**
			 * Asynchronously reads the bytes from the current stream and writes them to another
			 * stream, using a specified buffer size and cancellation token. Both streams positions
			 * are advanced by the number of bytes copied.
			 */
			CopyToAsync(
				destination: Duplex,
				bufferSize: number,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously reads the bytes from the current stream and writes them to another
			 * stream, using a specified cancellation token. Both streams positions are advanced by
			 * the number of bytes copied.
			 */
			CopyToAsync(
				destination: Duplex,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/** Releases all resources used by the {@link System.IO.Stream}. */
			dispose(): void;

			/**
			 * Asynchronously releases the unmanaged resources used by the {@link System.IO.Stream}.
			 */
			DisposeAsync(): Promise<void>;

			/**
			 * When overridden in a derived class, clears all buffers for this stream and causes any
			 * buffered data to be written to the underlying device.
			 */
			Flush(): void;

			/**
			 * Asynchronously clears all buffers for this stream and causes any buffered data to be
			 * written to the underlying device.
			 */
			FlushAsync(): Promise<void>;

			/**
			 * Asynchronously clears all buffers for this stream, causes any buffered data to be
			 * written to the underlying device, and monitors cancellation requests.
			 */
			FlushAsync(cancellationToken: AbortSignal): Promise<void>;

			/**
			 * When overridden in a derived class, reads a sequence of bytes from the current stream
			 * and advances the position within the stream by the number of bytes read.
			 */
			Read(
				buffer: number[],
				offset: number,
				count: number,
			): number;

			/**
			 * When overridden in a derived class, reads a sequence of bytes from the current stream
			 * and advances the position within the stream by the number of bytes read.
			 */
			Read(buffer: System.Span$1<number>): number;

			/**
			 * Asynchronously reads a sequence of bytes from the current stream and advances the
			 * position within the stream by the number of bytes read.
			 */
			ReadAsync(
				buffer: number[],
				offset: number,
				count: number,
			): Promise<number>;

			/**
			 * Asynchronously reads a sequence of bytes from the current stream, advances the
			 * position within the stream by the number of bytes read, and monitors cancellation
			 * requests.
			 */
			ReadAsync(
				buffer: number[],
				offset: number,
				count: number,
				cancellationToken: AbortSignal,
			): Promise<number>;

			/**
			 * Asynchronously reads a sequence of bytes from the current stream, advances the
			 * position within the stream by the number of bytes read, and monitors cancellation
			 * requests.
			 */
			ReadAsync(
				buffer: Uint8Array,
				cancellationToken?: AbortSignal,
			): Promise<number>;

			/**
			 * Reads at least a minimum number of bytes from the current stream and advances the
			 * position within the stream by the number of bytes read.
			 */
			ReadAtLeast(
				buffer: System.Span$1<number>,
				minimumBytes: number,
				throwOnEndOfStream?: boolean,
			): number;

			/**
			 * Asynchronously reads at least a minimum number of bytes from the current stream,
			 * advances the position within the stream by the number of bytes read, and monitors
			 * cancellation requests.
			 */
			ReadAtLeastAsync(
				buffer: Uint8Array,
				minimumBytes: number,
				throwOnEndOfStream?: boolean,
				cancellationToken?: AbortSignal,
			): Promise<number>;

			/**
			 * Reads a byte from the stream and advances the position within the stream by one byte,
			 * or returns -1 if at the end of the stream.
			 */
			ReadByte(): number;

			/**
			 * Reads `count` number of bytes from the current stream and advances the position within
			 * the stream.
			 */
			ReadExactly(
				buffer: number[],
				offset: number,
				count: number,
			): void;

			/**
			 * Reads bytes from the current stream and advances the position within the stream until
			 * the `buffer` is filled.
			 */
			ReadExactly(buffer: System.Span$1<number>): void;

			/**
			 * Asynchronously reads `count` number of bytes from the current stream, advances the
			 * position within the stream, and monitors cancellation requests.
			 */
			ReadExactlyAsync(
				buffer: number[],
				offset: number,
				count: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously reads bytes from the current stream, advances the position within the
			 * stream until the `buffer` is filled, and monitors cancellation requests.
			 */
			ReadExactlyAsync(
				buffer: Uint8Array,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** When overridden in a derived class, sets the position within the current stream. */
			Seek(
				offset: number,
				origin: System.IO.SeekOrigin,
			): number;

			/** When overridden in a derived class, sets the length of the current stream. */
			SetLength(value: number): void;

			/**
			 * Creates a thread-safe (synchronized) wrapper around the specified
			 * {@link System.IO.Stream} object.
			 */
			static Synchronized(stream: Duplex): Duplex;

			/**
			 * When overridden in a derived class, writes a sequence of bytes to the current stream
			 * and advances the current position within this stream by the number of bytes written.
			 */
			Write(
				buffer: number[],
				offset: number,
				count: number,
			): void;

			/**
			 * When overridden in a derived class, writes a sequence of bytes to the current stream
			 * and advances the current position within this stream by the number of bytes written.
			 */
			Write(buffer: System.ReadOnlySpan$1<number>): void;

			/**
			 * Asynchronously writes a sequence of bytes to the current stream and advances the
			 * current position within this stream by the number of bytes written.
			 */
			WriteAsync(
				buffer: number[],
				offset: number,
				count: number,
			): Promise<void>;

			/**
			 * Asynchronously writes a sequence of bytes to the current stream, advances the current
			 * position within this stream by the number of bytes written, and monitors cancellation
			 * requests.
			 */
			WriteAsync(
				buffer: number[],
				offset: number,
				count: number,
				cancellationToken: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a sequence of bytes to the current stream, advances the current
			 * position within this stream by the number of bytes written, and monitors cancellation
			 * requests.
			 */
			WriteAsync(
				buffer: Uint8Array,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Writes a byte to the current position in the stream and advances the position within
			 * the stream by one byte.
			 */
			WriteByte(value: number): void;
		}
	}

	export namespace System.IO {
		/**
		 * Implements a {@link System.IO.TextReader} that reads characters from a byte stream in
		 * a particular encoding.
		 */
		export class StreamReader extends System.IO.TextReader implements IDisposable {
			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified stream.
			 */
			constructor(stream: Duplex);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified stream, with the specified byte order mark detection option.
			 */
			constructor(
				stream: Duplex,
				detectEncodingFromByteOrderMarks: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified stream, with the specified character encoding.
			 */
			constructor(
				stream: Duplex,
				encoding: System.Text.Encoding,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified stream, with the specified character encoding and byte order mark detection
			 * option.
			 */
			constructor(
				stream: Duplex,
				encoding: System.Text.Encoding,
				detectEncodingFromByteOrderMarks: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified stream, with the specified character encoding, byte order mark detection
			 * option, and buffer size.
			 */
			constructor(
				stream: Duplex,
				encoding: System.Text.Encoding,
				detectEncodingFromByteOrderMarks: boolean,
				bufferSize: number,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified stream based on the specified character encoding, byte order mark detection
			 * option, and buffer size, and optionally leaves the stream open.
			 */
			constructor(
				stream: Duplex,
				encoding?: System.Text.Encoding,
				detectEncodingFromByteOrderMarks?: boolean,
				bufferSize?: number,
				leaveOpen?: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified file name.
			 */
			constructor(path: string);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified file name, with the specified byte order mark detection option.
			 */
			constructor(
				path: string,
				detectEncodingFromByteOrderMarks: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified file path, using the default encoding, enabling detection of byte order
			 * marks at the beginning of the file, and configured with the specified
			 * {@link System.IO.FileStreamOptions} object.
			 */
			constructor(
				path: string,
				options: System.IO.FileStreamOptions,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified file name, with the specified character encoding.
			 */
			constructor(
				path: string,
				encoding: System.Text.Encoding,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified file name, with the specified character encoding and byte order mark
			 * detection option.
			 */
			constructor(
				path: string,
				encoding: System.Text.Encoding,
				detectEncodingFromByteOrderMarks: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified file name, with the specified character encoding, byte order mark detection
			 * option, and buffer size.
			 */
			constructor(
				path: string,
				encoding: System.Text.Encoding,
				detectEncodingFromByteOrderMarks: boolean,
				bufferSize: number,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamReader} class for the
			 * specified file path, with the specified character encoding, byte order mark detection
			 * option, and configured with the specified {@link System.IO.FileStreamOptions} object.
			 */
			constructor(
				path: string,
				encoding: System.Text.Encoding,
				detectEncodingFromByteOrderMarks: boolean,
				options: System.IO.FileStreamOptions,
			);

			/** Returns the underlying stream. */
			readonly BaseStream: Duplex;

			/**
			 * Gets the current character encoding that the current {@link System.IO.StreamReader}
			 * object is using.
			 */
			readonly CurrentEncoding: System.Text.Encoding;

			/**
			 * Gets a value that indicates whether the current stream position is at the end of the
			 * stream.
			 */
			readonly EndOfStream: boolean;

			/**
			 * Closes the {@link System.IO.StreamReader} object and the underlying stream, and
			 * releases any system resources associated with the reader.
			 */
			Close(): void;

			/** Clears the internal buffer. */
			DiscardBufferedData(): void;

			/** Returns the next available character but does not consume it. */
			Peek(): number;

			/**
			 * Reads the next character from the input stream and advances the character position by
			 * one character.
			 */
			Read(): number;

			/**
			 * Reads a specified maximum of characters from the current stream into a buffer,
			 * beginning at the specified index.
			 */
			Read(
				buffer: System.Char[],
				index: number,
				count: number,
			): number;

			/** Reads the characters from the current stream into a span. */
			Read(buffer: System.Span$1<System.Char>): number;

			/**
			 * Reads a specified maximum number of characters from the current stream asynchronously
			 * and writes the data to a buffer, beginning at the specified index.
			 */
			ReadAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<number>;

			/** Asynchronously reads the characters from the current stream into a memory block. */
			ReadAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<number>;

			/**
			 * Reads a specified maximum number of characters from the current stream and writes the
			 * data to a buffer, beginning at the specified index.
			 */
			ReadBlock(
				buffer: System.Char[],
				index: number,
				count: number,
			): number;

			/** Reads the characters from the current stream and writes the data to a buffer. */
			ReadBlock(buffer: System.Span$1<System.Char>): number;

			/**
			 * Reads a specified maximum number of characters from the current stream asynchronously
			 * and writes the data to a buffer, beginning at the specified index.
			 */
			ReadBlockAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<number>;

			/**
			 * Asynchronously reads the characters from the current stream and writes the data to a
			 * buffer.
			 */
			ReadBlockAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<number>;

			/**
			 * Reads a line of characters from the current stream and returns the data as a string.
			 */
			ReadLine(): string | undefined;

			/**
			 * Reads a line of characters asynchronously from the current stream and returns the data
			 * as a string.
			 */
			ReadLineAsync(): Promise<string | undefined>;

			/**
			 * Reads a line of characters asynchronously from the current stream and returns the data
			 * as a string.
			 */
			ReadLineAsync(cancellationToken: AbortSignal): Promise<string | undefined>;

			/** Reads all characters from the current position to the end of the stream. */
			ReadToEnd(): string;

			/**
			 * Reads all characters from the current position to the end of the stream asynchronously
			 * and returns them as one string.
			 */
			ReadToEndAsync(): Promise<string>;

			/**
			 * Reads all characters from the current position to the end of the stream asynchronously
			 * and returns them as one string.
			 */
			ReadToEndAsync(cancellationToken: AbortSignal): Promise<string>;
		}
	}

	export namespace System.IO {
		/**
		 * Implements a {@link System.IO.TextWriter} for writing characters to a stream in a
		 * particular encoding.
		 */
		export class StreamWriter extends System.IO.TextWriter implements
			System.IAsyncDisposable,
			IDisposable {
			/**
			 * Initializes a new instance of the {@link System.IO.StreamWriter} class for the
			 * specified stream by using UTF-8 encoding and the default buffer size.
			 */
			constructor(stream: Duplex);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamWriter} class for the
			 * specified stream by using the specified encoding and the default buffer size.
			 */
			constructor(
				stream: Duplex,
				encoding: System.Text.Encoding,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamWriter} class for the
			 * specified stream by using the specified encoding and buffer size.
			 */
			constructor(
				stream: Duplex,
				encoding: System.Text.Encoding,
				bufferSize: number,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamWriter} class for the
			 * specified stream by using the specified encoding and buffer size, and optionally
			 * leaves the stream open.
			 */
			constructor(
				stream: Duplex,
				encoding?: System.Text.Encoding,
				bufferSize?: number,
				leaveOpen?: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamWriter} class for the
			 * specified file by using the default encoding and buffer size.
			 */
			constructor(path: string);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamWriter} class for the
			 * specified file by using the default encoding and buffer size. If the file exists, it
			 * can be either overwritten or appended to. If the file does not exist, this constructor
			 * creates a new file.
			 */
			constructor(
				path: string,
				append: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamWriter} class for the
			 * specified file by using the specified encoding and default buffer size. If the file
			 * exists, it can be either overwritten or appended to. If the file does not exist, this
			 * constructor creates a new file.
			 */
			constructor(
				path: string,
				append: boolean,
				encoding: System.Text.Encoding,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamWriter} class for the
			 * specified file on the specified path, using the specified encoding and buffer size. If
			 * the file exists, it can be either overwritten or appended to. If the file does not
			 * exist, this constructor creates a new file.
			 */
			constructor(
				path: string,
				append: boolean,
				encoding: System.Text.Encoding,
				bufferSize: number,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamWriter} class for the
			 * specified file, using the default encoding, and configured with the specified
			 * {@link System.IO.FileStreamOptions} object.
			 */
			constructor(
				path: string,
				options: System.IO.FileStreamOptions,
			);

			/**
			 * Initializes a new instance of the {@link System.IO.StreamWriter} class for the
			 * specified file, using the specified encoding, and configured with the specified
			 * {@link System.IO.FileStreamOptions} object.
			 */
			constructor(
				path: string,
				encoding: System.Text.Encoding,
				options: System.IO.FileStreamOptions,
			);

			/**
			 * Gets or sets a value indicating whether the {@link System.IO.StreamWriter} will flush
			 * its buffer to the underlying stream after every call to
			 * {@link System.IO.StreamWriter.Write(System.Char)}.
			 */
			AutoFlush: boolean;

			/** Gets the underlying stream that interfaces with a backing store. */
			readonly BaseStream: Duplex;

			/** Gets the {@link System.Text.Encoding} in which the output is written. */
			readonly Encoding: System.Text.Encoding;

			/** Closes the current `StreamWriter` object and the underlying stream. */
			Close(): void;

			/**
			 * Asynchronously writes any buffered data to the underlying stream and releases the
			 * unmanaged resources used by the {@link System.IO.StreamWriter}.
			 */
			DisposeAsync(): Promise<void>;

			/**
			 * Clears all buffers for the current writer and causes any buffered data to be written
			 * to the underlying stream.
			 */
			Flush(): void;

			/**
			 * Clears all buffers for this stream asynchronously and causes any buffered data to be
			 * written to the underlying device.
			 */
			FlushAsync(): Promise<void>;

			/**
			 * Clears all buffers for this stream asynchronously and causes any buffered data to be
			 * written to the underlying device.
			 */
			FlushAsync(cancellationToken: AbortSignal): Promise<void>;

			/** Writes a character to the stream. */
			Write(value: System.Char): void;

			/** Writes a character array to the stream. */
			Write(buffer: System.Char[] | undefined): void;

			/** Writes a subarray of characters to the stream. */
			Write(
				buffer: System.Char[],
				index: number,
				count: number,
			): void;

			/** Writes a character span to the stream. */
			Write(buffer: System.ReadOnlySpan$1<System.Char>): void;

			/** Writes a string to the stream. */
			Write(value: string | undefined): void;

			/**
			 * Writes a formatted string to the stream, using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object)} method.
			 */
			Write(
				format: string,
				arg0: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string to the stream using the same semantics  as the
			 * {@link System.String.Format(System.String,System.Object,System.Object)} method.
			 */
			Write(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string to the stream, using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object,System.Object,System.Object)}
			 * method.
			 */
			Write(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string to the stream, using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object[])} method.
			 */
			Write(
				format: string,
				arg: System.Object | undefined[],
			): void;

			/** Asynchronously writes a character to the stream. */
			WriteAsync(value: System.Char): Promise<void>;

			/** Asynchronously writes a subarray of characters to the stream. */
			WriteAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<void>;

			/** Asynchronously writes a character memory region to the stream. */
			WriteAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** Asynchronously writes a string to the stream. */
			WriteAsync(value: string | undefined): Promise<void>;

			/**
			 * Writes the text representation of a character span to the stream, followed by a line
			 * terminator.
			 */
			WriteLine(buffer: System.ReadOnlySpan$1<System.Char>): void;

			/** Writes a string to the stream, followed by a line terminator. */
			WriteLine(value: string | undefined): void;

			/**
			 * Writes a formatted string and a new line to the stream, using the same semantics as
			 * the {@link System.String.Format(System.String,System.Object)} method.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string and a new line to the stream, using the same semantics as
			 * the {@link System.String.Format(System.String,System.Object,System.Object)} method.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): void;

			/**
			 * Writes out a formatted string and a new line to the stream, using the same semantics
			 * as {@link System.String.Format(System.String,System.Object)}.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): void;

			/**
			 * Writes out a formatted string and a new line to the stream, using the same semantics
			 * as {@link System.String.Format(System.String,System.Object)}.
			 */
			WriteLine(
				format: string,
				arg: System.Object | undefined[],
			): void;

			/** Asynchronously writes a line terminator to the stream. */
			WriteLineAsync(): Promise<void>;

			/** Asynchronously writes a character to the stream, followed by a line terminator. */
			WriteLineAsync(value: System.Char): Promise<void>;

			/**
			 * Asynchronously writes a subarray of characters to the stream, followed by a line
			 * terminator.
			 */
			WriteLineAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<void>;

			/**
			 * Asynchronously writes the text representation of a character memory region to the
			 * stream, followed by a line terminator.
			 */
			WriteLineAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** Asynchronously writes a string to the stream, followed by a line terminator. */
			WriteLineAsync(value: string | undefined): Promise<void>;

			/** Writes the text representation of a `Boolean` value to the text stream. */
			Write(value: boolean): void;

			/** Writes the text representation of a decimal value to the text stream. */
			Write(value: System.Decimal): void;

			/**
			 * Writes the text representation of an 8-byte floating-point value to the text stream.
			 */
			Write(value: number): void;

			/** Writes the text representation of a 4-byte signed integer to the text stream. */
			Write(value: number): void;

			/** Writes the text representation of an 8-byte signed integer to the text stream. */
			Write(value: number): void;

			/**
			 * Writes the text representation of an object to the text stream by calling the
			 * `ToString` method on that object.
			 */
			Write(value: System.Object | undefined): void;

			/**
			 * Writes the text representation of a 4-byte floating-point value to the text stream.
			 */
			Write(value: number): void;

			/** Writes a string builder to the text stream. */
			Write(value: System.Text.StringBuilder | undefined): void;

			/** Writes the text representation of a 4-byte unsigned integer to the text stream. */
			Write(value: number): void;

			/** Writes the text representation of an 8-byte unsigned integer to the text stream. */
			Write(value: number): void;

			/** Writes a character array to the text stream asynchronously. */
			WriteAsync(buffer: System.Char[] | undefined): Promise<void>;

			/** Asynchronously writes a string builder to the text stream. */
			WriteAsync(
				value: System.Text.StringBuilder | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** Writes a line terminator to the text stream. */
			WriteLine(): void;

			/**
			 * Writes the text representation of a `Boolean` value to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(value: boolean): void;

			/** Writes a character to the text stream, followed by a line terminator. */
			WriteLine(value: System.Char): void;

			/** Writes an array of characters to the text stream, followed by a line terminator. */
			WriteLine(buffer: System.Char[] | undefined): void;

			/** Writes a subarray of characters to the text stream, followed by a line terminator. */
			WriteLine(
				buffer: System.Char[],
				index: number,
				count: number,
			): void;

			/**
			 * Writes the text representation of a decimal value to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(value: System.Decimal): void;

			/**
			 * Writes the text representation of a 8-byte floating-point value to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of a 4-byte signed integer to the text stream, followed
			 * by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an 8-byte signed integer to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an object to the text stream, by calling the
			 * `ToString` method on that object, followed by a line terminator.
			 */
			WriteLine(value: System.Object | undefined): void;

			/**
			 * Writes the text representation of a 4-byte floating-point value to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of a string builder to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(value: System.Text.StringBuilder | undefined): void;

			/**
			 * Writes the text representation of a 4-byte unsigned integer to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an 8-byte unsigned integer to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Asynchronously writes an array of characters to the text stream, followed by a line
			 * terminator.
			 */
			WriteLineAsync(buffer: System.Char[] | undefined): Promise<void>;

			/**
			 * Asynchronously writes the text representation of a string builder to the text stream,
			 * followed by a line terminator.
			 */
			WriteLineAsync(
				value: System.Text.StringBuilder | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;
		}
	}

	export namespace System.IO {
		/** Implements a {@link System.IO.TextReader} that reads from a string. */
		export class StringReader extends System.IO.TextReader implements IDisposable {
			/**
			 * Initializes a new instance of the {@link System.IO.StringReader} class that reads from
			 * the specified string.
			 */
			constructor(s: string);

			/** Closes the {@link System.IO.StringReader}. */
			Close(): void;

			/** Returns the next available character but does not consume it. */
			Peek(): number;

			/**
			 * Reads the next character from the input string and advances the character position by
			 * one character.
			 */
			Read(): number;

			/**
			 * Reads a block of characters from the input string and advances the character position
			 * by `count`.
			 */
			Read(
				buffer: System.Char[],
				index: number,
				count: number,
			): number;

			/**
			 * Reads all the characters from the input string, starting at the current position, and
			 * advances the current position to the end of the input string.
			 */
			Read(buffer: System.Span$1<System.Char>): number;

			/**
			 * Reads a specified maximum number of characters from the current string asynchronously
			 * and writes the data to a buffer, beginning at the specified index.
			 */
			ReadAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<number>;

			/**
			 * Asynchronously reads all the characters from the input string, starting at the current
			 * position, and advances the current position to the end of the input string.
			 */
			ReadAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<number>;

			/**
			 * Reads all the characters from the input string starting at the current position and
			 * advances the current position to the end of the input string.
			 */
			ReadBlock(buffer: System.Span$1<System.Char>): number;

			/**
			 * Reads a specified maximum number of characters from the current string asynchronously
			 * and writes the data to a buffer, beginning at the specified index.
			 */
			ReadBlockAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<number>;

			/**
			 * Asynchronously reads all the characters from the input string starting at the current
			 * position and advances the current position to the end of the input string.
			 */
			ReadBlockAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<number>;

			/**
			 * Reads a line of characters from the current string and returns the data as a string.
			 */
			ReadLine(): string | undefined;

			/**
			 * Reads a line of characters asynchronously from the current string and returns the data
			 * as a string.
			 */
			ReadLineAsync(): Promise<string | undefined>;

			/**
			 * Reads a line of characters asynchronously from the current string and returns the data
			 * as a string.
			 */
			ReadLineAsync(cancellationToken: AbortSignal): Promise<string | undefined>;

			/**
			 * Reads all characters from the current position to the end of the string and returns
			 * them as a single string.
			 */
			ReadToEnd(): string;

			/**
			 * Reads all characters from the current position to the end of the string asynchronously
			 * and returns them as a single string.
			 */
			ReadToEndAsync(): Promise<string>;

			/**
			 * Reads all characters from the current position to the end of the string asynchronously
			 * and returns them as a single string.
			 */
			ReadToEndAsync(cancellationToken: AbortSignal): Promise<string>;

			/**
			 * Reads a specified maximum number of characters from the current text reader and writes
			 * the data to a buffer, beginning at the specified index.
			 */
			ReadBlock(
				buffer: System.Char[],
				index: number,
				count: number,
			): number;
		}
	}

	export namespace System.IO {
		/**
		 * Implements a {@link System.IO.TextWriter} for writing information to a string. The
		 * information is stored in an underlying {@link System.Text.StringBuilder}.
		 */
		export class StringWriter extends System.IO.TextWriter implements
			System.IAsyncDisposable,
			IDisposable {
			/** Initializes a new instance of the {@link System.IO.StringWriter} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.IO.StringWriter} class with the
			 * specified format control.
			 */
			constructor(formatProvider: System.IFormatProvider | undefined);

			/**
			 * Initializes a new instance of the {@link System.IO.StringWriter} class that writes to
			 * the specified {@link System.Text.StringBuilder}.
			 */
			constructor(sb: System.Text.StringBuilder);

			/**
			 * Initializes a new instance of the {@link System.IO.StringWriter} class that writes to
			 * the specified {@link System.Text.StringBuilder} and has the specified format provider.
			 */
			constructor(
				sb: System.Text.StringBuilder,
				formatProvider: System.IFormatProvider | undefined,
			);

			/** Gets the {@link System.Text.Encoding} in which the output is written. */
			readonly Encoding: System.Text.Encoding;

			/** Closes the current {@link System.IO.StringWriter} and the underlying stream. */
			Close(): void;

			/**
			 * Asynchronously clears all buffers for the current writer and causes any buffered data
			 * to be written to the underlying device.
			 */
			FlushAsync(): Promise<void>;

			/** Returns the underlying {@link System.Text.StringBuilder}. */
			GetStringBuilder(): System.Text.StringBuilder;

			/**
			 * Returns a string containing the characters written to the current `StringWriter` so
			 * far.
			 */
			ToString(): string;

			/** Writes a character to the string. */
			Write(value: System.Char): void;

			/** Writes a subarray of characters to the string. */
			Write(
				buffer: System.Char[],
				index: number,
				count: number,
			): void;

			/** Writes the string representation of a span of chars to the current string. */
			Write(buffer: System.ReadOnlySpan$1<System.Char>): void;

			/** Writes a string to the current string. */
			Write(value: string | undefined): void;

			/** Writes the string representation of a string builder to the current string. */
			Write(value: System.Text.StringBuilder | undefined): void;

			/** Writes a character to the string asynchronously. */
			WriteAsync(value: System.Char): Promise<void>;

			/** Writes a subarray of characters to the string asynchronously. */
			WriteAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<void>;

			/** Asynchronously writes a memory region of characters to the string. */
			WriteAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** Writes a string to the current string asynchronously. */
			WriteAsync(value: string | undefined): Promise<void>;

			/** Asynchronously writes the text representation of a string builder to the string. */
			WriteAsync(
				value: System.Text.StringBuilder | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Writes the text representation a span of characters to the string, followed by a line
			 * terminator.
			 */
			WriteLine(buffer: System.ReadOnlySpan$1<System.Char>): void;

			/**
			 * Writes the text representation of a string builder to the string, followed by a line
			 * terminator.
			 */
			WriteLine(value: System.Text.StringBuilder | undefined): void;

			/** Asynchronously writes a character to the string, followed by a line terminator. */
			WriteLineAsync(value: System.Char): Promise<void>;

			/**
			 * asynchronously writes a subarray of characters to the string, followed by a line
			 * terminator.
			 */
			WriteLineAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<void>;

			/**
			 * Asynchronously writes the string representation of the memory region of characters to
			 * the current string, followed by a line terminator.
			 */
			WriteLineAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes a string to the current string, followed by a line terminator.
			 */
			WriteLineAsync(value: string | undefined): Promise<void>;

			/**
			 * Asynchronously writes the string representation of the string builder to the current
			 * string, followed by a line terminator.
			 */
			WriteLineAsync(
				value: System.Text.StringBuilder | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously clears all buffers for the current writer and causes any buffered data
			 * to be written to the underlying device.
			 */
			FlushAsync(cancellationToken: AbortSignal): Promise<void>;

			/** Writes the text representation of a `Boolean` value to the text stream. */
			Write(value: boolean): void;

			/** Writes a character array to the text stream. */
			Write(buffer: System.Char[] | undefined): void;

			/** Writes the text representation of a decimal value to the text stream. */
			Write(value: System.Decimal): void;

			/**
			 * Writes the text representation of an 8-byte floating-point value to the text stream.
			 */
			Write(value: number): void;

			/** Writes the text representation of a 4-byte signed integer to the text stream. */
			Write(value: number): void;

			/** Writes the text representation of an 8-byte signed integer to the text stream. */
			Write(value: number): void;

			/**
			 * Writes the text representation of an object to the text stream by calling the
			 * `ToString` method on that object.
			 */
			Write(value: System.Object | undefined): void;

			/**
			 * Writes the text representation of a 4-byte floating-point value to the text stream.
			 */
			Write(value: number): void;

			/**
			 * Writes a formatted string to the text stream, using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object)} method.
			 */
			Write(
				format: string,
				arg0: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string to the text stream using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object,System.Object)} method.
			 */
			Write(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string to the text stream, using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object,System.Object,System.Object)}
			 * method.
			 */
			Write(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string to the text stream, using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object[])} method.
			 */
			Write(
				format: string,
				arg: System.Object | undefined[],
			): void;

			/** Writes the text representation of a 4-byte unsigned integer to the text stream. */
			Write(value: number): void;

			/** Writes the text representation of an 8-byte unsigned integer to the text stream. */
			Write(value: number): void;

			/** Writes a character array to the text stream asynchronously. */
			WriteAsync(buffer: System.Char[] | undefined): Promise<void>;

			/** Writes a line terminator to the text stream. */
			WriteLine(): void;

			/**
			 * Writes the text representation of a `Boolean` value to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(value: boolean): void;

			/** Writes a character to the text stream, followed by a line terminator. */
			WriteLine(value: System.Char): void;

			/** Writes an array of characters to the text stream, followed by a line terminator. */
			WriteLine(buffer: System.Char[] | undefined): void;

			/** Writes a subarray of characters to the text stream, followed by a line terminator. */
			WriteLine(
				buffer: System.Char[],
				index: number,
				count: number,
			): void;

			/**
			 * Writes the text representation of a decimal value to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(value: System.Decimal): void;

			/**
			 * Writes the text representation of a 8-byte floating-point value to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of a 4-byte signed integer to the text stream, followed
			 * by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an 8-byte signed integer to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an object to the text stream, by calling the
			 * `ToString` method on that object, followed by a line terminator.
			 */
			WriteLine(value: System.Object | undefined): void;

			/**
			 * Writes the text representation of a 4-byte floating-point value to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/** Writes a string to the text stream, followed by a line terminator. */
			WriteLine(value: string | undefined): void;

			/**
			 * Writes a formatted string and a new line to the text stream, using the same semantics
			 * as the {@link System.String.Format(System.String,System.Object)} method.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string and a new line to the text stream, using the same semantics
			 * as the {@link System.String.Format(System.String,System.Object,System.Object)} method.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): void;

			/**
			 * Writes out a formatted string and a new line to the text stream, using the same
			 * semantics as {@link System.String.Format(System.String,System.Object)}.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): void;

			/**
			 * Writes out a formatted string and a new line to the text stream, using the same
			 * semantics as {@link System.String.Format(System.String,System.Object)}.
			 */
			WriteLine(
				format: string,
				arg: System.Object | undefined[],
			): void;

			/**
			 * Writes the text representation of a 4-byte unsigned integer to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an 8-byte unsigned integer to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/** Asynchronously writes a line terminator to the text stream. */
			WriteLineAsync(): Promise<void>;

			/**
			 * Asynchronously writes an array of characters to the text stream, followed by a line
			 * terminator.
			 */
			WriteLineAsync(buffer: System.Char[] | undefined): Promise<void>;
		}
	}

	export namespace System.IO {
		/** Represents a reader that can read a sequential series of characters. */
		export class TextReader extends System.MarshalByRefObject implements IDisposable {
			/**
			 * Closes the {@link System.IO.TextReader} and releases any system resources associated
			 * with the `TextReader`.
			 */
			Close(): void;

			/** Releases all resources used by the {@link System.IO.TextReader} object. */
			dispose(): void;

			/**
			 * Reads the next character without changing the state of the reader or the character
			 * source. Returns the next available character without actually reading it from the
			 * reader.
			 */
			Peek(): number;

			/**
			 * Reads the next character from the text reader and advances the character position by
			 * one character.
			 */
			Read(): number;

			/**
			 * Reads a specified maximum number of characters from the current reader and writes the
			 * data to a buffer, beginning at the specified index.
			 */
			Read(
				buffer: System.Char[],
				index: number,
				count: number,
			): number;

			/**
			 * Reads the characters from the current reader and writes the data to the specified
			 * buffer.
			 */
			Read(buffer: System.Span$1<System.Char>): number;

			/**
			 * Reads a specified maximum number of characters from the current text reader
			 * asynchronously and writes the data to a buffer, beginning at the specified index.
			 */
			ReadAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<number>;

			/** Asynchronously reads the characters from the current stream into a memory block. */
			ReadAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<number>;

			/**
			 * Reads a specified maximum number of characters from the current text reader and writes
			 * the data to a buffer, beginning at the specified index.
			 */
			ReadBlock(
				buffer: System.Char[],
				index: number,
				count: number,
			): number;

			/** Reads the characters from the current stream and writes the data to a buffer. */
			ReadBlock(buffer: System.Span$1<System.Char>): number;

			/**
			 * Reads a specified maximum number of characters from the current text reader
			 * asynchronously and writes the data to a buffer, beginning at the specified index.
			 */
			ReadBlockAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<number>;

			/**
			 * Asynchronously reads the characters from the current stream and writes the data to a
			 * buffer.
			 */
			ReadBlockAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<number>;

			/** Reads a line of characters from the text reader and returns the data as a string. */
			ReadLine(): string | undefined;

			/** Reads a line of characters asynchronously and returns the data as a string. */
			ReadLineAsync(): Promise<string | undefined>;

			/** Reads a line of characters asynchronously and returns the data as a string. */
			ReadLineAsync(cancellationToken: AbortSignal): Promise<string | undefined>;

			/**
			 * Reads all characters from the current position to the end of the text reader and
			 * returns them as one string.
			 */
			ReadToEnd(): string;

			/**
			 * Reads all characters from the current position to the end of the text reader
			 * asynchronously and returns them as one string.
			 */
			ReadToEndAsync(): Promise<string>;

			/**
			 * Reads all characters from the current position to the end of the text reader
			 * asynchronously and returns them as one string.
			 */
			ReadToEndAsync(cancellationToken: AbortSignal): Promise<string>;

			/** Creates a thread-safe wrapper around the specified `TextReader`. */
			static Synchronized(reader: System.IO.TextReader): System.IO.TextReader;
		}
	}

	export namespace System.IO {
		/**
		 * Represents a writer that can write a sequential series of characters. This class is
		 * abstract.
		 */
		export class TextWriter extends System.MarshalByRefObject implements
			System.IAsyncDisposable,
			IDisposable {
			/**
			 * When overridden in a derived class, returns the character encoding in which the output
			 * is written.
			 */
			readonly Encoding: System.Text.Encoding;

			/** Gets an object that controls formatting. */
			readonly FormatProvider: System.IFormatProvider;

			/** Gets or sets the line terminator string used by the current `TextWriter`. */
			NewLine: string;

			/**
			 * Closes the current writer and releases any system resources associated with the
			 * writer.
			 */
			Close(): void;

			/** Releases all resources used by the {@link System.IO.TextWriter} object. */
			dispose(): void;

			/**
			 * Asynchronously releases all resources used by the {@link System.IO.TextWriter} object.
			 */
			DisposeAsync(): Promise<void>;

			/**
			 * Clears all buffers for the current writer and causes any buffered data to be written
			 * to the underlying device.
			 */
			Flush(): void;

			/**
			 * Asynchronously clears all buffers for the current writer and causes any buffered data
			 * to be written to the underlying device.
			 */
			FlushAsync(): Promise<void>;

			/**
			 * Asynchronously clears all buffers for the current writer and causes any buffered data
			 * to be written to the underlying device.
			 */
			FlushAsync(cancellationToken: AbortSignal): Promise<void>;

			/** Creates a thread-safe wrapper around the specified `TextWriter`. */
			static Synchronized(writer: System.IO.TextWriter): System.IO.TextWriter;

			/** Writes the text representation of a `Boolean` value to the text stream. */
			Write(value: boolean): void;

			/** Writes a character to the text stream. */
			Write(value: System.Char): void;

			/** Writes a character array to the text stream. */
			Write(buffer: System.Char[] | undefined): void;

			/** Writes a subarray of characters to the text stream. */
			Write(
				buffer: System.Char[],
				index: number,
				count: number,
			): void;

			/** Writes the text representation of a decimal value to the text stream. */
			Write(value: System.Decimal): void;

			/**
			 * Writes the text representation of an 8-byte floating-point value to the text stream.
			 */
			Write(value: number): void;

			/** Writes the text representation of a 4-byte signed integer to the text stream. */
			Write(value: number): void;

			/** Writes the text representation of an 8-byte signed integer to the text stream. */
			Write(value: number): void;

			/**
			 * Writes the text representation of an object to the text stream by calling the
			 * `ToString` method on that object.
			 */
			Write(value: System.Object | undefined): void;

			/** Writes a character span to the text stream. */
			Write(buffer: System.ReadOnlySpan$1<System.Char>): void;

			/**
			 * Writes the text representation of a 4-byte floating-point value to the text stream.
			 */
			Write(value: number): void;

			/** Writes a string to the text stream. */
			Write(value: string | undefined): void;

			/**
			 * Writes a formatted string to the text stream, using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object)} method.
			 */
			Write(
				format: string,
				arg0: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string to the text stream using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object,System.Object)} method.
			 */
			Write(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string to the text stream, using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object,System.Object,System.Object)}
			 * method.
			 */
			Write(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string to the text stream, using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object[])} method.
			 */
			Write(
				format: string,
				arg: System.Object | undefined[],
			): void;

			/** Writes a string builder to the text stream. */
			Write(value: System.Text.StringBuilder | undefined): void;

			/** Writes the text representation of a 4-byte unsigned integer to the text stream. */
			Write(value: number): void;

			/** Writes the text representation of an 8-byte unsigned integer to the text stream. */
			Write(value: number): void;

			/** Writes a character to the text stream asynchronously. */
			WriteAsync(value: System.Char): Promise<void>;

			/** Writes a character array to the text stream asynchronously. */
			WriteAsync(buffer: System.Char[] | undefined): Promise<void>;

			/** Writes a subarray of characters to the text stream asynchronously. */
			WriteAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<void>;

			/** Asynchronously writes a character memory region to the text stream. */
			WriteAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** Writes a string to the text stream asynchronously. */
			WriteAsync(value: string | undefined): Promise<void>;

			/** Asynchronously writes a string builder to the text stream. */
			WriteAsync(
				value: System.Text.StringBuilder | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** Writes a line terminator to the text stream. */
			WriteLine(): void;

			/**
			 * Writes the text representation of a `Boolean` value to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(value: boolean): void;

			/** Writes a character to the text stream, followed by a line terminator. */
			WriteLine(value: System.Char): void;

			/** Writes an array of characters to the text stream, followed by a line terminator. */
			WriteLine(buffer: System.Char[] | undefined): void;

			/** Writes a subarray of characters to the text stream, followed by a line terminator. */
			WriteLine(
				buffer: System.Char[],
				index: number,
				count: number,
			): void;

			/**
			 * Writes the text representation of a decimal value to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(value: System.Decimal): void;

			/**
			 * Writes the text representation of a 8-byte floating-point value to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of a 4-byte signed integer to the text stream, followed
			 * by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an 8-byte signed integer to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an object to the text stream, by calling the
			 * `ToString` method on that object, followed by a line terminator.
			 */
			WriteLine(value: System.Object | undefined): void;

			/**
			 * Writes the text representation of a character span to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(buffer: System.ReadOnlySpan$1<System.Char>): void;

			/**
			 * Writes the text representation of a 4-byte floating-point value to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/** Writes a string to the text stream, followed by a line terminator. */
			WriteLine(value: string | undefined): void;

			/**
			 * Writes a formatted string and a new line to the text stream, using the same semantics
			 * as the {@link System.String.Format(System.String,System.Object)} method.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
			): void;

			/**
			 * Writes a formatted string and a new line to the text stream, using the same semantics
			 * as the {@link System.String.Format(System.String,System.Object,System.Object)} method.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): void;

			/**
			 * Writes out a formatted string and a new line to the text stream, using the same
			 * semantics as {@link System.String.Format(System.String,System.Object)}.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): void;

			/**
			 * Writes out a formatted string and a new line to the text stream, using the same
			 * semantics as {@link System.String.Format(System.String,System.Object)}.
			 */
			WriteLine(
				format: string,
				arg: System.Object | undefined[],
			): void;

			/**
			 * Writes the text representation of a string builder to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(value: System.Text.StringBuilder | undefined): void;

			/**
			 * Writes the text representation of a 4-byte unsigned integer to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an 8-byte unsigned integer to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/** Asynchronously writes a line terminator to the text stream. */
			WriteLineAsync(): Promise<void>;

			/**
			 * Asynchronously writes a character to the text stream, followed by a line terminator.
			 */
			WriteLineAsync(value: System.Char): Promise<void>;

			/**
			 * Asynchronously writes an array of characters to the text stream, followed by a line
			 * terminator.
			 */
			WriteLineAsync(buffer: System.Char[] | undefined): Promise<void>;

			/**
			 * Asynchronously writes a subarray of characters to the text stream, followed by a line
			 * terminator.
			 */
			WriteLineAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<void>;

			/**
			 * Asynchronously writes the text representation of a character memory region to the text
			 * stream, followed by a line terminator.
			 */
			WriteLineAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** Asynchronously writes a string to the text stream, followed by a line terminator. */
			WriteLineAsync(value: string | undefined): Promise<void>;

			/**
			 * Asynchronously writes the text representation of a string builder to the text stream,
			 * followed by a line terminator.
			 */
			WriteLineAsync(
				value: System.Text.StringBuilder | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;
		}
	}

	export namespace System.IO {
		/**
		 * Represents the Unix filesystem permissions. This enumeration supports a bitwise
		 * combination of its member values.
		 */
		export enum UnixFileMode {
			/** No permissions. */
			None = 0,

			/** Execute permission for others. */
			OtherExecute = 1,

			/** Write permission for others. */
			OtherWrite = 2,

			/** Read permission for others. */
			OtherRead = 4,

			/** Execute permission for group. */
			GroupExecute = 8,

			/** Write permission for group. */
			GroupWrite = 16,

			/** Read permission for group. */
			GroupRead = 32,

			/** Execute permission for owner. */
			UserExecute = 64,

			/** Write permission for owner. */
			UserWrite = 128,

			/** Read permission for owner. */
			UserRead = 256,

			/** Sticky bit permission. */
			StickyBit = 512,

			/** Set group permission. */
			SetGroup = 1024,

			/** Set user permission. */
			SetUser = 2048,
		}
	}

	export namespace System.IO {
		/** Provides access to unmanaged blocks of memory from managed code. */
		export class UnmanagedMemoryStream extends Duplex {
		}
	}

	export namespace System.IO.Enumeration {
		/**
		 * Provides a lower level view of {@link System.IO.FileSystemInfo} to help process and
		 * filter find results.
		 */
		export class FileSystemEntry extends System.ValueType {
			/** Gets the attributes for this entry. */
			readonly Attributes: System.IO.FileAttributes;

			/**
			 * Gets the creation time for the entry or the oldest available time stamp if the
			 * operating system does not support creation time stamps.
			 */
			readonly CreationTimeUtc: js.DateTimeOffset;

			/** Gets the full path of the directory this entry resides in. */
			readonly Directory: System.ReadOnlySpan$1<System.Char>;

			/** Gets the file name for this entry. */
			readonly FileName: System.ReadOnlySpan$1<System.Char>;

			/** Gets a value that indicates whether this entry is a directory. */
			readonly IsDirectory: boolean;

			/** Gets a value that indicates whether the file has the hidden attribute. */
			readonly IsHidden: boolean;

			/** Gets a datetime offset that represents the last access time in UTC. */
			readonly LastAccessTimeUtc: js.DateTimeOffset;

			/** Gets a datetime offset that represents the last write time in UTC. */
			readonly LastWriteTimeUtc: js.DateTimeOffset;

			/** Gets the length of the file, in bytes. */
			readonly Length: number;

			/** Gets the root directory for the enumeration as specified in the constructor. */
			readonly OriginalRootDirectory: System.ReadOnlySpan$1<System.Char>;

			/** Gets the full path of the root directory used for the enumeration. */
			readonly RootDirectory: System.ReadOnlySpan$1<System.Char>;

			/** Converts the value of this instance to a {@link System.IO.FileSystemInfo}. */
			ToFileSystemInfo(): System.IO.FileSystemInfo;

			/** Returns the full path of the find result. */
			ToFullPath(): string;

			/** Returns the full path for the find results, based on the initially provided path. */
			ToSpecifiedFullPath(): string;
		}
	}

	export namespace System.IO.Enumeration {
		/**
		 * [Generic type factory] Allows utilizing custom filter predicates and transform
		 * delegates for enumeration purposes.
		 */
		export function FileSystemEnumerable$(TResult: IType): typeof FileSystemEnumerable$1<any>;

		/**
		 * Allows utilizing custom filter predicates and transform delegates for enumeration
		 * purposes.
		 */
		export class FileSystemEnumerable$1<TResult> {
			constructor(
				directory: string,
				transform: System.IO.Enumeration.FileSystemEnumerable.FindTransform$1<TResult>,
				options?: System.IO.EnumerationOptions,
			);

			/**
			 * Gets or sets the predicate that can be used to verify if the TResults should be
			 * included.
			 */
			ShouldIncludePredicate?: System.IO.Enumeration.FileSystemEnumerable.FindPredicate$1<TResult>;

			/**
			 * Gets or sets the predicate that can be used to verify if the TResults should be
			 * recursed.
			 */
			ShouldRecursePredicate?: System.IO.Enumeration.FileSystemEnumerable.FindPredicate$1<TResult>;

			/** Retrieves the enumerator for this type of result. */
			GetEnumerator(): System.Collections.Generic.IEnumerator$1<TResult>;
		}
	}

	export namespace System.IO.Enumeration.FileSystemEnumerable {
		export function FindPredicate$(TResult: IType): IType;

		export interface FindPredicate$1<TResult> { (entry: System.IO.Enumeration.FileSystemEntry): boolean; }
	}

	export namespace System.IO.Enumeration.FileSystemEnumerable {
		export function FindTransform$(TResult: IType): IType;

		export interface FindTransform$1<TResult> { (entry: System.IO.Enumeration.FileSystemEntry): TResult; }
	}

	export namespace System.IO.Enumeration {
		/**
		 * [Generic type factory] Enumerates the file system elements of the provided type that
		 * are being searched and filtered by a
		 * {@link System.IO.Enumeration.FileSystemEnumerable<>}.
		 */
		export function FileSystemEnumerator$(TResult: IType): typeof FileSystemEnumerator$1<any>;

		/**
		 * Enumerates the file system elements of the provided type that are being searched and
		 * filtered by a {@link System.IO.Enumeration.FileSystemEnumerable<>}.
		 */
		export class FileSystemEnumerator$1<TResult> extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements
			IDisposable {
			/** Encapsulates a find operation. */
			constructor(
				directory: string,
				options?: System.IO.EnumerationOptions,
			);

			/** Gets the currently visited element. */
			readonly Current: TResult;

			/**
			 * Releases the resources used by the current instance of the
			 * {@link System.IO.Enumeration.FileSystemEnumerator<>} class.
			 */
			dispose(): void;

			/**
			 * Advances the enumerator to the next item of the
			 * {@link System.IO.Enumeration.FileSystemEnumerator<>}.
			 */
			MoveNext(): boolean;

			/** Always throws {@link System.NotSupportedException}. */
			Reset(): void;
		}
	}

	export namespace System.IO.Enumeration {
		/** Provides methods for matching file system names. */
		export namespace FileSystemName {
			/**
			 * Verifies if the given expression matches the given name. Supports the following
			 * wildcards: '*' and '?'. The backslash character '\' escapes.
			 */
			export function MatchesSimpleExpression(
				expression: System.ReadOnlySpan$1<System.Char>,
				name: System.ReadOnlySpan$1<System.Char>,
				ignoreCase?: boolean,
			): boolean;

			/**
			 * Verifies if the given Win32 expression matches the given name. Supports the following
			 * wildcards: '*', '?', '&lt;', '&gt;', '"'. The backslash character '\' escapes.
			 */
			export function MatchesWin32Expression(
				expression: System.ReadOnlySpan$1<System.Char>,
				name: System.ReadOnlySpan$1<System.Char>,
				ignoreCase?: boolean,
			): boolean;

			/**
			 * Translates the given Win32 expression. Change '*' and '?' to '&lt;', '&gt;' and '"' to
			 * match Win32 behavior.
			 */
			export function TranslateWin32Expression(expression: string | undefined): string;
		}
	}

	export namespace System.Globalization {
		/** Represents time in divisions, such as weeks, months, and years. */
		export class Calendar implements System.ICloneable {
			/**
			 * Gets a value indicating whether the current calendar is solar-based, lunar-based, or a
			 * combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/** When overridden in a derived class, gets the list of eras in the current calendar. */
			readonly Eras: number[];

			/**
			 * Gets a value indicating whether this {@link System.Globalization.Calendar} object is
			 * read-only.
			 */
			readonly IsReadOnly: boolean;

			/**
			 * Gets the latest date and time supported by this {@link System.Globalization.Calendar}
			 * object.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the earliest date and time supported by this
			 * {@link System.Globalization.Calendar} object.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of days away from the
			 * specified {@link System.DateTime}.
			 */
			AddDays(
				time: js.DateTime,
				days: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of hours away from the
			 * specified {@link System.DateTime}.
			 */
			AddHours(
				time: js.DateTime,
				hours: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of milliseconds away
			 * from the specified {@link System.DateTime}.
			 */
			AddMilliseconds(
				time: js.DateTime,
				milliseconds: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of minutes away from
			 * the specified {@link System.DateTime}.
			 */
			AddMinutes(
				time: js.DateTime,
				minutes: number,
			): js.DateTime;

			/**
			 * When overridden in a derived class, returns a {@link System.DateTime} that is the
			 * specified number of months away from the specified {@link System.DateTime}.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of seconds away from
			 * the specified {@link System.DateTime}.
			 */
			AddSeconds(
				time: js.DateTime,
				seconds: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of weeks away from the
			 * specified {@link System.DateTime}.
			 */
			AddWeeks(
				time: js.DateTime,
				weeks: number,
			): js.DateTime;

			/**
			 * When overridden in a derived class, returns a {@link System.DateTime} that is the
			 * specified number of years away from the specified {@link System.DateTime}.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/**
			 * Creates a new object that is a copy of the current
			 * {@link System.Globalization.Calendar} object.
			 */
			Clone(): System.Object;

			/**
			 * When overridden in a derived class, returns the day of the month in the specified
			 * {@link System.DateTime}.
			 */
			GetDayOfMonth(time: js.DateTime): number;

			/**
			 * When overridden in a derived class, returns the day of the week in the specified
			 * {@link System.DateTime}.
			 */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/**
			 * When overridden in a derived class, returns the day of the year in the specified
			 * {@link System.DateTime}.
			 */
			GetDayOfYear(time: js.DateTime): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/**
			 * When overridden in a derived class, returns the number of days in the specified month,
			 * year, and era.
			 */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/**
			 * When overridden in a derived class, returns the number of days in the specified year
			 * and era.
			 */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/**
			 * When overridden in a derived class, returns the era of the specified
			 * {@link System.DateTime}.
			 */
			GetEra(time: js.DateTime): number;

			/** Returns the hours value in the specified {@link System.DateTime}. */
			GetHour(time: js.DateTime): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Calculates the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the milliseconds value in the specified {@link System.DateTime}. */
			GetMilliseconds(time: js.DateTime): number;

			/** Returns the minutes value in the specified {@link System.DateTime}. */
			GetMinute(time: js.DateTime): number;

			/**
			 * When overridden in a derived class, returns the month in the specified
			 * {@link System.DateTime}.
			 */
			GetMonth(time: js.DateTime): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/**
			 * When overridden in a derived class, returns the number of months in the specified year
			 * in the specified era.
			 */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/** Returns the seconds value in the specified {@link System.DateTime}. */
			GetSecond(time: js.DateTime): number;

			/**
			 * Returns the week of the year that includes the date in the specified
			 * {@link System.DateTime} value.
			 */
			GetWeekOfYear(
				time: js.DateTime,
				rule: System.Globalization.CalendarWeekRule,
				firstDayOfWeek: System.DayOfWeek,
			): number;

			/**
			 * When overridden in a derived class, returns the year in the specified
			 * {@link System.DateTime}.
			 */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * When overridden in a derived class, determines whether the specified date in the
			 * specified era is a leap day.
			 */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/**
			 * When overridden in a derived class, determines whether the specified month in the
			 * specified year in the specified era is a leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * When overridden in a derived class, determines whether the specified year in the
			 * specified era is a leap year.
			 */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a read-only version of the specified {@link System.Globalization.Calendar}
			 * object.
			 */
			static ReadOnly(calendar: System.Globalization.Calendar): System.Globalization.Calendar;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;

			/**
			 * When overridden in a derived class, returns a {@link System.DateTime} that is set to
			 * the specified date and time in the specified era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/**
			 * Converts the specified year to a four-digit year by using the
			 * {@link System.Globalization.Calendar.TwoDigitYearMax} property to determine the
			 * appropriate century.
			 */
			ToFourDigitYear(year: number): number;
		}
	}

	export namespace System.Globalization {
		/** Specifies whether a calendar is solar-based, lunar-based, or lunisolar-based. */
		export enum CalendarAlgorithmType {
			/** An unknown calendar basis. */
			Unknown = 0,

			/** A solar-based calendar. */
			SolarCalendar = 1,

			/** A lunar-based calendar. */
			LunarCalendar = 2,

			/** A lunisolar-based calendar. */
			LunisolarCalendar = 3,
		}
	}

	export namespace System.Globalization {
		/** Defines different rules for determining the first week of the year. */
		export enum CalendarWeekRule {
			/**
			 * Indicates that the first week of the year starts on the first day of the year and ends
			 * before the following designated first day of the week. The value is 0.
			 */
			FirstDay = 0,

			/**
			 * Indicates that the first week of the year begins on the first occurrence of the
			 * designated first day of the week on or after the first day of the year. The value is
			 * 1.
			 */
			FirstFullWeek = 1,

			/**
			 * Indicates that the first week of the year is the first week with four or more days
			 * before the designated first day of the week. The value is 2.
			 */
			FirstFourDayWeek = 2,
		}
	}

	export namespace System.Globalization {
		/** Retrieves information about a Unicode character. This class cannot be inherited. */
		export namespace CharUnicodeInfo {
			/** Gets the decimal digit value of the specified numeric character. */
			export function GetDecimalDigitValue(ch: System.Char): number;

			/**
			 * Gets the decimal digit value of the numeric character at the specified index of the
			 * specified string.
			 */
			export function GetDecimalDigitValue(
				s: string,
				index: number,
			): number;

			/** Gets the digit value of the specified numeric character. */
			export function GetDigitValue(ch: System.Char): number;

			/**
			 * Gets the digit value of the numeric character at the specified index of the specified
			 * string.
			 */
			export function GetDigitValue(
				s: string,
				index: number,
			): number;

			/** Gets the numeric value associated with the specified character. */
			export function GetNumericValue(ch: System.Char): number;

			/**
			 * Gets the numeric value associated with the character at the specified index of the
			 * specified string.
			 */
			export function GetNumericValue(
				s: string,
				index: number,
			): number;

			/** Gets the Unicode category of the specified character. */
			export function GetUnicodeCategory(ch: System.Char): System.Globalization.UnicodeCategory;

			/** Gets the Unicode category of the specified character. */
			export function GetUnicodeCategory(codePoint: number): System.Globalization.UnicodeCategory;

			/**
			 * Gets the Unicode category of the character at the specified index of the specified
			 * string.
			 */
			export function GetUnicodeCategory(
				s: string,
				index: number,
			): System.Globalization.UnicodeCategory;
		}
	}

	export namespace System.Globalization {
		/**
		 * Represents time in divisions, such as months, days, and years. Years are calculated
		 * using the Chinese calendar, while days and months are calculated using the lunisolar
		 * calendar.
		 */
		export class ChineseLunisolarCalendar extends System.Globalization.EastAsianLunisolarCalendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the
			 * {@link System.Globalization.ChineseLunisolarCalendar} class.
			 */
			constructor();

			/**
			 * Gets the eras that correspond to the range of dates and times supported by the current
			 * {@link System.Globalization.ChineseLunisolarCalendar} object.
			 */
			readonly Eras: number[];

			/**
			 * Gets the maximum date and time supported by the
			 * {@link System.Globalization.ChineseLunisolarCalendar} class.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the minimum date and time supported by the
			 * {@link System.Globalization.ChineseLunisolarCalendar} class.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/** Retrieves the era that corresponds to the specified {@link System.DateTime} type. */
			GetEra(time: js.DateTime): number;
		}
	}

	export namespace System.Globalization {
		/** Implements a set of methods for culture-sensitive string comparisons. */
		export class CompareInfo {
			/**
			 * Gets the properly formed culture identifier for the current
			 * {@link System.Globalization.CompareInfo}.
			 */
			readonly LCID: number;

			/**
			 * Gets the name of the culture used for sorting operations by this
			 * {@link System.Globalization.CompareInfo} object.
			 */
			readonly Name: string;

			/**
			 * Gets information about the version of Unicode used for comparing and sorting strings.
			 */
			readonly Version: System.Globalization.SortVersion;

			/** Compares two read-only spans of characters. */
			Compare(
				string1: System.ReadOnlySpan$1<System.Char>,
				string2: System.ReadOnlySpan$1<System.Char>,
				options?: System.Globalization.CompareOptions,
			): number;

			/** Compares a section of one string with a section of another string. */
			Compare(
				string1: string | undefined,
				offset1: number,
				length1: number,
				string2: string | undefined,
				offset2: number,
				length2: number,
			): number;

			/**
			 * Compares a section of one string with a section of another string using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			Compare(
				string1: string | undefined,
				offset1: number,
				length1: number,
				string2: string | undefined,
				offset2: number,
				length2: number,
				options: System.Globalization.CompareOptions,
			): number;

			/** Compares the end section of a string with the end section of another string. */
			Compare(
				string1: string | undefined,
				offset1: number,
				string2: string | undefined,
				offset2: number,
			): number;

			/**
			 * Compares the end section of a string with the end section of another string using the
			 * specified {@link System.Globalization.CompareOptions} value.
			 */
			Compare(
				string1: string | undefined,
				offset1: number,
				string2: string | undefined,
				offset2: number,
				options: System.Globalization.CompareOptions,
			): number;

			/** Compares two strings. */
			Compare(
				string1: string | undefined,
				string2: string | undefined,
			): number;

			/**
			 * Compares two strings using the specified {@link System.Globalization.CompareOptions}
			 * value.
			 */
			Compare(
				string1: string | undefined,
				string2: string | undefined,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Determines whether the specified object is equal to the current
			 * {@link System.Globalization.CompareInfo} object.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Initializes a new {@link System.Globalization.CompareInfo} object that is associated
			 * with the culture with the specified identifier.
			 */
			static GetCompareInfo(culture: number): System.Globalization.CompareInfo;

			/**
			 * Initializes a new {@link System.Globalization.CompareInfo} object that is associated
			 * with the specified culture and that uses string comparison methods in the specified
			 * {@link System.Reflection.Assembly}.
			 */
			static GetCompareInfo(
				culture: number,
				assembly: System.Reflection.Assembly,
			): System.Globalization.CompareInfo;

			/**
			 * Initializes a new {@link System.Globalization.CompareInfo} object that is associated
			 * with the culture with the specified name.
			 */
			static GetCompareInfo(name: string): System.Globalization.CompareInfo;

			/**
			 * Initializes a new {@link System.Globalization.CompareInfo} object that is associated
			 * with the specified culture and that uses string comparison methods in the specified
			 * {@link System.Reflection.Assembly}.
			 */
			static GetCompareInfo(
				name: string,
				assembly: System.Reflection.Assembly,
			): System.Globalization.CompareInfo;

			/**
			 * Serves as a hash function for the current {@link System.Globalization.CompareInfo} for
			 * hashing algorithms and data structures, such as a hash table.
			 */
			GetHashCode(): number;

			/** Gets the hash code for a character span based on specified comparison options. */
			GetHashCode(
				source: System.ReadOnlySpan$1<System.Char>,
				options: System.Globalization.CompareOptions,
			): number;

			/** Gets the hash code for a string based on specified comparison options. */
			GetHashCode(
				source: string,
				options: System.Globalization.CompareOptions,
			): number;

			/** Computes a sort key for the specified input. */
			GetSortKey(
				source: System.ReadOnlySpan$1<System.Char>,
				destination: System.Span$1<number>,
				options?: System.Globalization.CompareOptions,
			): number;

			/** Gets the sort key for the specified string. */
			GetSortKey(source: string): System.Globalization.SortKey;

			/**
			 * Gets a {@link System.Globalization.SortKey} object for the specified string using the
			 * specified {@link System.Globalization.CompareOptions} value.
			 */
			GetSortKey(
				source: string,
				options: System.Globalization.CompareOptions,
			): System.Globalization.SortKey;

			/**
			 * Gets the total number of sort key bytes that would be produced from the specified
			 * input.
			 */
			GetSortKeyLength(
				source: System.ReadOnlySpan$1<System.Char>,
				options?: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the first occurrence of a substring within the specified read-only span
			 * of characters.
			 */
			IndexOf(
				source: System.ReadOnlySpan$1<System.Char>,
				value: System.ReadOnlySpan$1<System.Char>,
				options?: System.Globalization.CompareOptions,
			): number;

			IndexOf(
				source: System.ReadOnlySpan$1<System.Char>,
				value: System.ReadOnlySpan$1<System.Char>,
				options: System.Globalization.CompareOptions,
			): { result: number, matchLength: number };

			/**
			 * Searches for the first occurrence of a {@link System.Text.Rune} within the specified
			 * read-only span of characters.
			 */
			IndexOf(
				source: System.ReadOnlySpan$1<System.Char>,
				value: System.Text.Rune,
				options?: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the first
			 * occurrence within the entire source string.
			 */
			IndexOf(
				source: string,
				value: System.Char,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the first
			 * occurrence within the entire source string using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			IndexOf(
				source: string,
				value: System.Char,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the first
			 * occurrence within the section of the source string that extends from the specified
			 * index to the end of the string.
			 */
			IndexOf(
				source: string,
				value: System.Char,
				startIndex: number,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the first
			 * occurrence within the section of the source string that extends from the specified
			 * index to the end of the string using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			IndexOf(
				source: string,
				value: System.Char,
				startIndex: number,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the first
			 * occurrence within the section of the source string that starts at the specified index
			 * and contains the specified number of elements.
			 */
			IndexOf(
				source: string,
				value: System.Char,
				startIndex: number,
				count: number,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the first
			 * occurrence within the section of the source string that starts at the specified index
			 * and contains the specified number of elements using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			IndexOf(
				source: string,
				value: System.Char,
				startIndex: number,
				count: number,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the first
			 * occurrence within the entire source string.
			 */
			IndexOf(
				source: string,
				value: string,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the first
			 * occurrence within the entire source string using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			IndexOf(
				source: string,
				value: string,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the first
			 * occurrence within the section of the source string that extends from the specified
			 * index to the end of the string.
			 */
			IndexOf(
				source: string,
				value: string,
				startIndex: number,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the first
			 * occurrence within the section of the source string that extends from the specified
			 * index to the end of the string using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			IndexOf(
				source: string,
				value: string,
				startIndex: number,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the first
			 * occurrence within the section of the source string that starts at the specified index
			 * and contains the specified number of elements.
			 */
			IndexOf(
				source: string,
				value: string,
				startIndex: number,
				count: number,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the first
			 * occurrence within the section of the source string that starts at the specified index
			 * and contains the specified number of elements using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			IndexOf(
				source: string,
				value: string,
				startIndex: number,
				count: number,
				options: System.Globalization.CompareOptions,
			): number;

			/** Determines whether a read-only span of characters starts with a specific prefix. */
			IsPrefix(
				source: System.ReadOnlySpan$1<System.Char>,
				prefix: System.ReadOnlySpan$1<System.Char>,
				options?: System.Globalization.CompareOptions,
			): boolean;

			IsPrefix(
				source: System.ReadOnlySpan$1<System.Char>,
				prefix: System.ReadOnlySpan$1<System.Char>,
				options: System.Globalization.CompareOptions,
			): { result: boolean, matchLength: number };

			/** Determines whether the specified source string starts with the specified prefix. */
			IsPrefix(
				source: string,
				prefix: string,
			): boolean;

			/**
			 * Determines whether the specified source string starts with the specified prefix using
			 * the specified {@link System.Globalization.CompareOptions} value.
			 */
			IsPrefix(
				source: string,
				prefix: string,
				options: System.Globalization.CompareOptions,
			): boolean;

			/** Indicates whether a specified Unicode character is sortable. */
			static IsSortable(ch: System.Char): boolean;

			/** Indicates whether a specified Unicode read-only span of characters is sortable. */
			static IsSortable(text: System.ReadOnlySpan$1<System.Char>): boolean;

			/** Indicates whether a specified Unicode string is sortable. */
			static IsSortable(text: string): boolean;

			/** Indicates whether a specified {@link System.Text.Rune} is sortable. */
			static IsSortable(value: System.Text.Rune): boolean;

			/** Determines whether a read-only span of characters ends with a specific suffix. */
			IsSuffix(
				source: System.ReadOnlySpan$1<System.Char>,
				suffix: System.ReadOnlySpan$1<System.Char>,
				options?: System.Globalization.CompareOptions,
			): boolean;

			IsSuffix(
				source: System.ReadOnlySpan$1<System.Char>,
				suffix: System.ReadOnlySpan$1<System.Char>,
				options: System.Globalization.CompareOptions,
			): { result: boolean, matchLength: number };

			/** Determines whether the specified source string ends with the specified suffix. */
			IsSuffix(
				source: string,
				suffix: string,
			): boolean;

			/**
			 * Determines whether the specified source string ends with the specified suffix using
			 * the specified {@link System.Globalization.CompareOptions} value.
			 */
			IsSuffix(
				source: string,
				suffix: string,
				options: System.Globalization.CompareOptions,
			): boolean;

			/**
			 * Searches for the last occurrence of a substring within the specified read-only span of
			 * characters.
			 */
			LastIndexOf(
				source: System.ReadOnlySpan$1<System.Char>,
				value: System.ReadOnlySpan$1<System.Char>,
				options?: System.Globalization.CompareOptions,
			): number;

			LastIndexOf(
				source: System.ReadOnlySpan$1<System.Char>,
				value: System.ReadOnlySpan$1<System.Char>,
				options: System.Globalization.CompareOptions,
			): { result: number, matchLength: number };

			/**
			 * Searches for the last occurrence of a {@link System.Text.Rune} within the specified
			 * read-only span of characters.
			 */
			LastIndexOf(
				source: System.ReadOnlySpan$1<System.Char>,
				value: System.Text.Rune,
				options?: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the last
			 * occurrence within the entire source string.
			 */
			LastIndexOf(
				source: string,
				value: System.Char,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the last
			 * occurrence within the entire source string using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			LastIndexOf(
				source: string,
				value: System.Char,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the last
			 * occurrence within the section of the source string that extends from the beginning of
			 * the string to the specified index.
			 */
			LastIndexOf(
				source: string,
				value: System.Char,
				startIndex: number,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the last
			 * occurrence within the section of the source string that extends from the beginning of
			 * the string to the specified index using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			LastIndexOf(
				source: string,
				value: System.Char,
				startIndex: number,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the last
			 * occurrence within the section of the source string that contains the specified number
			 * of elements and ends at the specified index.
			 */
			LastIndexOf(
				source: string,
				value: System.Char,
				startIndex: number,
				count: number,
			): number;

			/**
			 * Searches for the specified character and returns the zero-based index of the last
			 * occurrence within the section of the source string that contains the specified number
			 * of elements and ends at the specified index using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			LastIndexOf(
				source: string,
				value: System.Char,
				startIndex: number,
				count: number,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the last
			 * occurrence within the entire source string.
			 */
			LastIndexOf(
				source: string,
				value: string,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the last
			 * occurrence within the entire source string using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			LastIndexOf(
				source: string,
				value: string,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the last
			 * occurrence within the section of the source string that extends from the beginning of
			 * the string to the specified index.
			 */
			LastIndexOf(
				source: string,
				value: string,
				startIndex: number,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the last
			 * occurrence within the section of the source string that extends from the beginning of
			 * the string to the specified index using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			LastIndexOf(
				source: string,
				value: string,
				startIndex: number,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the last
			 * occurrence within the section of the source string that contains the specified number
			 * of elements and ends at the specified index.
			 */
			LastIndexOf(
				source: string,
				value: string,
				startIndex: number,
				count: number,
			): number;

			/**
			 * Searches for the specified substring and returns the zero-based index of the last
			 * occurrence within the section of the source string that contains the specified number
			 * of elements and ends at the specified index using the specified
			 * {@link System.Globalization.CompareOptions} value.
			 */
			LastIndexOf(
				source: string,
				value: string,
				startIndex: number,
				count: number,
				options: System.Globalization.CompareOptions,
			): number;

			/**
			 * Returns a string that represents the current {@link System.Globalization.CompareInfo}
			 * object.
			 */
			ToString(): string;
		}
	}

	export namespace System.Globalization {
		/**
		 * Defines the string comparison options to use with
		 * {@link System.Globalization.CompareInfo}.
		 */
		export enum CompareOptions {
			/** Indicates the default option settings for string comparisons. */
			None = 0,

			/** Indicates that the string comparison must ignore case. */
			IgnoreCase = 1,

			/**
			 * Indicates that the string comparison must ignore nonspacing combining characters, such
			 * as diacritics. The Unicode Standard defines combining characters as characters that
			 * are combined with base characters to produce a new character. Nonspacing combining
			 * characters do not occupy a spacing position by themselves when rendered.
			 */
			IgnoreNonSpace = 2,

			/**
			 * Indicates that the string comparison must ignore symbols, such as white-space
			 * characters, punctuation, currency symbols, the percent sign, mathematical symbols, the
			 * ampersand, and so on.
			 */
			IgnoreSymbols = 4,

			/**
			 * Indicates that the string comparison must ignore the Kana type. Kana type refers to
			 * Japanese hiragana and katakana characters, which represent phonetic sounds in the
			 * Japanese language. Hiragana is used for native Japanese expressions and words, while
			 * katakana is used for words borrowed from other languages, such as "computer" or
			 * "Internet". A phonetic sound can be expressed in both hiragana and katakana. If this
			 * value is selected, the hiragana character for one sound is considered equal to the
			 * katakana character for the same sound.
			 */
			IgnoreKanaType = 8,

			/**
			 * Indicates that the string comparison must ignore the character width. For example,
			 * Japanese katakana characters can be written as full-width or half-width. If this value
			 * is selected, the katakana characters written as full-width are considered equal to the
			 * same characters written as half-width.
			 */
			IgnoreWidth = 16,

			/**
			 * String comparison must ignore case, then perform an ordinal comparison. This technique
			 * is equivalent to converting the string to uppercase using the invariant culture and
			 * then performing an ordinal comparison on the result.
			 */
			OrdinalIgnoreCase = 268435456,

			/**
			 * Indicates that the string comparison must use the string sort algorithm. In a string
			 * sort, the hyphen and the apostrophe, as well as other nonalphanumeric symbols, come
			 * before alphanumeric characters.
			 */
			StringSort = 536870912,

			/**
			 * Indicates that the string comparison must use successive Unicode UTF-16 encoded values
			 * of the string (code unit by code unit comparison), leading to a fast comparison but
			 * one that is culture-insensitive. A string starting with a code unit XXXX16 comes
			 * before a string starting with YYYY16, if XXXX16 is less than YYYY16. This value cannot
			 * be combined with other {@link System.Globalization.CompareOptions} values and must be
			 * used alone.
			 */
			Ordinal = 1073741824,
		}
	}

	export namespace System.Globalization {
		/**
		 * Provides information about a specific culture (called a locale for unmanaged code
		 * development). The information includes the names for the culture, the writing system,
		 * the calendar used, the sort order of strings, and formatting for dates and numbers.
		 */
		export class CultureInfo implements
			System.ICloneable,
			System.IFormatProvider {
			/**
			 * Initializes a new instance of the {@link System.Globalization.CultureInfo} class based
			 * on the culture specified by the culture identifier.
			 */
			constructor(culture: number);

			/**
			 * Initializes a new instance of the {@link System.Globalization.CultureInfo} class based
			 * on the culture specified by the culture identifier and on a value that specifies
			 * whether to use the user-selected culture settings from Windows.
			 */
			constructor(
				culture: number,
				useUserOverride: boolean,
			);

			/**
			 * Initializes a new instance of the {@link System.Globalization.CultureInfo} class based
			 * on the culture specified by name.
			 */
			constructor(name: string);

			/**
			 * Initializes a new instance of the {@link System.Globalization.CultureInfo} class based
			 * on the culture specified by name and on a value that specifies whether to use the
			 * user-selected culture settings from Windows.
			 */
			constructor(
				name: string,
				useUserOverride: boolean,
			);

			/** Gets the default calendar used by the culture. */
			readonly Calendar: System.Globalization.Calendar;

			/**
			 * Gets the {@link System.Globalization.CompareInfo} that defines how to compare strings
			 * for the culture.
			 */
			readonly CompareInfo: System.Globalization.CompareInfo;

			/**
			 * Gets the culture types that pertain to the current
			 * {@link System.Globalization.CultureInfo} object.
			 */
			readonly CultureTypes: System.Globalization.CultureTypes;

			/**
			 * Gets or sets the {@link System.Globalization.CultureInfo} object that represents the
			 * culture used by the current thread and task-based asynchronous operations.
			 */
			static CurrentCulture: System.Globalization.CultureInfo;

			/**
			 * Gets or sets the {@link System.Globalization.CultureInfo} object that represents the
			 * current user interface culture used by the Resource Manager to look up
			 * culture-specific resources at run time.
			 */
			static CurrentUICulture: System.Globalization.CultureInfo;

			/**
			 * Gets or sets a {@link System.Globalization.DateTimeFormatInfo} that defines the
			 * culturally appropriate format of displaying dates and times.
			 */
			DateTimeFormat: System.Globalization.DateTimeFormatInfo;

			/** Gets or sets the default culture for threads in the current application domain. */
			static DefaultThreadCurrentCulture?: System.Globalization.CultureInfo;

			/** Gets or sets the default UI culture for threads in the current application domain. */
			static DefaultThreadCurrentUICulture?: System.Globalization.CultureInfo;

			/** Gets the full localized culture name. */
			readonly DisplayName: string;

			/** Gets the culture name in the format languagefull [country/regionfull] in English. */
			readonly EnglishName: string;

			/** Deprecated. Gets the RFC 4646 standard identification for a language. */
			readonly IetfLanguageTag: string;

			/**
			 * Gets the {@link System.Globalization.CultureInfo} that represents the culture
			 * installed with the operating system.
			 */
			static readonly InstalledUICulture: System.Globalization.CultureInfo;

			/**
			 * Gets the {@link System.Globalization.CultureInfo} object that is culture-independent
			 * (invariant).
			 */
			static readonly InvariantCulture: System.Globalization.CultureInfo;

			/**
			 * Gets a value indicating whether the current {@link System.Globalization.CultureInfo}
			 * represents a neutral culture.
			 */
			readonly IsNeutralCulture: boolean;

			/**
			 * Gets a value indicating whether the current {@link System.Globalization.CultureInfo}
			 * is read-only.
			 */
			readonly IsReadOnly: boolean;

			/** Gets the active input locale identifier. */
			readonly KeyboardLayoutId: number;

			/**
			 * Gets the culture identifier for the current {@link System.Globalization.CultureInfo}.
			 */
			readonly LCID: number;

			/** Gets the culture name in the format languagecode2-country/regioncode2. */
			readonly Name: string;

			/**
			 * Gets the culture name, consisting of the language, the country/region, and the
			 * optional script, that the culture is set to display.
			 */
			readonly NativeName: string;

			/**
			 * Gets or sets a {@link System.Globalization.NumberFormatInfo} that defines the
			 * culturally appropriate format of displaying numbers, currency, and percentage.
			 */
			NumberFormat: System.Globalization.NumberFormatInfo;

			/** Gets the list of calendars that can be used by the culture. */
			readonly OptionalCalendars: System.Globalization.Calendar[];

			/**
			 * Gets the {@link System.Globalization.CultureInfo} that represents the parent culture
			 * of the current {@link System.Globalization.CultureInfo}.
			 */
			readonly Parent: System.Globalization.CultureInfo;

			/**
			 * Gets the {@link System.Globalization.TextInfo} that defines the writing system
			 * associated with the culture.
			 */
			readonly TextInfo: System.Globalization.TextInfo;

			/**
			 * Gets the ISO 639-2 three-letter code for the language of the current
			 * {@link System.Globalization.CultureInfo}.
			 */
			readonly ThreeLetterISOLanguageName: string;

			/** Gets the three-letter code for the language as defined in the Windows API. */
			readonly ThreeLetterWindowsLanguageName: string;

			/**
			 * Gets the ISO 639-1 two-letter or ISO 639-3 three-letter code for the language of the
			 * current {@link System.Globalization.CultureInfo}.
			 */
			readonly TwoLetterISOLanguageName: string;

			/**
			 * Gets a value indicating whether the current {@link System.Globalization.CultureInfo}
			 * object uses the user-selected culture settings.
			 */
			readonly UseUserOverride: boolean;

			/** Refreshes cached culture-related information. */
			ClearCachedData(): void;

			/** Creates a copy of the current {@link System.Globalization.CultureInfo}. */
			Clone(): System.Object;

			/**
			 * Creates a {@link System.Globalization.CultureInfo} that represents the specific
			 * culture that is associated with the specified name.
			 */
			static CreateSpecificCulture(name: string): System.Globalization.CultureInfo;

			/**
			 * Determines whether the specified object is the same culture as the current
			 * {@link System.Globalization.CultureInfo}.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Gets an alternate user interface culture suitable for console applications when the
			 * default graphic user interface culture is unsuitable.
			 */
			GetConsoleFallbackUICulture(): System.Globalization.CultureInfo;

			/**
			 * Retrieves a cached, read-only instance of a culture by using the specified culture
			 * identifier.
			 */
			static GetCultureInfo(culture: number): System.Globalization.CultureInfo;

			/**
			 * Retrieves a cached, read-only instance of a culture using the specified culture name.
			 */
			static GetCultureInfo(name: string): System.Globalization.CultureInfo;

			/** Retrieves a cached, read-only instance of a culture. */
			static GetCultureInfo(
				name: string,
				predefinedOnly: boolean,
			): System.Globalization.CultureInfo;

			/**
			 * Retrieves a cached, read-only instance of a culture. Parameters specify a culture that
			 * is initialized with the {@link System.Globalization.TextInfo} and
			 * {@link System.Globalization.CompareInfo} objects specified by another culture.
			 */
			static GetCultureInfo(
				name: string,
				altName: string,
			): System.Globalization.CultureInfo;

			/**
			 * Deprecated. Retrieves a read-only {@link System.Globalization.CultureInfo} object
			 * having linguistic characteristics that are identified by the specified RFC 4646
			 * language tag.
			 */
			static GetCultureInfoByIetfLanguageTag(name: string): System.Globalization.CultureInfo;

			/**
			 * Gets the list of supported cultures filtered by the specified
			 * {@link System.Globalization.CultureTypes} parameter.
			 */
			static GetCultures(types: System.Globalization.CultureTypes): System.Globalization.CultureInfo[];

			/** Gets an object that defines how to format the specified type. */
			GetFormat(formatType: System.Type | undefined): System.Object | undefined;

			/**
			 * Serves as a hash function for the current {@link System.Globalization.CultureInfo},
			 * suitable for hashing algorithms and data structures, such as a hash table.
			 */
			GetHashCode(): number;

			/**
			 * Returns a read-only wrapper around the specified
			 * {@link System.Globalization.CultureInfo} object.
			 */
			static ReadOnly(ci: System.Globalization.CultureInfo): System.Globalization.CultureInfo;

			/**
			 * Returns a string containing the name of the current
			 * {@link System.Globalization.CultureInfo} in the format
			 * languagecode2-country/regioncode2.
			 */
			ToString(): string;
		}
	}

	export namespace System.Globalization {
		/**
		 * The exception that is thrown when a method attempts to construct a culture that is not
		 * available.
		 */
		export class CultureNotFoundException extends System.ArgumentException {
			/**
			 * Initializes a new instance of the
			 * {@link System.Globalization.CultureNotFoundException} class with its message string
			 * set to a system-supplied message.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Globalization.CultureNotFoundException} class with the specified error
			 * message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Globalization.CultureNotFoundException} class with a specified error
			 * message and a reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Globalization.CultureNotFoundException} class with a specified error
			 * message, the invalid Culture ID, and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				invalidCultureId: number,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Globalization.CultureNotFoundException} class with a specified error
			 * message, the invalid Culture ID, and the name of the parameter that is the cause this
			 * exception.
			 */
			constructor(
				paramName: string | undefined,
				invalidCultureId: number,
				message: string | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Globalization.CultureNotFoundException} class with a specified error
			 * message and the name of the parameter that is the cause this exception.
			 */
			constructor(
				paramName: string | undefined,
				message: string | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Globalization.CultureNotFoundException} class with a specified error
			 * message, the invalid Culture Name, and a reference to the inner exception that is the
			 * cause of this exception.
			 */
			constructor(
				message: string | undefined,
				invalidCultureName: string | undefined,
				innerException: System.Exception | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Globalization.CultureNotFoundException} class with a specified error
			 * message, the invalid Culture Name, and the name of the parameter that is the cause
			 * this exception.
			 */
			constructor(
				paramName: string | undefined,
				invalidCultureName: string | undefined,
				message: string | undefined,
			);

			/** Gets the culture identifier that cannot be found. */
			readonly InvalidCultureId?: number;

			/** Gets the culture name that cannot be found. */
			readonly InvalidCultureName?: string;

			/** Gets the error message that explains the reason for the exception. */
			readonly Message: string;
		}
	}

	export namespace System.Globalization {
		/**
		 * Defines the types of culture lists that can be retrieved using the
		 * {@link System.Globalization.CultureInfo.GetCultures(System.Globalization.CultureTypes)}
		 * method.
		 */
		export enum CultureTypes {
			/**
			 * Cultures that are associated with a language but are not specific to a country/region.
			 */
			NeutralCultures = 1,

			/** Cultures that are specific to a country/region. */
			SpecificCultures = 2,

			/**
			 * This member is deprecated. All cultures that are installed in the Windows operating
			 * system.
			 */
			InstalledWin32Cultures = 4,

			/**
			 * All cultures that are recognized by .NET, including neutral and specific cultures and
			 * custom cultures created by the user.  On .NET Framework 4 and later versions and .NET
			 * Core running on Windows, it includes the culture data available from the Windows
			 * operating system. On .NET Core running on Linux and macOS, it includes culture data
			 * defined in the ICU libraries. {@link System.Globalization.CultureTypes.AllCultures} is
			 * a composite field that includes the
			 * {@link System.Globalization.CultureTypes.NeutralCultures},
			 * {@link System.Globalization.CultureTypes.SpecificCultures}, and
			 * {@link System.Globalization.CultureTypes.InstalledWin32Cultures} values.
			 */
			AllCultures = 7,

			/** This member is deprecated. Custom cultures created by the user. */
			UserCustomCulture = 8,

			/**
			 * This member is deprecated. Custom cultures created by the user that replace cultures
			 * shipped with the .NET Framework.
			 */
			ReplacementCultures = 16,

			/** This member is deprecated and is ignored. */
			WindowsOnlyCultures = 32,

			/**
			 * This member is deprecated; using this value with
			 * {@link System.Globalization.CultureInfo.GetCultures(System.Globalization.CultureTypes)}
			 * returns neutral and specific cultures shipped with the .NET Framework 2.0.
			 */
			FrameworkCultures = 64,
		}
	}

	export namespace System.Globalization {
		/** Provides culture-specific information about the format of date and time values. */
		export class DateTimeFormatInfo implements
			System.ICloneable,
			System.IFormatProvider {
			/**
			 * Initializes a new writable instance of the
			 * {@link System.Globalization.DateTimeFormatInfo} class that is culture-independent
			 * (invariant).
			 */
			constructor();

			/**
			 * Gets or sets a one-dimensional array of type {@link System.String} containing the
			 * culture-specific abbreviated names of the days of the week.
			 */
			AbbreviatedDayNames: string[];

			/**
			 * Gets or sets a string array of abbreviated month names associated with the current
			 * {@link System.Globalization.DateTimeFormatInfo} object.
			 */
			AbbreviatedMonthGenitiveNames: string[];

			/**
			 * Gets or sets a one-dimensional string array that contains the culture-specific
			 * abbreviated names of the months.
			 */
			AbbreviatedMonthNames: string[];

			/**
			 * Gets or sets the string designator for hours that are "ante meridiem" (before noon).
			 */
			AMDesignator: string;

			/** Gets or sets the calendar to use for the current culture. */
			Calendar: System.Globalization.Calendar;

			/**
			 * Gets or sets a value that specifies which rule is used to determine the first calendar
			 * week of the year.
			 */
			CalendarWeekRule: System.Globalization.CalendarWeekRule;

			/**
			 * Gets a read-only {@link System.Globalization.DateTimeFormatInfo} object that formats
			 * values based on the current culture.
			 */
			static readonly CurrentInfo: System.Globalization.DateTimeFormatInfo;

			/**
			 * Gets or sets the string that separates the components of a date, that is, the year,
			 * month, and day.
			 */
			DateSeparator: string;

			/**
			 * Gets or sets a one-dimensional string array that contains the culture-specific full
			 * names of the days of the week.
			 */
			DayNames: string[];

			/** Gets or sets the first day of the week. */
			FirstDayOfWeek: System.DayOfWeek;

			/** Gets or sets the custom format string for a long date and long time value. */
			FullDateTimePattern: string;

			/**
			 * Gets the default read-only {@link System.Globalization.DateTimeFormatInfo} object that
			 * is culture-independent (invariant).
			 */
			static readonly InvariantInfo: System.Globalization.DateTimeFormatInfo;

			/**
			 * Gets a value indicating whether the {@link System.Globalization.DateTimeFormatInfo}
			 * object is read-only.
			 */
			readonly IsReadOnly: boolean;

			/** Gets or sets the custom format string for a long date value. */
			LongDatePattern: string;

			/** Gets or sets the custom format string for a long time value. */
			LongTimePattern: string;

			/** Gets or sets the custom format string for a month and day value. */
			MonthDayPattern: string;

			/**
			 * Gets or sets a string array of month names associated with the current
			 * {@link System.Globalization.DateTimeFormatInfo} object.
			 */
			MonthGenitiveNames: string[];

			/**
			 * Gets or sets a one-dimensional array of type {@link System.String} containing the
			 * culture-specific full names of the months.
			 */
			MonthNames: string[];

			/**
			 * Gets the native name of the calendar associated with the current
			 * {@link System.Globalization.DateTimeFormatInfo} object.
			 */
			readonly NativeCalendarName: string;

			/**
			 * Gets or sets the string designator for hours that are "post meridiem" (after noon).
			 */
			PMDesignator: string;

			/**
			 * Gets the custom format string for a time value that is based on the Internet
			 * Engineering Task Force (IETF) Request for Comments (RFC) 1123 specification.
			 */
			readonly RFC1123Pattern: string;

			/** Gets or sets the custom format string for a short date value. */
			ShortDatePattern: string;

			/**
			 * Gets or sets a string array of the shortest unique abbreviated day names associated
			 * with the current {@link System.Globalization.DateTimeFormatInfo} object.
			 */
			ShortestDayNames: string[];

			/** Gets or sets the custom format string for a short time value. */
			ShortTimePattern: string;

			/** Gets the custom format string for a sortable date and time value. */
			readonly SortableDateTimePattern: string;

			/**
			 * Gets or sets the string that separates the components of time, that is, the hour,
			 * minutes, and seconds.
			 */
			TimeSeparator: string;

			/**
			 * Gets the custom format string for a universal, sortable date and time string, as
			 * defined by ISO 8601.
			 */
			readonly UniversalSortableDateTimePattern: string;

			/** Gets or sets the custom format string for a year and month value. */
			YearMonthPattern: string;

			/** Creates a shallow copy of the {@link System.Globalization.DateTimeFormatInfo}. */
			Clone(): System.Object;

			/**
			 * Returns the culture-specific abbreviated name of the specified day of the week based
			 * on the culture associated with the current
			 * {@link System.Globalization.DateTimeFormatInfo} object.
			 */
			GetAbbreviatedDayName(dayofweek: System.DayOfWeek): string;

			/**
			 * Returns the string containing the abbreviated name of the specified era, if an
			 * abbreviation exists.
			 */
			GetAbbreviatedEraName(era: number): string;

			/**
			 * Returns the culture-specific abbreviated name of the specified month based on the
			 * culture associated with the current {@link System.Globalization.DateTimeFormatInfo}
			 * object.
			 */
			GetAbbreviatedMonthName(month: number): string;

			/** Returns all the standard patterns in which date and time values can be formatted. */
			GetAllDateTimePatterns(): string[];

			/**
			 * Returns all the patterns in which date and time values can be formatted using the
			 * specified standard format string.
			 */
			GetAllDateTimePatterns(format: System.Char): string[];

			/**
			 * Returns the culture-specific full name of the specified day of the week based on the
			 * culture associated with the current {@link System.Globalization.DateTimeFormatInfo}
			 * object.
			 */
			GetDayName(dayofweek: System.DayOfWeek): string;

			/** Returns the integer representing the specified era. */
			GetEra(eraName: string): number;

			/** Returns the string containing the name of the specified era. */
			GetEraName(era: number): string;

			/**
			 * Returns an object of the specified type that provides a date and time  formatting
			 * service.
			 */
			GetFormat(formatType: System.Type | undefined): System.Object | undefined;

			/**
			 * Returns the {@link System.Globalization.DateTimeFormatInfo} object associated with the
			 * specified {@link System.IFormatProvider}.
			 */
			static GetInstance(provider: System.IFormatProvider | undefined): System.Globalization.DateTimeFormatInfo;

			/**
			 * Returns the culture-specific full name of the specified month based on the culture
			 * associated with the current {@link System.Globalization.DateTimeFormatInfo} object.
			 */
			GetMonthName(month: number): string;

			/**
			 * Obtains the shortest abbreviated day name for a specified day of the week associated
			 * with the current {@link System.Globalization.DateTimeFormatInfo} object.
			 */
			GetShortestDayName(dayOfWeek: System.DayOfWeek): string;

			/** Returns a read-only {@link System.Globalization.DateTimeFormatInfo} wrapper. */
			static ReadOnly(dtfi: System.Globalization.DateTimeFormatInfo): System.Globalization.DateTimeFormatInfo;

			/**
			 * Sets the custom date and time format strings that correspond to a specified standard
			 * format string.
			 */
			SetAllDateTimePatterns(
				patterns: string[],
				format: System.Char,
			): void;
		}
	}

	export namespace System.Globalization {
		/**
		 * Defines the formatting options that customize string parsing for some date and time
		 * parsing methods.
		 */
		export enum DateTimeStyles {
			/**
			 * Default formatting options must be used. This value represents the default style for
			 * the {@link System.DateTime.Parse(System.String)},
			 * {@link System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)},
			 * and {@link System.DateTime.TryParse(System.String,System.DateTime@)} methods.
			 */
			None = 0,

			/**
			 * Leading white-space characters must be ignored during parsing, except if they occur in
			 * the {@link System.Globalization.DateTimeFormatInfo} format patterns.
			 */
			AllowLeadingWhite = 1,

			/**
			 * Trailing white-space characters must be ignored during parsing, except if they occur
			 * in the {@link System.Globalization.DateTimeFormatInfo} format patterns.
			 */
			AllowTrailingWhite = 2,

			/**
			 * Extra white-space characters in the middle of the string must be ignored during
			 * parsing, except if they occur in the {@link System.Globalization.DateTimeFormatInfo}
			 * format patterns.
			 */
			AllowInnerWhite = 4,

			/**
			 * Extra white-space characters anywhere in the string must be ignored during parsing,
			 * except if they occur in the {@link System.Globalization.DateTimeFormatInfo} format
			 * patterns. This value is a combination of the
			 * {@link System.Globalization.DateTimeStyles.AllowLeadingWhite},
			 * {@link System.Globalization.DateTimeStyles.AllowTrailingWhite}, and
			 * {@link System.Globalization.DateTimeStyles.AllowInnerWhite} values.
			 */
			AllowWhiteSpaces = 7,

			/**
			 * If the parsed string contains only the time and not the date, the parsing methods
			 * assume the Gregorian date with year = 1, month = 1, and day = 1. If this value is not
			 * used, the current date is assumed.
			 */
			NoCurrentDateDefault = 8,

			/**
			 * Date and time are returned as a Coordinated Universal Time (UTC). If the input string
			 * denotes a local time, through a time zone specifier or
			 * {@link System.Globalization.DateTimeStyles.AssumeLocal}, the date and time are
			 * converted from the local time to UTC. If the input string denotes a UTC time, through
			 * a time zone specifier or {@link System.Globalization.DateTimeStyles.AssumeUniversal},
			 * no conversion occurs. If the input string does not denote a local or UTC time, no
			 * conversion occurs and the resulting {@link System.DateTime.Kind} property is
			 * {@link System.DateTimeKind.Unspecified}. This value cannot be used with
			 * {@link System.Globalization.DateTimeStyles.RoundtripKind}.
			 */
			AdjustToUniversal = 16,

			/**
			 * If no time zone is specified in the parsed string, the string is assumed to denote a
			 * local time. This value cannot be used with
			 * {@link System.Globalization.DateTimeStyles.AssumeUniversal} or
			 * {@link System.Globalization.DateTimeStyles.RoundtripKind}.
			 */
			AssumeLocal = 32,

			/**
			 * If no time zone is specified in the parsed string, the string is assumed to denote a
			 * UTC. This value cannot be used with
			 * {@link System.Globalization.DateTimeStyles.AssumeLocal} or
			 * {@link System.Globalization.DateTimeStyles.RoundtripKind}.
			 */
			AssumeUniversal = 64,

			/**
			 * The {@link System.DateTimeKind} field of a date is preserved when a
			 * {@link System.DateTime} object is converted to a string using the "o" or "r" standard
			 * format specifier, and the string is then converted back to a {@link System.DateTime}
			 * object.
			 */
			RoundtripKind = 128,
		}
	}

	export namespace System.Globalization {
		/** Defines the period of daylight saving time. */
		export class DaylightTime {
			/**
			 * Initializes a new instance of the {@link System.Globalization.DaylightTime} class with
			 * the specified start, end, and time difference information.
			 */
			constructor(
				start: js.DateTime,
				end: js.DateTime,
				delta: number,
			);

			/**
			 * Gets the time interval that represents the difference between standard time and
			 * daylight saving time.
			 */
			readonly Delta: number;

			/**
			 * Gets the object that represents the date and time when the daylight saving period
			 * ends.
			 */
			readonly End: js.DateTime;

			/**
			 * Gets the object that represents the date and time when the daylight saving period
			 * begins.
			 */
			readonly Start: js.DateTime;
		}
	}

	export namespace System.Globalization {
		/** Specifies the culture-specific display of digits. */
		export enum DigitShapes {
			/**
			 * The digit shape depends on the previous text in the same output. European digits
			 * follow Latin scripts; Arabic-Indic digits follow Arabic text; and Thai digits follow
			 * Thai text.
			 */
			Context = 0,

			/** The digit shape is not changed. Full Unicode compatibility is maintained. */
			None = 1,

			/**
			 * The digit shape is the native equivalent of the digits from 0 through 9. ASCII digits
			 * from 0 through 9 are replaced by equivalent native national digits.
			 */
			NativeNational = 2,
		}
	}

	export namespace System.Globalization {
		/**
		 * Represents a calendar that divides time into months, days, years, and eras, and has
		 * dates that are based on cycles of the sun and the moon.
		 */
		export class EastAsianLunisolarCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Gets a value indicating whether the current calendar is solar-based, lunar-based, or a
			 * combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Calculates the date that is the specified number of months away from the specified
			 * date.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Calculates the date that is the specified number of years away from the specified
			 * date.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/**
			 * Calculates the celestial stem of the specified year in the sexagenary (60-year) cycle.
			 */
			GetCelestialStem(sexagenaryYear: number): number;

			/** Calculates the day of the month in the specified date. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Calculates the day of the week in the specified date. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Calculates the day of the year in the specified date. */
			GetDayOfYear(time: js.DateTime): number;

			/**
			 * Calculates the number of days in the specified month of the specified year and era.
			 */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Calculates the number of days in the specified year and era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Calculates the leap month for the specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the month in the specified date. */
			GetMonth(time: js.DateTime): number;

			/** Calculates the number of months in the specified year and era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/**
			 * Calculates the year in the sexagenary (60-year) cycle that corresponds to the
			 * specified date.
			 */
			GetSexagenaryYear(time: js.DateTime): number;

			/**
			 * Calculates the terrestrial branch of the specified year in the sexagenary (60-year)
			 * cycle.
			 */
			GetTerrestrialBranch(sexagenaryYear: number): number;

			/** Returns the year in the specified date. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date in the specified era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year and era is a leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date, time, and era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/** Converts the specified year to a four-digit year. */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/** Provides globalization-related extension methods. */
		export namespace GlobalizationExtensions {
			/**
			 * Returns a {@link System.StringComparer} object based on the culture-sensitive string
			 * comparison rules of a specified {@link System.Globalization.CompareInfo} object.
			 */
			export function GetStringComparer(
				compareInfo: System.Globalization.CompareInfo,
				options: System.Globalization.CompareOptions,
			): System.StringComparer;
		}
	}

	export namespace System.Globalization {
		/** Extension methods from {@link System.Globalization.GlobalizationExtensions} */
		export interface CompareInfo {
			/**
			 * Returns a {@link System.StringComparer} object based on the culture-sensitive string
			 * comparison rules of a specified {@link System.Globalization.CompareInfo} object.
			 */
			GetStringComparer(options: System.Globalization.CompareOptions): System.StringComparer;
		}
	}

	export namespace System.Globalization {
		/** Represents the Gregorian calendar. */
		export class GregorianCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.GregorianCalendar} class
			 * using the default {@link System.Globalization.GregorianCalendarTypes} value.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Globalization.GregorianCalendar} class
			 * using the specified {@link System.Globalization.GregorianCalendarTypes} value.
			 */
			constructor(type: System.Globalization.GregorianCalendarTypes);

			/**
			 * Gets a value that indicates whether the current calendar is solar-based, lunar-based,
			 * or a combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/**
			 * Gets or sets the {@link System.Globalization.GregorianCalendarTypes} value that
			 * denotes the language version of the current
			 * {@link System.Globalization.GregorianCalendar}.
			 */
			CalendarType: System.Globalization.GregorianCalendarTypes;

			/** Gets the list of eras in the {@link System.Globalization.GregorianCalendar}. */
			readonly Eras: number[];

			/**
			 * Gets the latest date and time supported by the
			 * {@link System.Globalization.GregorianCalendar} type.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the earliest date and time supported by the
			 * {@link System.Globalization.GregorianCalendar} type.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of months away from the
			 * specified {@link System.DateTime}.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of years away from the
			 * specified {@link System.DateTime}.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/** Returns the day of the month in the specified {@link System.DateTime}. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Returns the day of the week in the specified {@link System.DateTime}. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Returns the day of the year in the specified {@link System.DateTime}. */
			GetDayOfYear(time: js.DateTime): number;

			/**
			 * Returns the number of days in the specified month in the specified year in the
			 * specified era.
			 */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Returns the number of days in the specified year in the specified era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Returns the era in the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;

			/** Calculates the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the month in the specified {@link System.DateTime}. */
			GetMonth(time: js.DateTime): number;

			/** Returns the number of months in the specified year in the specified era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/** Returns the year in the specified {@link System.DateTime}. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date in the specified era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the specified era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * specified era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/**
			 * Converts the specified year to a four-digit year by using the
			 * {@link System.Globalization.GregorianCalendar.TwoDigitYearMax} property to determine
			 * the appropriate century.
			 */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/** Defines the different language versions of the Gregorian calendar. */
		export enum GregorianCalendarTypes {
			/**
			 * Refers to the localized version of the Gregorian calendar, based on the language of
			 * the {@link System.Globalization.CultureInfo} that uses the
			 * {@link System.Globalization.DateTimeFormatInfo}.
			 */
			Localized = 1,

			/** Refers to the U.S. English version of the Gregorian calendar. */
			USEnglish = 2,

			/** Refers to the Middle East French version of the Gregorian calendar. */
			MiddleEastFrench = 9,

			/** Refers to the Arabic version of the Gregorian calendar. */
			Arabic = 10,

			/** Refers to the transliterated English version of the Gregorian calendar. */
			TransliteratedEnglish = 11,

			/** Refers to the transliterated French version of the Gregorian calendar. */
			TransliteratedFrench = 12,
		}
	}

	export namespace System.Globalization {
		/** Represents the Hebrew calendar. */
		export class HebrewCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.HebrewCalendar} class.
			 */
			constructor();

			/**
			 * Gets a value that indicates whether the current calendar is solar-based, lunar-based,
			 * or a combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/** Gets the list of eras in the {@link System.Globalization.HebrewCalendar}. */
			readonly Eras: number[];

			/**
			 * Gets the latest date and time supported by the
			 * {@link System.Globalization.HebrewCalendar} type.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the earliest date and time supported by the
			 * {@link System.Globalization.HebrewCalendar} type.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of months away from the
			 * specified {@link System.DateTime}.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of years away from the
			 * specified {@link System.DateTime}.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/** Returns the day of the month in the specified {@link System.DateTime}. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Returns the day of the week in the specified {@link System.DateTime}. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Returns the day of the year in the specified {@link System.DateTime}. */
			GetDayOfYear(time: js.DateTime): number;

			/**
			 * Returns the number of days in the specified month in the specified year in the
			 * specified era.
			 */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Returns the number of days in the specified year in the specified era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Returns the era in the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;

			/** Calculates the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the month in the specified {@link System.DateTime}. */
			GetMonth(time: js.DateTime): number;

			/** Returns the number of months in the specified year in the specified era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/** Returns the year in the specified {@link System.DateTime} value. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date in the specified era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the specified era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * specified era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/**
			 * Converts the specified year to a 4-digit year by using the
			 * {@link System.Globalization.HebrewCalendar.TwoDigitYearMax} property to determine the
			 * appropriate century.
			 */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/** Represents the Hijri calendar. */
		export class HijriCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.HijriCalendar} class.
			 */
			constructor();

			/**
			 * Gets a value that indicates whether the current calendar is solar-based, lunar-based,
			 * or a combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/** Gets the list of eras in the {@link System.Globalization.HijriCalendar}. */
			readonly Eras: number[];

			/**
			 * Gets or sets the number of days to add or subtract from the calendar to accommodate
			 * the variances in the start and the end of Ramadan and to accommodate the date
			 * difference between countries/regions.
			 */
			HijriAdjustment: number;

			/** Gets the latest date and time supported by this calendar. */
			readonly MaxSupportedDateTime: js.DateTime;

			/** Gets the earliest date and time supported by this calendar. */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of months away from the
			 * specified {@link System.DateTime}.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of years away from the
			 * specified {@link System.DateTime}.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/** Returns the day of the month in the specified {@link System.DateTime}. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Returns the day of the week in the specified {@link System.DateTime}. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Returns the day of the year in the specified {@link System.DateTime}. */
			GetDayOfYear(time: js.DateTime): number;

			/** Returns the number of days in the specified month of the specified year and era. */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Returns the number of days in the specified year and era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Returns the era in the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;

			/** Calculates the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the month in the specified {@link System.DateTime}. */
			GetMonth(time: js.DateTime): number;

			/** Returns the number of months in the specified year and era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/** Returns the year in the specified {@link System.DateTime}. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year and era is a leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date, time, and era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/**
			 * Converts the specified year to a four-digit year by using the
			 * {@link System.Globalization.HijriCalendar.TwoDigitYearMax} property to determine the
			 * appropriate century.
			 */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/**
		 * Supports the use of non-ASCII characters for Internet domain names. This class cannot
		 * be inherited.
		 */
		export class IdnMapping {
			/** Initializes a new instance of the {@link System.Globalization.IdnMapping} class. */
			constructor();

			/**
			 * Gets or sets a value that indicates whether unassigned Unicode code points are used in
			 * operations performed by members of the current {@link System.Globalization.IdnMapping}
			 * object.
			 */
			AllowUnassigned: boolean;

			/**
			 * Gets or sets a value that indicates whether standard or relaxed naming conventions are
			 * used in operations performed by members of the current
			 * {@link System.Globalization.IdnMapping} object.
			 */
			UseStd3AsciiRules: boolean;

			/**
			 * Indicates whether a specified object and the current
			 * {@link System.Globalization.IdnMapping} object are equal.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Encodes a string of domain name labels that consist of Unicode characters to a string
			 * of displayable Unicode characters in the US-ASCII character range. The string is
			 * formatted according to the IDNA standard.
			 */
			GetAscii(unicode: string): string;

			/**
			 * Encodes a substring of domain name labels that include Unicode characters outside the
			 * US-ASCII character range. The substring is converted to a string of displayable
			 * Unicode characters in the US-ASCII character range and is formatted according to the
			 * IDNA standard.
			 */
			GetAscii(
				unicode: string,
				index: number,
			): string;

			/**
			 * Encodes the specified number of characters in a substring of domain name labels that
			 * include Unicode characters outside the US-ASCII character range. The substring is
			 * converted to a string of displayable Unicode characters in the US-ASCII character
			 * range and is formatted according to the IDNA standard.
			 */
			GetAscii(
				unicode: string,
				index: number,
				count: number,
			): string;

			/** Returns a hash code for this {@link System.Globalization.IdnMapping} object. */
			GetHashCode(): number;

			/**
			 * Decodes a string of one or more domain name labels, encoded according to the IDNA
			 * standard, to a string of Unicode characters.
			 */
			GetUnicode(ascii: string): string;

			/**
			 * Decodes a substring of one or more domain name labels, encoded according to the IDNA
			 * standard, to a string of Unicode characters.
			 */
			GetUnicode(
				ascii: string,
				index: number,
			): string;

			/**
			 * Decodes a substring of a specified length that contains one or more domain name
			 * labels, encoded according to the IDNA standard, to a string of Unicode characters.
			 */
			GetUnicode(
				ascii: string,
				index: number,
				count: number,
			): string;
		}
	}

	export namespace System.Globalization {
		/**
		 * Provides static members to support the ISO week date that is part of the ISO 8601 date
		 * and time standard issued by the International Organization for Standardization (ISO).
		 */
		export namespace ISOWeek {
			/** Calculates the ISO week number of a given Gregorian date. */
			export function GetWeekOfYear(date: js.DateTime): number;

			/** calculates the number of weeks in a given ISO week-numbering year. */
			export function GetWeeksInYear(year: number): number;

			/**
			 * Calculates the ISO week-numbering year (also called ISO year informally) mapped to the
			 * input Gregorian date.
			 */
			export function GetYear(date: js.DateTime): number;

			/** Calculates the Gregorian date at which the week-numbering year will end. */
			export function GetYearEnd(year: number): js.DateTime;

			/** Calculates the Gregorian date at which the week-numbering year will start. */
			export function GetYearStart(year: number): js.DateTime;

			/**
			 * Maps the ISO week date represented by a specified ISO year, week number, and day of
			 * week to the equivalent Gregorian date.
			 */
			export function ToDateTime(
				year: number,
				week: number,
				dayOfWeek: System.DayOfWeek,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/** Represents the Japanese calendar. */
		export class JapaneseCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.JapaneseCalendar} class.
			 */
			constructor();

			/**
			 * Gets a value that indicates whether the current calendar is solar-based, lunar-based,
			 * or a combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/** Gets the list of eras in the {@link System.Globalization.JapaneseCalendar}. */
			readonly Eras: number[];

			/**
			 * Gets the latest date and time supported by the current
			 * {@link System.Globalization.JapaneseCalendar} object.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the earliest date and time supported by the current
			 * {@link System.Globalization.JapaneseCalendar} object.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of months away from the
			 * specified {@link System.DateTime}.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of years away from the
			 * specified {@link System.DateTime}.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/** Returns the day of the month in the specified {@link System.DateTime}. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Returns the day of the week in the specified {@link System.DateTime}. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Returns the day of the year in the specified {@link System.DateTime}. */
			GetDayOfYear(time: js.DateTime): number;

			/**
			 * Returns the number of days in the specified month in the specified year in the
			 * specified era.
			 */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Returns the number of days in the specified year in the specified era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Returns the era in the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;

			/** Calculates the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the month in the specified {@link System.DateTime}. */
			GetMonth(time: js.DateTime): number;

			/** Returns the number of months in the specified year in the specified era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/**
			 * Returns the week of the year that includes the date in the specified
			 * {@link System.DateTime}.
			 */
			GetWeekOfYear(
				time: js.DateTime,
				rule: System.Globalization.CalendarWeekRule,
				firstDayOfWeek: System.DayOfWeek,
			): number;

			/** Returns the year in the specified {@link System.DateTime}. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date in the specified era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the specified era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * specified era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/**
			 * Converts the specified year to a four-digit year by using the
			 * {@link System.Globalization.JapaneseCalendar.TwoDigitYearMax} property to determine
			 * the appropriate century.
			 */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/**
		 * Represents time in divisions, such as months, days, and years. Years are calculated as
		 * for the Japanese calendar, while days and months are calculated using the lunisolar
		 * calendar.
		 */
		export class JapaneseLunisolarCalendar extends System.Globalization.EastAsianLunisolarCalendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the
			 * {@link System.Globalization.JapaneseLunisolarCalendar} class.
			 */
			constructor();

			/**
			 * Gets the eras that are relevant to the
			 * {@link System.Globalization.JapaneseLunisolarCalendar} object.
			 */
			readonly Eras: number[];

			/**
			 * Gets the maximum date and time supported by the
			 * {@link System.Globalization.JapaneseLunisolarCalendar} class.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the minimum date and time supported by the
			 * {@link System.Globalization.JapaneseLunisolarCalendar} class.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/** Retrieves the era that corresponds to the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;
		}
	}

	export namespace System.Globalization {
		/** Represents the Julian calendar. */
		export class JulianCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.JulianCalendar} class.
			 */
			constructor();

			/**
			 * Gets a value that indicates whether the current calendar is solar-based, lunar-based,
			 * or a combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/** Gets the list of eras in the {@link System.Globalization.JulianCalendar}. */
			readonly Eras: number[];

			/**
			 * Gets the latest date and time supported by the
			 * {@link System.Globalization.JulianCalendar} class.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the earliest date and time supported by the
			 * {@link System.Globalization.JulianCalendar} class.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of months away from the
			 * specified {@link System.DateTime}.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of years away from the
			 * specified {@link System.DateTime}.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/** Returns the day of the month in the specified {@link System.DateTime}. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Returns the day of the week in the specified {@link System.DateTime}. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Returns the day of the year in the specified {@link System.DateTime}. */
			GetDayOfYear(time: js.DateTime): number;

			/**
			 * Returns the number of days in the specified month in the specified year in the
			 * specified era.
			 */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Returns the number of days in the specified year in the specified era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Returns the era in the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;

			/** Calculates the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the month in the specified {@link System.DateTime}. */
			GetMonth(time: js.DateTime): number;

			/** Returns the number of months in the specified year in the specified era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/** Returns the year in the specified {@link System.DateTime}. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date in the specified era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the specified era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * specified era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/**
			 * Converts the specified year to a four-digit year by using the
			 * {@link System.Globalization.JulianCalendar.TwoDigitYearMax} property to determine the
			 * appropriate century.
			 */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/** Represents the Korean calendar. */
		export class KoreanCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.KoreanCalendar} class.
			 */
			constructor();

			/**
			 * Gets a value indicating whether the current calendar is solar-based, lunar-based, or a
			 * combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/** Gets the list of eras in the {@link System.Globalization.KoreanCalendar}. */
			readonly Eras: number[];

			/**
			 * Gets the latest date and time supported by the
			 * {@link System.Globalization.KoreanCalendar} class.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the earliest date and time supported by the
			 * {@link System.Globalization.KoreanCalendar} class.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of months away from the
			 * specified {@link System.DateTime}.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of years away from the
			 * specified {@link System.DateTime}.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/** Returns the day of the month in the specified {@link System.DateTime}. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Returns the day of the week in the specified {@link System.DateTime}. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Returns the day of the year in the specified {@link System.DateTime}. */
			GetDayOfYear(time: js.DateTime): number;

			/**
			 * Returns the number of days in the specified month in the specified year in the
			 * specified era.
			 */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Returns the number of days in the specified year in the specified era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Returns the era in the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;

			/** Calculates the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the month in the specified {@link System.DateTime}. */
			GetMonth(time: js.DateTime): number;

			/** Returns the number of months in the specified year in the specified era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/**
			 * Returns the week of the year that includes the date in the specified
			 * {@link System.DateTime}.
			 */
			GetWeekOfYear(
				time: js.DateTime,
				rule: System.Globalization.CalendarWeekRule,
				firstDayOfWeek: System.DayOfWeek,
			): number;

			/** Returns the year in the specified {@link System.DateTime}. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date in the specified era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the specified era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * specified era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/**
			 * Converts the specified year to a four-digit year by using the
			 * {@link System.Globalization.KoreanCalendar.TwoDigitYearMax} property to determine the
			 * appropriate century.
			 */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/**
		 * Represents time in divisions, such as months, days, and years. Years are calculated
		 * using the Gregorian calendar, while days and months are calculated using the lunisolar
		 * calendar.
		 */
		export class KoreanLunisolarCalendar extends System.Globalization.EastAsianLunisolarCalendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.KoreanLunisolarCalendar}
			 * class.
			 */
			constructor();

			/**
			 * Gets the eras that correspond to the range of dates and times supported by the current
			 * {@link System.Globalization.KoreanLunisolarCalendar} object.
			 */
			readonly Eras: number[];

			/**
			 * Gets the maximum date and time supported by the
			 * {@link System.Globalization.KoreanLunisolarCalendar} class.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the minimum date and time supported by the
			 * {@link System.Globalization.KoreanLunisolarCalendar} class.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/** Retrieves the era that corresponds to the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;
		}
	}

	export namespace System.Globalization {
		/** Provides culture-specific information for formatting and parsing numeric values. */
		export class NumberFormatInfo implements
			System.ICloneable,
			System.IFormatProvider {
			/**
			 * Initializes a new writable instance of the
			 * {@link System.Globalization.NumberFormatInfo} class that is culture-independent
			 * (invariant).
			 */
			constructor();

			/** Gets or sets the number of decimal places to use in currency values. */
			CurrencyDecimalDigits: number;

			/** Gets or sets the string to use as the decimal separator in currency values. */
			CurrencyDecimalSeparator: string;

			/**
			 * Gets or sets the string that separates groups of digits to the left of the decimal in
			 * currency values.
			 */
			CurrencyGroupSeparator: string;

			/**
			 * Gets or sets the number of digits in each group to the left of the decimal in currency
			 * values.
			 */
			CurrencyGroupSizes: number[];

			/** Gets or sets the format pattern for negative currency values. */
			CurrencyNegativePattern: number;

			/** Gets or sets the format pattern for positive currency values. */
			CurrencyPositivePattern: number;

			/** Gets or sets the string to use as the currency symbol. */
			CurrencySymbol: string;

			/**
			 * Gets a read-only {@link System.Globalization.NumberFormatInfo} that formats values
			 * based on the current culture.
			 */
			static readonly CurrentInfo: System.Globalization.NumberFormatInfo;

			/**
			 * Gets or sets a value that specifies how the graphical user interface displays the
			 * shape of a digit.
			 */
			DigitSubstitution: System.Globalization.DigitShapes;

			/**
			 * Gets a read-only {@link System.Globalization.NumberFormatInfo} object that is
			 * culture-independent (invariant).
			 */
			static readonly InvariantInfo: System.Globalization.NumberFormatInfo;

			/**
			 * Gets a value that indicates whether this {@link System.Globalization.NumberFormatInfo}
			 * object is read-only.
			 */
			readonly IsReadOnly: boolean;

			/** Gets or sets the string that represents the IEEE NaN (not a number) value. */
			NaNSymbol: string;

			/**
			 * Gets or sets a string array of native digits equivalent to the Western digits 0
			 * through 9.
			 */
			NativeDigits: string[];

			/** Gets or sets the string that represents negative infinity. */
			NegativeInfinitySymbol: string;

			/** Gets or sets the string that denotes that the associated number is negative. */
			NegativeSign: string;

			/** Gets or sets the number of decimal places to use in numeric values. */
			NumberDecimalDigits: number;

			/** Gets or sets the string to use as the decimal separator in numeric values. */
			NumberDecimalSeparator: string;

			/**
			 * Gets or sets the string that separates groups of digits to the left of the decimal in
			 * numeric values.
			 */
			NumberGroupSeparator: string;

			/**
			 * Gets or sets the number of digits in each group to the left of the decimal in numeric
			 * values.
			 */
			NumberGroupSizes: number[];

			/** Gets or sets the format pattern for negative numeric values. */
			NumberNegativePattern: number;

			/** Gets or sets the number of decimal places to use in percent values. */
			PercentDecimalDigits: number;

			/** Gets or sets the string to use as the decimal separator in percent values. */
			PercentDecimalSeparator: string;

			/**
			 * Gets or sets the string that separates groups of digits to the left of the decimal in
			 * percent values.
			 */
			PercentGroupSeparator: string;

			/**
			 * Gets or sets the number of digits in each group to the left of the decimal in percent
			 * values.
			 */
			PercentGroupSizes: number[];

			/** Gets or sets the format pattern for negative percent values. */
			PercentNegativePattern: number;

			/** Gets or sets the format pattern for positive percent values. */
			PercentPositivePattern: number;

			/** Gets or sets the string to use as the percent symbol. */
			PercentSymbol: string;

			/** Gets or sets the string to use as the per mille symbol. */
			PerMilleSymbol: string;

			/** Gets or sets the string that represents positive infinity. */
			PositiveInfinitySymbol: string;

			/** Gets or sets the string that denotes that the associated number is positive. */
			PositiveSign: string;

			/**
			 * Creates a shallow copy of the {@link System.Globalization.NumberFormatInfo} object.
			 */
			Clone(): System.Object;

			/** Gets an object of the specified type that provides a number formatting service. */
			GetFormat(formatType: System.Type | undefined): System.Object | undefined;

			/**
			 * Gets the {@link System.Globalization.NumberFormatInfo} associated with the specified
			 * {@link System.IFormatProvider}.
			 */
			static GetInstance(formatProvider: System.IFormatProvider | undefined): System.Globalization.NumberFormatInfo;

			/** Returns a read-only {@link System.Globalization.NumberFormatInfo} wrapper. */
			static ReadOnly(nfi: System.Globalization.NumberFormatInfo): System.Globalization.NumberFormatInfo;
		}
	}

	export namespace System.Globalization {
		/**
		 * Determines the styles permitted in numeric string arguments that are passed to the
		 * `Parse` and `TryParse` methods of the integral and floating-point numeric types.
		 */
		export enum NumberStyles {
			/**
			 * Indicates that no style elements, such as leading or trailing white space, thousands
			 * separators, or a decimal separator, can be present in the parsed string. The string to
			 * be parsed must consist of integral decimal digits only.
			 */
			None = 0,

			/**
			 * Indicates that leading white-space characters can be present in the parsed string.
			 * Valid white-space characters have the Unicode values U+0009, U+000A, U+000B, U+000C,
			 * U+000D, and U+0020. Note that this is a subset of the characters for which the
			 * {@link System.Char.IsWhiteSpace(System.Char)} method returns `true`.
			 */
			AllowLeadingWhite = 1,

			/**
			 * Indicates that trailing white-space characters can be present in the parsed string.
			 * Valid white-space characters have the Unicode values U+0009, U+000A, U+000B, U+000C,
			 * U+000D, and U+0020. Note that this is a subset of the characters for which the
			 * {@link System.Char.IsWhiteSpace(System.Char)} method returns `true`.
			 */
			AllowTrailingWhite = 2,

			/**
			 * Indicates that the numeric string can have a leading sign. Valid leading sign
			 * characters are determined by the
			 * {@link System.Globalization.NumberFormatInfo.PositiveSign} and
			 * {@link System.Globalization.NumberFormatInfo.NegativeSign} properties.
			 */
			AllowLeadingSign = 4,

			/**
			 * Indicates that the {@link System.Globalization.NumberStyles.AllowLeadingWhite},
			 * {@link System.Globalization.NumberStyles.AllowTrailingWhite}, and
			 * {@link System.Globalization.NumberStyles.AllowLeadingSign} styles are used. This is a
			 * composite number style.
			 */
			Integer = 7,

			/**
			 * Indicates that the numeric string can have a trailing sign. Valid trailing sign
			 * characters are determined by the
			 * {@link System.Globalization.NumberFormatInfo.PositiveSign} and
			 * {@link System.Globalization.NumberFormatInfo.NegativeSign} properties.
			 */
			AllowTrailingSign = 8,

			/**
			 * Indicates that the numeric string can have one pair of parentheses enclosing the
			 * number. The parentheses indicate that the string to be parsed represents a negative
			 * number.
			 */
			AllowParentheses = 16,

			/**
			 * Indicates that the numeric string can have a decimal point. If the
			 * {@link System.Globalization.NumberStyles} value includes the
			 * {@link System.Globalization.NumberStyles.AllowCurrencySymbol} flag and the parsed
			 * string includes a currency symbol, the decimal separator character is determined by
			 * the {@link System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator} property.
			 * Otherwise, the decimal separator character is determined by the
			 * {@link System.Globalization.NumberFormatInfo.NumberDecimalSeparator} property.
			 */
			AllowDecimalPoint = 32,

			/**
			 * Indicates that the numeric string can have group separators, such as symbols that
			 * separate hundreds from thousands. If the {@link System.Globalization.NumberStyles}
			 * value includes the {@link System.Globalization.NumberStyles.AllowCurrencySymbol} flag
			 * and the string to be parsed includes a currency symbol, the valid group separator
			 * character is determined by the
			 * {@link System.Globalization.NumberFormatInfo.CurrencyGroupSeparator} property,  and
			 * the number of digits in each group is determined by the
			 * {@link System.Globalization.NumberFormatInfo.CurrencyGroupSizes} property. Otherwise,
			 * the valid group separator character is determined by the
			 * {@link System.Globalization.NumberFormatInfo.NumberGroupSeparator} property, and the
			 * number of digits in each group is determined by the
			 * {@link System.Globalization.NumberFormatInfo.NumberGroupSizes} property.
			 */
			AllowThousands = 64,

			/**
			 * Indicates that the {@link System.Globalization.NumberStyles.AllowLeadingWhite},
			 * {@link System.Globalization.NumberStyles.AllowTrailingWhite},
			 * {@link System.Globalization.NumberStyles.AllowLeadingSign},
			 * {@link System.Globalization.NumberStyles.AllowTrailingSign},
			 * {@link System.Globalization.NumberStyles.AllowDecimalPoint}, and
			 * {@link System.Globalization.NumberStyles.AllowThousands} styles are used. This is a
			 * composite number style.
			 */
			Number = 111,

			/**
			 * Indicates that the numeric string can be in exponential notation. The
			 * {@link System.Globalization.NumberStyles.AllowExponent} flag allows the parsed string
			 * to contain an exponent that begins with the "E" or "e" character and that is followed
			 * by an optional positive or negative sign and an integer. In other words, it
			 * successfully parses strings in the form nnnExx, nnnE+xx, and nnnE-xx. It does not
			 * allow a decimal separator or sign in the significand or mantissa; to allow these
			 * elements in the string to be parsed, use the
			 * {@link System.Globalization.NumberStyles.AllowDecimalPoint} and
			 * {@link System.Globalization.NumberStyles.AllowLeadingSign} flags, or use a composite
			 * style that includes these individual flags.
			 */
			AllowExponent = 128,

			/**
			 * Indicates that the {@link System.Globalization.NumberStyles.AllowLeadingWhite},
			 * {@link System.Globalization.NumberStyles.AllowTrailingWhite},
			 * {@link System.Globalization.NumberStyles.AllowLeadingSign},
			 * {@link System.Globalization.NumberStyles.AllowDecimalPoint}, and
			 * {@link System.Globalization.NumberStyles.AllowExponent} styles are used. This is a
			 * composite number style.
			 */
			Float = 167,

			/**
			 * Indicates that the numeric string can contain a currency symbol. Valid currency
			 * symbols are determined by the
			 * {@link System.Globalization.NumberFormatInfo.CurrencySymbol} property.
			 */
			AllowCurrencySymbol = 256,

			/**
			 * Indicates that all styles except
			 * {@link System.Globalization.NumberStyles.AllowExponent} and
			 * {@link System.Globalization.NumberStyles.AllowHexSpecifier} are used. This is a
			 * composite number style.
			 */
			Currency = 383,

			/**
			 * Indicates that all styles except
			 * {@link System.Globalization.NumberStyles.AllowHexSpecifier} are used. This is a
			 * composite number style.
			 */
			Any = 511,

			/**
			 * Indicates that the numeric string represents a hexadecimal value. Valid hexadecimal
			 * values include the numeric digits 0-9 and the hexadecimal digits A-F and a-f. Strings
			 * that are parsed using this style cannot be prefixed with "0x" or "&amp;h". A string
			 * that is parsed with the {@link System.Globalization.NumberStyles.AllowHexSpecifier}
			 * style will always be interpreted as a hexadecimal value. The only flags that can be
			 * combined with {@link System.Globalization.NumberStyles.AllowHexSpecifier} are
			 * {@link System.Globalization.NumberStyles.AllowLeadingWhite} and
			 * {@link System.Globalization.NumberStyles.AllowTrailingWhite}. The
			 * {@link System.Globalization.NumberStyles} enumeration includes a composite style,
			 * {@link System.Globalization.NumberStyles.HexNumber}, that consists of these three
			 * flags.
			 */
			AllowHexSpecifier = 512,

			/**
			 * Indicates that the {@link System.Globalization.NumberStyles.AllowLeadingWhite},
			 * {@link System.Globalization.NumberStyles.AllowTrailingWhite}, and
			 * {@link System.Globalization.NumberStyles.AllowHexSpecifier} styles are used. This is a
			 * composite number style.
			 */
			HexNumber = 515,

			/**
			 * Indicates that the numeric string represents a binary value. Valid binary values
			 * include the numeric digits 0 and 1. Strings that are parsed using this style do not
			 * employ a prefix; 0b cannot be used. A string that is parsed with the
			 * {@link System.Globalization.NumberStyles.AllowBinarySpecifier} style will always be
			 * interpreted as a binary value. The only flags that can be combined with
			 * {@link System.Globalization.NumberStyles.AllowBinarySpecifier} are
			 * {@link System.Globalization.NumberStyles.AllowLeadingWhite} and
			 * {@link System.Globalization.NumberStyles.AllowTrailingWhite}. The
			 * {@link System.Globalization.NumberStyles} enumeration includes a composite style,
			 * {@link System.Globalization.NumberStyles.BinaryNumber}, that consists of these three
			 * flags.
			 */
			AllowBinarySpecifier = 1024,

			/**
			 * Indicates that the {@link System.Globalization.NumberStyles.AllowLeadingWhite},
			 * {@link System.Globalization.NumberStyles.AllowTrailingWhite}, and
			 * {@link System.Globalization.NumberStyles.AllowBinarySpecifier} styles are used. This
			 * is a composite number style.
			 */
			BinaryNumber = 1027,
		}
	}

	export namespace System.Globalization {
		/** Represents the Persian calendar. */
		export class PersianCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.PersianCalendar} class.
			 */
			constructor();

			/**
			 * Gets a value indicating whether the current calendar is solar-based, lunar-based, or
			 * lunisolar-based.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/** Gets the list of eras in a {@link System.Globalization.PersianCalendar} object. */
			readonly Eras: number[];

			/**
			 * Gets the latest date and time supported by the
			 * {@link System.Globalization.PersianCalendar} class.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the earliest date and time supported by the
			 * {@link System.Globalization.PersianCalendar} class.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Returns a {@link System.DateTime} object that is offset the specified number of months
			 * from the specified {@link System.DateTime} object.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} object that is offset the specified number of years
			 * from the specified {@link System.DateTime} object.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/** Returns the day of the month in the specified {@link System.DateTime} object. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Returns the day of the week in the specified {@link System.DateTime} object. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Returns the day of the year in the specified {@link System.DateTime} object. */
			GetDayOfYear(time: js.DateTime): number;

			/** Returns the number of days in the specified month of the specified year and era. */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Returns the number of days in the specified year of the specified era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Returns the era in the specified {@link System.DateTime} object. */
			GetEra(time: js.DateTime): number;

			/** Returns the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the month in the specified {@link System.DateTime} object. */
			GetMonth(time: js.DateTime): number;

			/** Returns the number of months in the specified year of the specified era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/** Returns the year in the specified {@link System.DateTime} object. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year and era is a leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} object that is set to the specified date, time, and
			 * era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/** Converts the specified year to a four-digit year representation. */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/** Contains information about the country/region. */
		export class RegionInfo {
			/**
			 * Initializes a new instance of the {@link System.Globalization.RegionInfo} class based
			 * on the country/region associated with the specified culture identifier.
			 */
			constructor(culture: number);

			/**
			 * Initializes a new instance of the {@link System.Globalization.RegionInfo} class based
			 * on the country/region or specific culture, specified by name.
			 */
			constructor(name: string);

			/** Gets the name, in English, of the currency used in the country/region. */
			readonly CurrencyEnglishName: string;

			/**
			 * Gets the name of the currency used in the country/region, formatted in the native
			 * language of the country/region.
			 */
			readonly CurrencyNativeName: string;

			/** Gets the currency symbol associated with the country/region. */
			readonly CurrencySymbol: string;

			/**
			 * Gets the {@link System.Globalization.RegionInfo} that represents the country/region
			 * used by the current thread.
			 */
			static readonly CurrentRegion: System.Globalization.RegionInfo;

			/**
			 * Gets the full name of the country/region in the language of the localized version of
			 * .NET.
			 */
			readonly DisplayName: string;

			/** Gets the full name of the country/region in English. */
			readonly EnglishName: string;

			/**
			 * Gets a unique identification number for a geographical region, country, city, or
			 * location.
			 */
			readonly GeoId: number;

			/**
			 * Gets a value indicating whether the country/region uses the metric system for
			 * measurements.
			 */
			readonly IsMetric: boolean;

			/**
			 * Gets the three-character ISO 4217 currency symbol associated with the country/region.
			 */
			readonly ISOCurrencySymbol: string;

			/**
			 * Gets the name or ISO 3166 two-letter country/region code for the current
			 * {@link System.Globalization.RegionInfo} object.
			 */
			readonly Name: string;

			/**
			 * Gets the name of a country/region formatted in the native language of the
			 * country/region.
			 */
			readonly NativeName: string;

			/** Gets the three-letter code defined in ISO 3166 for the country/region. */
			readonly ThreeLetterISORegionName: string;

			/**
			 * Gets the three-letter code assigned by Windows to the country/region represented by
			 * this {@link System.Globalization.RegionInfo}.
			 */
			readonly ThreeLetterWindowsRegionName: string;

			/** Gets the two-letter code defined in ISO 3166 for the country/region. */
			readonly TwoLetterISORegionName: string;

			/**
			 * Determines whether the specified object is the same instance as the current
			 * {@link System.Globalization.RegionInfo}.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Serves as a hash function for the current {@link System.Globalization.RegionInfo},
			 * suitable for hashing algorithms and data structures, such as a hash table.
			 */
			GetHashCode(): number;

			/**
			 * Returns a string containing the culture name or ISO 3166 two-letter country/region
			 * codes specified for the current {@link System.Globalization.RegionInfo}.
			 */
			ToString(): string;
		}
	}

	export namespace System.Globalization {
		/** Represents the result of mapping a string to its sort key. */
		export class SortKey {
			/**
			 * Gets the byte array representing the current {@link System.Globalization.SortKey}
			 * object.
			 */
			readonly KeyData: number[];

			/**
			 * Gets the original string used to create the current
			 * {@link System.Globalization.SortKey} object.
			 */
			readonly OriginalString: string;

			/** Compares two sort keys. */
			static Compare(
				sortkey1: System.Globalization.SortKey,
				sortkey2: System.Globalization.SortKey,
			): number;

			/**
			 * Determines whether the specified object is equal to the current
			 * {@link System.Globalization.SortKey} object.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Serves as a hash function for the current {@link System.Globalization.SortKey} object
			 * that is suitable for hashing algorithms and data structures such as a hash table.
			 */
			GetHashCode(): number;

			/**
			 * Returns a string that represents the current {@link System.Globalization.SortKey}
			 * object.
			 */
			ToString(): string;
		}
	}

	export namespace System.Globalization {
		/**
		 * Provides information about the version of Unicode used to compare and order strings.
		 */
		export class SortVersion implements System.IEquatable$1<System.Globalization.SortVersion> {
			/** Creates a new instance of the {@link System.Globalization.SortVersion} class. */
			constructor(
				fullVersion: number,
				sortId: string,
			);

			/**
			 * Gets the full version number of the {@link System.Globalization.SortVersion} object.
			 */
			readonly FullVersion: number;

			/**
			 * Gets a globally unique identifier for this {@link System.Globalization.SortVersion}
			 * object.
			 */
			readonly SortId: string;

			/**
			 * Returns a value that indicates whether this {@link System.Globalization.SortVersion}
			 * instance is equal to a specified {@link System.Globalization.SortVersion} object.
			 */
			Equals(other: System.Globalization.SortVersion | undefined): boolean;

			/**
			 * Returns a value that indicates whether this {@link System.Globalization.SortVersion}
			 * instance is equal to a specified object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns a hash code for this instance. */
			GetHashCode(): number;
		}
	}

	export namespace System.Globalization {
		/**
		 * Provides functionality to split a string into text elements and to iterate through
		 * those text elements.
		 */
		export class StringInfo {
			/** Initializes a new instance of the {@link System.Globalization.StringInfo} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Globalization.StringInfo} class to a
			 * specified string.
			 */
			constructor(value: string);

			/**
			 * Gets the number of text elements in the current
			 * {@link System.Globalization.StringInfo} object.
			 */
			readonly LengthInTextElements: number;

			/**
			 * Gets or sets the value of the current {@link System.Globalization.StringInfo} object.
			 */
			String: string;

			/**
			 * Indicates whether the current {@link System.Globalization.StringInfo} object is equal
			 * to a specified object.
			 */
			Equals(value: System.Object | undefined): boolean;

			/**
			 * Calculates a hash code for the value of the current
			 * {@link System.Globalization.StringInfo} object.
			 */
			GetHashCode(): number;

			/** Gets the first text element in a specified string. */
			static GetNextTextElement(str: string): string;

			/** Gets the text element at the specified index of the specified string. */
			static GetNextTextElement(
				str: string,
				index: number,
			): string;

			/**
			 * Returns the length of the first text element (extended grapheme cluster) that occurs
			 * in the input span.
			 */
			static GetNextTextElementLength(str: System.ReadOnlySpan$1<System.Char>): number;

			/**
			 * Returns the length of the first text element (extended grapheme cluster) that occurs
			 * in the input string.
			 */
			static GetNextTextElementLength(str: string): number;

			/**
			 * Returns the length of the first text element (extended grapheme cluster) that occurs
			 * in the input string starting at the specified index.
			 */
			static GetNextTextElementLength(
				str: string,
				index: number,
			): number;

			/**
			 * Returns an enumerator that iterates through the text elements of the entire string.
			 */
			static GetTextElementEnumerator(str: string): System.Globalization.TextElementEnumerator;

			/**
			 * Returns an enumerator that iterates through the text elements of the string, starting
			 * at the specified index.
			 */
			static GetTextElementEnumerator(
				str: string,
				index: number,
			): System.Globalization.TextElementEnumerator;

			/**
			 * Returns the indexes of each base character, high surrogate, or control character
			 * within the specified string.
			 */
			static ParseCombiningCharacters(str: string): number[];

			/**
			 * Retrieves a substring of text elements from the current
			 * {@link System.Globalization.StringInfo} object starting from a specified text element
			 * and continuing through the last text element.
			 */
			SubstringByTextElements(startingTextElement: number): string;

			/**
			 * Retrieves a substring of text elements from the current
			 * {@link System.Globalization.StringInfo} object starting from a specified text element
			 * and continuing through the specified number of text elements.
			 */
			SubstringByTextElements(
				startingTextElement: number,
				lengthInTextElements: number,
			): string;
		}
	}

	export namespace System.Globalization {
		/** the Taiwan calendar. */
		export class TaiwanCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.TaiwanCalendar} class.
			 */
			constructor();

			/**
			 * Gets a value that indicates whether the current calendar is solar-based, lunar-based,
			 * or a combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/** Gets the list of eras in the {@link System.Globalization.TaiwanCalendar}. */
			readonly Eras: number[];

			/**
			 * Gets the latest date and time supported by the
			 * {@link System.Globalization.TaiwanCalendar} class.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the earliest date and time supported by the
			 * {@link System.Globalization.TaiwanCalendar} class.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of months away from the
			 * specified {@link System.DateTime}.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of years away from the
			 * specified {@link System.DateTime}.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/** Returns the day of the month in the specified {@link System.DateTime}. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Returns the day of the week in the specified {@link System.DateTime}. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Returns the day of the year in the specified {@link System.DateTime}. */
			GetDayOfYear(time: js.DateTime): number;

			/**
			 * Returns the number of days in the specified month in the specified year in the
			 * specified era.
			 */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Returns the number of days in the specified year in the specified era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Returns the era in the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;

			/** Calculates the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the month in the specified {@link System.DateTime}. */
			GetMonth(time: js.DateTime): number;

			/** Returns the number of months in the specified year in the specified era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/**
			 * Returns the week of the year that includes the date in the specified
			 * {@link System.DateTime}.
			 */
			GetWeekOfYear(
				time: js.DateTime,
				rule: System.Globalization.CalendarWeekRule,
				firstDayOfWeek: System.DayOfWeek,
			): number;

			/** Returns the year in the specified {@link System.DateTime}. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date in the specified era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the specified era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * specified era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/**
			 * Converts the specified year to a four-digit year by using the
			 * {@link System.Globalization.TaiwanCalendar.TwoDigitYearMax} property to determine the
			 * appropriate century.
			 */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/**
		 * Represents the Taiwan lunisolar calendar. As for the Taiwan calendar, years are
		 * calculated using the Gregorian calendar, while days and months are calculated using
		 * the lunisolar calendar.
		 */
		export class TaiwanLunisolarCalendar extends System.Globalization.EastAsianLunisolarCalendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.TaiwanLunisolarCalendar}
			 * class.
			 */
			constructor();

			/**
			 * Gets the eras that are relevant to the current
			 * {@link System.Globalization.TaiwanLunisolarCalendar} object.
			 */
			readonly Eras: number[];

			/**
			 * Gets the maximum date and time supported by the
			 * {@link System.Globalization.TaiwanLunisolarCalendar} class.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the minimum date and time supported by the
			 * {@link System.Globalization.TaiwanLunisolarCalendar} class.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/** Retrieves the era that corresponds to the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;
		}
	}

	export namespace System.Globalization {
		/** Enumerates the text elements of a string. */
		export class TextElementEnumerator implements System.Collections.IEnumerator {
			/** Gets the current text element in the string. */
			readonly Current: System.Object;

			/**
			 * Gets the index of the text element that the enumerator is currently positioned over.
			 */
			readonly ElementIndex: number;

			/** Gets the current text element in the string. */
			GetTextElement(): string;

			/** Advances the enumerator to the next text element of the string. */
			MoveNext(): boolean;

			/**
			 * Sets the enumerator to its initial position, which is before the first text element in
			 * the string.
			 */
			Reset(): void;
		}
	}

	export namespace System.Globalization {
		/**
		 * Defines text properties and behaviors, such as casing, that are specific to a writing
		 * system.
		 */
		export class TextInfo implements System.ICloneable {
			/**
			 * Gets the American National Standards Institute (ANSI) code page used by the writing
			 * system represented by the current {@link System.Globalization.TextInfo}.
			 */
			readonly ANSICodePage: number;

			/**
			 * Gets the name of the culture associated with the current
			 * {@link System.Globalization.TextInfo} object.
			 */
			readonly CultureName: string;

			/**
			 * Gets the Extended Binary Coded Decimal Interchange Code (EBCDIC) code page used by the
			 * writing system represented by the current {@link System.Globalization.TextInfo}.
			 */
			readonly EBCDICCodePage: number;

			/**
			 * Gets a value indicating whether the current {@link System.Globalization.TextInfo}
			 * object is read-only.
			 */
			readonly IsReadOnly: boolean;

			/**
			 * Gets a value indicating whether the current {@link System.Globalization.TextInfo}
			 * object represents a writing system where text flows from right to left.
			 */
			readonly IsRightToLeft: boolean;

			/**
			 * Gets the culture identifier for the culture associated with the current
			 * {@link System.Globalization.TextInfo} object.
			 */
			readonly LCID: number;

			/** Gets or sets the string that separates items in a list. */
			ListSeparator: string;

			/**
			 * Gets the Macintosh code page used by the writing system represented by the current
			 * {@link System.Globalization.TextInfo}.
			 */
			readonly MacCodePage: number;

			/**
			 * Gets the original equipment manufacturer (OEM) code page used by the writing system
			 * represented by the current {@link System.Globalization.TextInfo}.
			 */
			readonly OEMCodePage: number;

			/**
			 * Creates a new object that is a copy of the current
			 * {@link System.Globalization.TextInfo} object.
			 */
			Clone(): System.Object;

			/**
			 * Determines whether the specified object represents the same writing system as the
			 * current {@link System.Globalization.TextInfo} object.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/**
			 * Serves as a hash function for the current {@link System.Globalization.TextInfo},
			 * suitable for hashing algorithms and data structures, such as a hash table.
			 */
			GetHashCode(): number;

			/**
			 * Returns a read-only version of the specified {@link System.Globalization.TextInfo}
			 * object.
			 */
			static ReadOnly(textInfo: System.Globalization.TextInfo): System.Globalization.TextInfo;

			/** Converts the specified character to lowercase. */
			ToLower(c: System.Char): System.Char;

			/** Converts the specified string to lowercase. */
			ToLower(str: string): string;

			/**
			 * Returns a string that represents the current {@link System.Globalization.TextInfo}.
			 */
			ToString(): string;

			/**
			 * Converts the specified string to title case (except for words that are entirely in
			 * uppercase, which are considered to be acronyms).
			 */
			ToTitleCase(str: string): string;

			/** Converts the specified character to uppercase. */
			ToUpper(c: System.Char): System.Char;

			/** Converts the specified string to uppercase. */
			ToUpper(str: string): string;
		}
	}

	export namespace System.Globalization {
		/** Represents the Thai Buddhist calendar. */
		export class ThaiBuddhistCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.ThaiBuddhistCalendar}
			 * class.
			 */
			constructor();

			/**
			 * Gets a value indicating whether the current calendar is solar-based, lunar-based, or a
			 * combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/**
			 * Gets the list of eras in the {@link System.Globalization.ThaiBuddhistCalendar} class.
			 */
			readonly Eras: number[];

			/**
			 * Gets the latest date and time supported by the
			 * {@link System.Globalization.ThaiBuddhistCalendar} class.
			 */
			readonly MaxSupportedDateTime: js.DateTime;

			/**
			 * Gets the earliest date and time supported by the
			 * {@link System.Globalization.ThaiBuddhistCalendar} class.
			 */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of months away from the
			 * specified {@link System.DateTime}.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Returns a {@link System.DateTime} that is the specified number of years away from the
			 * specified {@link System.DateTime}.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/** Returns the day of the month in the specified {@link System.DateTime}. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Returns the day of the week in the specified {@link System.DateTime}. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Returns the day of the year in the specified {@link System.DateTime}. */
			GetDayOfYear(time: js.DateTime): number;

			/**
			 * Returns the number of days in the specified month in the specified year in the
			 * specified era.
			 */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Returns the number of days in the specified year in the specified era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Returns the era in the specified {@link System.DateTime}. */
			GetEra(time: js.DateTime): number;

			/** Calculates the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Returns the month in the specified {@link System.DateTime}. */
			GetMonth(time: js.DateTime): number;

			/** Returns the number of months in the specified year in the specified era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/**
			 * Returns the week of the year that includes the date in the specified
			 * {@link System.DateTime}.
			 */
			GetWeekOfYear(
				time: js.DateTime,
				rule: System.Globalization.CalendarWeekRule,
				firstDayOfWeek: System.DayOfWeek,
			): number;

			/** Returns the year in the specified {@link System.DateTime}. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date in the specified era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the specified era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * specified era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/**
			 * Converts the specified year to a four-digit year by using the
			 * {@link System.Globalization.ThaiBuddhistCalendar.TwoDigitYearMax} property to
			 * determine the appropriate century.
			 */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/**
		 * Defines the formatting options that customize string parsing for the
		 * {@link System.TimeSpan.ParseExact} and {@link System.TimeSpan.TryParseExact} methods.
		 */
		export enum TimeSpanStyles {
			/**
			 * Indicates that input is interpreted as a negative time interval only if a negative
			 * sign is present.
			 */
			None = 0,

			/** Indicates that input is always interpreted as a negative time interval. */
			AssumeNegative = 1,
		}
	}

	export namespace System.Globalization {
		/** Represents the Saudi Hijri (Um Al Qura) calendar. */
		export class UmAlQuraCalendar extends System.Globalization.Calendar implements System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Globalization.UmAlQuraCalendar} class.
			 */
			constructor();

			/**
			 * Gets a value indicating whether the current calendar is solar-based, lunar-based, or a
			 * combination of both.
			 */
			readonly AlgorithmType: System.Globalization.CalendarAlgorithmType;

			/**
			 * Gets a list of the eras that are supported by the current
			 * {@link System.Globalization.UmAlQuraCalendar}.
			 */
			readonly Eras: number[];

			/** Gets the latest date and time supported by this calendar. */
			readonly MaxSupportedDateTime: js.DateTime;

			/** Gets the earliest date and time supported by this calendar. */
			readonly MinSupportedDateTime: js.DateTime;

			/**
			 * Gets or sets the last year of a 100-year range that can be represented by a 2-digit
			 * year.
			 */
			TwoDigitYearMax: number;

			/**
			 * Calculates a date that is a specified number of months away from a specified initial
			 * date.
			 */
			AddMonths(
				time: js.DateTime,
				months: number,
			): js.DateTime;

			/**
			 * Calculates a date that is a specified number of years away from a specified initial
			 * date.
			 */
			AddYears(
				time: js.DateTime,
				years: number,
			): js.DateTime;

			/** Calculates the day of the month on which a specified date occurs. */
			GetDayOfMonth(time: js.DateTime): number;

			/** Calculates the day of the week on which a specified date occurs. */
			GetDayOfWeek(time: js.DateTime): System.DayOfWeek;

			/** Calculates the day of the year on which a specified date occurs. */
			GetDayOfYear(time: js.DateTime): number;

			/**
			 * Calculates the number of days in the specified month of the specified year and era.
			 */
			GetDaysInMonth(
				year: number,
				month: number,
				era: number,
			): number;

			/** Calculates the number of days in the specified year of the specified era. */
			GetDaysInYear(
				year: number,
				era: number,
			): number;

			/** Calculates the era in which a specified date occurs. */
			GetEra(time: js.DateTime): number;

			/** Calculates the leap month for a specified year and era. */
			GetLeapMonth(
				year: number,
				era: number,
			): number;

			/** Calculates the month in which a specified date occurs. */
			GetMonth(time: js.DateTime): number;

			/** Calculates the number of months in the specified year of the specified era. */
			GetMonthsInYear(
				year: number,
				era: number,
			): number;

			/** Calculates the year of a date represented by a specified {@link System.DateTime}. */
			GetYear(time: js.DateTime): number;

			/** Determines whether the specified date is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
				era: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year and era is a leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
				era: number,
			): boolean;

			/** Determines whether the specified year in the specified era is a leap year. */
			IsLeapYear(
				year: number,
				era: number,
			): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date, time, and era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
				era: number,
			): js.DateTime;

			/**
			 * Converts the specified year to a four-digit year by using the
			 * {@link System.Globalization.UmAlQuraCalendar.TwoDigitYearMax} property to determine
			 * the appropriate century.
			 */
			ToFourDigitYear(year: number): number;

			/** Returns the number of days in the specified month and year of the current era. */
			GetDaysInMonth(
				year: number,
				month: number,
			): number;

			/** Returns the number of days in the specified year of the current era. */
			GetDaysInYear(year: number): number;

			/** Calculates the leap month for a specified year. */
			GetLeapMonth(year: number): number;

			/** Returns the number of months in the specified year in the current era. */
			GetMonthsInYear(year: number): number;

			/** Determines whether the specified date in the current era is a leap day. */
			IsLeapDay(
				year: number,
				month: number,
				day: number,
			): boolean;

			/**
			 * Determines whether the specified month in the specified year in the current era is a
			 * leap month.
			 */
			IsLeapMonth(
				year: number,
				month: number,
			): boolean;

			/** Determines whether the specified year in the current era is a leap year. */
			IsLeapYear(year: number): boolean;

			/**
			 * Returns a {@link System.DateTime} that is set to the specified date and time in the
			 * current era.
			 */
			ToDateTime(
				year: number,
				month: number,
				day: number,
				hour: number,
				minute: number,
				second: number,
				millisecond: number,
			): js.DateTime;
		}
	}

	export namespace System.Globalization {
		/** Defines the Unicode category of a character. */
		export enum UnicodeCategory {
			/**
			 * Uppercase letter. Signified by the Unicode designation "Lu" (letter, uppercase). The
			 * value is 0.
			 */
			UppercaseLetter = 0,

			/**
			 * Lowercase letter. Signified by the Unicode designation "Ll" (letter, lowercase). The
			 * value is 1.
			 */
			LowercaseLetter = 1,

			/**
			 * Titlecase letter. Signified by the Unicode designation "Lt" (letter, titlecase). The
			 * value is 2.
			 */
			TitlecaseLetter = 2,

			/**
			 * Modifier letter character, which is free-standing spacing character that indicates
			 * modifications of a preceding letter. Signified by the Unicode designation "Lm"
			 * (letter, modifier). The value is 3.
			 */
			ModifierLetter = 3,

			/**
			 * Letter that is not an uppercase letter, a lowercase letter, a titlecase letter, or a
			 * modifier letter. Signified by the Unicode designation "Lo" (letter, other). The value
			 * is 4.
			 */
			OtherLetter = 4,

			/**
			 * Nonspacing character that indicates modifications of a base character. Signified by
			 * the Unicode designation "Mn" (mark, nonspacing). The value is 5.
			 */
			NonSpacingMark = 5,

			/**
			 * Spacing character that indicates modifications of a base character and affects the
			 * width of the glyph for that base character. Signified by the Unicode designation "Mc"
			 * (mark, spacing combining). The value is 6.
			 */
			SpacingCombiningMark = 6,

			/**
			 * Enclosing mark character, which is a nonspacing combining character that surrounds all
			 * previous characters up to and including a base character. Signified by the Unicode
			 * designation "Me" (mark, enclosing). The value is 7.
			 */
			EnclosingMark = 7,

			/**
			 * Decimal digit character, that is, a character representing an integer in the range 0
			 * through 9. Signified by the Unicode designation "Nd" (number, decimal digit). The
			 * value is 8.
			 */
			DecimalDigitNumber = 8,

			/**
			 * Number represented by a letter, instead of a decimal digit, for example, the Roman
			 * numeral for five, which is "V". The indicator is signified by the Unicode designation
			 * "Nl" (number, letter). The value is 9.
			 */
			LetterNumber = 9,

			/**
			 * Number that is neither a decimal digit nor a letter number, for example, the fraction
			 * 1/2. The indicator is signified by the Unicode designation "No" (number, other). The
			 * value is 10.
			 */
			OtherNumber = 10,

			/**
			 * Space character, which has no glyph but is not a control or format character.
			 * Signified by the Unicode designation "Zs" (separator, space). The value is 11.
			 */
			SpaceSeparator = 11,

			/**
			 * Character that is used to separate lines of text. Signified by the Unicode designation
			 * "Zl" (separator, line). The value is 12.
			 */
			LineSeparator = 12,

			/**
			 * Character used to separate paragraphs. Signified by the Unicode designation "Zp"
			 * (separator, paragraph). The value is 13.
			 */
			ParagraphSeparator = 13,

			/**
			 * Control code character, with a Unicode value of U+007F or in the range U+0000 through
			 * U+001F or U+0080 through U+009F. Signified by the Unicode designation "Cc" (other,
			 * control). The value is 14.
			 */
			Control = 14,

			/**
			 * Format character that affects the layout of text or the operation of text processes,
			 * but is not normally rendered. Signified by the Unicode designation "Cf" (other,
			 * format). The value is 15.
			 */
			Format = 15,

			/**
			 * High surrogate or a low surrogate character. Surrogate code values are in the range
			 * U+D800 through U+DFFF. Signified by the Unicode designation "Cs" (other, surrogate).
			 * The value is 16.
			 */
			Surrogate = 16,

			/**
			 * Private-use character, with a Unicode value in the range U+E000 through U+F8FF.
			 * Signified by the Unicode designation "Co" (other, private use). The value is 17.
			 */
			PrivateUse = 17,

			/**
			 * Connector punctuation character that connects two characters. Signified by the Unicode
			 * designation "Pc" (punctuation, connector). The value is 18.
			 */
			ConnectorPunctuation = 18,

			/**
			 * Dash or hyphen character. Signified by the Unicode designation "Pd" (punctuation,
			 * dash). The value is 19.
			 */
			DashPunctuation = 19,

			/**
			 * Opening character of one of the paired punctuation marks, such as parentheses, square
			 * brackets, and braces. Signified by the Unicode designation "Ps" (punctuation, open).
			 * The value is 20.
			 */
			OpenPunctuation = 20,

			/**
			 * Closing character of one of the paired punctuation marks, such as parentheses, square
			 * brackets, and braces. Signified by the Unicode designation "Pe" (punctuation, close).
			 * The value is 21.
			 */
			ClosePunctuation = 21,

			/**
			 * Opening or initial quotation mark character. Signified by the Unicode designation "Pi"
			 * (punctuation, initial quote). The value is 22.
			 */
			InitialQuotePunctuation = 22,

			/**
			 * Closing or final quotation mark character. Signified by the Unicode designation "Pf"
			 * (punctuation, final quote). The value is 23.
			 */
			FinalQuotePunctuation = 23,

			/**
			 * Punctuation character that is not a connector, a dash, open punctuation, close
			 * punctuation, an initial quote, or a final quote. Signified by the Unicode designation
			 * "Po" (punctuation, other). The value is 24.
			 */
			OtherPunctuation = 24,

			/**
			 * Mathematical symbol character, such as "+" or "= ". Signified by the Unicode
			 * designation "Sm" (symbol, math). The value is 25.
			 */
			MathSymbol = 25,

			/**
			 * Currency symbol character. Signified by the Unicode designation "Sc" (symbol,
			 * currency). The value is 26.
			 */
			CurrencySymbol = 26,

			/**
			 * Modifier symbol character, which indicates modifications of surrounding characters.
			 * For example, the fraction slash indicates that the number to the left is the numerator
			 * and the number to the right is the denominator. The indicator is signified by the
			 * Unicode designation "Sk" (symbol, modifier). The value is 27.
			 */
			ModifierSymbol = 27,

			/**
			 * Symbol character that is not a mathematical symbol, a currency symbol or a modifier
			 * symbol. Signified by the Unicode designation "So" (symbol, other). The value is 28.
			 */
			OtherSymbol = 28,

			/**
			 * Character that is not assigned to any Unicode category. Signified by the Unicode
			 * designation "Cn" (other, not assigned). The value is 29.
			 */
			OtherNotAssigned = 29,
		}
	}

	export namespace System.Diagnostics {
		/**
		 * Indicates to compilers that a method call or attribute should be ignored unless a
		 * specified conditional compilation symbol is defined.
		 */
		export class ConditionalAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Diagnostics.ConditionalAttribute}
			 * class.
			 */
			constructor(conditionString: string);

			/**
			 * Gets the conditional compilation symbol that is associated with the
			 * {@link System.Diagnostics.ConditionalAttribute} attribute.
			 */
			readonly ConditionString: string;
		}
	}

	export namespace System.Diagnostics {
		/** Provides a set of methods and properties that help debug your code. */
		export namespace Debug {
			/**
			 * Gets or sets a value indicating whether {@link System.Diagnostics.Debug.Flush} should
			 * be called on the {@link System.Diagnostics.Debug.Listeners} after every write.
			 */
			export var AutoFlush: boolean;

			/** Gets or sets the indent level. */
			export var IndentLevel: number;

			/** Gets or sets the number of spaces in an indent. */
			export var IndentSize: number;

			/**
			 * Checks for a condition; if the condition is `false`, displays a message box that shows
			 * the call stack.
			 */
			export function Assert(condition: boolean): void;

			export function Assert(
				condition: boolean,
				message: System.Diagnostics.Debug.AssertInterpolatedStringHandler | undefined,
			): void;

			export function Assert(
				condition: boolean,
				message: System.Diagnostics.Debug.AssertInterpolatedStringHandler | undefined,
				detailMessage: System.Diagnostics.Debug.AssertInterpolatedStringHandler | undefined,
			): void;

			/**
			 * Checks for a condition; if the condition is `false`, outputs a specified message and
			 * displays a message box that shows the call stack.
			 */
			export function Assert(
				condition: boolean,
				message: string | undefined,
			): void;

			/**
			 * Checks for a condition; if the condition is `false`, outputs two specified messages
			 * and displays a message box that shows the call stack.
			 */
			export function Assert(
				condition: boolean,
				message: string | undefined,
				detailMessage: string | undefined,
			): void;

			/**
			 * Checks for a condition; if the condition is `false`, outputs two messages (simple and
			 * formatted) and displays a message box that shows the call stack.
			 */
			export function Assert(
				condition: boolean,
				message: string | undefined,
				detailMessageFormat: string,
				args: System.Object | undefined[],
			): void;

			/**
			 * Flushes the output buffer and then calls the `Close` method on each of the
			 * {@link System.Diagnostics.Debug.Listeners}.
			 */
			export function Close(): void;

			/** Emits the specified error message. */
			export function Fail(message: string | undefined): void;

			/** Emits an error message and a detailed error message. */
			export function Fail(
				message: string | undefined,
				detailMessage: string | undefined,
			): void;

			/**
			 * Flushes the output buffer and causes buffered data to write to the
			 * {@link System.Diagnostics.Debug.Listeners} collection.
			 */
			export function Flush(): void;

			/** Increases the current {@link System.Diagnostics.Debug.IndentLevel} by one. */
			export function Indent(): void;

			/**
			 * Writes a message followed by a line terminator to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection.
			 */
			export function Print(message: string | undefined): void;

			/**
			 * Writes a formatted string followed by a line terminator to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection.
			 */
			export function Print(
				format: string,
				args: System.Object | undefined[],
			): void;

			/** Decreases the current {@link System.Diagnostics.Debug.IndentLevel} by one. */
			export function Unindent(): void;

			/**
			 * Writes the value of the object's {@link System.Object.ToString} method to the trace
			 * listeners in the {@link System.Diagnostics.Debug.Listeners} collection.
			 */
			export function Write(value: System.Object | undefined): void;

			/**
			 * Writes a category name and the value of the object's {@link System.Object.ToString}
			 * method to the trace listeners in the {@link System.Diagnostics.Debug.Listeners}
			 * collection.
			 */
			export function Write(
				value: System.Object | undefined,
				category: string | undefined,
			): void;

			/**
			 * Writes a message to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection.
			 */
			export function Write(message: string | undefined): void;

			/**
			 * Writes a category name and message to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection.
			 */
			export function Write(
				message: string | undefined,
				category: string | undefined,
			): void;

			export function WriteIf(
				condition: boolean,
				message: System.Diagnostics.Debug.WriteIfInterpolatedStringHandler | undefined,
			): void;

			export function WriteIf(
				condition: boolean,
				message: System.Diagnostics.Debug.WriteIfInterpolatedStringHandler | undefined,
				category: string | undefined,
			): void;

			/**
			 * Writes the value of the object's {@link System.Object.ToString} method to the trace
			 * listeners in the {@link System.Diagnostics.Debug.Listeners} collection if a condition
			 * is `true`.
			 */
			export function WriteIf(
				condition: boolean,
				value: System.Object | undefined,
			): void;

			/**
			 * Writes a category name and the value of the object's {@link System.Object.ToString}
			 * method to the trace listeners in the {@link System.Diagnostics.Debug.Listeners}
			 * collection if a condition is `true`.
			 */
			export function WriteIf(
				condition: boolean,
				value: System.Object | undefined,
				category: string | undefined,
			): void;

			/**
			 * Writes a message to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection if a condition is `true`.
			 */
			export function WriteIf(
				condition: boolean,
				message: string | undefined,
			): void;

			/**
			 * Writes a category name and message to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection if a condition is `true`.
			 */
			export function WriteIf(
				condition: boolean,
				message: string | undefined,
				category: string | undefined,
			): void;

			/**
			 * Writes the value of the object's {@link System.Object.ToString} method to the trace
			 * listeners in the {@link System.Diagnostics.Debug.Listeners} collection.
			 */
			export function WriteLine(value: System.Object | undefined): void;

			/**
			 * Writes a category name and the value of the object's {@link System.Object.ToString}
			 * method to the trace listeners in the {@link System.Diagnostics.Debug.Listeners}
			 * collection.
			 */
			export function WriteLine(
				value: System.Object | undefined,
				category: string | undefined,
			): void;

			/**
			 * Writes a message followed by a line terminator to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection.
			 */
			export function WriteLine(message: string | undefined): void;

			/**
			 * Writes a formatted message followed by a line terminator to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection.
			 */
			export function WriteLine(
				format: string,
				args: System.Object | undefined[],
			): void;

			/**
			 * Writes a category name and message to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection.
			 */
			export function WriteLine(
				message: string | undefined,
				category: string | undefined,
			): void;

			export function WriteLineIf(
				condition: boolean,
				message: System.Diagnostics.Debug.WriteIfInterpolatedStringHandler | undefined,
			): void;

			export function WriteLineIf(
				condition: boolean,
				message: System.Diagnostics.Debug.WriteIfInterpolatedStringHandler | undefined,
				category: string | undefined,
			): void;

			/**
			 * Writes the value of the object's {@link System.Object.ToString} method to the trace
			 * listeners in the {@link System.Diagnostics.Debug.Listeners} collection if a condition
			 * is `true`.
			 */
			export function WriteLineIf(
				condition: boolean,
				value: System.Object | undefined,
			): void;

			/**
			 * Writes a category name and the value of the object's {@link System.Object.ToString}
			 * method to the trace listeners in the {@link System.Diagnostics.Debug.Listeners}
			 * collection if a condition is `true`.
			 */
			export function WriteLineIf(
				condition: boolean,
				value: System.Object | undefined,
				category: string | undefined,
			): void;

			/**
			 * Writes a message to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection if a condition is `true`.
			 */
			export function WriteLineIf(
				condition: boolean,
				message: string | undefined,
			): void;

			/**
			 * Writes a category name and message to the trace listeners in the
			 * {@link System.Diagnostics.Debug.Listeners} collection if a condition is `true`.
			 */
			export function WriteLineIf(
				condition: boolean,
				message: string | undefined,
				category: string | undefined,
			): void;
		}
	}

	export namespace System.Diagnostics.Debug {
		export class AssertInterpolatedStringHandler extends System.ValueType {
			constructor(
				literalLength: number,
				formattedCount: number,
				condition: boolean,
			);

			AppendFormatted(
				value: System.Object | undefined,
				alignment?: number,
				format?: string,
			): void;

			AppendFormatted(value: System.ReadOnlySpan$1<System.Char>): void;

			AppendFormatted(
				value: System.ReadOnlySpan$1<System.Char>,
				alignment?: number,
				format?: string,
			): void;

			AppendFormatted(value: string | undefined): void;

			AppendFormatted(
				value: string | undefined,
				alignment?: number,
				format?: string,
			): void;

			AppendFormatted<T>(value: T): void;

			AppendFormatted<T>(
				value: T,
				alignment: number,
			): void;

			AppendFormatted<T>(
				value: T,
				alignment: number,
				format: string | undefined,
			): void;

			AppendFormatted<T>(
				value: T,
				format: string | undefined,
			): void;

			AppendLiteral(value: string): void;
		}
	}

	export namespace System.Diagnostics.Debug {
		export class WriteIfInterpolatedStringHandler extends System.ValueType {
			constructor(
				literalLength: number,
				formattedCount: number,
				condition: boolean,
			);

			AppendFormatted(
				value: System.Object | undefined,
				alignment?: number,
				format?: string,
			): void;

			AppendFormatted(value: System.ReadOnlySpan$1<System.Char>): void;

			AppendFormatted(
				value: System.ReadOnlySpan$1<System.Char>,
				alignment?: number,
				format?: string,
			): void;

			AppendFormatted(value: string | undefined): void;

			AppendFormatted(
				value: string | undefined,
				alignment?: number,
				format?: string,
			): void;

			AppendFormatted<T>(value: T): void;

			AppendFormatted<T>(
				value: T,
				alignment: number,
			): void;

			AppendFormatted<T>(
				value: T,
				alignment: number,
				format: string | undefined,
			): void;

			AppendFormatted<T>(
				value: T,
				format: string | undefined,
			): void;

			AppendLiteral(value: string): void;
		}
	}

	export namespace System.Diagnostics {
		/**
		 * Modifies code generation for runtime just-in-time (JIT) debugging. This class cannot
		 * be inherited.
		 */
		export class DebuggableAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Diagnostics.DebuggableAttribute}
			 * class, using the specified tracking and optimization options for the just-in-time
			 * (JIT) compiler.
			 */
			constructor(
				isJITTrackingEnabled: boolean,
				isJITOptimizerDisabled: boolean,
			);

			constructor(modes: System.Diagnostics.DebuggableAttribute.DebuggingModes);

			/** Gets the debugging modes for the attribute. */
			readonly DebuggingFlags: System.Diagnostics.DebuggableAttribute.DebuggingModes;

			/** Gets a value that indicates whether the runtime optimizer is disabled. */
			readonly IsJITOptimizerDisabled: boolean;

			/**
			 * Gets a value that indicates whether the runtime will track information during code
			 * generation for the debugger.
			 */
			readonly IsJITTrackingEnabled: boolean;
		}
	}

	export namespace System.Diagnostics.DebuggableAttribute {
		export enum DebuggingModes {
			None = 0,

			Default = 1,

			IgnoreSymbolStoreSequencePoints = 2,

			EnableEditAndContinue = 4,

			DisableOptimizations = 256,
		}
	}

	export namespace System.Diagnostics {
		/** Enables communication with a debugger. This class cannot be inherited. */
		export namespace Debugger {
			/** Gets a value that indicates whether a debugger is attached to the process. */
			export const IsAttached: boolean;

			/** Signals a breakpoint to an attached debugger. */
			export function Break(): void;

			/** Checks to see if logging is enabled by an attached debugger. */
			export function IsLogging(): boolean;

			/** Launches and attaches a debugger to the process. */
			export function Launch(): boolean;

			/** Posts a message for the attached debugger. */
			export function Log(
				level: number,
				category: string | undefined,
				message: string | undefined,
			): void;

			/**
			 * Notifies a debugger that execution is about to enter a path that involves a
			 * cross-thread dependency.
			 */
			export function NotifyOfCrossThreadDependency(): void;
		}
	}

	export namespace System.Diagnostics {
		/**
		 * Determines if and how a member is displayed in the debugger variable windows. This
		 * class cannot be inherited.
		 */
		export class DebuggerBrowsableAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerBrowsableAttribute} class.
			 */
			constructor(state: System.Diagnostics.DebuggerBrowsableState);

			/** Gets the display state for the attribute. */
			readonly State: System.Diagnostics.DebuggerBrowsableState;
		}
	}

	export namespace System.Diagnostics {
		/** Provides display instructions for the debugger. */
		export enum DebuggerBrowsableState {
			/** Never show the element. */
			Never = 0,

			/** Show the element as collapsed. */
			Collapsed = 2,

			/**
			 * Do not display the root element; display the child elements if the element is a
			 * collection or array of items.
			 */
			RootHidden = 3,
		}
	}

	export namespace System.Diagnostics {
		/** Determines how a class or field is displayed in the debugger variable windows. */
		export class DebuggerDisplayAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Diagnostics.DebuggerDisplayAttribute}
			 * class.
			 */
			constructor(value: string | undefined);

			/** Gets or sets the name to display in the debugger variable windows. */
			Name?: string;

			/** Gets or sets the type of the attribute's target. */
			Target?: System.Type;

			/** Gets or sets the type name of the attribute's target. */
			TargetTypeName?: string;

			/**
			 * Gets or sets the string to display in the type column of the debugger variable
			 * windows.
			 */
			Type?: string;

			/** Gets the string to display in the value column of the debugger variable windows. */
			readonly Value: string;
		}
	}

	export namespace System.Diagnostics {
		/**
		 * Specifies the {@link System.Diagnostics.DebuggerHiddenAttribute}. This class cannot be
		 * inherited.
		 */
		export class DebuggerHiddenAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Diagnostics.DebuggerHiddenAttribute}
			 * class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics {
		/** Identifies a type or member that is not part of the user code for an application. */
		export class DebuggerNonUserCodeAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerNonUserCodeAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics {
		/**
		 * Indicates the code following the attribute is to be executed in run, not step, mode.
		 */
		export class DebuggerStepperBoundaryAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerStepperBoundaryAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics {
		/**
		 * Instructs the debugger to step through the code instead of stepping into the code.
		 * This class cannot be inherited.
		 */
		export class DebuggerStepThroughAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerStepThroughAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics {
		/** Specifies the display proxy for a type. */
		export class DebuggerTypeProxyAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerTypeProxyAttribute} class using the type name of the
			 * proxy.
			 */
			constructor(typeName: string);

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerTypeProxyAttribute} class using the type of the
			 * proxy.
			 */
			constructor(type: System.Type);

			/** Gets the type name of the proxy type. */
			readonly ProxyTypeName: string;

			/** Gets or sets the target type for the attribute. */
			Target?: System.Type;

			/** Gets or sets the name of the target type. */
			TargetTypeName?: string;
		}
	}

	export namespace System.Diagnostics {
		/** Specifies that the type has a visualizer. This class cannot be inherited. */
		export class DebuggerVisualizerAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerVisualizerAttribute} class, specifying the type name
			 * of the visualizer.
			 */
			constructor(visualizerTypeName: string);

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerVisualizerAttribute} class, specifying the type name
			 * of the visualizer and the type name of the visualizer object source.
			 */
			constructor(
				visualizerTypeName: string,
				visualizerObjectSourceTypeName: string | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerVisualizerAttribute} class, specifying the type name
			 * of the visualizer and the type of the visualizer object source.
			 */
			constructor(
				visualizerTypeName: string,
				visualizerObjectSource: System.Type,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerVisualizerAttribute} class, specifying the type of
			 * the visualizer.
			 */
			constructor(visualizer: System.Type);

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerVisualizerAttribute} class, specifying the type of
			 * the visualizer and the type name of the visualizer object source.
			 */
			constructor(
				visualizer: System.Type,
				visualizerObjectSourceTypeName: string | undefined,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.DebuggerVisualizerAttribute} class, specifying the type of
			 * the visualizer and the type of the visualizer object source.
			 */
			constructor(
				visualizer: System.Type,
				visualizerObjectSource: System.Type,
			);

			/** Gets or sets the description of the visualizer. */
			Description?: string;

			/** Gets or sets the target type when the attribute is applied at the assembly level. */
			Target?: System.Type;

			/**
			 * Gets or sets the fully qualified type name when the attribute is applied at the
			 * assembly level.
			 */
			TargetTypeName?: string;

			/** Gets the fully qualified type name of the visualizer object source. */
			readonly VisualizerObjectSourceTypeName?: string;

			/** Gets the fully qualified type name of the visualizer. */
			readonly VisualizerTypeName: string;
		}
	}

	export namespace System.Diagnostics {
		/**
		 * Types and Methods attributed with StackTraceHidden will be omitted from the stack
		 * trace text shown in StackTrace.ToString() and Exception.StackTrace
		 */
		export class StackTraceHiddenAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.Diagnostics.StackTraceHiddenAttribute}
			 * class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics {
		/**
		 * Provides a set of methods and properties that you can use to accurately measure
		 * elapsed time.
		 */
		export class Stopwatch {
			/** Initializes a new instance of the {@link System.Diagnostics.Stopwatch} class. */
			constructor();

			/** Gets the total elapsed time measured by the current instance. */
			readonly Elapsed: number;

			/** Gets the total elapsed time measured by the current instance, in milliseconds. */
			readonly ElapsedMilliseconds: number;

			/** Gets the total elapsed time measured by the current instance, in timer ticks. */
			readonly ElapsedTicks: number;

			/**
			 * Gets a value indicating whether the {@link System.Diagnostics.Stopwatch} timer is
			 * running.
			 */
			readonly IsRunning: boolean;

			/** Gets the current number of ticks in the timer mechanism. */
			static GetTimestamp(): number;

			/**
			 * Gets the elapsed time since the `startingTimestamp` value retrieved using
			 * {@link System.Diagnostics.Stopwatch.GetTimestamp}.
			 */
			static GetElapsedTime(startingTimestamp: number): number;

			/**
			 * Gets the elapsed time between two timestamps retrieved using
			 * {@link System.Diagnostics.Stopwatch.GetTimestamp}.
			 */
			static GetElapsedTime(
				startingTimestamp: number,
				endingTimestamp: number,
			): number;

			/** Stops time interval measurement and resets the elapsed time to zero. */
			Reset(): void;

			/**
			 * Stops time interval measurement, resets the elapsed time to zero, and starts measuring
			 * elapsed time.
			 */
			Restart(): void;

			/** Starts, or resumes, measuring elapsed time for an interval. */
			Start(): void;

			/**
			 * Initializes a new {@link System.Diagnostics.Stopwatch} instance, sets the elapsed time
			 * property to zero, and starts measuring elapsed time.
			 */
			static StartNew(): System.Diagnostics.Stopwatch;

			/** Stops measuring elapsed time for an interval. */
			Stop(): void;

			/** Returns the {@link System.Diagnostics.Stopwatch.Elapsed} time as a string. */
			ToString(): string;
		}
	}

	export namespace System.Diagnostics {
		/**
		 * The exception that is thrown when the program executes an instruction that was thought
		 * to be unreachable.
		 */
		export class UnreachableException extends System.Exception {
			/**
			 * Initializes a new instance of the {@link System.Diagnostics.UnreachableException}
			 * class with the default error message.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Diagnostics.UnreachableException}
			 * class with a specified error message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.Diagnostics.UnreachableException}
			 * class with a specified error message and a reference to the inner exception that is
			 * the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that `null` is allowed as an input even if the corresponding type disallows
		 * it.
		 */
		export class AllowNullAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.AllowNullAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/** Indicates that the specified method parameter expects a constant. */
		export class ConstantExpectedAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute} class.
			 */
			constructor();

			/** Gets or sets the maximum bound of the expected constant, inclusive. */
			Max?: System.Object;

			/** Gets or sets the minimum bound of the expected constant, inclusive. */
			Min?: System.Object;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that `null` is disallowed as an input even if the corresponding type allows
		 * it.
		 */
		export class DisallowNullAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.DisallowNullAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/** Specifies that a method that will never return under any circumstance. */
		export class DoesNotReturnAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that the method will not return if the associated {@link System.Boolean}
		 * parameter is passed the specified value.
		 */
		export class DoesNotReturnIfAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute} class with the
			 * specified parameter value.
			 */
			constructor(parameterValue: boolean);

			/** Gets the condition parameter value. */
			readonly ParameterValue: boolean;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Indicates that certain members on a specified {@link System.Type} are accessed
		 * dynamically, for example, through {@link System.Reflection}.
		 */
		export class DynamicallyAccessedMembersAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute} class with
			 * the specified member types.
			 */
			constructor(memberTypes: System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes);

			/**
			 * Gets the {@link System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes} that
			 * specifies the type of dynamically accessed members.
			 */
			readonly MemberTypes: System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies the types of members that are dynamically accessed. This enumeration has a
		 * {@link System.FlagsAttribute} attribute that allows a bitwise combination of its
		 * member values.
		 */
		export enum DynamicallyAccessedMemberTypes {
			/** Specifies all members. */
			All = -1,

			/** Specifies no members. */
			None = 0,

			/** Specifies the default, parameterless public constructor. */
			PublicParameterlessConstructor = 1,

			/** Specifies all public constructors. */
			PublicConstructors = 3,

			/** Specifies all non-public constructors. */
			NonPublicConstructors = 4,

			/** Specifies all public methods. */
			PublicMethods = 8,

			/** Specifies all non-public methods. */
			NonPublicMethods = 16,

			/** Specifies all public fields. */
			PublicFields = 32,

			/** Specifies all non-public fields. */
			NonPublicFields = 64,

			/** Specifies all public nested types. */
			PublicNestedTypes = 128,

			/** Specifies all non-public nested types. */
			NonPublicNestedTypes = 256,

			/** Specifies all public properties. */
			PublicProperties = 512,

			/** Specifies all non-public properties. */
			NonPublicProperties = 1024,

			/** Specifies all public events. */
			PublicEvents = 2048,

			/** Specifies all non-public events. */
			NonPublicEvents = 4096,

			/** Specifies all interfaces implemented by the type. */
			Interfaces = 8192,
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/** States a dependency that one member has on another. */
		export class DynamicDependencyAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute} class with the
			 * specified types of members on a type in an assembly.
			 */
			constructor(
				memberTypes: System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes,
				typeName: string,
				assemblyName: string,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute} class with the
			 * specified types of members on a {@link System.Type}.
			 */
			constructor(
				memberTypes: System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes,
				type: System.Type,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute} class with the
			 * specified signature of a member on the same type as the consumer.
			 */
			constructor(memberSignature: string);

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute} class with the
			 * specified signature of a member on a type in an assembly.
			 */
			constructor(
				memberSignature: string,
				typeName: string,
				assemblyName: string,
			);

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute} class with the
			 * specified signature of a member on a {@link System.Type}.
			 */
			constructor(
				memberSignature: string,
				type: System.Type,
			);

			/** Gets the assembly name of the specified type. */
			readonly AssemblyName?: string;

			/** Gets or sets the condition in which the dependency is applicable. */
			Condition?: string;

			/** Gets the signature of the member depended on. */
			readonly MemberSignature?: string;

			/**
			 * Gets the types of the members that are depended on, for example, fields and
			 * properties.
			 */
			readonly MemberTypes: System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes;

			/** Gets the {@link System.Type} containing the specified member. */
			readonly Type?: System.Type;

			/** Gets the full name of the type containing the specified member. */
			readonly TypeName?: string;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that the attributed code should be excluded from code coverage information.
		 */
		export class ExcludeFromCodeCoverageAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute} class.
			 */
			constructor();

			/** Gets or sets the justification for excluding the member from code coverage. */
			Justification?: string;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/** Indicates that an API is experimental and it may change in the future. */
		export class ExperimentalAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.ExperimentalAttribute} class, specifying the ID
			 * that the compiler will use when reporting a use of the API the attribute applies to.
			 */
			constructor(diagnosticId: string);

			/**
			 * Gets the ID that the compiler will use when reporting a use of the API the attribute
			 * applies to.
			 */
			readonly DiagnosticId: string;

			/**
			 * Gets or sets the URL for corresponding documentation. The API accepts a format string
			 * instead of an actual URL, creating a generic URL that includes the diagnostic ID.
			 */
			UrlFormat?: string;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that an output may be `null` even if the corresponding type disallows it.
		 */
		export class MaybeNullAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.MaybeNullAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that when a method returns
		 * {@link System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue}, the
		 * parameter may be `null` even if the corresponding type disallows it.
		 */
		export class MaybeNullWhenAttribute extends System.Attribute {
			/** Initializes the attribute with the specified return value condition. */
			constructor(returnValue: boolean);

			/** Gets the return value condition. */
			readonly ReturnValue: boolean;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that the method or property will ensure that the listed field and property
		 * members have values that aren't `null`.
		 */
		export class MemberNotNullAttribute extends System.Attribute {
			/** Initializes the attribute with a field or property member. */
			constructor(member: string);

			/** Initializes the attribute with the list of field and property members. */
			constructor(members: string[]);

			/** Gets field or property member names. */
			readonly Members: string[];
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that the method or property will ensure that the listed field and property
		 * members have non-null values when returning with the specified return value condition.
		 */
		export class MemberNotNullWhenAttribute extends System.Attribute {
			/**
			 * Initializes the attribute with the specified return value condition and a field or
			 * property member.
			 */
			constructor(
				returnValue: boolean,
				member: string,
			);

			/**
			 * Initializes the attribute with the specified return value condition and list of field
			 * and property members.
			 */
			constructor(
				returnValue: boolean,
				members: string[],
			);

			/** Gets field or property member names. */
			readonly Members: string[];

			/** Gets the return value condition. */
			readonly ReturnValue: boolean;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that an output is not `null` even if the corresponding type allows it.
		 * Specifies that an input argument was not `null` when the call returns.
		 */
		export class NotNullAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.NotNullAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/** Specifies that the output will be non-null if the named parameter is non-null. */
		export class NotNullIfNotNullAttribute extends System.Attribute {
			/** Initializes the attribute with the associated parameter name. */
			constructor(parameterName: string);

			/** Gets the associated parameter name. */
			readonly ParameterName: string;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that when a method returns
		 * {@link System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue}, the
		 * parameter will not be `null` even if the corresponding type allows it.
		 */
		export class NotNullWhenAttribute extends System.Attribute {
			/** Initializes the attribute with the specified return value condition. */
			constructor(returnValue: boolean);

			/** Gets the return value condition. */
			readonly ReturnValue: boolean;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/** Used to indicate a byref escapes and is not scoped. */
		export class UnscopedRefAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.UnscopedRefAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/** Indicates that the specified member requires assembly files to be on disk. */
		export class RequiresAssemblyFilesAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.RequiresAssemblyFilesAttribute} class.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.RequiresAssemblyFilesAttribute} class.
			 */
			constructor(message: string);

			/**
			 * Gets an optional message that contains information about the need for assembly files
			 * to be on disk.
			 */
			readonly Message?: string;

			/**
			 * Gets or sets an optional URL that contains more information about the member, why it
			 * requires assembly files to be on disk, and what options a consumer has to deal with
			 * it.
			 */
			Url?: string;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Indicates that the specified method requires the ability to generate new code at
		 * runtime, for example through {@link System.Reflection}.
		 */
		export class RequiresDynamicCodeAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute} class with the
			 * specified message.
			 */
			constructor(message: string);

			/** Gets a message that contains information about the usage of dynamic code. */
			readonly Message: string;

			/**
			 * Gets or sets an optional URL that contains more information about the method, why it
			 * requires dynamic code, and what options a consumer has to deal with it.
			 */
			Url?: string;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Indicates that the specified method requires dynamic access to code that is not
		 * referenced statically, for example, through {@link System.Reflection}.
		 */
		export class RequiresUnreferencedCodeAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute} class with
			 * the specified message.
			 */
			constructor(message: string);

			/** Gets a message that contains information about the usage of unreferenced code. */
			readonly Message: string;

			/**
			 * Gets or sets an optional URL that contains more information about the method, why it
			 * requires unreferenced code, and what options a consumer has to deal with it.
			 */
			Url?: string;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Specifies that this constructor sets all required members for the current type, and
		 * callers do not need to set any required members themselves.
		 */
		export class SetsRequiredMembersAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute} class.
			 */
			constructor();
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/** Specifies the syntax used in a string. */
		export class StringSyntaxAttribute extends System.Attribute {
			/**
			 * Initializes the {@link System.Diagnostics.CodeAnalysis.StringSyntaxAttribute} with the
			 * identifier of the syntax used.
			 */
			constructor(syntax: string);

			/**
			 * Initializes the {@link System.Diagnostics.CodeAnalysis.StringSyntaxAttribute} with the
			 * identifier of the syntax used.
			 */
			constructor(
				syntax: string,
				_arguments: System.Object | undefined[],
			);

			/** Gets the identifier of the syntax used. */
			readonly Syntax: string;

			/** Gets the optional arguments associated with the specific syntax employed. */
			readonly Arguments: System.Object | undefined[];
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Suppresses reporting of a specific code analysis rule violation, allowing multiple
		 * suppressions on a single code artifact. Does not apply to compiler diagnostics.
		 */
		export class SuppressMessageAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.SuppressMessageAttribute} class, specifying the
			 * category of the code analysis tool and the identifier for an analysis rule.
			 */
			constructor(
				category: string,
				checkId: string,
			);

			/** Gets the category identifying the classification of the attribute. */
			readonly Category: string;

			/** Gets the identifier of the code analysis tool rule to be suppressed. */
			readonly CheckId: string;

			/** Gets or sets the justification for suppressing the code analysis message. */
			Justification?: string;

			/** Gets or sets the expanded exclusion criteria. */
			MessageId?: string;

			/** Gets or sets the scope of the code that is relevant for the attribute. */
			Scope?: string;

			/** Gets or sets a fully qualified path that represents the code analysis target. */
			Target?: string;
		}
	}

	export namespace System.Diagnostics.CodeAnalysis {
		/**
		 * Suppresses reporting of a specific rule violation, allowing multiple suppressions on a
		 * single code artifact.
		 */
		export class UnconditionalSuppressMessageAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute} class,
			 * specifying the category of the tool and the identifier for an analysis rule.
			 */
			constructor(
				category: string,
				checkId: string,
			);

			/** Gets the category identifying the classification of the attribute. */
			readonly Category: string;

			/** Gets the identifier of the analysis tool rule to be suppressed. */
			readonly CheckId: string;

			/** Gets or sets the justification for suppressing the code analysis message. */
			Justification?: string;

			/** Gets or sets an optional argument expanding on exclusion criteria. */
			MessageId?: string;

			/** Gets or sets the scope of the code that is relevant for the attribute. */
			Scope?: string;

			/** Gets or sets a fully qualified path that represents the target of the attribute. */
			Target?: string;
		}
	}

	export namespace System.Configuration.Assemblies {
		/**
		 * Specifies all the hash algorithms used for hashing files and for generating the strong
		 * name.
		 */
		export enum AssemblyHashAlgorithm {
			/**
			 * A mask indicating that there is no hash algorithm. If you specify `None` for a
			 * multi-module assembly, the common language runtime defaults to the SHA1 algorithm,
			 * since multi-module assemblies need to generate a hash. Due to collision problems with
			 * SHA1, Microsoft recommends SHA256.
			 */
			None = 0,

			/**
			 * Retrieves the MD5 message-digest algorithm. MD5 was developed by Rivest in 1991. It is
			 * basically MD4 with safety-belts and while it is slightly slower than MD4, it helps
			 * provide more security. The algorithm consists of four distinct rounds, which has a
			 * slightly different design from that of MD4. Message-digest size, as well as padding
			 * requirements, remain the same.
			 */
			MD5 = 32771,

			/**
			 * A mask used to retrieve a revision of the Secure Hash Algorithm that corrects an
			 * unpublished flaw in SHA.
			 */
			SHA1 = 32772,

			/**
			 * A mask used to retrieve a version of the Secure Hash Algorithm with a hash size of 256
			 * bits.
			 */
			SHA256 = 32780,

			/**
			 * A mask used to retrieve a version of the Secure Hash Algorithm with a hash size of 384
			 * bits.
			 */
			SHA384 = 32781,

			/**
			 * A mask used to retrieve a version of the Secure Hash Algorithm with a hash size of 512
			 * bits.
			 */
			SHA512 = 32782,
		}
	}

	export namespace System.Configuration.Assemblies {
		/** Defines the different types of assembly version compatibility. */
		export enum AssemblyVersionCompatibility {
			/**
			 * The assembly cannot execute with other versions if they are executing on the same
			 * machine.
			 */
			SameMachine = 1,

			/**
			 * The assembly cannot execute with other versions if they are executing in the same
			 * process.
			 */
			SameProcess = 2,

			/**
			 * The assembly cannot execute with other versions if they are executing in the same
			 * application domain.
			 */
			SameDomain = 3,
		}
	}

	export namespace System.ComponentModel {
		/** Specifies the default value for a property. */
		export class DefaultValueAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a {@link System.Boolean} value.
			 */
			constructor(value: boolean);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using an 8-bit unsigned integer.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a Unicode character.
			 */
			constructor(value: System.Char);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a double-precision floating point number.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a 16-bit signed integer.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a 32-bit signed integer.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a 64-bit signed integer.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class.
			 */
			constructor(value: System.Object | undefined);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a {@link System.SByte} value.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a single-precision floating point number.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a {@link System.String}.
			 */
			constructor(value: string | undefined);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class, converting the specified value to the specified type, and using an invariant
			 * culture as the translation context.
			 */
			constructor(
				type: System.Type,
				value: string | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a {@link System.UInt16} value.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a {@link System.UInt32} value.
			 */
			constructor(value: number);

			/**
			 * Initializes a new instance of the {@link System.ComponentModel.DefaultValueAttribute}
			 * class using a {@link System.UInt64} value.
			 */
			constructor(value: number);

			/** Gets the default value of the property this attribute is bound to. */
			readonly Value?: System.Object;

			/**
			 * Returns whether the value of the given object is equal to the current
			 * {@link System.ComponentModel.DefaultValueAttribute}.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;
		}
	}

	export namespace System.ComponentModel {
		/**
		 * Specifies that a class or member is viewable in an editor. This class cannot be
		 * inherited.
		 */
		export class EditorBrowsableAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.ComponentModel.EditorBrowsableAttribute} class with
			 * {@link System.ComponentModel.EditorBrowsableAttribute.State} set to the default state.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.ComponentModel.EditorBrowsableAttribute} class with an
			 * {@link System.ComponentModel.EditorBrowsableState}.
			 */
			constructor(state: System.ComponentModel.EditorBrowsableState);

			/** Gets the browsable state of the property or method. */
			readonly State: System.ComponentModel.EditorBrowsableState;

			/**
			 * Returns whether the value of the given object is equal to the current
			 * {@link System.ComponentModel.EditorBrowsableAttribute}.
			 */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;
		}
	}

	export namespace System.ComponentModel {
		/** Specifies the browsable state of a property or method from within an editor. */
		export enum EditorBrowsableState {
			/** The property or method is always browsable from within an editor. */
			Always = 0,

			/** The property or method is never browsable from within an editor. */
			Never = 1,

			/**
			 * The property or method is a feature that only advanced users should see. An editor can
			 * either show or hide such properties.
			 */
			Advanced = 2,
		}
	}

	export namespace System.Collections {
		/**
		 * Implements the {@link System.Collections.IList} interface using an array whose size is
		 * dynamically increased as required.
		 */
		export class ArrayList implements
			System.Collections.ICollection,
			System.Collections.IEnumerable,
			System.Collections.IList,
			System.ICloneable {
			/**
			 * Initializes a new instance of the {@link System.Collections.ArrayList} class that is
			 * empty and has the default initial capacity.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Collections.ArrayList} class that
			 * contains elements copied from the specified collection and that has the same initial
			 * capacity as the number of elements copied.
			 */
			constructor(c: System.Collections.ICollection);

			/**
			 * Initializes a new instance of the {@link System.Collections.ArrayList} class that is
			 * empty and has the specified initial capacity.
			 */
			constructor(capacity: number);

			/**
			 * Gets or sets the number of elements that the {@link System.Collections.ArrayList} can
			 * contain.
			 */
			Capacity: number;

			/**
			 * Gets the number of elements actually contained in the
			 * {@link System.Collections.ArrayList}.
			 */
			readonly Count: number;

			/**
			 * Gets a value indicating whether the {@link System.Collections.ArrayList} has a fixed
			 * size.
			 */
			readonly IsFixedSize: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Collections.ArrayList} is read-only.
			 */
			readonly IsReadOnly: boolean;

			/**
			 * Gets a value indicating whether access to the {@link System.Collections.ArrayList} is
			 * synchronized (thread safe).
			 */
			readonly IsSynchronized: boolean;

			/**
			 * Gets an object that can be used to synchronize access to the
			 * {@link System.Collections.ArrayList}.
			 */
			readonly SyncRoot: System.Object;

			/**
			 * Creates an {@link System.Collections.ArrayList} wrapper for a specific
			 * {@link System.Collections.IList}.
			 */
			static Adapter(list: System.Collections.IList): System.Collections.ArrayList;

			/** Adds an object to the end of the {@link System.Collections.ArrayList}. */
			Add(value: System.Object | undefined): number;

			/**
			 * Adds the elements of an {@link System.Collections.ICollection} to the end of the
			 * {@link System.Collections.ArrayList}.
			 */
			AddRange(c: System.Collections.ICollection): void;

			/**
			 * Searches a range of elements in the sorted {@link System.Collections.ArrayList} for an
			 * element using the specified comparer and returns the zero-based index of the element.
			 */
			BinarySearch(
				index: number,
				count: number,
				value: System.Object | undefined,
				comparer: System.Collections.IComparer | undefined,
			): number;

			/**
			 * Searches the entire sorted {@link System.Collections.ArrayList} for an element using
			 * the default comparer and returns the zero-based index of the element.
			 */
			BinarySearch(value: System.Object | undefined): number;

			/**
			 * Searches the entire sorted {@link System.Collections.ArrayList} for an element using
			 * the specified comparer and returns the zero-based index of the element.
			 */
			BinarySearch(
				value: System.Object | undefined,
				comparer: System.Collections.IComparer | undefined,
			): number;

			/** Removes all elements from the {@link System.Collections.ArrayList}. */
			Clear(): void;

			/** Creates a shallow copy of the {@link System.Collections.ArrayList}. */
			Clone(): System.Object;

			/** Determines whether an element is in the {@link System.Collections.ArrayList}. */
			Contains(item: System.Object | undefined): boolean;

			/**
			 * Copies the entire {@link System.Collections.ArrayList} to a compatible one-dimensional
			 * {@link System.Array}, starting at the beginning of the target array.
			 */
			CopyTo(array: System.Array): void;

			/**
			 * Copies the entire {@link System.Collections.ArrayList} to a compatible one-dimensional
			 * {@link System.Array}, starting at the specified index of the target array.
			 */
			CopyTo(
				array: System.Array,
				arrayIndex: number,
			): void;

			/**
			 * Copies a range of elements from the {@link System.Collections.ArrayList} to a
			 * compatible one-dimensional {@link System.Array}, starting at the specified index of
			 * the target array.
			 */
			CopyTo(
				index: number,
				array: System.Array,
				arrayIndex: number,
				count: number,
			): void;

			/** Returns an {@link System.Collections.ArrayList} wrapper with a fixed size. */
			static FixedSize(list: System.Collections.ArrayList): System.Collections.ArrayList;

			/** Returns an {@link System.Collections.IList} wrapper with a fixed size. */
			static FixedSize(list: System.Collections.IList): System.Collections.IList;

			/** Returns an enumerator for the entire {@link System.Collections.ArrayList}. */
			GetEnumerator(): System.Collections.IEnumerator;

			/**
			 * Returns an enumerator for a range of elements in the
			 * {@link System.Collections.ArrayList}.
			 */
			GetEnumerator(
				index: number,
				count: number,
			): System.Collections.IEnumerator;

			/**
			 * Returns an {@link System.Collections.ArrayList} which represents a subset of the
			 * elements in the source {@link System.Collections.ArrayList}.
			 */
			GetRange(
				index: number,
				count: number,
			): System.Collections.ArrayList;

			/**
			 * Searches for the specified {@link System.Object} and returns the zero-based index of
			 * the first occurrence within the entire {@link System.Collections.ArrayList}.
			 */
			IndexOf(value: System.Object | undefined): number;

			/**
			 * Searches for the specified {@link System.Object} and returns the zero-based index of
			 * the first occurrence within the range of elements in the
			 * {@link System.Collections.ArrayList} that extends from the specified index to the last
			 * element.
			 */
			IndexOf(
				value: System.Object | undefined,
				startIndex: number,
			): number;

			/**
			 * Searches for the specified {@link System.Object} and returns the zero-based index of
			 * the first occurrence within the range of elements in the
			 * {@link System.Collections.ArrayList} that starts at the specified index and contains
			 * the specified number of elements.
			 */
			IndexOf(
				value: System.Object | undefined,
				startIndex: number,
				count: number,
			): number;

			/**
			 * Inserts an element into the {@link System.Collections.ArrayList} at the specified
			 * index.
			 */
			Insert(
				index: number,
				value: System.Object | undefined,
			): void;

			/**
			 * Inserts the elements of a collection into the {@link System.Collections.ArrayList} at
			 * the specified index.
			 */
			InsertRange(
				index: number,
				c: System.Collections.ICollection,
			): void;

			/**
			 * Searches for the specified {@link System.Object} and returns the zero-based index of
			 * the last occurrence within the entire {@link System.Collections.ArrayList}.
			 */
			LastIndexOf(value: System.Object | undefined): number;

			/**
			 * Searches for the specified {@link System.Object} and returns the zero-based index of
			 * the last occurrence within the range of elements in the
			 * {@link System.Collections.ArrayList} that extends from the first element to the
			 * specified index.
			 */
			LastIndexOf(
				value: System.Object | undefined,
				startIndex: number,
			): number;

			/**
			 * Searches for the specified {@link System.Object} and returns the zero-based index of
			 * the last occurrence within the range of elements in the
			 * {@link System.Collections.ArrayList} that contains the specified number of elements
			 * and ends at the specified index.
			 */
			LastIndexOf(
				value: System.Object | undefined,
				startIndex: number,
				count: number,
			): number;

			/** Returns a read-only {@link System.Collections.ArrayList} wrapper. */
			static ReadOnly(list: System.Collections.ArrayList): System.Collections.ArrayList;

			/** Returns a read-only {@link System.Collections.IList} wrapper. */
			static ReadOnly(list: System.Collections.IList): System.Collections.IList;

			/**
			 * Removes the first occurrence of a specific object from the
			 * {@link System.Collections.ArrayList}.
			 */
			Remove(obj: System.Object | undefined): void;

			/**
			 * Removes the element at the specified index of the
			 * {@link System.Collections.ArrayList}.
			 */
			RemoveAt(index: number): void;

			/** Removes a range of elements from the {@link System.Collections.ArrayList}. */
			RemoveRange(
				index: number,
				count: number,
			): void;

			/**
			 * Returns an {@link System.Collections.ArrayList} whose elements are copies of the
			 * specified value.
			 */
			static Repeat(
				value: System.Object | undefined,
				count: number,
			): System.Collections.ArrayList;

			/**
			 * Reverses the order of the elements in the entire {@link System.Collections.ArrayList}.
			 */
			Reverse(): void;

			/** Reverses the order of the elements in the specified range. */
			Reverse(
				index: number,
				count: number,
			): void;

			/**
			 * Copies the elements of a collection over a range of elements in the
			 * {@link System.Collections.ArrayList}.
			 */
			SetRange(
				index: number,
				c: System.Collections.ICollection,
			): void;

			/** Sorts the elements in the entire {@link System.Collections.ArrayList}. */
			Sort(): void;

			/**
			 * Sorts the elements in the entire {@link System.Collections.ArrayList} using the
			 * specified comparer.
			 */
			Sort(comparer: System.Collections.IComparer | undefined): void;

			/**
			 * Sorts the elements in a range of elements in {@link System.Collections.ArrayList}
			 * using the specified comparer.
			 */
			Sort(
				index: number,
				count: number,
				comparer: System.Collections.IComparer | undefined,
			): void;

			/**
			 * Returns an {@link System.Collections.ArrayList} wrapper that is synchronized (thread
			 * safe).
			 */
			static Synchronized(list: System.Collections.ArrayList): System.Collections.ArrayList;

			/**
			 * Returns an {@link System.Collections.IList} wrapper that is synchronized (thread
			 * safe).
			 */
			static Synchronized(list: System.Collections.IList): System.Collections.IList;

			/**
			 * Copies the elements of the {@link System.Collections.ArrayList} to a new
			 * {@link System.Object} array.
			 */
			ToArray(): System.Object | undefined[];

			/**
			 * Copies the elements of the {@link System.Collections.ArrayList} to a new array of the
			 * specified element type.
			 */
			ToArray(type: System.Type): System.Array;

			/**
			 * Sets the capacity to the actual number of elements in the
			 * {@link System.Collections.ArrayList}.
			 */
			TrimToSize(): void;
		}
	}

	export namespace System.Collections {
		/** Compares two objects for equivalence, where string comparisons are case-sensitive. */
		export class Comparer implements System.Collections.IComparer {
			/**
			 * Initializes a new instance of the {@link System.Collections.Comparer} class using the
			 * specified {@link System.Globalization.CultureInfo}.
			 */
			constructor(culture: System.Globalization.CultureInfo);

			/**
			 * Performs a case-sensitive comparison of two objects of the same type and returns a
			 * value indicating whether one is less than, equal to, or greater than the other.
			 */
			Compare(
				a: System.Object | undefined,
				b: System.Object | undefined,
			): number;
		}
	}

	export namespace System.Collections {
		/** Defines a dictionary key/value pair that can be set or retrieved. */
		export class DictionaryEntry extends System.ValueType {
			/**
			 * Initializes an instance of the {@link System.Collections.DictionaryEntry} type with
			 * the specified key and value.
			 */
			constructor(
				key: System.Object,
				value: System.Object | undefined,
			);

			/** Gets or sets the key in the key/value pair. */
			Key: System.Object;

			/** Gets or sets the value in the key/value pair. */
			Value?: System.Object;

			Deconstruct(): { key: System.Object, value?: System.Object };
		}
	}

	export namespace System.Collections {
		/**
		 * Represents a collection of key/value pairs that are organized based on the hash code
		 * of the key.
		 */
		export class Hashtable implements
			System.ICloneable {
			/**
			 * Initializes a new, empty instance of the {@link System.Collections.Hashtable} class
			 * using the default initial capacity, load factor, hash code provider, and comparer.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Collections.Hashtable} class by
			 * copying the elements from the specified dictionary to the new
			 * {@link System.Collections.Hashtable} object. The new
			 * {@link System.Collections.Hashtable} object has an initial capacity equal to the
			 * number of elements copied, and uses the default load factor, hash code provider, and
			 * comparer.
			 */
			constructor(d: System.Collections.IDictionary);

			/**
			 * Initializes a new instance of the {@link System.Collections.Hashtable} class by
			 * copying the elements from the specified dictionary to a new
			 * {@link System.Collections.Hashtable} object. The new
			 * {@link System.Collections.Hashtable} object has an initial capacity equal to the
			 * number of elements copied, and uses the default load factor and the specified
			 * {@link System.Collections.IEqualityComparer} object.
			 */
			constructor(
				d: System.Collections.IDictionary,
				equalityComparer: System.Collections.IEqualityComparer | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.Collections.Hashtable} class by
			 * copying the elements from the specified dictionary to the new
			 * {@link System.Collections.Hashtable} object. The new
			 * {@link System.Collections.Hashtable} object has an initial capacity equal to the
			 * number of elements copied, and uses the default load factor, and the specified hash
			 * code provider and comparer. This API is obsolete. For an alternative, see
			 * {@link System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)}.
			 */
			constructor(
				d: System.Collections.IDictionary,
				hcp: System.Collections.IHashCodeProvider | undefined,
				comparer: System.Collections.IComparer | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.Collections.Hashtable} class by
			 * copying the elements from the specified dictionary to the new
			 * {@link System.Collections.Hashtable} object. The new
			 * {@link System.Collections.Hashtable} object has an initial capacity equal to the
			 * number of elements copied, and uses the specified load factor, and the default hash
			 * code provider and comparer.
			 */
			constructor(
				d: System.Collections.IDictionary,
				loadFactor: number,
			);

			/**
			 * Initializes a new instance of the {@link System.Collections.Hashtable} class by
			 * copying the elements from the specified dictionary to the new
			 * {@link System.Collections.Hashtable} object. The new
			 * {@link System.Collections.Hashtable} object has an initial capacity equal to the
			 * number of elements copied, and uses the specified load factor and
			 * {@link System.Collections.IEqualityComparer} object.
			 */
			constructor(
				d: System.Collections.IDictionary,
				loadFactor: number,
				equalityComparer: System.Collections.IEqualityComparer | undefined,
			);

			/**
			 * Initializes a new instance of the {@link System.Collections.Hashtable} class by
			 * copying the elements from the specified dictionary to the new
			 * {@link System.Collections.Hashtable} object. The new
			 * {@link System.Collections.Hashtable} object has an initial capacity equal to the
			 * number of elements copied, and uses the specified load factor, hash code provider, and
			 * comparer.
			 */
			constructor(
				d: System.Collections.IDictionary,
				loadFactor: number,
				hcp: System.Collections.IHashCodeProvider | undefined,
				comparer: System.Collections.IComparer | undefined,
			);

			/**
			 * Initializes a new, empty instance of the {@link System.Collections.Hashtable} class
			 * using the default initial capacity and load factor, and the specified
			 * {@link System.Collections.IEqualityComparer} object.
			 */
			constructor(equalityComparer: System.Collections.IEqualityComparer | undefined);

			/**
			 * Initializes a new, empty instance of the {@link System.Collections.Hashtable} class
			 * using the default initial capacity and load factor, and the specified hash code
			 * provider and comparer.
			 */
			constructor(
				hcp: System.Collections.IHashCodeProvider | undefined,
				comparer: System.Collections.IComparer | undefined,
			);

			/**
			 * Initializes a new, empty instance of the {@link System.Collections.Hashtable} class
			 * using the specified initial capacity, and the default load factor, hash code provider,
			 * and comparer.
			 */
			constructor(capacity: number);

			/**
			 * Initializes a new, empty instance of the {@link System.Collections.Hashtable} class
			 * using the specified initial capacity and {@link System.Collections.IEqualityComparer},
			 * and the default load factor.
			 */
			constructor(
				capacity: number,
				equalityComparer: System.Collections.IEqualityComparer | undefined,
			);

			/**
			 * Initializes a new, empty instance of the {@link System.Collections.Hashtable} class
			 * using the specified initial capacity, hash code provider, comparer, and the default
			 * load factor.
			 */
			constructor(
				capacity: number,
				hcp: System.Collections.IHashCodeProvider | undefined,
				comparer: System.Collections.IComparer | undefined,
			);

			/**
			 * Initializes a new, empty instance of the {@link System.Collections.Hashtable} class
			 * using the specified initial capacity and load factor, and the default hash code
			 * provider and comparer.
			 */
			constructor(
				capacity: number,
				loadFactor: number,
			);

			/**
			 * Initializes a new, empty instance of the {@link System.Collections.Hashtable} class
			 * using the specified initial capacity, load factor, and
			 * {@link System.Collections.IEqualityComparer} object.
			 */
			constructor(
				capacity: number,
				loadFactor: number,
				equalityComparer: System.Collections.IEqualityComparer | undefined,
			);

			/**
			 * Initializes a new, empty instance of the {@link System.Collections.Hashtable} class
			 * using the specified initial capacity, load factor, hash code provider, and comparer.
			 */
			constructor(
				capacity: number,
				loadFactor: number,
				hcp: System.Collections.IHashCodeProvider | undefined,
				comparer: System.Collections.IComparer | undefined,
			);

			/**
			 * Gets the number of key/value pairs contained in the
			 * {@link System.Collections.Hashtable}.
			 */
			readonly Count: number;

			/**
			 * Gets a value indicating whether the {@link System.Collections.Hashtable} has a fixed
			 * size.
			 */
			readonly IsFixedSize: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Collections.Hashtable} is read-only.
			 */
			readonly IsReadOnly: boolean;

			/**
			 * Gets a value indicating whether access to the {@link System.Collections.Hashtable} is
			 * synchronized (thread safe).
			 */
			readonly IsSynchronized: boolean;

			/**
			 * Gets an {@link System.Collections.ICollection} containing the keys in the
			 * {@link System.Collections.Hashtable}.
			 */
			readonly Keys: System.Collections.ICollection;

			/**
			 * Gets an object that can be used to synchronize access to the
			 * {@link System.Collections.Hashtable}.
			 */
			readonly SyncRoot: System.Object;

			/**
			 * Gets an {@link System.Collections.ICollection} containing the values in the
			 * {@link System.Collections.Hashtable}.
			 */
			readonly Values: System.Collections.ICollection;

			/**
			 * Adds an element with the specified key and value into the
			 * {@link System.Collections.Hashtable}.
			 */
			Add(
				key: System.Object,
				value: System.Object | undefined,
			): void;

			/** Removes all elements from the {@link System.Collections.Hashtable}. */
			Clear(): void;

			/** Creates a shallow copy of the {@link System.Collections.Hashtable}. */
			Clone(): System.Object;

			/**
			 * Determines whether the {@link System.Collections.Hashtable} contains a specific key.
			 */
			Contains(key: System.Object): boolean;

			/**
			 * Determines whether the {@link System.Collections.Hashtable} contains a specific key.
			 */
			ContainsKey(key: System.Object): boolean;

			/**
			 * Determines whether the {@link System.Collections.Hashtable} contains a specific value.
			 */
			ContainsValue(value: System.Object | undefined): boolean;

			/**
			 * Copies the {@link System.Collections.Hashtable} elements to a one-dimensional
			 * {@link System.Array} instance at the specified index.
			 */
			CopyTo(
				array: System.Array,
				arrayIndex: number,
			): void;

			/**
			 * Returns an {@link System.Collections.IDictionaryEnumerator} that iterates through the
			 * {@link System.Collections.Hashtable}.
			 */
			GetEnumerator(): System.Collections.IDictionaryEnumerator;

			/**
			 * Implements the {@link System.Runtime.Serialization.ISerializable} interface and raises
			 * the deserialization event when the deserialization is complete.
			 */
			OnDeserialization(sender: System.Object | undefined): void;

			/**
			 * Removes the element with the specified key from the
			 * {@link System.Collections.Hashtable}.
			 */
			Remove(key: System.Object): void;

			/**
			 * Returns a synchronized (thread-safe) wrapper for the
			 * {@link System.Collections.Hashtable}.
			 */
			static Synchronized(table: System.Collections.Hashtable): System.Collections.Hashtable;
		}
	}

	export namespace System.Collections {
		/**
		 * Defines size, enumerators, and synchronization methods for all nongeneric collections.
		 */
		export interface ICollection extends System.Collections.IEnumerable {
			/**
			 * Gets the number of elements contained in the {@link System.Collections.ICollection}.
			 */
			readonly Count: number;

			/**
			 * Gets a value indicating whether access to the {@link System.Collections.ICollection}
			 * is synchronized (thread safe).
			 */
			readonly IsSynchronized: boolean;

			/**
			 * Gets an object that can be used to synchronize access to the
			 * {@link System.Collections.ICollection}.
			 */
			readonly SyncRoot: System.Object;

			/**
			 * Copies the elements of the {@link System.Collections.ICollection} to an
			 * {@link System.Array}, starting at a particular {@link System.Array} index.
			 */
			CopyTo(
				array: System.Array,
				index: number,
			): void;
		}
	}

	export namespace System.Collections {
		/** Exposes a method that compares two objects. */
		export interface IComparer {
			/**
			 * Compares two objects and returns a value indicating whether one is less than, equal
			 * to, or greater than the other.
			 */
			Compare(
				x: System.Object | undefined,
				y: System.Object | undefined,
			): number;
		}
	}

	export namespace System.Collections {
		/** Represents a nongeneric collection of key/value pairs. */
		export interface IDictionary extends
			System.Collections.ICollection,
			System.Collections.IEnumerable {
			/**
			 * Gets a value indicating whether the {@link System.Collections.IDictionary} object has
			 * a fixed size.
			 */
			readonly IsFixedSize: boolean;

			/**
			 * Gets a value indicating whether the {@link System.Collections.IDictionary} object is
			 * read-only.
			 */
			readonly IsReadOnly: boolean;

			/**
			 * Gets an {@link System.Collections.ICollection} object containing the keys of the
			 * {@link System.Collections.IDictionary} object.
			 */
			readonly Keys: System.Collections.ICollection;

			/**
			 * Gets an {@link System.Collections.ICollection} object containing the values in the
			 * {@link System.Collections.IDictionary} object.
			 */
			readonly Values: System.Collections.ICollection;

			/**
			 * Adds an element with the provided key and value to the
			 * {@link System.Collections.IDictionary} object.
			 */
			Add(
				key: System.Object,
				value: System.Object | undefined,
			): void;

			/** Removes all elements from the {@link System.Collections.IDictionary} object. */
			Clear(): void;

			/**
			 * Determines whether the {@link System.Collections.IDictionary} object contains an
			 * element with the specified key.
			 */
			Contains(key: System.Object): boolean;

			/**
			 * Returns an {@link System.Collections.IDictionaryEnumerator} object for the
			 * {@link System.Collections.IDictionary} object.
			 */
			GetEnumerator(): System.Collections.IDictionaryEnumerator;

			/**
			 * Removes the element with the specified key from the
			 * {@link System.Collections.IDictionary} object.
			 */
			Remove(key: System.Object): void;
		}
	}

	export namespace System.Collections {
		/** Enumerates the elements of a nongeneric dictionary. */
		export interface IDictionaryEnumerator extends System.Collections.IEnumerator {
			/** Gets both the key and the value of the current dictionary entry. */
			readonly Entry: System.Collections.DictionaryEntry;

			/** Gets the key of the current dictionary entry. */
			readonly Key: System.Object;

			/** Gets the value of the current dictionary entry. */
			readonly Value?: System.Object;
		}
	}

	export namespace System.Collections {
		/**
		 * Exposes an enumerator, which supports a simple iteration over a non-generic
		 * collection.
		 */
		export interface IEnumerable {
			/** Returns an enumerator that iterates through a collection. */
			GetEnumerator(): System.Collections.IEnumerator;
		}
	}

	export namespace System.Collections {
		/** Supports a simple iteration over a non-generic collection. */
		export interface IEnumerator {
			/** Gets the element in the collection at the current position of the enumerator. */
			readonly Current: System.Object;

			/** Advances the enumerator to the next element of the collection. */
			MoveNext(): boolean;

			/**
			 * Sets the enumerator to its initial position, which is before the first element in the
			 * collection.
			 */
			Reset(): void;
		}
	}

	export namespace System.Collections {
		/** Defines methods to support the comparison of objects for equality. */
		export interface IEqualityComparer {
			/** Determines whether the specified objects are equal. */
			Equals(
				x: System.Object | undefined,
				y: System.Object | undefined,
			): boolean;

			/** Returns a hash code for the specified object. */
			GetHashCode(obj: System.Object): number;
		}
	}

	export namespace System.Collections {
		/** Supplies a hash code for an object, using a custom hash function. */
		export interface IHashCodeProvider {
			/** Returns a hash code for the specified object. */
			GetHashCode(obj: System.Object): number;
		}
	}

	export namespace System.Collections {
		/**
		 * Represents a non-generic collection of objects that can be individually accessed by
		 * index.
		 */
		export interface IList extends
			System.Collections.ICollection,
			System.Collections.IEnumerable {
			/**
			 * Gets a value indicating whether the {@link System.Collections.IList} has a fixed size.
			 */
			readonly IsFixedSize: boolean;

			/** Gets a value indicating whether the {@link System.Collections.IList} is read-only. */
			readonly IsReadOnly: boolean;

			/** Adds an item to the {@link System.Collections.IList}. */
			Add(value: System.Object | undefined): number;

			/** Removes all items from the {@link System.Collections.IList}. */
			Clear(): void;

			/** Determines whether the {@link System.Collections.IList} contains a specific value. */
			Contains(value: System.Object | undefined): boolean;

			/** Determines the index of a specific item in the {@link System.Collections.IList}. */
			IndexOf(value: System.Object | undefined): number;

			/** Inserts an item to the {@link System.Collections.IList} at the specified index. */
			Insert(
				index: number,
				value: System.Object | undefined,
			): void;

			/**
			 * Removes the first occurrence of a specific object from the
			 * {@link System.Collections.IList}.
			 */
			Remove(value: System.Object | undefined): void;

			/** Removes the {@link System.Collections.IList} item at the specified index. */
			RemoveAt(index: number): void;
		}
	}

	export namespace System.Collections {
		/** Supports the structural comparison of collection objects. */
		export interface IStructuralComparable {
			/**
			 * Determines whether the current collection object precedes, occurs in the same position
			 * as, or follows another object in the sort order.
			 */
			CompareTo(
				other: System.Object | undefined,
				comparer: System.Collections.IComparer,
			): number;
		}
	}

	export namespace System.Collections {
		/** Defines methods to support the comparison of objects for structural equality. */
		export interface IStructuralEquatable {
			/** Determines whether an object is structurally equal to the current instance. */
			Equals(
				other: System.Object | undefined,
				comparer: System.Collections.IEqualityComparer,
			): boolean;

			/** Returns a hash code for the current instance. */
			GetHashCode(comparer: System.Collections.IEqualityComparer): number;
		}
	}

	export namespace System.Collections.ObjectModel {
		/** [Generic type factory] Provides the base class for a generic collection. */
		export function Collection$(T: IType): typeof Collection$1<any>;

		/** Provides the base class for a generic collection. */
		export class Collection$1<T> {
			/**
			 * Initializes a new instance of the {@link System.Collections.ObjectModel.Collection<>}
			 * class that is empty.
			 */
			constructor();

			/**
			 * Initializes a new instance of the {@link System.Collections.ObjectModel.Collection<>}
			 * class as a wrapper for the specified list.
			 */
			constructor(list: T[]);

			/**
			 * Gets the number of elements actually contained in the
			 * {@link System.Collections.ObjectModel.Collection<>}.
			 */
			readonly Count: number;

			/**
			 * Adds an object to the end of the {@link System.Collections.ObjectModel.Collection<>}.
			 */
			Add(item: T): void;

			/** Removes all elements from the {@link System.Collections.ObjectModel.Collection<>}. */
			Clear(): void;

			/**
			 * Determines whether an element is in the
			 * {@link System.Collections.ObjectModel.Collection<>}.
			 */
			Contains(item: T): boolean;

			CopyTo(
				array: T[],
				index: number,
			): void;

			/**
			 * Returns an enumerator that iterates through the
			 * {@link System.Collections.ObjectModel.Collection<>}.
			 */
			GetEnumerator(): System.Collections.Generic.IEnumerator$1<T>;

			/**
			 * Searches for the specified object and returns the zero-based index of the first
			 * occurrence within the entire {@link System.Collections.ObjectModel.Collection<>}.
			 */
			IndexOf(item: T): number;

			/**
			 * Inserts an element into the {@link System.Collections.ObjectModel.Collection<>} at the
			 * specified index.
			 */
			Insert(
				index: number,
				item: T,
			): void;

			/**
			 * Removes the first occurrence of a specific object from the
			 * {@link System.Collections.ObjectModel.Collection<>}.
			 */
			Remove(item: T): boolean;

			/**
			 * Removes the element at the specified index of the
			 * {@link System.Collections.ObjectModel.Collection<>}.
			 */
			RemoveAt(index: number): void;
		}
	}

	export namespace System.Collections.ObjectModel {
		/** [Generic type factory] Provides the base class for a generic read-only collection. */
		export function ReadOnlyCollection$(T: IType): typeof ReadOnlyCollection$1<any>;

		/** Provides the base class for a generic read-only collection. */
		export class ReadOnlyCollection$1<T> {
			/**
			 * Initializes a new instance of the
			 * {@link System.Collections.ObjectModel.ReadOnlyCollection<>} class that is a read-only
			 * wrapper around the specified list.
			 */
			constructor(list: T[]);

			/**
			 * Gets the number of elements contained in the
			 * {@link System.Collections.ObjectModel.ReadOnlyCollection<>} instance.
			 */
			readonly Count: number;

			/** Gets an empty {@link System.Collections.ObjectModel.ReadOnlyCollection<>}. */
			static readonly Empty: readonly any[];

			/**
			 * Determines whether an element is in the
			 * {@link System.Collections.ObjectModel.ReadOnlyCollection<>}.
			 */
			Contains(value: T): boolean;

			CopyTo(
				array: T[],
				index: number,
			): void;

			/**
			 * Returns an enumerator that iterates through the
			 * {@link System.Collections.ObjectModel.ReadOnlyCollection<>}.
			 */
			GetEnumerator(): System.Collections.Generic.IEnumerator$1<T>;

			/**
			 * Searches for the specified object and returns the zero-based index of the first
			 * occurrence within the entire
			 * {@link System.Collections.ObjectModel.ReadOnlyCollection<>}.
			 */
			IndexOf(value: T): number;
		}
	}

	export namespace System.Collections.ObjectModel {
		/**
		 * [Generic type factory] Represents a read-only, generic collection of key/value pairs.
		 */
		export function ReadOnlyDictionary$(TKey: IType, TValue: IType): typeof ReadOnlyDictionary$2<any, any>;

		/** Represents a read-only, generic collection of key/value pairs. */
		export class ReadOnlyDictionary$2<TKey, TValue> {
			/**
			 * Initializes a new instance of the
			 * {@link System.Collections.ObjectModel.ReadOnlyDictionary<,>} class that is a wrapper
			 * around the specified dictionary.
			 */
			constructor(dictionary: Map<TKey, TValue>);

			/** Gets the number of items in the dictionary. */
			readonly Count: number;

			/** Gets an empty {@link System.Collections.ObjectModel.ReadOnlyDictionary<,>}. */
			static readonly Empty: ReadonlyMap<any, any>;

			/** Gets a key collection that contains the keys of the dictionary. */
			readonly Keys: TKey[];

			/** Gets a collection that contains the values in the dictionary. */
			readonly Values: TValue[];

			/** Determines whether the dictionary contains an element that has the specified key. */
			ContainsKey(key: TKey): boolean;

			/**
			 * Returns an enumerator that iterates through the
			 * {@link System.Collections.ObjectModel.ReadOnlyDictionary<,>}.
			 */
			GetEnumerator(): System.Collections.Generic.IEnumerator$1<[TKey, TValue]>;

			TryGetValue(key: TKey): TValue | undefined;
		}
	}

	export namespace System.Collections.ObjectModel.ReadOnlyDictionary {
		export function KeyCollection$(TKey: IType, TValue: IType): typeof KeyCollection$2<any, any>;

		export class KeyCollection$2<TKey, TValue> {
			readonly Count: number;

			CopyTo(
				array: TKey[],
				arrayIndex: number,
			): void;

			GetEnumerator(): System.Collections.Generic.IEnumerator$1<TKey>;

			Contains(item: TKey): boolean;
		}
	}

	export namespace System.Collections.ObjectModel.ReadOnlyDictionary {
		export function ValueCollection$(TKey: IType, TValue: IType): typeof ValueCollection$2<any, any>;

		export class ValueCollection$2<TKey, TValue> {
			readonly Count: number;

			CopyTo(
				array: TValue[],
				arrayIndex: number,
			): void;

			GetEnumerator(): System.Collections.Generic.IEnumerator$1<TValue>;
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * [Generic type factory] Exposes an enumerator that provides asynchronous iteration over
		 * values of a specified type.
		 */
		export function IAsyncEnumerable$(T: IType): IType;

		/**
		 * Exposes an enumerator that provides asynchronous iteration over values of a specified
		 * type.
		 */
		export interface IAsyncEnumerable$1<T> {
			/** Returns an enumerator that iterates asynchronously through the collection. */
			GetAsyncEnumerator(cancellationToken?: AbortSignal): System.Collections.Generic.IAsyncEnumerator$1<T>;
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * [Generic type factory] Supports a simple asynchronous iteration over a generic
		 * collection.
		 */
		export function IAsyncEnumerator$(T: IType): IType;

		/** Supports a simple asynchronous iteration over a generic collection. */
		export interface IAsyncEnumerator$1<T> extends System.IAsyncDisposable {
			/** Gets the element in the collection at the current position of the enumerator. */
			readonly Current: T;

			/** Advances the enumerator asynchronously to the next element of the collection. */
			MoveNextAsync(): Promise<boolean>;
		}
	}

	export namespace System.Collections.Generic {
		/** [Generic type factory] Defines methods to manipulate generic collections. */
		export function ICollection$(T: IType): IType;

		/** Defines methods to manipulate generic collections. */
		export interface ICollection$1<T> extends
			System.Collections.IEnumerable {
			/**
			 * Gets the number of elements contained in the
			 * {@link System.Collections.Generic.ICollection<>}.
			 */
			readonly Count: number;

			/**
			 * Gets a value indicating whether the {@link System.Collections.Generic.ICollection<>}
			 * is read-only.
			 */
			readonly IsReadOnly: boolean;

			/** Adds an item to the {@link System.Collections.Generic.ICollection<>}. */
			Add(item: T): void;

			/** Removes all items from the {@link System.Collections.Generic.ICollection<>}. */
			Clear(): void;

			/**
			 * Determines whether the {@link System.Collections.Generic.ICollection<>} contains a
			 * specific value.
			 */
			Contains(item: T): boolean;

			CopyTo(
				array: T[],
				arrayIndex: number,
			): void;

			/**
			 * Removes the first occurrence of a specific object from the
			 * {@link System.Collections.Generic.ICollection<>}.
			 */
			Remove(item: T): boolean;
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * [Generic type factory] Defines a method that a type implements to compare two objects.
		 */
		export function IComparer$(T: IType): IType;

		/** Defines a method that a type implements to compare two objects. */
		export interface IComparer$1<T> {
			/**
			 * Compares two objects and returns a value indicating whether one is less than, equal
			 * to, or greater than the other.
			 */
			Compare(
				x: T,
				y: T,
			): number;
		}
	}

	export namespace System.Collections.Generic {
		/** [Generic type factory] Represents a generic collection of key/value pairs. */
		export function IDictionary$(TKey: IType, TValue: IType): IType;

		/** Represents a generic collection of key/value pairs. */
		export interface IDictionary$2<TKey, TValue> extends
			System.Collections.IEnumerable {
			/**
			 * Gets an {@link System.Collections.Generic.ICollection<>} containing the keys of the
			 * {@link System.Collections.Generic.IDictionary<,>}.
			 */
			readonly Keys: Iterable<TKey> | { length: number, add(item: TKey): void, delete(item: TKey): boolean };

			/**
			 * Gets an {@link System.Collections.Generic.ICollection<>} containing the values in the
			 * {@link System.Collections.Generic.IDictionary<,>}.
			 */
			readonly Values: Iterable<TValue> | { length: number, add(item: TValue): void, delete(item: TValue): boolean };

			/**
			 * Adds an element with the provided key and value to the
			 * {@link System.Collections.Generic.IDictionary<,>}.
			 */
			Add(
				key: TKey,
				value: TValue,
			): void;

			/**
			 * Determines whether the {@link System.Collections.Generic.IDictionary<,>} contains an
			 * element with the specified key.
			 */
			ContainsKey(key: TKey): boolean;

			/**
			 * Removes the element with the specified key from the
			 * {@link System.Collections.Generic.IDictionary<,>}.
			 */
			Remove(key: TKey): boolean;

			TryGetValue(key: TKey): TValue | undefined;
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * [Generic type factory] Exposes the enumerator, which supports a simple iteration over
		 * a collection of a specified type.
		 */
		export function IEnumerable$(T: IType): IType;

		/**
		 * Exposes the enumerator, which supports a simple iteration over a collection of a
		 * specified type.
		 */
		export interface IEnumerable$1<T> extends System.Collections.IEnumerable {
			/** Returns an enumerator that iterates through the collection. */
			GetEnumerator(): System.Collections.Generic.IEnumerator$1<T>;
		}
	}

	export namespace System.Collections.Generic {
		/** [Generic type factory] Supports a simple iteration over a generic collection. */
		export function IEnumerator$(T: IType): IType;

		/** Supports a simple iteration over a generic collection. */
		export interface IEnumerator$1<T> extends
			System.Collections.IEnumerator,
			IDisposable {
			/** Gets the element in the collection at the current position of the enumerator. */
			readonly Current: T;
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * [Generic type factory] Defines methods to support the comparison of objects for
		 * equality.
		 */
		export function IEqualityComparer$(T: IType): IType;

		/** Defines methods to support the comparison of objects for equality. */
		export interface IEqualityComparer$1<T> {
			/** Determines whether the specified objects are equal. */
			Equals(
				x: T,
				y: T,
			): boolean;

			/** Returns a hash code for the specified object. */
			GetHashCode(obj: T): number;
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * [Generic type factory] Represents a collection of objects that can be individually
		 * accessed by index.
		 */
		export function IList$(T: IType): IType;

		/** Represents a collection of objects that can be individually accessed by index. */
		export interface IList$1<T> extends
			System.Collections.IEnumerable {
			/**
			 * Determines the index of a specific item in the
			 * {@link System.Collections.Generic.IList<>}.
			 */
			IndexOf(item: T): number;

			/**
			 * Inserts an item to the {@link System.Collections.Generic.IList<>} at the specified
			 * index.
			 */
			Insert(
				index: number,
				item: T,
			): void;

			/**
			 * Removes the {@link System.Collections.Generic.IList<>} item at the specified index.
			 */
			RemoveAt(index: number): void;
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * [Generic type factory] Represents a strongly-typed, read-only collection of elements.
		 */
		export function IReadOnlyCollection$(T: IType): IType;

		/** Represents a strongly-typed, read-only collection of elements. */
		export interface IReadOnlyCollection$1<T> extends
			System.Collections.IEnumerable {
			/** Gets the number of elements in the collection. */
			readonly Count: number;
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * [Generic type factory] Represents a generic read-only collection of key/value pairs.
		 */
		export function IReadOnlyDictionary$(TKey: IType, TValue: IType): IType;

		/** Represents a generic read-only collection of key/value pairs. */
		export interface IReadOnlyDictionary$2<TKey, TValue> extends
			System.Collections.IEnumerable {
			/** Gets an enumerable collection that contains the keys in the read-only dictionary. */
			readonly Keys: Iterable<TKey>;

			/**
			 * Gets an enumerable collection that contains the values in the read-only dictionary.
			 */
			readonly Values: Iterable<TValue>;

			/**
			 * Determines whether the read-only dictionary contains an element that has the specified
			 * key.
			 */
			ContainsKey(key: TKey): boolean;

			TryGetValue(key: TKey): TValue | undefined;
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * [Generic type factory] Represents a read-only collection of elements that can be
		 * accessed by index.
		 */
		export function IReadOnlyList$(T: IType): IType;

		/** Represents a read-only collection of elements that can be accessed by index. */
		export interface IReadOnlyList$1<T> extends
			System.Collections.IEnumerable {
		}
	}

	export namespace System.Collections.Generic {
		/** [Generic type factory] Provides a readonly abstraction of a set. */
		export function IReadOnlySet$(T: IType): IType;

		/** Provides a readonly abstraction of a set. */
		export interface IReadOnlySet$1<T> extends
			System.Collections.IEnumerable {
			/** Determines if the set contains a specific item. */
			Contains(item: T): boolean;

			/**
			 * Determines whether the current set is a proper (strict) subset of a specified
			 * collection.
			 */
			IsProperSubsetOf(other: Iterable<T>): boolean;

			/**
			 * Determines whether the current set is a proper (strict) superset of a specified
			 * collection.
			 */
			IsProperSupersetOf(other: Iterable<T>): boolean;

			/** Determine whether the current set is a subset of a specified collection. */
			IsSubsetOf(other: Iterable<T>): boolean;

			/** Determine whether the current set is a super set of a specified collection. */
			IsSupersetOf(other: Iterable<T>): boolean;

			/** Determines whether the current set overlaps with the specified collection. */
			Overlaps(other: Iterable<T>): boolean;

			/**
			 * Determines whether the current set and the specified collection contain the same
			 * elements.
			 */
			SetEquals(other: Iterable<T>): boolean;
		}
	}

	export namespace System.Collections.Generic {
		/** [Generic type factory] Provides the base interface for the abstraction of sets. */
		export function ISet$(T: IType): IType;

		/** Provides the base interface for the abstraction of sets. */
		export interface ISet$1<T> extends
			System.Collections.IEnumerable {
			/**
			 * Adds an element to the current set and returns a value to indicate if the element was
			 * successfully added.
			 */
			Add(item: T): boolean;

			/** Removes all elements in the specified collection from the current set. */
			ExceptWith(other: Iterable<T>): void;

			/**
			 * Modifies the current set so that it contains only elements that are also in a
			 * specified collection.
			 */
			IntersectWith(other: Iterable<T>): void;

			/**
			 * Determines whether the current set is a proper (strict) subset of a specified
			 * collection.
			 */
			IsProperSubsetOf(other: Iterable<T>): boolean;

			/**
			 * Determines whether the current set is a proper (strict) superset of a specified
			 * collection.
			 */
			IsProperSupersetOf(other: Iterable<T>): boolean;

			/** Determines whether a set is a subset of a specified collection. */
			IsSubsetOf(other: Iterable<T>): boolean;

			/** Determines whether the current set is a superset of a specified collection. */
			IsSupersetOf(other: Iterable<T>): boolean;

			/** Determines whether the current set overlaps with the specified collection. */
			Overlaps(other: Iterable<T>): boolean;

			/**
			 * Determines whether the current set and the specified collection contain the same
			 * elements.
			 */
			SetEquals(other: Iterable<T>): boolean;

			/**
			 * Modifies the current set so that it contains only elements that are present either in
			 * the current set or in the specified collection, but not both.
			 */
			SymmetricExceptWith(other: Iterable<T>): void;

			/**
			 * Modifies the current set so that it contains all elements that are present in the
			 * current set, in the specified collection, or in both.
			 */
			UnionWith(other: Iterable<T>): void;
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * The exception that is thrown when the key specified for accessing an element in a
		 * collection does not match any key in the collection.
		 */
		export class KeyNotFoundException extends System.SystemException {
			/**
			 * Initializes a new instance of the
			 * {@link System.Collections.Generic.KeyNotFoundException} class using default property
			 * values.
			 */
			constructor();

			/**
			 * Initializes a new instance of the
			 * {@link System.Collections.Generic.KeyNotFoundException} class with the specified error
			 * message.
			 */
			constructor(message: string | undefined);

			/**
			 * Initializes a new instance of the
			 * {@link System.Collections.Generic.KeyNotFoundException} class with the specified error
			 * message and a reference to the inner exception that is the cause of this exception.
			 */
			constructor(
				message: string | undefined,
				innerException: System.Exception | undefined,
			);
		}
	}

	export namespace System.Collections.Generic {
		/**
		 * Creates instances of the {@link System.Collections.Generic.KeyValuePair<,>} struct.
		 */
		export namespace KeyValuePair {
			/** Creates a new key/value pair instance using provided values. */
			export function Create<TKey, TValue>(
				key: TKey,
				value: TValue,
			): [TKey, TValue];
		}
	}

	export namespace System.Collections.Generic {
		/** [Generic type factory] Defines a key/value pair that can be set or retrieved. */
		export function KeyValuePair$(TKey: IType, TValue: IType): typeof KeyValuePair$2<any, any>;

		/** Defines a key/value pair that can be set or retrieved. */
		export class KeyValuePair$2<TKey, TValue> extends System.ValueType {
			/**
			 * Initializes a new instance of the {@link System.Collections.Generic.KeyValuePair<,>}
			 * structure with the specified key and value.
			 */
			constructor(
				key: TKey,
				value: TValue,
			);

			/** Gets the key in the key/value pair. */
			readonly Key: TKey;

			/** Gets the value in the key/value pair. */
			readonly Value: TValue;

			Deconstruct(): { key: TKey, value: TValue };

			/**
			 * Returns a string representation of the
			 * {@link System.Collections.Generic.KeyValuePair<,>}, using the string representations
			 * of the key and value.
			 */
			ToString(): string;
		}
	}

	export namespace System.CodeDom.Compiler {
		/** Identifies code generated by a tool. This class cannot be inherited. */
		export class GeneratedCodeAttribute extends System.Attribute {
			/**
			 * Initializes a new instance of the
			 * {@link System.CodeDom.Compiler.GeneratedCodeAttribute} class specifying the name and
			 * version of the tool that generated the code.
			 */
			constructor(
				tool: string | undefined,
				version: string | undefined,
			);

			/** Gets the name of the tool that generated the code. */
			readonly Tool?: string;

			/** Gets the version of the tool that generated the code. */
			readonly Version?: string;
		}
	}

	export namespace System.CodeDom.Compiler {
		/** Provides a text writer that can indent new lines by a tab string token. */
		export class IndentedTextWriter extends System.IO.TextWriter implements
			System.IAsyncDisposable,
			IDisposable {
			/**
			 * Initializes a new instance of the {@link System.CodeDom.Compiler.IndentedTextWriter}
			 * class using the specified text writer and default tab string.
			 */
			constructor(writer: System.IO.TextWriter);

			/**
			 * Initializes a new instance of the {@link System.CodeDom.Compiler.IndentedTextWriter}
			 * class using the specified text writer and tab string.
			 */
			constructor(
				writer: System.IO.TextWriter,
				tabString: string,
			);

			/** Gets the encoding for the text writer to use. */
			readonly Encoding: System.Text.Encoding;

			/** Gets or sets the number of spaces to indent. */
			Indent: number;

			/** Gets the {@link System.IO.TextWriter} to use. */
			readonly InnerWriter: System.IO.TextWriter;

			/** Gets or sets the new line character to use. */
			NewLine: string;

			/** Closes the document being written to. */
			Close(): void;

			/**
			 * Performs application-defined tasks associated with freeing, releasing, or resetting
			 * unmanaged resources asynchronously.
			 */
			DisposeAsync(): Promise<void>;

			/** Flushes the stream. */
			Flush(): void;

			/**
			 * Clears all buffers for this  asynchronously and causes any buffered data to be written
			 * to the underlying device.
			 */
			FlushAsync(): Promise<void>;

			/**
			 * Clears all buffers for this {@link System.CodeDom.Compiler.IndentedTextWriter}
			 * asynchronously and causes any buffered data to be written to the underlying device.
			 */
			FlushAsync(cancellationToken: AbortSignal): Promise<void>;

			/** Writes the text representation of a Boolean value to the text stream. */
			Write(value: boolean): void;

			/** Writes a character to the text stream. */
			Write(value: System.Char): void;

			/** Writes a character array to the text stream. */
			Write(buffer: System.Char[] | undefined): void;

			/** Writes a subarray of characters to the text stream. */
			Write(
				buffer: System.Char[],
				index: number,
				count: number,
			): void;

			/** Writes the text representation of a Double to the text stream. */
			Write(value: number): void;

			/** Writes the text representation of an integer to the text stream. */
			Write(value: number): void;

			/** Writes the text representation of an 8-byte integer to the text stream. */
			Write(value: number): void;

			/** Writes the text representation of an object to the text stream. */
			Write(value: System.Object | undefined): void;

			/** Writes the text representation of a Single to the text stream. */
			Write(value: number): void;

			/** Writes the specified string to the text stream. */
			Write(s: string | undefined): void;

			/** Writes out a formatted string, using the same semantics as specified. */
			Write(
				format: string,
				arg0: System.Object | undefined,
			): void;

			/** Writes out a formatted string, using the same semantics as specified. */
			Write(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): void;

			/** Writes out a formatted string, using the same semantics as specified. */
			Write(
				format: string,
				arg: System.Object | undefined[],
			): void;

			/**
			 * Asynchronously writes the specified {@link System.Char} to the underlying
			 * {@link System.IO.TextWriter}, inserting tabs at the start of every line.
			 */
			WriteAsync(value: System.Char): Promise<void>;

			/**
			 * Asynchronously writes the specified number of {@link System.Char} s from the specified
			 * buffer to the underlying {@link System.IO.TextWriter}, starting at the specified
			 * index, and outputting tabs at the start of every new line.
			 */
			WriteAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<void>;

			/**
			 * Asynchronously writes the specified characters to the underlying
			 * {@link System.IO.TextWriter}, inserting tabs at the start of every line.
			 */
			WriteAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the specified string to the underlying
			 * {@link System.IO.TextWriter}, inserting tabs at the start of every line.
			 */
			WriteAsync(value: string | undefined): Promise<void>;

			/**
			 * Asynchronously writes the contents of the specified {@link System.Text.StringBuilder}
			 * to the underlying {@link System.IO.TextWriter}, inserting tabs at the start of every
			 * line.
			 */
			WriteAsync(
				value: System.Text.StringBuilder | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** Writes a line terminator. */
			WriteLine(): void;

			/**
			 * Writes the text representation of a Boolean, followed by a line terminator, to the
			 * text stream.
			 */
			WriteLine(value: boolean): void;

			/** Writes a character, followed by a line terminator, to the text stream. */
			WriteLine(value: System.Char): void;

			/** Writes a character array, followed by a line terminator, to the text stream. */
			WriteLine(buffer: System.Char[] | undefined): void;

			/**
			 * Writes a subarray of characters, followed by a line terminator, to the text stream.
			 */
			WriteLine(
				buffer: System.Char[],
				index: number,
				count: number,
			): void;

			/**
			 * Writes the text representation of a Double, followed by a line terminator, to the text
			 * stream.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an integer, followed by a line terminator, to the
			 * text stream.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an 8-byte integer, followed by a line terminator, to
			 * the text stream.
			 */
			WriteLine(value: number): void;

			/**
			 * Writes the text representation of an object, followed by a line terminator, to the
			 * text stream.
			 */
			WriteLine(value: System.Object | undefined): void;

			/**
			 * Writes the text representation of a Single, followed by a line terminator, to the text
			 * stream.
			 */
			WriteLine(value: number): void;

			/** Writes the specified string, followed by a line terminator, to the text stream. */
			WriteLine(s: string | undefined): void;

			/**
			 * Writes out a formatted string, followed by a line terminator, using the same semantics
			 * as specified.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
			): void;

			/**
			 * Writes out a formatted string, followed by a line terminator, using the same semantics
			 * as specified.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
			): void;

			/**
			 * Writes out a formatted string, followed by a line terminator, using the same semantics
			 * as specified.
			 */
			WriteLine(
				format: string,
				arg: System.Object | undefined[],
			): void;

			/**
			 * Writes the text representation of a UInt32, followed by a line terminator, to the text
			 * stream.
			 */
			WriteLine(value: number): void;

			/** Asynchronously writes the line terminator to the underlying  . */
			WriteLineAsync(): Promise<void>;

			/**
			 * Asynchronously writes the specified {@link System.Char} to the underlying
			 * {@link System.IO.TextWriter} followed by a line terminator, inserting tabs at the
			 * start of every line.
			 */
			WriteLineAsync(value: System.Char): Promise<void>;

			/**
			 * Asynchronously writes the specified number of characters from the specified buffer
			 * followed by a line terminator, to the underlying {@link System.IO.TextWriter},
			 * starting at the specified index within the buffer, inserting tabs at the start of
			 * every line.
			 */
			WriteLineAsync(
				buffer: System.Char[],
				index: number,
				count: number,
			): Promise<void>;

			/**
			 * Asynchronously writes the specified characters followed by a line terminator to the
			 * underlying {@link System.IO.TextWriter}, inserting tabs at the start of every line.
			 */
			WriteLineAsync(
				buffer: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/**
			 * Asynchronously writes the specified string followed by a line terminator to the
			 * underlying {@link System.IO.TextWriter}, inserting tabs at the start of every line.
			 */
			WriteLineAsync(value: string | undefined): Promise<void>;

			/**
			 * Asynchronously writes the contents of the specified {@link System.Text.StringBuilder}
			 * followed by a line terminator to the underlying {@link System.IO.TextWriter},
			 * inserting tabs at the start of every line.
			 */
			WriteLineAsync(
				value: System.Text.StringBuilder | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			/** Writes the specified string to a line without tabs. */
			WriteLineNoTabs(s: string | undefined): void;

			/**
			 * Asynchronously writes the specified string to the underlying
			 * {@link System.IO.TextWriter} without inserting tabs.
			 */
			WriteLineNoTabsAsync(s: string | undefined): Promise<void>;

			/** Writes the text representation of a decimal value to the text stream. */
			Write(value: System.Decimal): void;

			/** Writes a character span to the text stream. */
			Write(buffer: System.ReadOnlySpan$1<System.Char>): void;

			/**
			 * Writes a formatted string to the text stream, using the same semantics as the
			 * {@link System.String.Format(System.String,System.Object,System.Object,System.Object)}
			 * method.
			 */
			Write(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): void;

			/** Writes a string builder to the text stream. */
			Write(value: System.Text.StringBuilder | undefined): void;

			/** Writes the text representation of a 4-byte unsigned integer to the text stream. */
			Write(value: number): void;

			/** Writes the text representation of an 8-byte unsigned integer to the text stream. */
			Write(value: number): void;

			/** Writes a character array to the text stream asynchronously. */
			WriteAsync(buffer: System.Char[] | undefined): Promise<void>;

			/**
			 * Writes the text representation of a decimal value to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(value: System.Decimal): void;

			/**
			 * Writes the text representation of a character span to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(buffer: System.ReadOnlySpan$1<System.Char>): void;

			/**
			 * Writes out a formatted string and a new line to the text stream, using the same
			 * semantics as {@link System.String.Format(System.String,System.Object)}.
			 */
			WriteLine(
				format: string,
				arg0: System.Object | undefined,
				arg1: System.Object | undefined,
				arg2: System.Object | undefined,
			): void;

			/**
			 * Writes the text representation of a string builder to the text stream, followed by a
			 * line terminator.
			 */
			WriteLine(value: System.Text.StringBuilder | undefined): void;

			/**
			 * Writes the text representation of an 8-byte unsigned integer to the text stream,
			 * followed by a line terminator.
			 */
			WriteLine(value: number): void;

			/**
			 * Asynchronously writes an array of characters to the text stream, followed by a line
			 * terminator.
			 */
			WriteLineAsync(buffer: System.Char[] | undefined): Promise<void>;
		}
	}

	export namespace System.Buffers {
		/**
		 * [Generic type factory] Provides a resource pool that enables reusing instances of type
		 * T[].
		 */
		export function ArrayPool$(T: IType): typeof ArrayPool$1<any>;

		/** Provides a resource pool that enables reusing instances of type T[]. */
		export class ArrayPool$1<T> {
			/** Gets a shared {@link System.Buffers.ArrayPool<>} instance. */
			static readonly Shared: System.Buffers.ArrayPool$1<any>;

			/** Creates a new instance of the {@link System.Buffers.ArrayPool<>} class. */
			static Create(): System.Buffers.ArrayPool$1<any>;

			/**
			 * Creates a new instance of the {@link System.Buffers.ArrayPool<>} class using the
			 * specified configuration.
			 */
			static Create(
				maxArrayLength: number,
				maxArraysPerBucket: number,
			): System.Buffers.ArrayPool$1<any>;

			/** Retrieves a buffer that is at least the requested length. */
			Rent(minimumLength: number): T[];

			Return(
				array: T[],
				clearArray?: boolean,
			): void;
		}
	}

	export namespace System.Buffers {
		/**
		 * [Generic type factory] Identifies the owner of a block of memory who is responsible
		 * for disposing of the underlying memory appropriately.
		 */
		export function IMemoryOwner$(T: IType): IType;

		/**
		 * Identifies the owner of a block of memory who is responsible for disposing of the
		 * underlying memory appropriately.
		 */
		export interface IMemoryOwner$1<T> extends IDisposable {
			/** Gets the memory belonging to this owner. */
			readonly Memory: unknown;
		}
	}

	export namespace System.Buffers {
		/**
		 * [Generic type factory] Provides an immutable, read-only set of values optimized for
		 * efficient searching. Instances are created by
		 * {@link System.Buffers.SearchValues.Create(System.ReadOnlySpan{System.Byte})} or
		 * {@link System.Buffers.SearchValues.Create(System.ReadOnlySpan{System.Char})}.
		 */
		export function SearchValues$(T: IType): typeof SearchValues$1<any>;

		/**
		 * Provides an immutable, read-only set of values optimized for efficient searching.
		 * Instances are created by
		 * {@link System.Buffers.SearchValues.Create(System.ReadOnlySpan{System.Byte})} or
		 * {@link System.Buffers.SearchValues.Create(System.ReadOnlySpan{System.Char})}.
		 */
		export class SearchValues$1<T> {
			/** Searches for the specified value. */
			Contains(value: T): boolean;
		}
	}

	export namespace System.Buffers {
		/**
		 * Provides a set of initialization methods for instances of the
		 * {@link System.Buffers.SearchValues<>} class.
		 */
		export namespace SearchValues {
			/** Creates an optimized representation of `values` used for efficient searching. */
			export function Create(values: System.ReadOnlySpan$1<number>): System.Buffers.SearchValues$1<number>;

			/** Creates an optimized representation of `values` used for efficient searching. */
			export function Create(values: System.ReadOnlySpan$1<System.Char>): System.Buffers.SearchValues$1<System.Char>;
		}
	}

	export namespace System.Buffers {
		/**
		 * Provides a mechanism for pinning and unpinning objects to prevent the garbage
		 * collector from moving them.
		 */
		export interface IPinnable {
			/** Pins a block of memory. */
			Pin(elementIndex: number): System.Buffers.MemoryHandle;

			/** Frees a block of pinned memory. */
			Unpin(): void;
		}
	}

	export namespace System.Buffers {
		/** Provides a memory handle for a block of memory. */
		export class MemoryHandle extends System.ValueType implements IDisposable {
			/**
			 * Frees the pinned handle and releases the {@link System.Buffers.IPinnable} instance.
			 */
			dispose(): void;
		}
	}

	export namespace System.Buffers {
		/**
		 * [Generic type factory] An abstract base class that is used to replace the
		 * implementation of {@link System.Memory<>}.
		 */
		export function MemoryManager$(T: IType): typeof MemoryManager$1<any>;

		/**
		 * An abstract base class that is used to replace the implementation of
		 * {@link System.Memory<>}.
		 */
		export class MemoryManager$1<T> implements
			System.Buffers.IPinnable {
			/** Gets the memory block handled by this {@link System.Buffers.MemoryManager<>}. */
			readonly Memory: unknown;

			/** Returns a memory span that wraps the underlying memory buffer. */
			GetSpan(): System.Span$1<T>;

			/**
			 * Returns a handle to the memory that has been pinned and whose address can be taken.
			 */
			Pin(elementIndex?: number): System.Buffers.MemoryHandle;

			/** Unpins pinned memory so that the garbage collector is free to move it. */
			Unpin(): void;
		}
	}

	export namespace System.Buffers {
		/**
		 * Defines the values that can be returned from span-based operations that support
		 * processing of input contained in multiple discontiguous buffers.
		 */
		export enum OperationStatus {
			/** The entire input buffer has been processed and the operation is complete. */
			Done = 0,

			/**
			 * The input is partially processed, up to what could fit into the destination buffer.
			 * The caller can enlarge the destination buffer, slice the buffers appropriately, and
			 * retry.
			 */
			DestinationTooSmall = 1,

			/**
			 * The input is partially processed, up to the last valid chunk of the input that could
			 * be consumed. The caller can stitch the remaining unprocessed input with more data,
			 * slice the buffers appropriately, and retry.
			 */
			NeedMoreData = 2,

			/**
			 * The input contained invalid bytes which could not be processed. If the input is
			 * partially processed, the destination contains the partial result. This guarantees that
			 * no additional data appended to the input will make the invalid sequence valid.
			 */
			InvalidData = 3,
		}
	}

	export namespace System.Buffers {
		/**
		 * [Generic type factory] Encapsulates a method that receives a read-only span of objects
		 * of type  and a state object of type  .
		 */
		export function ReadOnlySpanAction$(T: IType, TArg: IType): IType;

		/**
		 * Encapsulates a method that receives a read-only span of objects of type  and a state
		 * object of type  .
		 */
		export interface ReadOnlySpanAction$2<T, TArg> { (
			span: System.ReadOnlySpan$1<T>,
			arg: TArg,
		): void; }
	}

	export namespace System.Buffers {
		/**
		 * [Generic type factory] Encapsulates a method that receives a span of objects of type
		 * and a state object of type  .
		 */
		export function SpanAction$(T: IType, TArg: IType): IType;

		/**
		 * Encapsulates a method that receives a span of objects of type  and a state object of
		 * type  .
		 */
		export interface SpanAction$2<T, TArg> { (
			span: System.Span$1<T>,
			arg: TArg,
		): void; }
	}

	export namespace System.Buffers.Text {
		/**
		 * Converts between binary data and UTF-8 encoded text that is represented in base 64.
		 */
		export namespace Base64 {
			export function DecodeFromUtf8(
				utf8: System.ReadOnlySpan$1<number>,
				bytes: System.Span$1<number>,
				isFinalBlock?: boolean,
			): { result: System.Buffers.OperationStatus, bytesConsumed: number, bytesWritten: number };

			export function DecodeFromUtf8InPlace(buffer: System.Span$1<number>): { result: System.Buffers.OperationStatus, bytesWritten: number };

			export function EncodeToUtf8(
				bytes: System.ReadOnlySpan$1<number>,
				utf8: System.Span$1<number>,
				isFinalBlock?: boolean,
			): { result: System.Buffers.OperationStatus, bytesConsumed: number, bytesWritten: number };

			export function EncodeToUtf8InPlace(
				buffer: System.Span$1<number>,
				dataLength: number,
			): { result: System.Buffers.OperationStatus, bytesWritten: number };

			/**
			 * Returns the maximum length (in bytes) of the result if you were to decode base-64
			 * encoded text within a byte span with the specified length.
			 */
			export function GetMaxDecodedFromUtf8Length(length: number): number;

			/**
			 * Returns the maximum length (in bytes) of the result if you were to encode binary data
			 * within a byte span with the specified length.
			 */
			export function GetMaxEncodedToUtf8Length(length: number): number;

			/**
			 * Validates that the specified span of text is comprised of valid base-64 encoded data.
			 */
			export function IsValid(base64Text: System.ReadOnlySpan$1<System.Char>): boolean;

			export function IsValid(base64Text: System.ReadOnlySpan$1<System.Char>): { result: boolean, decodedLength: number };

			/**
			 * Validates that the specified span of UTF-8 text is comprised of valid base-64 encoded
			 * data.
			 */
			export function IsValid(base64TextUtf8: System.ReadOnlySpan$1<number>): boolean;

			export function IsValid(base64TextUtf8: System.ReadOnlySpan$1<number>): { result: boolean, decodedLength: number };
		}
	}

	export namespace Microsoft.Win32.SafeHandles {
		/**
		 * Provides a base class for Win32 critical handle implementations in which the value of
		 * -1 indicates an invalid handle.
		 */
		export class CriticalHandleMinusOneIsInvalid extends System.Runtime.InteropServices.CriticalHandle implements IDisposable {
			/** Gets a value that indicates whether the handle is invalid. */
			readonly IsInvalid: boolean;
		}
	}

	export namespace Microsoft.Win32.SafeHandles {
		/**
		 * Provides a base class for Win32 critical handle implementations in which the value of
		 * either 0 or -1 indicates an invalid handle.
		 */
		export class CriticalHandleZeroOrMinusOneIsInvalid extends System.Runtime.InteropServices.CriticalHandle implements IDisposable {
			/** Gets a value that indicates whether the handle is invalid. */
			readonly IsInvalid: boolean;
		}
	}

	export namespace Microsoft.Win32.SafeHandles {
		/** Represents a wrapper class for a file handle. */
		export class SafeFileHandle extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid implements IDisposable {
			/** Creates a {@link Microsoft.Win32.SafeHandles.SafeFileHandle} around a file handle. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Microsoft.Win32.SafeHandles.SafeFileHandle}
			 * class.
			 */
			constructor(
				preexistingHandle: System.IntPtr,
				ownsHandle: boolean,
			);

			/** Gets a value that indicates whether the handle is invalid. */
			readonly IsInvalid: boolean;

			/** Gets a value that determines if the handle is asynchronous or not. */
			readonly IsAsync: boolean;
		}
	}

	export namespace Microsoft.Win32.SafeHandles {
		/**
		 * Provides a base class for Win32 safe handle implementations in which the value of -1
		 * indicates an invalid handle.
		 */
		export class SafeHandleMinusOneIsInvalid extends System.Runtime.InteropServices.SafeHandle implements IDisposable {
			/** Gets a value that indicates whether the handle is invalid. */
			readonly IsInvalid: boolean;
		}
	}

	export namespace Microsoft.Win32.SafeHandles {
		/**
		 * Provides a base class for Win32 safe handle implementations in which the value of
		 * either 0 or -1 indicates an invalid handle.
		 */
		export class SafeHandleZeroOrMinusOneIsInvalid extends System.Runtime.InteropServices.SafeHandle implements IDisposable {
			/** Gets a value that indicates whether the handle is invalid. */
			readonly IsInvalid: boolean;
		}
	}

	export namespace Microsoft.Win32.SafeHandles {
		/** Represents a wrapper class for a wait handle. */
		export class SafeWaitHandle extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid implements IDisposable {
			/** Creates a {@link Microsoft.Win32.SafeHandles.SafeWaitHandle}. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Microsoft.Win32.SafeHandles.SafeWaitHandle}
			 * class.
			 */
			constructor(
				existingHandle: System.IntPtr,
				ownsHandle: boolean,
			);
		}
	}
}
