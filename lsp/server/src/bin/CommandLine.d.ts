// Generated for: CommandLine 2.9.1.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.8.0.0
/* eslint-disable */

import './System.Runtime';

/** A JavaScript projection of a .NET type. */
interface IType {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): IType;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace CommandLine {
		/** Models a base attribute to define command line syntax. */
		export class BaseAttribute extends System.Attribute {
			/** Gets or sets a value indicating whether a command line option is required. */
			Required: boolean;

			/**
			 * When applied to {@link System.Collections.Generic.IEnumerable<>} properties defines
			 * the lower range of items.
			 *
			 * If not set, no lower range is enforced.
			 */
			Min: number;

			/**
			 * When applied to {@link System.Collections.Generic.IEnumerable<>} properties defines
			 * the upper range of items.
			 *
			 * If not set, no upper range is enforced.
			 */
			Max: number;

			/** Gets or sets mapped property default value. */
			Default: System.Object;

			/**
			 * Gets or sets a short description of this command line option. Usually a sentence
			 * summary.
			 */
			HelpText: string;

			/**
			 * Gets or sets mapped property meta value. Usually an uppercase hint of required value
			 * type.
			 */
			MetaValue: string;

			/**
			 * Gets or sets a value indicating whether a command line option is visible in the help
			 * text.
			 */
			Hidden: boolean;

			/**
			 * Gets or sets the {@link System.Type} that contains the resources for
			 * {@link CommandLine.BaseAttribute.HelpText}.
			 */
			ResourceType: System.Type;
		}
	}

	export namespace CommandLine {
		export namespace CastExtensions {
			export function CanCast<T>(baseType: System.Type): boolean;

			export function CanCast<T>(obj: System.Object): boolean;

			export function Cast<T>(obj: System.Object): T;
		}
	}

	export namespace System {
		/** Extension methods from {@link CommandLine.CastExtensions} */
		export interface Type {
			CanCast<T>(): boolean;
		}
	}

	export namespace System {
		/** Extension methods from {@link CommandLine.CastExtensions} */
		export interface Object {
			CanCast<T>(): boolean;

			Cast<T>(): T;
		}
	}

	export namespace CommandLine {
		/** Discriminator enumeration of {@link CommandLine.Error} derivates. */
		export enum ErrorType {
			/** Value of {@link CommandLine.BadFormatTokenError} type. */
			BadFormatTokenError = 0,

			/** Value of {@link CommandLine.MissingValueOptionError} type. */
			MissingValueOptionError = 1,

			/** Value of {@link CommandLine.UnknownOptionError} type. */
			UnknownOptionError = 2,

			/** Value of {@link CommandLine.MissingRequiredOptionError} type. */
			MissingRequiredOptionError = 3,

			/** Value of {@link CommandLine.MutuallyExclusiveSetError} type. */
			MutuallyExclusiveSetError = 4,

			/** Value of {@link CommandLine.BadFormatConversionError} type. */
			BadFormatConversionError = 5,

			/** Value of {@link CommandLine.SequenceOutOfRangeError} type. */
			SequenceOutOfRangeError = 6,

			/** Value of {@link CommandLine.RepeatedOptionError} type. */
			RepeatedOptionError = 7,

			/** Value of {@link CommandLine.NoVerbSelectedError} type. */
			NoVerbSelectedError = 8,

			/** Value of {@link CommandLine.BadVerbSelectedError} type. */
			BadVerbSelectedError = 9,

			/** Value of {@link CommandLine.HelpRequestedError} type. */
			HelpRequestedError = 10,

			/** Value of {@link CommandLine.HelpVerbRequestedError} type. */
			HelpVerbRequestedError = 11,

			/** Value of {@link CommandLine.VersionRequestedError} type. */
			VersionRequestedError = 12,

			/** Value of {@link CommandLine.SetValueExceptionError} type. */
			SetValueExceptionError = 13,

			/** Value of {@link CommandLine.InvalidAttributeConfigurationError} type. */
			InvalidAttributeConfigurationError = 14,

			/** Value of {@link CommandLine.MissingGroupOptionError} type. */
			MissingGroupOptionError = 15,

			/** Value of {@link CommandLine.GroupOptionAmbiguityError} type. */
			GroupOptionAmbiguityError = 16,

			/** Value of {@link CommandLine.MultipleDefaultVerbsError} type. */
			MultipleDefaultVerbsError = 17,
		}
	}

	export namespace CommandLine {
		/**
		 * Base type of all errors.
		 *
		 * All errors are defined within the system. There's no reason to create custom derivate
		 * types.
		 */
		export class Error {
			/** Error type discriminator, defined as {@link CommandLine.ErrorType} enumeration. */
			readonly Tag: CommandLine.ErrorType;

			/**
			 * Tells if error stops parsing process. Filtered by
			 * {@link CommandLine.ErrorExtensions.OnlyMeaningfulOnes(System.Collections.Generic.IEnumerable{CommandLine.Error})}.
			 */
			readonly StopsProcessing: boolean;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link System.Object}.
			 */
			Equals(obj: System.Object): boolean;

			/**
			 * Serves as a hash function for a particular type.
			 *
			 * A hash code for the current {@link System.Object}.
			 */
			GetHashCode(): number;

			/**
			 * Returns a value that indicates whether the current instance and a specified
			 * {@link CommandLine.Error} have the same value.
			 */
			Equals(other: CommandLine.Error): boolean;
		}
	}

	export namespace CommandLine {
		/** Base type of all errors related to bad token detection. */
		export class TokenError extends CommandLine.Error {
			/** The string containing the token text. */
			readonly Token: string;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link System.Object}.
			 */
			Equals(obj: System.Object): boolean;

			/**
			 * Serves as a hash function for a particular type.
			 *
			 * A hash code for the current {@link System.Object}.
			 */
			GetHashCode(): number;

			/**
			 * Returns a value that indicates whether the current instance and a specified
			 * {@link CommandLine.TokenError} have the same value.
			 */
			Equals(other: CommandLine.TokenError): boolean;

			/**
			 * Returns a value that indicates whether the current instance and a specified
			 * {@link CommandLine.Error} have the same value.
			 */
			Equals(other: CommandLine.Error): boolean;
		}
	}

	export namespace CommandLine {
		/** Models an error generated when an invalid token is detected. */
		export class BadFormatTokenError extends CommandLine.TokenError {
		}
	}

	export namespace CommandLine {
		/** Base type of all erros with name information. */
		export class NamedError extends CommandLine.Error {
			/** Name information relative to this error instance. */
			readonly NameInfo: CommandLine.NameInfo;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link System.Object}.
			 */
			Equals(obj: System.Object): boolean;

			/**
			 * Serves as a hash function for a particular type.
			 *
			 * A hash code for the current {@link System.Object}.
			 */
			GetHashCode(): number;

			/**
			 * Returns a value that indicates whether the current instance and a specified
			 * {@link CommandLine.NamedError} have the same value.
			 */
			Equals(other: CommandLine.NamedError): boolean;

			/**
			 * Returns a value that indicates whether the current instance and a specified
			 * {@link CommandLine.Error} have the same value.
			 */
			Equals(other: CommandLine.Error): boolean;
		}
	}

	export namespace CommandLine {
		/** Models an error generated when an option lacks its value. */
		export class MissingValueOptionError extends CommandLine.NamedError {
		}
	}

	export namespace CommandLine {
		/** Models an error generated when an unknown option is detected. */
		export class UnknownOptionError extends CommandLine.TokenError {
		}
	}

	export namespace CommandLine {
		/** Models an error generated when a required option is required. */
		export class MissingRequiredOptionError extends CommandLine.NamedError {
		}
	}

	export namespace CommandLine {
		/** Models an error generated when a an option from another set is defined. */
		export class MutuallyExclusiveSetError extends CommandLine.NamedError {
			/** Option's set name. */
			readonly SetName: string;
		}
	}

	export namespace CommandLine {
		/** Models an error generated when a value conversion fails. */
		export class BadFormatConversionError extends CommandLine.NamedError {
		}
	}

	export namespace CommandLine {
		/** Models an error generated when a sequence value lacks elements. */
		export class SequenceOutOfRangeError extends CommandLine.NamedError {
		}
	}

	export namespace CommandLine {
		/** Models an error generated when an option is repeated two or more times. */
		export class RepeatedOptionError extends CommandLine.NamedError {
		}
	}

	export namespace CommandLine {
		/** Models an error generated when an unknown verb is detected. */
		export class BadVerbSelectedError extends CommandLine.TokenError {
		}
	}

	export namespace CommandLine {
		/** Models an error generated when a user explicitly requests help. */
		export class HelpRequestedError extends CommandLine.Error {
		}
	}

	export namespace CommandLine {
		/**
		 * Models an error generated when a user explicitly requests help in verb commands
		 * scenario.
		 */
		export class HelpVerbRequestedError extends CommandLine.Error {
			/** Verb command string. */
			readonly Verb: string;

			/** {@link System.Type} of verb command. */
			readonly Type: System.Type;

			/** true if verb command is found; otherwise false . */
			readonly Matched: boolean;
		}
	}

	export namespace CommandLine {
		/** Models an error generated when no verb is selected. */
		export class NoVerbSelectedError extends CommandLine.Error {
		}
	}

	export namespace CommandLine {
		/** Models an error generated when a user explicitly requests version. */
		export class VersionRequestedError extends CommandLine.Error {
		}
	}

	export namespace CommandLine {
		/** Models as error generated when exception is thrown at Property.SetValue */
		export class SetValueExceptionError extends CommandLine.NamedError {
			/** The expection thrown from Property.SetValue */
			readonly Exception: System.Exception;

			/** The value that had to be set to the property */
			readonly Value: System.Object;
		}
	}

	export namespace CommandLine {
		/** Models an error generated when an invalid token is detected. */
		export class InvalidAttributeConfigurationError extends CommandLine.Error {
		}
	}

	export namespace CommandLine {
		export class MissingGroupOptionError extends CommandLine.Error {
			readonly Group: string;

			readonly Names: Iterable<CommandLine.NameInfo>;

			Equals(obj: CommandLine.Error): boolean;

			Equals(other: CommandLine.MissingGroupOptionError): boolean;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link System.Object}.
			 */
			Equals(obj: System.Object): boolean;

			/**
			 * Returns a value that indicates whether the current instance and a specified
			 * {@link CommandLine.Error} have the same value.
			 */
			Equals(other: CommandLine.Error): boolean;
		}
	}

	export namespace CommandLine {
		export class GroupOptionAmbiguityError extends CommandLine.NamedError {
		}
	}

	export namespace CommandLine {
		/** Models an error generated when multiple default verbs are defined. */
		export class MultipleDefaultVerbsError extends CommandLine.Error {
		}
	}

	export namespace CommandLine {
		export namespace HelpTextExtensions {
			/** return true when errors contain HelpXXXError */
			export function IsHelp(errs: Iterable<CommandLine.Error>): boolean;

			/** return true when errors contain VersionXXXError */
			export function IsVersion(errs: Iterable<CommandLine.Error>): boolean;

			/** redirect errs to Console.Error, and to Console.Out for help/version error */
			export function Output(errs: Iterable<CommandLine.Error>): System.IO.TextWriter;
		}
	}

	export namespace CommandLine {
		/** Models name information, used in {@link CommandLine.Error} instances. */
		export class NameInfo {
			/** Gets the short name of the name information. */
			readonly ShortName: string;

			/** Gets the long name of the name information. */
			readonly LongName: string;

			/** Gets a formatted text with unified name information. */
			readonly NameText: string;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link System.Object}.
			 */
			Equals(obj: System.Object): boolean;

			/**
			 * Serves as a hash function for a particular type.
			 *
			 * A hash code for the current {@link System.Object}.
			 */
			GetHashCode(): number;

			/**
			 * Returns a value that indicates whether the current instance and a specified
			 * {@link CommandLine.NameInfo} have the same value.
			 */
			Equals(other: CommandLine.NameInfo): boolean;
		}
	}

	export namespace CommandLine {
		/**
		 * Models a null result when constructing a {@link CommandLine.ParserResult<>} in a
		 * faling verbs scenario.
		 */
		export class NullInstance {
		}
	}

	export namespace CommandLine {
		/** Models an option specification. */
		export class OptionAttribute extends CommandLine.BaseAttribute {
			/**
			 * Initializes a new instance of the {@link CommandLine.OptionAttribute} class. The
			 * default long name will be inferred from target property.
			 */
			constructor();

			/** Initializes a new instance of the {@link CommandLine.OptionAttribute} class. */
			constructor(longName: string);

			/** Initializes a new instance of the {@link CommandLine.OptionAttribute} class. */
			constructor(
				shortName: System.Char,
				longName: string,
			);

			/** Initializes a new instance of the {@link CommandLine.OptionAttribute} class. */
			constructor(shortName: System.Char);

			/**
			 * Gets long name of this command line option. This name is usually a single english
			 * word.
			 */
			readonly LongName: string;

			/** Gets a short name of this command line option, made of one character. */
			readonly ShortName: string;

			/** Gets or sets the option's mutually exclusive set name. */
			SetName: string;

			/**
			 * If true, this is an int option that counts how many times a flag was set (e.g. "-v -v
			 * -v" or "-vvv" would return 3). The property must be of type int (signed 32-bit
			 * integer).
			 */
			FlagCounter: boolean;

			/**
			 * When applying attribute to {@link System.Collections.Generic.IEnumerable<>} target
			 * properties, it allows you to split an argument and consume its content as a sequence.
			 */
			Separator: System.Char;

			/**
			 * Gets or sets the option group name. When one or more options are grouped, at least one
			 * of them should have value. Required rules are ignored.
			 */
			Group: string;
		}
	}

	export namespace CommandLine {
		/** Provides methods to parse command line arguments. */
		export class Parser {
			/** Initializes a new instance of the {@link CommandLine.Parser} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link CommandLine.Parser} class, configurable with
			 * {@link CommandLine.ParserSettings} using a delegate.
			 */
			constructor(configuration: System.Action$1<CommandLine.ParserSettings>);

			/** Gets the singleton instance created with basic defaults. */
			static readonly Default: CommandLine.Parser;

			/** Gets the instance that implements {@link CommandLine.ParserSettings} in use. */
			readonly Settings: CommandLine.ParserSettings;

			/**
			 * Parses a string array of command line arguments constructing values in an instance of
			 * type  . Grammar rules are defined decorating public properties with appropriate
			 * attributes.
			 */
			ParseArguments<T>(args: Iterable<string>): CommandLine.ParserResult$1<T>;

			/**
			 * Parses a string array of command line arguments constructing values in an instance of
			 * type  . Grammar rules are defined decorating public properties with appropriate
			 * attributes.
			 */
			ParseArguments<T>(
				factory: System.Func$1<T>,
				args: Iterable<string>,
			): CommandLine.ParserResult$1<T>;

			/**
			 * Parses a string array of command line arguments for verb commands scenario,
			 * constructing the proper instance from the array of types supplied by `types`. Grammar
			 * rules are defined decorating public properties with appropriate attributes. The
			 * {@link CommandLine.VerbAttribute} must be applied to types in the array.
			 *
			 * All types must expose a parameterless constructor. It's strongly recommended to use a
			 * generic overload.
			 */
			ParseArguments(
				args: Iterable<string>,
				types: System.Type[],
			): CommandLine.ParserResult$1<System.Object>;

			/** Frees resources owned by the instance. */
			dispose(): void;
		}
	}

	export namespace CommandLine {
		/**
		 * Defines generic overloads for
		 * {@link CommandLine.Parser.ParseArguments(System.Collections.Generic.IEnumerable{System.String},System.Type[])}.
		 */
		export namespace ParserExtensions {
		}
	}

	export namespace CommandLine {
		export class TypeInfo {
			readonly Current: System.Type;

			readonly Choices: Iterable<System.Type>;
		}
	}

	export namespace CommandLine {
		/** Discriminator enumeration of {@link CommandLine.ParserResultType} derivates. */
		export enum ParserResultType {
			/** Value of {@link CommandLine.Parsed<>} type. */
			Parsed = 0,

			/** Value of {@link CommandLine.NotParsed<>} type. */
			NotParsed = 1,
		}
	}

	export namespace CommandLine {
		/**
		 * [Generic type factory] Models a parser result. When inherited by
		 * {@link CommandLine.Parsed<>}, it contains an instance of type  with parsed values.
		 * When inherited by {@link CommandLine.NotParsed<>}, it contains a sequence of
		 * {@link CommandLine.Error}.
		 */
		export function ParserResult$(T: IType): typeof ParserResult$1<any>;

		/**
		 * Models a parser result. When inherited by {@link CommandLine.Parsed<>}, it contains an
		 * instance of type  with parsed values. When inherited by
		 * {@link CommandLine.NotParsed<>}, it contains a sequence of {@link CommandLine.Error}.
		 */
		export class ParserResult$1<T> {
			/**
			 * Parser result type discriminator, defined as {@link CommandLine.ParserResultType}
			 * enumeration.
			 */
			readonly Tag: CommandLine.ParserResultType;

			readonly TypeInfo: CommandLine.TypeInfo;

			/**
			 * Gets the instance with parsed values. If one or more errors occures, `default` is
			 * returned.
			 */
			readonly Value: T;

			/**
			 * Gets the sequence of parsing errors. If there are no errors, then an empty IEnumerable
			 * is returned.
			 */
			readonly Errors: Iterable<CommandLine.Error>;
		}
	}

	export namespace CommandLine {
		/** [Generic type factory] It contains an instance of type  with parsed values. */
		export function Parsed$(T: IType): typeof Parsed$1<any>;

		/** It contains an instance of type  with parsed values. */
		export class Parsed$1<T> extends CommandLine.ParserResult$1<T> {
			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link System.Object}.
			 */
			Equals(obj: System.Object): boolean;

			/**
			 * Serves as a hash function for a particular type.
			 *
			 * A hash code for the current {@link System.Object}.
			 */
			GetHashCode(): number;

			/**
			 * Returns a value that indicates whether the current instance and a specified
			 * {@link CommandLine.Parsed<>} have the same value.
			 */
			Equals(other: CommandLine.Parsed$1<T>): boolean;
		}
	}

	export namespace CommandLine {
		/** [Generic type factory] It contains a sequence of {@link CommandLine.Error}. */
		export function NotParsed$(T: IType): typeof NotParsed$1<any>;

		/** It contains a sequence of {@link CommandLine.Error}. */
		export class NotParsed$1<T> extends CommandLine.ParserResult$1<T> {
			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link System.Object}.
			 */
			Equals(obj: System.Object): boolean;

			/**
			 * Serves as a hash function for a particular type.
			 *
			 * A hash code for the current {@link System.Object}.
			 */
			GetHashCode(): number;

			/**
			 * Returns a value that indicates whether the current instance and a specified
			 * {@link CommandLine.NotParsed<>} have the same value.
			 */
			Equals(other: CommandLine.NotParsed$1<T>): boolean;
		}
	}

	export namespace CommandLine {
		/** Provides convenience extension methods for {@link CommandLine.ParserResult<>}. */
		export namespace ParserResultExtensions {
			/** Executes `action` if {@link CommandLine.ParserResult<>} contains parsed values. */
			export function WithParsed<T>(
				result: CommandLine.ParserResult$1<T>,
				action: System.Action$1<T>,
			): CommandLine.ParserResult$1<T>;

			/** Executes `action` if parsed values are of  . */
			export function WithParsed<T>(
				result: CommandLine.ParserResult$1<System.Object>,
				action: System.Action$1<T>,
			): CommandLine.ParserResult$1<System.Object>;

			/**
			 * Executes `action` if {@link CommandLine.ParserResult<>} lacks parsed values and
			 * contains errors.
			 */
			export function WithNotParsed<T>(
				result: CommandLine.ParserResult$1<T>,
				action: System.Action$1<Iterable<CommandLine.Error>>,
			): CommandLine.ParserResult$1<T>;

			/** Provides a way to transform result data into another value. */
			export function MapResult<TSource, TResult>(
				result: CommandLine.ParserResult$1<TSource>,
				parsedFunc: System.Func$2<TSource, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, T7, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				parsedFunc7: System.Func$2<T7, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				parsedFunc7: System.Func$2<T7, TResult>,
				parsedFunc8: System.Func$2<T8, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				parsedFunc7: System.Func$2<T7, TResult>,
				parsedFunc8: System.Func$2<T8, TResult>,
				parsedFunc9: System.Func$2<T9, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				parsedFunc7: System.Func$2<T7, TResult>,
				parsedFunc8: System.Func$2<T8, TResult>,
				parsedFunc9: System.Func$2<T9, TResult>,
				parsedFunc10: System.Func$2<T10, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				parsedFunc7: System.Func$2<T7, TResult>,
				parsedFunc8: System.Func$2<T8, TResult>,
				parsedFunc9: System.Func$2<T9, TResult>,
				parsedFunc10: System.Func$2<T10, TResult>,
				parsedFunc11: System.Func$2<T11, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				parsedFunc7: System.Func$2<T7, TResult>,
				parsedFunc8: System.Func$2<T8, TResult>,
				parsedFunc9: System.Func$2<T9, TResult>,
				parsedFunc10: System.Func$2<T10, TResult>,
				parsedFunc11: System.Func$2<T11, TResult>,
				parsedFunc12: System.Func$2<T12, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				parsedFunc7: System.Func$2<T7, TResult>,
				parsedFunc8: System.Func$2<T8, TResult>,
				parsedFunc9: System.Func$2<T9, TResult>,
				parsedFunc10: System.Func$2<T10, TResult>,
				parsedFunc11: System.Func$2<T11, TResult>,
				parsedFunc12: System.Func$2<T12, TResult>,
				parsedFunc13: System.Func$2<T13, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				parsedFunc7: System.Func$2<T7, TResult>,
				parsedFunc8: System.Func$2<T8, TResult>,
				parsedFunc9: System.Func$2<T9, TResult>,
				parsedFunc10: System.Func$2<T10, TResult>,
				parsedFunc11: System.Func$2<T11, TResult>,
				parsedFunc12: System.Func$2<T12, TResult>,
				parsedFunc13: System.Func$2<T13, TResult>,
				parsedFunc14: System.Func$2<T14, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				parsedFunc7: System.Func$2<T7, TResult>,
				parsedFunc8: System.Func$2<T8, TResult>,
				parsedFunc9: System.Func$2<T9, TResult>,
				parsedFunc10: System.Func$2<T10, TResult>,
				parsedFunc11: System.Func$2<T11, TResult>,
				parsedFunc12: System.Func$2<T12, TResult>,
				parsedFunc13: System.Func$2<T13, TResult>,
				parsedFunc14: System.Func$2<T14, TResult>,
				parsedFunc15: System.Func$2<T15, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/** Provides a way to transform result data into another value. */
			export function MapResult<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult>(
				result: CommandLine.ParserResult$1<System.Object>,
				parsedFunc1: System.Func$2<T1, TResult>,
				parsedFunc2: System.Func$2<T2, TResult>,
				parsedFunc3: System.Func$2<T3, TResult>,
				parsedFunc4: System.Func$2<T4, TResult>,
				parsedFunc5: System.Func$2<T5, TResult>,
				parsedFunc6: System.Func$2<T6, TResult>,
				parsedFunc7: System.Func$2<T7, TResult>,
				parsedFunc8: System.Func$2<T8, TResult>,
				parsedFunc9: System.Func$2<T9, TResult>,
				parsedFunc10: System.Func$2<T10, TResult>,
				parsedFunc11: System.Func$2<T11, TResult>,
				parsedFunc12: System.Func$2<T12, TResult>,
				parsedFunc13: System.Func$2<T13, TResult>,
				parsedFunc14: System.Func$2<T14, TResult>,
				parsedFunc15: System.Func$2<T15, TResult>,
				parsedFunc16: System.Func$2<T16, TResult>,
				notParsedFunc: System.Func$2<Iterable<CommandLine.Error>, TResult>,
			): TResult;

			/**
			 * Executes asynchronously `action` if {@link CommandLine.ParserResult<>} contains parsed
			 * values.
			 */
			export function WithParsedAsync<T>(
				result: CommandLine.ParserResult$1<T>,
				action: System.Func$2<T, Promise<void>>,
			): Promise<CommandLine.ParserResult$1<T>>;

			/** Executes asynchronously `action` if parsed values are of  . */
			export function WithParsedAsync<T>(
				result: CommandLine.ParserResult$1<System.Object>,
				action: System.Func$2<T, Promise<void>>,
			): Promise<CommandLine.ParserResult$1<System.Object>>;

			/**
			 * Executes asynchronously `action` if {@link CommandLine.ParserResult<>} lacks parsed
			 * values and contains errors.
			 */
			export function WithNotParsedAsync<T>(
				result: CommandLine.ParserResult$1<T>,
				action: System.Func$2<Iterable<CommandLine.Error>, Promise<void>>,
			): Promise<CommandLine.ParserResult$1<T>>;
		}
	}

	export namespace CommandLine {
		/** Provides settings for {@link CommandLine.Parser}. Once consumed cannot be reused. */
		export class ParserSettings {
			/** Initializes a new instance of the {@link CommandLine.ParserSettings} class. */
			constructor();

			/**
			 * Gets or sets a value indicating whether perform case sensitive comparisons. Note that
			 * case insensitivity only applies to parameters , not the values assigned to them (for
			 * example, enum parsing).
			 */
			CaseSensitive: boolean;

			/**
			 * Gets or sets a value indicating whether perform case sensitive comparisons of values .
			 * Note that case insensitivity only applies to values , not the parameters.
			 */
			CaseInsensitiveEnumValues: boolean;

			/**
			 * Gets or sets the culture used when parsing arguments to typed properties.
			 *
			 * Default is invariant culture,
			 * {@link System.Globalization.CultureInfo.InvariantCulture}.
			 */
			ParsingCulture: System.Globalization.CultureInfo;

			/**
			 * Gets or sets the {@link System.IO.TextWriter} used for help method output. Setting
			 * this property to null, will disable help screen.
			 *
			 * It is the caller's responsibility to dispose or close the
			 * {@link System.IO.TextWriter}.
			 */
			HelpWriter: System.IO.TextWriter;

			/**
			 * Gets or sets a value indicating whether the parser shall move on to the next argument
			 * and ignore the given argument if it encounter an unknown arguments
			 *
			 * This allows fragmented version class parsing, useful for project with add-on where
			 * add-ons also requires command line arguments but when these are unknown by the main
			 * program at build time.
			 */
			IgnoreUnknownArguments: boolean;

			/**
			 * Gets or sets a value indicating whether implicit option or verb 'help' should be
			 * supported.
			 */
			AutoHelp: boolean;

			/**
			 * Gets or sets a value indicating whether implicit option or verb 'version' should be
			 * supported.
			 */
			AutoVersion: boolean;

			/**
			 * Gets or sets a value indicating whether enable double dash '--' syntax, that forces
			 * parsing of all subsequent tokens as values. If GetoptMode is true, this defaults to
			 * true, but can be turned off by explicitly specifying EnableDashDash = false.
			 */
			EnableDashDash: boolean;

			/**
			 * Gets or sets the maximum width of the display.  This determines word wrap when
			 * displaying the text.
			 */
			MaximumDisplayWidth: number;

			/**
			 * Gets or sets a value indicating whether options are allowed to be specified multiple
			 * times. If GetoptMode is true, this defaults to true, but can be turned off by
			 * explicitly specifying AllowMultiInstance = false.
			 */
			AllowMultiInstance: boolean;

			/**
			 * Whether strict getopt-like processing is applied to option values; if true,
			 * AllowMultiInstance and EnableDashDash will default to true as well.
			 */
			GetoptMode: boolean;

			/**
			 * Whether getopt-like processing should follow the POSIX rules (the equivalent of using
			 * the "+" prefix in the C getopt() call). If not explicitly set, will default to false
			 * unless the POSIXLY_CORRECT environment variable is set, in which case it will default
			 * to true.
			 */
			PosixlyCorrect: boolean;

			/** Frees resources owned by the instance. */
			dispose(): void;
		}
	}

	export namespace CommandLine {
		/**
		 * Provides settings for when formatting command line from an options instance../&gt;.
		 */
		export class UnParserSettings {
			constructor();

			/**
			 * Gets or sets a value indicating whether unparsing process shall prefer short or long
			 * names.
			 */
			PreferShortName: boolean;

			/** Gets or sets a value indicating whether unparsing process shall group switches. */
			GroupSwitches: boolean;

			/**
			 * Gets or sets a value indicating whether unparsing process shall use equal sign with
			 * long names.
			 */
			UseEqualToken: boolean;

			/**
			 * Gets or sets a value indicating whether unparsing process shall expose hidden options.
			 */
			ShowHidden: boolean;

			/**
			 * Gets or sets a value indicating whether unparsing process shall skip options with
			 * DefaultValue.
			 */
			SkipDefault: boolean;

			/**
			 * Factory method that creates an instance of {@link CommandLine.UnParserSettings} with
			 * GroupSwitches set to true.
			 */
			static WithGroupSwitchesOnly(): CommandLine.UnParserSettings;

			/**
			 * Factory method that creates an instance of {@link CommandLine.UnParserSettings} with
			 * UseEqualToken set to true.
			 */
			static WithUseEqualTokenOnly(): CommandLine.UnParserSettings;
		}
	}

	export namespace CommandLine {
		/** Provides overloads to unparse options instance. */
		export namespace UnParserExtensions {
			/** Format a command line argument string from a parsed instance. */
			export function FormatCommandLine<T>(
				parser: CommandLine.Parser,
				options: T,
			): string;

			/**
			 * Format a command line argument string from a parsed instance in the form of string[].
			 */
			export function FormatCommandLineArgs<T>(
				parser: CommandLine.Parser,
				options: T,
			): string[];

			/** Format a command line argument string from a parsed instance. */
			export function FormatCommandLine<T>(
				parser: CommandLine.Parser,
				options: T,
				configuration: System.Action$1<CommandLine.UnParserSettings>,
			): string;

			/** Format a command line argument string[] from a parsed instance. */
			export function FormatCommandLineArgs<T>(
				parser: CommandLine.Parser,
				options: T,
				configuration: System.Action$1<CommandLine.UnParserSettings>,
			): string[];

			/**
			 * Returns a string array that contains the substrings in this instance that are
			 * delimited by space considering string between double quote.
			 */
			export function SplitArgs(
				command: string,
				keepQuote?: boolean,
			): string[];
		}
	}

	export namespace CommandLine {
		/** Extension methods from {@link CommandLine.UnParserExtensions} */
		export interface Parser {
			/** Format a command line argument string from a parsed instance. */
			FormatCommandLine<T>(options: T): string;

			/**
			 * Format a command line argument string from a parsed instance in the form of string[].
			 */
			FormatCommandLineArgs<T>(options: T): string[];

			/** Format a command line argument string from a parsed instance. */
			FormatCommandLine<T>(
				options: T,
				configuration: System.Action$1<CommandLine.UnParserSettings>,
			): string;

			/** Format a command line argument string[] from a parsed instance. */
			FormatCommandLineArgs<T>(
				options: T,
				configuration: System.Action$1<CommandLine.UnParserSettings>,
			): string[];
		}
	}

	export namespace System {
		/** Extension methods from {@link CommandLine.UnParserExtensions} */
		export interface String {
			/**
			 * Returns a string array that contains the substrings in this instance that are
			 * delimited by space considering string between double quote.
			 */
			SplitArgs(keepQuote?: boolean): string[];
		}
	}

	export namespace CommandLine {
		/**
		 * Models an value specification, or better how to handle values not bound to options.
		 */
		export class ValueAttribute extends CommandLine.BaseAttribute {
			/** Initializes a new instance of the {@link CommandLine.ValueAttribute} class. */
			constructor(index: number);

			/** Gets the position this option has on the command line. */
			readonly Index: number;

			/** Gets or sets name of this positional value specification. */
			MetaName: string;
		}
	}

	export namespace CommandLine {
		/** Models a verb command specification. */
		export class VerbAttribute extends System.Attribute {
			/** Initializes a new instance of the {@link CommandLine.VerbAttribute} class. */
			constructor(
				name: string,
				isDefault?: boolean,
				aliases?: string[],
			);

			/** Gets the verb name. */
			Name: string;

			/**
			 * Gets or sets a value indicating whether a command line verb is visible in the help
			 * text.
			 */
			Hidden: boolean;

			/**
			 * Gets or sets a short description of this command line option. Usually a sentence
			 * summary.
			 */
			HelpText: string;

			/**
			 * Gets or sets the {@link System.Type} that contains the resources for
			 * {@link CommandLine.VerbAttribute.HelpText}.
			 */
			ResourceType: System.Type;

			/** Gets whether this verb is the default verb. */
			IsDefault: boolean;

			/** Gets or sets the aliases */
			Aliases: string[];
		}
	}

	export namespace CommandLine.Text {
		/** Models a multiline assembly license text. */
		export class AssemblyLicenseAttribute extends CommandLine.Text.MultilineTextAttribute {
			/**
			 * Initializes a new instance of the {@link CommandLine.Text.AssemblyLicenseAttribute}
			 * class with one line of text.
			 */
			constructor(line1: string);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.AssemblyLicenseAttribute}
			 * class with two lines of text.
			 */
			constructor(
				line1: string,
				line2: string,
			);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.AssemblyLicenseAttribute}
			 * class with three lines of text.
			 */
			constructor(
				line1: string,
				line2: string,
				line3: string,
			);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.AssemblyLicenseAttribute}
			 * class with four lines of text.
			 */
			constructor(
				line1: string,
				line2: string,
				line3: string,
				line4: string,
			);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.AssemblyLicenseAttribute}
			 * class with five lines of text.
			 */
			constructor(
				line1: string,
				line2: string,
				line3: string,
				line4: string,
				line5: string,
			);
		}
	}

	export namespace CommandLine.Text {
		/** Models a multiline assembly usage text. */
		export class AssemblyUsageAttribute extends CommandLine.Text.MultilineTextAttribute {
			/**
			 * Initializes a new instance of the {@link CommandLine.Text.AssemblyUsageAttribute}
			 * class with one line of text.
			 */
			constructor(line1: string);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.AssemblyUsageAttribute}
			 * class with two lines of text.
			 */
			constructor(
				line1: string,
				line2: string,
			);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.AssemblyUsageAttribute}
			 * class with three lines of text.
			 */
			constructor(
				line1: string,
				line2: string,
				line3: string,
			);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.AssemblyUsageAttribute}
			 * class with four lines of text.
			 */
			constructor(
				line1: string,
				line2: string,
				line3: string,
				line4: string,
			);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.AssemblyUsageAttribute}
			 * class with five lines of text.
			 */
			constructor(
				line1: string,
				line2: string,
				line3: string,
				line4: string,
				line5: string,
			);
		}
	}

	export namespace CommandLine.Text {
		/**
		 * Models the copyright part of an help text. You can assign it where you assign any
		 * {@link System.String} instance.
		 */
		export class CopyrightInfo {
			/**
			 * Initializes a new instance of the {@link CommandLine.Text.CopyrightInfo} class
			 * specifying author and year.
			 */
			constructor(
				author: string,
				year: number,
			);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.CopyrightInfo} class
			 * specifying author and copyrightYears.
			 */
			constructor(
				author: string,
				years: number[],
			);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.CopyrightInfo} class
			 * specifying symbol case, author and copyrightYears.
			 */
			constructor(
				isSymbolUpper: boolean,
				author: string,
				copyrightYears: number[],
			);

			/** An empty object used for initialization. */
			static readonly Empty: CommandLine.Text.CopyrightInfo;

			/**
			 * Gets the default copyright information. Retrieved from
			 * {@link System.Reflection.AssemblyCopyrightAttribute}, if it exists, otherwise it uses
			 * {@link System.Reflection.AssemblyCompanyAttribute} as copyright holder with the
			 * current year. If neither exists it throws an {@link System.InvalidOperationException}.
			 */
			static readonly Default: CommandLine.Text.CopyrightInfo;

			/** Returns the copyright as a {@link System.String}. */
			ToString(): string;
		}
	}

	export namespace CommandLine.Text {
		/** Models a command line usage example. */
		export class Example {
			/** Initializes a new instance of the {@link CommandLine.Text.Example} class. */
			constructor(
				helpText: string,
				formatStyles: Iterable<CommandLine.UnParserSettings>,
				sample: System.Object,
			);

			/** Initializes a new instance of the {@link CommandLine.Text.Example} class. */
			constructor(
				helpText: string,
				formatStyle: CommandLine.UnParserSettings,
				sample: System.Object,
			);

			/** Initializes a new instance of the {@link CommandLine.Text.Example} class. */
			constructor(
				helpText: string,
				sample: System.Object,
			);

			/** Example description. */
			readonly HelpText: string;

			/** A sequence of format styles. */
			readonly FormatStyles: Iterable<CommandLine.UnParserSettings>;

			/** A sample instance. */
			readonly Sample: System.Object;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link System.Object}.
			 */
			Equals(obj: System.Object): boolean;

			/**
			 * Serves as a hash function for a particular type.
			 *
			 * A hash code for the current {@link System.Object}.
			 */
			GetHashCode(): number;

			/**
			 * Returns a value that indicates whether the current instance and a specified
			 * {@link CommandLine.Text.Example} have the same value.
			 */
			Equals(other: CommandLine.Text.Example): boolean;
		}
	}

	export namespace CommandLine.Text {
		/**
		 * Models the heading part of an help text. You can assign it where you assign any
		 * {@link System.String} instance.
		 */
		export class HeadingInfo {
			/**
			 * Initializes a new instance of the {@link CommandLine.Text.HeadingInfo} class
			 * specifying program name and version.
			 */
			constructor(
				programName: string,
				version?: string,
			);

			/** An empty object used for initialization. */
			static readonly Empty: CommandLine.Text.HeadingInfo;

			/**
			 * Gets the default heading instance. The title is retrieved from
			 * {@link System.Reflection.AssemblyTitleAttribute}, or the assembly short name if its
			 * not defined. The version is retrieved from
			 * {@link System.Reflection.AssemblyInformationalVersionAttribute}, or the assembly
			 * version if its not defined.
			 */
			static readonly Default: CommandLine.Text.HeadingInfo;

			/** Returns the heading as a {@link System.String}. */
			ToString(): string;

			/**
			 * Writes out a string and a new line using the program name specified in the constructor
			 * and `message` parameter.
			 */
			WriteMessage(
				message: string,
				writer: System.IO.TextWriter,
			): void;

			/**
			 * Writes out a string and a new line using the program name specified in the constructor
			 * and `message` parameter to standard output stream.
			 */
			WriteMessage(message: string): void;

			/**
			 * Writes out a string and a new line using the program name specified in the constructor
			 * and `message` parameter to standard error stream.
			 */
			WriteError(message: string): void;
		}
	}

	export namespace CommandLine.Text {
		/**
		 * Provides means to format an help screen. You can assign it in place of a
		 * {@link System.String} instance.
		 */
		export class ComparableOption extends System.ValueType {
		}
	}

	export namespace CommandLine.Text {
		export class HelpText {
			/** Initializes a new instance of the {@link CommandLine.Text.HelpText} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.HelpText} class  specifying
			 * the sentence builder.
			 */
			constructor(sentenceBuilder: CommandLine.Text.SentenceBuilder);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.HelpText} class specifying
			 * heading string.
			 */
			constructor(heading: string);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.HelpText} class specifying
			 * the sentence builder and heading string.
			 */
			constructor(
				sentenceBuilder: CommandLine.Text.SentenceBuilder,
				heading: string,
			);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.HelpText} class specifying
			 * heading and copyright strings.
			 */
			constructor(
				heading: string,
				copyright: string,
			);

			/**
			 * Initializes a new instance of the {@link CommandLine.Text.HelpText} class specifying
			 * heading and copyright strings.
			 */
			constructor(
				sentenceBuilder: CommandLine.Text.SentenceBuilder,
				heading: string,
				copyright: string,
			);

			OptionComparison: System.Comparison$1<CommandLine.Text.ComparableOption>;

			/**
			 * Gets or sets the heading string. You can directly assign a
			 * {@link CommandLine.Text.HeadingInfo} instance.
			 */
			Heading: string;

			/**
			 * Gets or sets the copyright string. You can directly assign a
			 * {@link CommandLine.Text.CopyrightInfo} instance.
			 */
			Copyright: string;

			/**
			 * Gets or sets the maximum width of the display.  This determines word wrap when
			 * displaying the text.
			 */
			MaximumDisplayWidth: number;

			/**
			 * Gets or sets a value indicating whether the format of options should contain dashes.
			 * It modifies behavior of
			 * {@link CommandLine.Text.HelpText.AddOptions``1(CommandLine.ParserResult{``0})} method.
			 */
			AddDashesToOption: boolean;

			/**
			 * Gets or sets a value indicating whether to add an additional line after the
			 * description of the specification.
			 */
			AdditionalNewLineAfterOption: boolean;

			/** Gets or sets a value indicating whether to add newlines between help sections. */
			AddNewLineBetweenHelpSections: boolean;

			/**
			 * Gets or sets a value indicating whether to add the values of an enum after the
			 * description of the specification.
			 */
			AddEnumValuesToHelpText: boolean;

			/**
			 * Gets or sets a value indicating whether implicit option or verb 'help' should be
			 * supported.
			 */
			AutoHelp: boolean;

			/**
			 * Gets or sets a value indicating whether implicit option or verb 'version' should be
			 * supported.
			 */
			AutoVersion: boolean;

			/**
			 * Gets the {@link CommandLine.Text.HelpText.SentenceBuilder} instance specified in
			 * constructor.
			 */
			readonly SentenceBuilder: CommandLine.Text.SentenceBuilder;

			/**
			 * Creates a new instance of the {@link CommandLine.Text.HelpText} class using common
			 * defaults.
			 *
			 * The parameter `verbsIndex` is not ontly a metter of formatting, it controls whether to
			 * handle verbs or options.
			 */
			static AutoBuild<T>(
				parserResult: CommandLine.ParserResult$1<T>,
				onError: System.Func$2<CommandLine.Text.HelpText, CommandLine.Text.HelpText>,
				onExample: System.Func$2<CommandLine.Text.Example, CommandLine.Text.Example>,
				verbsIndex?: boolean,
				maxDisplayWidth?: number,
			): CommandLine.Text.HelpText;

			/**
			 * Creates a default instance of the {@link CommandLine.Text.HelpText} class,
			 * automatically handling verbs or options scenario.
			 *
			 * This feature is meant to be invoked automatically by the parser, setting the
			 * HelpWriter property of {@link CommandLine.ParserSettings}.
			 */
			static AutoBuild<T>(
				parserResult: CommandLine.ParserResult$1<T>,
				maxDisplayWidth?: number,
			): CommandLine.Text.HelpText;

			/**
			 * Creates a custom instance of the {@link CommandLine.Text.HelpText} class,
			 * automatically handling verbs or options scenario.
			 *
			 * This feature is meant to be invoked automatically by the parser, setting the
			 * HelpWriter property of {@link CommandLine.ParserSettings}.
			 */
			static AutoBuild<T>(
				parserResult: CommandLine.ParserResult$1<T>,
				onError: System.Func$2<CommandLine.Text.HelpText, CommandLine.Text.HelpText>,
				maxDisplayWidth?: number,
			): CommandLine.Text.HelpText;

			/** Supplies a default parsing error handler implementation. */
			static DefaultParsingErrorsHandler<T>(
				parserResult: CommandLine.ParserResult$1<T>,
				current: CommandLine.Text.HelpText,
			): CommandLine.Text.HelpText;

			/** Adds a text line after copyright and before options usage strings. */
			AddPreOptionsLine(value: string): CommandLine.Text.HelpText;

			/** Adds a text line at the bottom, after options usage string. */
			AddPostOptionsLine(value: string): CommandLine.Text.HelpText;

			/** Adds text lines after copyright and before options usage strings. */
			AddPreOptionsLines(lines: Iterable<string>): CommandLine.Text.HelpText;

			/** Adds text lines at the bottom, after options usage string. */
			AddPostOptionsLines(lines: Iterable<string>): CommandLine.Text.HelpText;

			/** Adds a text block of lines after copyright and before options usage strings. */
			AddPreOptionsText(text: string): CommandLine.Text.HelpText;

			/** Adds a text block of lines at the bottom, after options usage string. */
			AddPostOptionsText(text: string): CommandLine.Text.HelpText;

			/** Adds a text block with options usage string. */
			AddOptions<T>(result: CommandLine.ParserResult$1<T>): CommandLine.Text.HelpText;

			/** Adds a text block with verbs usage string. */
			AddVerbs(types: System.Type[]): CommandLine.Text.HelpText;

			/** Adds a text block with options usage string. */
			AddOptions<T>(
				maximumLength: number,
				result: CommandLine.ParserResult$1<T>,
			): CommandLine.Text.HelpText;

			/** Adds a text block with verbs usage string. */
			AddVerbs(
				maximumLength: number,
				types: System.Type[],
			): CommandLine.Text.HelpText;

			/** Builds a string that contains a parsing error message. */
			static RenderParsingErrorsText<T>(
				parserResult: CommandLine.ParserResult$1<T>,
				formatError: System.Func$2<CommandLine.Error, string>,
				formatMutuallyExclusiveSetErrors: System.Func$2<Iterable<CommandLine.MutuallyExclusiveSetError>, string>,
				indent: number,
			): string;

			/** Builds a sequence of string that contains a parsing error message. */
			static RenderParsingErrorsTextAsLines<T>(
				parserResult: CommandLine.ParserResult$1<T>,
				formatError: System.Func$2<CommandLine.Error, string>,
				formatMutuallyExclusiveSetErrors: System.Func$2<Iterable<CommandLine.MutuallyExclusiveSetError>, string>,
				indent: number,
			): Iterable<string>;

			/**
			 * Builds a string with usage text block created using
			 * {@link CommandLine.Text.UsageAttribute} data and metadata.
			 */
			static RenderUsageText<T>(parserResult: CommandLine.ParserResult$1<T>): string;

			/**
			 * Builds a string with usage text block created using
			 * {@link CommandLine.Text.UsageAttribute} data and metadata.
			 */
			static RenderUsageText<T>(
				parserResult: CommandLine.ParserResult$1<T>,
				mapperFunc: System.Func$2<CommandLine.Text.Example, CommandLine.Text.Example>,
			): string;

			/**
			 * Builds a string sequence with usage text block created using
			 * {@link CommandLine.Text.UsageAttribute} data and metadata.
			 */
			static RenderUsageTextAsLines<T>(
				parserResult: CommandLine.ParserResult$1<T>,
				mapperFunc: System.Func$2<CommandLine.Text.Example, CommandLine.Text.Example>,
			): Iterable<string>;

			/** Returns the help screen as a {@link System.String}. */
			ToString(): string;
		}
	}

	export namespace CommandLine.Text {
		/**
		 * Provides base properties for creating an attribute, used to define multiple lines of
		 * text.
		 */
		export class MultilineTextAttribute extends System.Attribute {
			/** Gets the all non-blank lines as string. */
			readonly Value: string;

			/** Gets the first line of text. */
			readonly Line1: string;

			/** Gets the second line of text. */
			readonly Line2: string;

			/** Gets third line of text. */
			readonly Line3: string;

			/** Gets the fourth line of text. */
			readonly Line4: string;

			/** Gets the fifth line of text. */
			readonly Line5: string;
		}
	}

	export namespace CommandLine.Text {
		/**
		 * Exposes standard delegates to provide a mean to customize part of help screen
		 * generation. This type is consumed by {@link CommandLine.Text.HelpText}.
		 */
		export class SentenceBuilder {
			/** Factory to allow custom SentenceBuilder injection */
			static Factory: System.Func$1<CommandLine.Text.SentenceBuilder>;

			/** Gets a delegate that returns the word 'required'. */
			readonly RequiredWord: System.Func$1<string>;

			/** Gets a delegate that returns the word 'group'. */
			readonly OptionGroupWord: System.Func$1<string>;

			/** Gets a delegate that returns that errors block heading text. */
			readonly ErrorsHeadingText: System.Func$1<string>;

			/** Gets a delegate that returns usage text block heading text. */
			readonly UsageHeadingText: System.Func$1<string>;

			/**
			 * Get a delegate that returns the help text of help command. The delegates must accept a
			 * boolean that is equal true for options; otherwise false for verbs.
			 */
			readonly HelpCommandText: System.Func$2<boolean, string>;

			/**
			 * Get a delegate that returns the help text of vesion command. The delegates must accept
			 * a boolean that is equal true for options; otherwise false for verbs.
			 */
			readonly VersionCommandText: System.Func$2<boolean, string>;

			/**
			 * Gets a delegate that handles singular error formatting. The delegates must accept an
			 * {@link CommandLine.Error} and returns a string.
			 */
			readonly FormatError: System.Func$2<CommandLine.Error, string>;

			/**
			 * Gets a delegate that handles mutually exclusive set errors formatting. The delegates
			 * must accept a sequence of {@link CommandLine.MutuallyExclusiveSetError} and returns a
			 * string.
			 */
			readonly FormatMutuallyExclusiveSetErrors: System.Func$2<Iterable<CommandLine.MutuallyExclusiveSetError>, string>;

			/** Create instance of {@link CommandLine.Text.SentenceBuilder}, */
			static Create(): CommandLine.Text.SentenceBuilder;
		}
	}

	export namespace CommandLine.Text {
		/** A utility class to word-wrap and indent blocks of text */
		export class TextWrapper {
			constructor(input: string);

			/**
			 * Splits a string into a words and performs wrapping while also preserving line-breaks
			 * and sub-indentation
			 *
			 * This method attempts to wrap text without breaking words  For example, if columnWidth
			 * is 10 , the input "a string for wrapping 01234567890123" would return "a string "for
			 * "wrapping "0123456789 "0123"
			 */
			WordWrap(columnWidth: number): CommandLine.Text.TextWrapper;

			/** Indent all lines in the TextWrapper by the desired number of spaces */
			Indent(numberOfSpaces: number): CommandLine.Text.TextWrapper;

			/** Returns the current state of the TextWrapper as a string */
			ToText(): string;

			/**
			 * Convenience method to wraps and indent a string in a single operation
			 *
			 * The string is wrapped _then_ indented so the columnWidth is the width of the usable
			 * text block, and does NOT include the indentLevel.
			 */
			static WrapAndIndentText(
				input: string,
				indentLevel: number,
				columnWidth: number,
			): string;
		}
	}

	export namespace CommandLine.Text {
		/**
		 * Applied to a static property that yields a sequence of
		 * {@link CommandLine.Text.Example}, provides data to render usage section of help
		 * screen.
		 */
		export class UsageAttribute extends System.Attribute {
			constructor();

			/** Application name, script or any means that starts current program. */
			ApplicationAlias: string;
		}
	}
}
