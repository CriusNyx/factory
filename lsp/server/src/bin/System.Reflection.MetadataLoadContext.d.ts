// Generated for: System.Reflection.MetadataLoadContext 6.0.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.8.0.0
/* eslint-disable */

import './System.Runtime';

import { Duplex } from 'stream';

declare module 'node-api-dotnet' {

	export namespace System.Reflection {
		/**
		 * The base class for binding algorithms used by
		 * {@link System.Reflection.MetadataLoadContext}.
		 */
		export class MetadataAssemblyResolver {
			/**
			 * The binding algorithm. This method is called when an Assembly is to be returned from a
			 * given AssemblyName. This occurs when MetadataLoadContext.LoadAssemblyByName() is
			 * called or when a Type from one assembly has a dependency on another assembly.  It
			 * should use MetadataLoadContext.LoadFromStream(), LoadFromAssemblyPath() or
			 * LoadFromByteArray() to load the requested assembly and return it.
			 *
			 * To indicate the failure to find an assembly, the handler should return null rather
			 * than throwing an exception. Returning null commits the failure so that future attempts
			 * to load that name will fail without re-invoking the handler.  If the handler throws an
			 * exception, the exception will be passed through to the application that invoked the
			 * operation that triggered the binding. The MetadataLoadContext will not catch it and no
			 * binding will occur.  The handler will generally not be called more than once for the
			 * same name, unless two threads race to load the same assembly. Even in that case, one
			 * result will win and be atomically bound to the name.  The MetadataLoadContext
			 * intentionally performs no ref-def matching on the returned assembly as what
			 * constitutes a ref-def match is a policy. It is also the kind of arbitrary restriction
			 * that MetadataLoadContext strives to avoid.  The MetadataLoadContext cannot consume
			 * assemblies from other MetadataLoadContexts or other type providers (such as the
			 * underlying runtime's own Reflection system.) If a handler returns such an assembly,
			 * the MetadataLoadContext throws a FileLoadException.
			 */
			Resolve(
				context: System.Reflection.MetadataLoadContext,
				assemblyName: System.Reflection.AssemblyName,
			): System.Reflection.Assembly | undefined;
		}
	}

	export namespace System.Reflection {
		/**
		 * A MetadataLoadContext represents a closed universe of Type objects loaded for
		 * inspection-only purposes. Each MetadataLoadContext can have its own binding rules and
		 * is isolated from all other MetadataLoadContexts.  A MetadataLoadContext serves as a
		 * dictionary that binds assembly names to Assembly instances that were previously loaded
		 * into the context or need to be loaded.  Assemblies are treated strictly as metadata.
		 * There are no restrictions on loading assemblies based on target platform, CPU
		 * architecture or pointer size. There are no restrictions on the assembly designated as
		 * the core assembly ("mscorlib").
		 *
		 * Also, as long as the metadata is "syntactically correct", the MetadataLoadContext
		 * strives to report it "as is" (as long it can do so in a way that can be distinguished
		 * from valid data) and refrains from judging whether it's "executable." This is both for
		 * performance reasons (checks cost time) and its intended role as metadata inspection
		 * tool. Examples of things that MetadataLoadContexts let go unchecked include creating
		 * generic instances that violate generic parameter constraints, and loading type
		 * hierachies that would be unloadable in an actual runtime (deriving from sealed
		 * classes, overriding members that don't exist in the ancestor classes, failing to
		 * implement all abstract methods, etc.)  You cannot invoke methods, set or get field or
		 * property values or instantiate objects using the Type objects from a
		 * MetadataLoadContext. You can however, use FieldInfo.GetRawConstantValue(),
		 * ParameterInfo.RawDefaultValue and PropertyInfo.GetRawConstantValue(). You can retrieve
		 * custom attributes in CustomAttributeData format but not as instantiated custom
		 * attributes. The CustomAttributeExtensions extension api will not work with these Types
		 * nor will the IsDefined() family of api.  There is no default binding policy. You must
		 * use a MetadataAssemblyResolver-derived class to load dependencies as needed. The
		 * MetadataLoadContext strives to avoid loading dependencies unless needed. Therefore, it
		 * is possible to do useful analysis of an assembly even in the absence of dependencies.
		 * For example, retrieving an assembly's name and the names of its (direct) dependencies
		 * can be done without having any of those dependencies on hand.  To bind assemblies, the
		 * MetadataLoadContext calls the Resolve method on the correspding
		 * MetadataAssemblyResolver. That method should load the requested assembly and return
		 * it. To do this, it can use LoadFromAssemblyPath() or one of its variants
		 * (LoadFromStream(), LoadFromByteArray()).  Once an assembly has been bound, no assembly
		 * with the same assembly name identity can be bound again from a different location
		 * unless the Mvids are identical.  Once loaded, the underlying file may be locked for
		 * the duration of the MetadataLoadContext's lifetime. You can release the locks by
		 * disposing the MetadataLoadContext object. The behavior of any Type, Assembly or other
		 * reflection objects handed out by the MetadataLoadContext is undefined after disposal.
		 * Though objects provided by the MetadataLoadContext strive to throw an
		 * ObjectDisposedException, this is not guaranteed. Some apis may return fixed or
		 * previously cached data. Accessing objects *during* a Dispose may result in a unmanaged
		 * access violation and failfast.  Comparing Type, Member and Assembly objects: The right
		 * way to compare two Reflection objects dispensed by the MetadataLoadContext are: m1 ==
		 * m2 m1.Equals(m2) but not object.ReferenceEquals(m1, m2)   /// WRONG (object)m1 ==
		 * (object)m2         /// WRONG  Note that the following descriptions are not literal
		 * descriptions of how Equals() is implemented. The MetadataLoadContext reserves the
		 * right to implement Equals() as "object.ReferenceEquals()" and intern the associated
		 * objects in such a way that Equals() works "as if" it were comparing those things.  -
		 * Each MetadataLoadContext permits only one Assembly instance per assembly identity so
		 * equality of assemblies is the same as the equality of their assembly identity.  -
		 * Modules are compared by comparing their containing assemblies and their row indices in
		 * the assembly's manifest file table.  - Defined types are compared by comparing their
		 * containing modules and their row indices in the module's TypeDefinition table.  -
		 * Constructed types (arrays, byrefs, pointers, generic instances) are compared by
		 * comparing all of their component types.  - Generic parameter types are compared by
		 * comparing their containing Modules and their row indices in the module's
		 * GenericParameter table.  - Constructors, methods, fields, events and properties are
		 * compared by comparing their declaring types, their row indices in their respective
		 * token tables and their ReflectedType property.  - Parameters are compared by comparing
		 * their declaring member and their position index.  Multithreading: The
		 * MetadataLoadContext and the reflection objects it hands out are all multithread-safe
		 * and logically immutable, except that no Loads or inspections of reflection objects can
		 * be done during or after disposing the owning MetadataLoadContext.  Support for NetCore
		 * Reflection apis: .NETCore added a number of apis (IsSZArray, IsVariableBoundArray,
		 * IsTypeDefinition, IsGenericTypeParameter, IsGenericMethodParameter,
		 * HasSameMetadataDefinitionAs, to name a few.) to the Reflection surface area.  The
		 * Reflection objects dispensed by MetadataLoadContexts support all the new apis
		 * *provided* that you are using the netcore build of
		 * System.Reflection.MetadataLoadContext.dll.  If you are using the netstandard build of
		 * System.Reflection.MetadataLoadContext.dll, the NetCore-specific apis are not
		 * supported. Attempting to invoke them will generate a NotImplementedException or
		 * NullReferenceException (unfortunately, we can't improve the exceptions thrown because
		 * they are being thrown by code this library doesn't control.)
		 */
		export class MetadataLoadContext {
			/** Create a new MetadataLoadContext object. */
			constructor(
				resolver: System.Reflection.MetadataAssemblyResolver,
				coreAssemblyName?: string,
			);

			/**
			 * Returns the assembly that denotes the "system assembly" that houses the well-known
			 * types such as System.Int32. The core assembly is treated differently than other
			 * assemblies because references to these well-known types do not include the assembly
			 * reference, unlike normal types.  Typically, this assembly is named "mscorlib", or
			 * "netstandard". If the core assembly cannot be found, the value will be null and many
			 * other reflection methods, including those that parse method signatures, will throw.
			 * The CoreAssembly is determined by passing the coreAssemblyName parameter passed to the
			 * MetadataAssemblyResolver constructor to the MetadataAssemblyResolver's Resolve method.
			 * If no coreAssemblyName argument was specified in the constructor of
			 * MetadataLoadContext, then default values are used including "mscorlib",
			 * "System.Runtime" and "netstandard".  The designated core assembly does not need to
			 * contain the core types directly. It can type forward them to other assemblies. Thus,
			 * it is perfectly permissible to use the mscorlib facade as the designated core
			 * assembly.  Note that "System.Runtime" is not an ideal core assembly as it excludes
			 * some of the interop-related pseudo-custom attribute types such as DllImportAttribute.
			 * However, it can serve if you have no interest in those attributes. The
			 * CustomAttributes api will skip those attributes if the core assembly does not include
			 * the necessary types.  The CoreAssembly is not loaded until necessary. These APIs do
			 * not trigger the search for the core assembly: MetadataLoadContext.LoadFromStream(),
			 * LoadFromAssemblyPath(), LoadFromByteArray() Assembly.GetName(), Assembly.FullName,
			 * Assembly.GetReferencedAssemblies() Assembly.GetTypes(), Assembly.DefinedTypes,
			 * Assembly.GetExportedTypes(), Assembly.GetForwardedTypes() Assembly.GetType(string,
			 * bool, bool) Type.Name, Type.FullName, Type.AssemblyQualifiedName  If a core assembly
			 * cannot be found or if the core assembly is missing types, this will affect the
			 * behavior of the MetadataLoadContext as follows:  - Apis that need to parse signatures
			 * or typespecs and return the results as Types will throw. For example,
			 * MethodBase.ReturnType, MethodBase.GetParameters(), Type.BaseType,
			 * Type.GetInterfaces().  - Apis that need to compare types to well known core types will
			 * not throw and the comparison will evaluate to "false." For example, if you do not
			 * specify a core assembly, Type.IsPrimitive will return false for everything, even types
			 * named "System.Int32". Similarly, Type.GetTypeCode() will return TypeCode.Object for
			 * everything.  - If a metadata entity sets flags that surface as a pseudo-custom
			 * attribute, and the core assembly does not contain the pseudo-custom attribute type,
			 * the necessary constructor or any of the parameter types of the constructor, the
			 * MetadataLoadContext will not throw. It will omit the pseudo-custom attribute from the
			 * list of returned attributes.
			 */
			readonly CoreAssembly?: System.Reflection.Assembly;

			/**
			 * Loads an assembly from a specific path on the disk and binds its assembly name to it
			 * in the MetadataLoadContext. If a prior assembly with the same name was already loaded
			 * into the MetadataLoadContext, the prior assembly will be returned. If the two
			 * assemblies do not have the same Mvid, this method throws a FileLoadException.
			 */
			LoadFromAssemblyPath(assemblyPath: string): System.Reflection.Assembly;

			/**
			 * Loads an assembly from a byte array and binds its assembly name to it in the
			 * MetadataLoadContext. If a prior assembly with the same name was already loaded into
			 * the MetadataLoadContext, the prior assembly will be returned. If the two assemblies do
			 * not have the same Mvid, this method throws a FileLoadException.
			 */
			LoadFromByteArray(assembly: number[]): System.Reflection.Assembly;

			/**
			 * Loads an assembly from a stream and binds its assembly name to it in the
			 * MetadataLoadContext. If a prior assembly with the same name was already loaded into
			 * the MetadataLoadContext, the prior assembly will be returned. If the two assemblies do
			 * not have the same Mvid, this method throws a FileLoadException.  The
			 * MetadataLoadContext takes ownership of the Stream passed into this method. The
			 * original owner must not mutate its position, dispose the Stream or assume that its
			 * position will stay unchanged.
			 */
			LoadFromStream(assembly: Duplex): System.Reflection.Assembly;

			/**
			 * Resolves the supplied assembly name to an assembly. If an assembly was previously
			 * bound by to this name, that assembly is returned. Otherwise, the MetadataLoadContext
			 * calls the specified MetadataAssemblyResolver. If the resolver returns null, this
			 * method throws a FileNotFoundException.  Note that this behavior matches the behavior
			 * of AssemblyLoadContext.LoadFromAssemblyName() but does not match the behavior of
			 * Assembly.ReflectionOnlyLoad(). (the latter gives up without raising its resolve
			 * event.)
			 */
			LoadFromAssemblyName(assemblyName: string): System.Reflection.Assembly;

			/**
			 * Resolves the supplied assembly name to an assembly. If an assembly was previously
			 * bound by to this name, that assembly is returned. Otherwise, the MetadataLoadContext
			 * calls the specified MetadataAssemblyResolver. If the resolver returns null, this
			 * method throws a FileNotFoundException.  Note that this behavior matches the behavior
			 * of AssemblyLoadContext.LoadFromAssemblyName() resolve event but does not match the
			 * behavior of Assembly.ReflectionOnlyLoad(). (the latter gives up without raising its
			 * resolve event.)
			 */
			LoadFromAssemblyName(assemblyName: System.Reflection.AssemblyName): System.Reflection.Assembly;

			/**
			 * Return an atomic snapshot of the assemblies that have been loaded into the
			 * MetadataLoadContext.
			 */
			GetAssemblies(): Iterable<System.Reflection.Assembly>;

			/**
			 * Releases any native resources (such as file locks on assembly files.) After disposal,
			 * it is not safe to use any Assembly objects dispensed by the MetadataLoadContext, nor
			 * any Reflection objects dispensed by those Assembly objects. Though objects provided by
			 * the MetadataLoadContext strive to throw an ObjectDisposedException, this is not
			 * guaranteed. Some apis may return fixed or previously cached data. Accessing objects
			 * *during* a Dispose may result in an unmanaged access violation and failfast.
			 */
			dispose(): void;
		}
	}

	export namespace System.Reflection {
		/**
		 * An assembly resolver that uses paths to every assembly that may be loaded. The file
		 * name is expected to be the same as the assembly's simple name. Multiple assemblies can
		 * exist on disk with the same name but in different directories. A single instance of
		 * PathAssemblyResolver can be used with multiple MetadataAssemblyResolver instances.
		 *
		 * In order for an AssemblyName to match to a loaded assembly, AssemblyName.Name must be
		 * equal (casing ignored). - If AssemblyName.PublicKeyToken is specified, it must be
		 * equal. - If AssemblyName.PublicKeyToken is not specified, assemblies with no
		 * PublicKeyToken are selected over those with a PublicKeyToken. - If more than one
		 * assembly matches, the assembly with the highest Version is returned. - CultureName is
		 * ignored.
		 */
		export class PathAssemblyResolver extends System.Reflection.MetadataAssemblyResolver {
			/**
			 * Initializes a new instance of the {@link System.Reflection.PathAssemblyResolver}
			 * class.
			 */
			constructor(assemblyPaths: Iterable<string>);

			Resolve(
				context: System.Reflection.MetadataLoadContext,
				assemblyName: System.Reflection.AssemblyName,
			): System.Reflection.Assembly | undefined;
		}
	}
}
