// Generated for: System.CommandLine 2.0.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.8.0.0
/* eslint-disable */

import './System.Runtime';

/** A JavaScript projection of a .NET type. */
interface IType {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): IType;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace System.CommandLine {
		/**
		 * A symbol defining a value that can be passed on the command line to a
		 * {@link System.CommandLine.Command} or {@link System.CommandLine.Option}.
		 */
		export class Argument extends System.CommandLine.Symbol implements
			System.CommandLine.Completions.ICompletionSource {
			/** Gets or sets the arity of the argument. */
			Arity: System.CommandLine.ArgumentArity;

			/** The name used in help output to describe the argument. */
			HelpName?: string;

			/** Gets the list of completion sources for the argument. */
			readonly Completions: System.CommandLine.CompletionSourceList;

			/**
			 * Gets or sets the {@link System.Type} that the argument token(s) will be converted to.
			 */
			readonly ValueType: System.Type;

			/** Specifies if a default value is defined for the argument. */
			readonly HasDefaultValue: boolean;

			/**
			 * Adds a custom {@link System.CommandLine.Parsing.ValidateSymbolResult<>} to the
			 * argument. Validators can be used to provide custom errors based on user input.
			 */
			AddValidator(validate: System.CommandLine.Parsing.ValidateSymbolResult$1<System.CommandLine.Parsing.ArgumentResult>): void;

			/** Gets the default value for the argument. */
			GetDefaultValue(): System.Object | undefined;

			/** Sets the default value for the argument. */
			SetDefaultValue(value: System.Object | undefined): void;

			/** Sets a delegate to invoke when the default value for the argument is required. */
			SetDefaultValueFactory(getDefaultValue: System.Func$1<System.Object | undefined>): void;

			/**
			 * Sets a delegate to invoke when the default value for the argument is required.
			 *
			 * In this overload, the {@link System.CommandLine.Parsing.ArgumentResult} is provided to
			 * the delegate.
			 */
			SetDefaultValueFactory(getDefaultValue: System.Func$2<System.CommandLine.Parsing.ArgumentResult, System.Object | undefined>): void;

			/** Gets the suggested values for command line completion. */
			GetCompletions(context: System.CommandLine.Completions.CompletionContext): Iterable<System.CommandLine.Completions.CompletionItem>;

			/** Returns a string that represents the current object. */
			ToString(): string;

			/** Gets completions for the symbol. */
			GetCompletions(): Iterable<System.CommandLine.Completions.CompletionItem>;
		}
	}

	export namespace System.CommandLine {
		/**
		 * Defines the arity of an option or argument.
		 *
		 * The arity refers to the number of values that can be passed on the command line.
		 */
		export class ArgumentArity extends System.ValueType {
			/** Initializes a new instance of the ArgumentArity class. */
			constructor(
				minimumNumberOfValues: number,
				maximumNumberOfValues: number,
			);

			/**
			 * Gets the minimum number of values required for an {@link System.CommandLine.Argument}.
			 */
			readonly MinimumNumberOfValues: number;

			/**
			 * Gets the maximum number of values allowed for an {@link System.CommandLine.Argument}.
			 */
			readonly MaximumNumberOfValues: number;

			/** An arity that does not allow any values. */
			static readonly Zero: System.CommandLine.ArgumentArity;

			/** An arity that may have one value, but no more than one. */
			static readonly ZeroOrOne: System.CommandLine.ArgumentArity;

			/** An arity that must have exactly one value. */
			static readonly ExactlyOne: System.CommandLine.ArgumentArity;

			/** An arity that may have multiple values. */
			static readonly ZeroOrMore: System.CommandLine.ArgumentArity;

			/** An arity that must have at least one value. */
			static readonly OneOrMore: System.CommandLine.ArgumentArity;

			/** Indicates whether this instance and a specified object are equal. */
			Equals(other: System.CommandLine.ArgumentArity): boolean;

			/** Indicates whether this instance and a specified object are equal. */
			Equals(obj: System.Object | undefined): boolean;

			/** Returns the hash code for this instance. */
			GetHashCode(): number;
		}
	}

	export namespace System.CommandLine {
		/** Provides extension methods for {@link System.CommandLine.Argument}. */
		export namespace ArgumentExtensions {
			/** Adds completions for an argument. */
			export function AddCompletions<TArgument>(
				argument: TArgument,
				values: string[],
			): TArgument;

			/** Adds completions for an option. */
			export function AddCompletions<TArgument>(
				argument: TArgument,
				complete: System.Func$2<System.CommandLine.Completions.CompletionContext, Iterable<string>>,
			): TArgument;

			/** Adds completions for an argument. */
			export function AddCompletions<TArgument>(
				argument: TArgument,
				complete: System.CommandLine.Completions.CompletionDelegate,
			): TArgument;

			/**
			 * Configures an argument to accept only the specified values, and to suggest them as
			 * command line completions.
			 */
			export function FromAmong<TArgument>(
				argument: TArgument,
				values: string[],
			): TArgument;

			/** Configures an argument to accept only values corresponding to an existing file. */
			export function ExistingOnly(argument: System.CommandLine.Argument$1<System.IO.FileInfo>): System.CommandLine.Argument$1<System.IO.FileInfo>;

			/**
			 * Configures an argument to accept only values corresponding to an existing directory.
			 */
			export function ExistingOnly(argument: System.CommandLine.Argument$1<System.IO.DirectoryInfo>): System.CommandLine.Argument$1<System.IO.DirectoryInfo>;

			/**
			 * Configures an argument to accept only values corresponding to an existing file or
			 * directory.
			 */
			export function ExistingOnly(argument: System.CommandLine.Argument$1<System.IO.FileSystemInfo>): System.CommandLine.Argument$1<System.IO.FileSystemInfo>;

			/**
			 * Configures an argument to accept only values corresponding to a existing files or
			 * directories.
			 */
			export function ExistingOnly<T>(argument: System.CommandLine.Argument$1<T>): System.CommandLine.Argument$1<T>;

			/** Configures an argument to accept only values representing legal file paths. */
			export function LegalFilePathsOnly<TArgument>(argument: TArgument): TArgument;

			/**
			 * Configures an argument to accept only values representing legal file names.
			 *
			 * A parse error will result, for example, if file path separators are found in the
			 * parsed value.
			 */
			export function LegalFileNamesOnly<TArgument>(argument: TArgument): TArgument;

			/**
			 * Parses a command line string value using an argument.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			export function Parse(
				argument: System.CommandLine.Argument,
				commandLine: string,
			): System.CommandLine.Parsing.ParseResult;

			/** Parses a command line string value using an argument. */
			export function Parse(
				argument: System.CommandLine.Argument,
				args: string[],
			): System.CommandLine.Parsing.ParseResult;
		}
	}

	export namespace System.CommandLine.ArgumentExtensions {
		/** Extension methods from {@link System.CommandLine.ArgumentExtensions} */
		export interface TArgument {
			/** Adds completions for an argument. */
			AddCompletions<TArgument>(values: string[]): TArgument;
		}
	}

	export namespace System.CommandLine.ArgumentExtensions {
		/** Extension methods from {@link System.CommandLine.ArgumentExtensions} */
		export interface TArgument {
			/** Adds completions for an option. */
			AddCompletions<TArgument>(complete: System.Func$2<System.CommandLine.Completions.CompletionContext, Iterable<string>>): TArgument;
		}
	}

	export namespace System.CommandLine.ArgumentExtensions {
		/** Extension methods from {@link System.CommandLine.ArgumentExtensions} */
		export interface TArgument {
			/** Adds completions for an argument. */
			AddCompletions<TArgument>(complete: System.CommandLine.Completions.CompletionDelegate): TArgument;
		}
	}

	export namespace System.CommandLine.ArgumentExtensions {
		/** Extension methods from {@link System.CommandLine.ArgumentExtensions} */
		export interface TArgument {
			/**
			 * Configures an argument to accept only the specified values, and to suggest them as
			 * command line completions.
			 */
			FromAmong<TArgument>(values: string[]): TArgument;
		}
	}

	export namespace System.CommandLine.ArgumentExtensions {
		/** Extension methods from {@link System.CommandLine.ArgumentExtensions} */
		export interface TArgument {
			/** Configures an argument to accept only values representing legal file paths. */
			LegalFilePathsOnly<TArgument>(): TArgument;
		}
	}

	export namespace System.CommandLine.ArgumentExtensions {
		/** Extension methods from {@link System.CommandLine.ArgumentExtensions} */
		export interface TArgument {
			/**
			 * Configures an argument to accept only values representing legal file names.
			 *
			 * A parse error will result, for example, if file path separators are found in the
			 * parsed value.
			 */
			LegalFileNamesOnly<TArgument>(): TArgument;
		}
	}

	export namespace System.CommandLine {
		/** Extension methods from {@link System.CommandLine.ArgumentExtensions} */
		export interface Argument {
			/**
			 * Parses a command line string value using an argument.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			Parse(commandLine: string): System.CommandLine.Parsing.ParseResult;

			/** Parses a command line string value using an argument. */
			Parse(args: string[]): System.CommandLine.Parsing.ParseResult;
		}
	}

	export namespace System.CommandLine {
		export function Argument$(T: IType): typeof Argument$1<any>;

		export class Argument$1<T> extends System.CommandLine.Argument implements
			System.CommandLine.Completions.ICompletionSource {
			/** Initializes a new instance of the Argument class. */
			constructor();

			constructor(
				name: string | undefined,
				description?: string,
			);

			/** Initializes a new instance of the Argument class. */
			constructor(
				name: string,
				getDefaultValue: System.Func$1<T>,
				description?: string,
			);

			/** Initializes a new instance of the Argument class. */
			constructor(getDefaultValue: System.Func$1<T>);

			/** Initializes a new instance of the Argument class. */
			constructor(
				name: string | undefined,
				parse: System.CommandLine.Parsing.ParseArgument$1<T>,
				isDefault?: boolean,
				description?: string,
			);

			/** Initializes a new instance of the Argument class. */
			constructor(
				parse: System.CommandLine.Parsing.ParseArgument$1<T>,
				isDefault?: boolean,
			);

			/**
			 * Gets or sets the {@link System.Type} that the argument token(s) will be converted to.
			 */
			readonly ValueType: System.Type;
		}
	}

	export namespace System.CommandLine {
		/**
		 * Represents a specific action that the application performs.
		 *
		 * Use the Command object for actions that correspond to a specific string (the command
		 * name). See {@link System.CommandLine.RootCommand} for simple applications that only
		 * have one action. For example, dotnet run uses run as the command.
		 */
		export class Command extends System.CommandLine.IdentifierSymbol implements System.CommandLine.Completions.ICompletionSource {
			/** Initializes a new instance of the Command class. */
			constructor(
				name: string,
				description?: string,
			);

			/** Gets the child symbols. */
			readonly Children: Iterable<System.CommandLine.Symbol>;

			/** Represents all of the arguments for the command. */
			readonly Arguments: readonly System.CommandLine.Argument[];

			/**
			 * Represents all of the options for the command, including global options that have been
			 * applied to any of the command's ancestors.
			 */
			readonly Options: readonly System.CommandLine.Option[];

			/** Represents all of the subcommands for the command. */
			readonly Subcommands: readonly System.CommandLine.Command[];

			/**
			 * Gets or sets a value that indicates whether unmatched tokens should be treated as
			 * errors. For example, if set to `true` and an extra command or argument is provided,
			 * validation will fail.
			 */
			TreatUnmatchedTokensAsErrors: boolean;

			/**
			 * Gets or sets the {@link System.CommandLine.Invocation.ICommandHandler} for the
			 * command. The handler represents the action that will be performed when the command is
			 * invoked.
			 *
			 * Use one of the
			 * {@link System.CommandLine.Handler.SetHandler(System.CommandLine.Command,System.Action)}
			 * overloads to construct a handler. If the handler is not specified, parser errors will
			 * be generated for command line input that invokes this command.
			 */
			Handler?: System.CommandLine.Invocation.ICommandHandler;

			/** Adds an {@link System.CommandLine.Argument} to the command. */
			AddArgument(argument: System.CommandLine.Argument): void;

			/**
			 * Adds a subcommand to the command.
			 *
			 * Commands can be nested to an arbitrary depth.
			 */
			AddCommand(command: System.CommandLine.Command): void;

			/** Adds an {@link System.CommandLine.Option} to the command. */
			AddOption(option: System.CommandLine.Option): void;

			/**
			 * Adds a global {@link System.CommandLine.Option} to the command.
			 *
			 * Global options are applied to the command and recursively to subcommands. They do not
			 * apply to parent commands.
			 */
			AddGlobalOption(option: System.CommandLine.Option): void;

			/** Adds an {@link System.CommandLine.Option} to the command. */
			Add(option: System.CommandLine.Option): void;

			/** Adds an {@link System.CommandLine.Argument} to the command. */
			Add(argument: System.CommandLine.Argument): void;

			/**
			 * Adds a subcommand to the command.
			 *
			 * Commands can be nested to an arbitrary depth.
			 */
			Add(command: System.CommandLine.Command): void;

			/**
			 * Adds a custom validator to the command. Validators can be used to create custom
			 * validation logic.
			 */
			AddValidator(validate: System.CommandLine.Parsing.ValidateSymbolResult$1<System.CommandLine.Parsing.CommandResult>): void;

			/** Represents all of the symbols for the command. */
			GetEnumerator(): System.Collections.Generic.IEnumerator$1<System.CommandLine.Symbol>;

			/** Gets the suggested values for command line completion. */
			GetCompletions(context: System.CommandLine.Completions.CompletionContext): Iterable<System.CommandLine.Completions.CompletionItem>;

			/** Gets completions for the symbol. */
			GetCompletions(): Iterable<System.CommandLine.Completions.CompletionItem>;
		}
	}

	export namespace System.CommandLine {
		/** Provides extension methods for {@link System.CommandLine.Command}. */
		export namespace CommandExtensions {
			/** Parses and invokes a command. */
			export function Invoke(
				command: System.CommandLine.Command,
				args: string[],
				console?: System.CommandLine.IConsole,
			): number;

			/**
			 * Parses and invokes a command.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			export function Invoke(
				command: System.CommandLine.Command,
				commandLine: string,
				console?: System.CommandLine.IConsole,
			): number;

			/** Parses and invokes a command. */
			export function InvokeAsync(
				command: System.CommandLine.Command,
				args: string[],
				console?: System.CommandLine.IConsole,
			): Promise<number>;

			/**
			 * Parses and invokes a command.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			export function InvokeAsync(
				command: System.CommandLine.Command,
				commandLine: string,
				console?: System.CommandLine.IConsole,
			): Promise<number>;

			/** Parses an array strings using the specified command. */
			export function Parse(
				command: System.CommandLine.Command,
				args: string[],
			): System.CommandLine.Parsing.ParseResult;

			/**
			 * Parses a command line string value using the specified command.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			export function Parse(
				command: System.CommandLine.Command,
				commandLine: string,
			): System.CommandLine.Parsing.ParseResult;
		}
	}

	export namespace System.CommandLine {
		/** Extension methods from {@link System.CommandLine.CommandExtensions} */
		export interface Command {
			/** Parses and invokes a command. */
			Invoke(
				args: string[],
				console?: System.CommandLine.IConsole,
			): number;

			/**
			 * Parses and invokes a command.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			Invoke(
				commandLine: string,
				console?: System.CommandLine.IConsole,
			): number;

			/** Parses and invokes a command. */
			InvokeAsync(
				args: string[],
				console?: System.CommandLine.IConsole,
			): Promise<number>;

			/**
			 * Parses and invokes a command.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			InvokeAsync(
				commandLine: string,
				console?: System.CommandLine.IConsole,
			): Promise<number>;

			/** Parses an array strings using the specified command. */
			Parse(args: string[]): System.CommandLine.Parsing.ParseResult;

			/**
			 * Parses a command line string value using the specified command.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			Parse(commandLine: string): System.CommandLine.Parsing.ParseResult;
		}
	}

	export namespace System.CommandLine {
		/**
		 * Represents the configuration used by the {@link System.CommandLine.Parsing.Parser}.
		 */
		export class CommandLineConfiguration {
			/** Initializes a new instance of the CommandLineConfiguration class. */
			constructor(
				command: System.CommandLine.Command,
				enablePosixBundling?: boolean,
				enableDirectives?: boolean,
				enableLegacyDoubleDashBehavior?: boolean,
				enableTokenReplacement?: boolean,
				resources?: System.CommandLine.LocalizationResources,
				middlewarePipeline?: readonly System.CommandLine.Invocation.InvocationMiddleware[],
				helpBuilderFactory?: System.Func$2<System.CommandLine.Binding.BindingContext, System.CommandLine.Help.HelpBuilder>,
				tokenReplacer?: System.CommandLine.Parsing.TryReplaceToken,
			);

			/** Gets whether directives are enabled. */
			readonly EnableDirectives: boolean;

			/**
			 * Enables the legacy behavior of the -- token, which is to ignore parsing of subsequent
			 * tokens and place them in the
			 * {@link System.CommandLine.Parsing.ParseResult.UnparsedTokens} list.
			 */
			readonly EnableLegacyDoubleDashBehavior: boolean;

			/**
			 * Gets a value indicating whether POSIX bundling is enabled.
			 *
			 * POSIX recommends that single-character options be allowed to be specified together
			 * after a single - prefix.
			 */
			readonly EnablePosixBundling: boolean;

			/**
			 * Gets a value indicating whether token replacement is enabled.
			 *
			 * When enabled, any token prefixed with @ can be replaced with zero or more other
			 * tokens. This is mostly commonly used to expand tokens from response files and
			 * interpolate them into a command line prior to parsing.
			 */
			readonly EnableTokenReplacement: boolean;

			/** Gets the localizable resources. */
			readonly LocalizationResources: System.CommandLine.LocalizationResources;

			/** Gets the root command. */
			readonly RootCommand: System.CommandLine.Command;

			/**
			 * Throws an exception if the parser configuration is ambiguous or otherwise not valid.
			 *
			 * Due to the performance cost of this method, it is recommended to be used in unit
			 * testing or in scenarios where the parser is configured dynamically at runtime.
			 */
			ThrowIfInvalid(): void;
		}
	}

	export namespace System.CommandLine {
		/** Indicates that a command line configuration is invalid. */
		export class CommandLineConfigurationException extends System.Exception {
			constructor(message: string);

			constructor();

			constructor(
				message: string,
				innerException: System.Exception,
			);
		}
	}

	export namespace System.CommandLine {
		/** Provides extension methods for working with completion sources. */
		export namespace CompletionSourceExtensions {
		}
	}

	export namespace System.CommandLine {
		/** A list of completion sources to be used when providing completions for completion. */
		export class CompletionSourceList {
			constructor();

			readonly Count: number;

			/** Adds a completion source to the list. */
			Add(source: System.CommandLine.Completions.ICompletionSource): void;

			GetEnumerator(): System.Collections.Generic.IEnumerator$1<System.CommandLine.Completions.ICompletionSource>;

			/** Clears the completion sources. */
			Clear(): void;
		}
	}

	export namespace System.CommandLine {
		/** Provides extension methods for {@link System.CommandLine.IConsole}. */
		export namespace ConsoleExtensions {
			/** Writes the current string value to the standard output stream. */
			export function Write(
				console: System.CommandLine.IConsole,
				value: string,
			): void;

			/**
			 * Writes the current string value, followed by the current environment's line
			 * terminator, to the standard output stream.
			 */
			export function WriteLine(
				console: System.CommandLine.IConsole,
				value: string,
			): void;
		}
	}

	export namespace System.CommandLine {
		/** Extension methods from {@link System.CommandLine.ConsoleExtensions} */
		export interface IConsole {
			/** Writes the current string value to the standard output stream. */
			Write(value: string): void;

			/**
			 * Writes the current string value, followed by the current environment's line
			 * terminator, to the standard output stream.
			 */
			WriteLine(value: string): void;
		}
	}

	export namespace System.CommandLine {
		/**
		 * A collection of directives parsed from a command line.
		 *
		 * A directive is specified on the command line using square brackets, containing no
		 * spaces and preceding other tokens unless they are also directives. In the following
		 * example, two directives are present, directive-one and directive-two : &gt; myapp
		 * [directive-one] [directive-two:value] arg1 arg2 The second has a value specified as
		 * well, value . Directive values can be read by calling using
		 * {@link System.CommandLine.DirectiveCollection.TryGetValues(System.String,System.Collections.Generic.IReadOnlyList{System.String}@)}.
		 */
		export class DirectiveCollection {
			constructor();

			/** Gets a value determining whether a directive with the specified name was parsed. */
			Contains(name: string): boolean;

			TryGetValues(name: string): readonly string[] | undefined;

			GetEnumerator(): System.Collections.Generic.IEnumerator$1<[string, Iterable<string>]>;
		}
	}

	export namespace System.CommandLine {
		/** Provides methods for creating and working with command handlers. */
		export namespace Handler {
			/** Sets a command's handler based on an {@link System.Action<>}. */
			export function SetHandler(
				command: System.CommandLine.Command,
				handle: System.Action$1<System.CommandLine.Invocation.InvocationContext>,
			): void;

			/** Sets a command's handler based on an {@link System.Action}. */
			export function SetHandler(
				command: System.CommandLine.Command,
				handle: () => void,
			): void;

			/** Sets a command's handler based on an {@link System.Action<>}. */
			export function SetHandler<T>(
				command: System.CommandLine.Command,
				handle: System.Action$1<T>,
				symbol: System.CommandLine.Binding.IValueDescriptor$1<T>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,>}. */
			export function SetHandler<T1, T2>(
				command: System.CommandLine.Command,
				handle: System.Action$2<T1, T2>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,>}. */
			export function SetHandler<T1, T2, T3>(
				command: System.CommandLine.Command,
				handle: System.Action$3<T1, T2, T3>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,,>}. */
			export function SetHandler<T1, T2, T3, T4>(
				command: System.CommandLine.Command,
				handle: System.Action$4<T1, T2, T3, T4>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,,,>}. */
			export function SetHandler<T1, T2, T3, T4, T5>(
				command: System.CommandLine.Command,
				handle: System.Action$5<T1, T2, T3, T4, T5>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,,,,>}. */
			export function SetHandler<T1, T2, T3, T4, T5, T6>(
				command: System.CommandLine.Command,
				handle: System.Action$6<T1, T2, T3, T4, T5, T6>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,,,,,>}. */
			export function SetHandler<T1, T2, T3, T4, T5, T6, T7>(
				command: System.CommandLine.Command,
				handle: System.Action$7<T1, T2, T3, T4, T5, T6, T7>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
				symbol7: System.CommandLine.Binding.IValueDescriptor$1<T7>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,,,,,,>}. */
			export function SetHandler<T1, T2, T3, T4, T5, T6, T7, T8>(
				command: System.CommandLine.Command,
				handle: System.Action$8<T1, T2, T3, T4, T5, T6, T7, T8>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
				symbol7: System.CommandLine.Binding.IValueDescriptor$1<T7>,
				symbol8: System.CommandLine.Binding.IValueDescriptor$1<T8>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<>}. */
			export function SetHandler(
				command: System.CommandLine.Command,
				handle: System.Func$1<Promise<void>>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,>}. */
			export function SetHandler(
				command: System.CommandLine.Command,
				handle: System.Func$2<System.CommandLine.Invocation.InvocationContext, Promise<void>>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,>}. */
			export function SetHandler<T>(
				command: System.CommandLine.Command,
				handle: System.Func$2<T, Promise<void>>,
				symbol: System.CommandLine.Binding.IValueDescriptor$1<T>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,>}. */
			export function SetHandler<T1, T2>(
				command: System.CommandLine.Command,
				handle: System.Func$3<T1, T2, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,>}. */
			export function SetHandler<T1, T2, T3>(
				command: System.CommandLine.Command,
				handle: System.Func$4<T1, T2, T3, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,,>}. */
			export function SetHandler<T1, T2, T3, T4>(
				command: System.CommandLine.Command,
				handle: System.Func$5<T1, T2, T3, T4, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,,,>}. */
			export function SetHandler<T1, T2, T3, T4, T5>(
				command: System.CommandLine.Command,
				handle: System.Func$6<T1, T2, T3, T4, T5, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,,,,>}. */
			export function SetHandler<T1, T2, T3, T4, T5, T6>(
				command: System.CommandLine.Command,
				handle: System.Func$7<T1, T2, T3, T4, T5, T6, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,,,,,>}. */
			export function SetHandler<T1, T2, T3, T4, T5, T6, T7>(
				command: System.CommandLine.Command,
				handle: System.Func$8<T1, T2, T3, T4, T5, T6, T7, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
				symbol7: System.CommandLine.Binding.IValueDescriptor$1<T7>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,,,,,,>}. */
			export function SetHandler<T1, T2, T3, T4, T5, T6, T7, T8>(
				command: System.CommandLine.Command,
				handle: System.Func$9<T1, T2, T3, T4, T5, T6, T7, T8, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
				symbol7: System.CommandLine.Binding.IValueDescriptor$1<T7>,
				symbol8: System.CommandLine.Binding.IValueDescriptor$1<T8>,
			): void;
		}
	}

	export namespace System.CommandLine {
		/** Extension methods from {@link System.CommandLine.Handler} */
		export interface Command {
			/** Sets a command's handler based on an {@link System.Action<>}. */
			SetHandler(handle: System.Action$1<System.CommandLine.Invocation.InvocationContext>): void;

			/** Sets a command's handler based on an {@link System.Action}. */
			SetHandler(handle: () => void): void;

			/** Sets a command's handler based on an {@link System.Action<>}. */
			SetHandler<T>(
				handle: System.Action$1<T>,
				symbol: System.CommandLine.Binding.IValueDescriptor$1<T>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,>}. */
			SetHandler<T1, T2>(
				handle: System.Action$2<T1, T2>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,>}. */
			SetHandler<T1, T2, T3>(
				handle: System.Action$3<T1, T2, T3>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,,>}. */
			SetHandler<T1, T2, T3, T4>(
				handle: System.Action$4<T1, T2, T3, T4>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,,,>}. */
			SetHandler<T1, T2, T3, T4, T5>(
				handle: System.Action$5<T1, T2, T3, T4, T5>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,,,,>}. */
			SetHandler<T1, T2, T3, T4, T5, T6>(
				handle: System.Action$6<T1, T2, T3, T4, T5, T6>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,,,,,>}. */
			SetHandler<T1, T2, T3, T4, T5, T6, T7>(
				handle: System.Action$7<T1, T2, T3, T4, T5, T6, T7>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
				symbol7: System.CommandLine.Binding.IValueDescriptor$1<T7>,
			): void;

			/** Sets a command's handler based on an {@link System.Action<,,,,,,,>}. */
			SetHandler<T1, T2, T3, T4, T5, T6, T7, T8>(
				handle: System.Action$8<T1, T2, T3, T4, T5, T6, T7, T8>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
				symbol7: System.CommandLine.Binding.IValueDescriptor$1<T7>,
				symbol8: System.CommandLine.Binding.IValueDescriptor$1<T8>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<>}. */
			SetHandler(handle: System.Func$1<Promise<void>>): void;

			/** Sets a command's handler based on a {@link System.Func<,>}. */
			SetHandler(handle: System.Func$2<System.CommandLine.Invocation.InvocationContext, Promise<void>>): void;

			/** Sets a command's handler based on a {@link System.Func<,>}. */
			SetHandler<T>(
				handle: System.Func$2<T, Promise<void>>,
				symbol: System.CommandLine.Binding.IValueDescriptor$1<T>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,>}. */
			SetHandler<T1, T2>(
				handle: System.Func$3<T1, T2, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,>}. */
			SetHandler<T1, T2, T3>(
				handle: System.Func$4<T1, T2, T3, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,,>}. */
			SetHandler<T1, T2, T3, T4>(
				handle: System.Func$5<T1, T2, T3, T4, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,,,>}. */
			SetHandler<T1, T2, T3, T4, T5>(
				handle: System.Func$6<T1, T2, T3, T4, T5, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,,,,>}. */
			SetHandler<T1, T2, T3, T4, T5, T6>(
				handle: System.Func$7<T1, T2, T3, T4, T5, T6, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,,,,,>}. */
			SetHandler<T1, T2, T3, T4, T5, T6, T7>(
				handle: System.Func$8<T1, T2, T3, T4, T5, T6, T7, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
				symbol7: System.CommandLine.Binding.IValueDescriptor$1<T7>,
			): void;

			/** Sets a command's handler based on a {@link System.Func<,,,,,,,,>}. */
			SetHandler<T1, T2, T3, T4, T5, T6, T7, T8>(
				handle: System.Func$9<T1, T2, T3, T4, T5, T6, T7, T8, Promise<void>>,
				symbol1: System.CommandLine.Binding.IValueDescriptor$1<T1>,
				symbol2: System.CommandLine.Binding.IValueDescriptor$1<T2>,
				symbol3: System.CommandLine.Binding.IValueDescriptor$1<T3>,
				symbol4: System.CommandLine.Binding.IValueDescriptor$1<T4>,
				symbol5: System.CommandLine.Binding.IValueDescriptor$1<T5>,
				symbol6: System.CommandLine.Binding.IValueDescriptor$1<T6>,
				symbol7: System.CommandLine.Binding.IValueDescriptor$1<T7>,
				symbol8: System.CommandLine.Binding.IValueDescriptor$1<T8>,
			): void;
		}
	}

	export namespace System.CommandLine {
		/** Represents the standard console input, output, and error streams. */
		export interface IConsole extends
			System.CommandLine.IO.IStandardOut,
			System.CommandLine.IO.IStandardError,
			System.CommandLine.IO.IStandardIn {
		}
	}

	export namespace System.CommandLine {
		/**
		 * A symbol, such as an option or command, having one or more fixed names in a command
		 * line interface.
		 */
		export class IdentifierSymbol extends System.CommandLine.Symbol implements System.CommandLine.Completions.ICompletionSource {
			/**
			 * Gets the set of strings that can be used on the command line to specify the symbol.
			 */
			readonly Aliases: Iterable<string> | { length: number };

			/** Gets or sets the name of the symbol. */
			Name: string;

			/**
			 * Adds an alias .
			 *
			 * You can add multiple aliases for a symbol.
			 */
			AddAlias(alias: string): void;

			/** Determines whether the specified alias has already been defined. */
			HasAlias(alias: string): boolean;
		}
	}

	export namespace System.CommandLine {
		/** Provides localizable strings for help and error messages. */
		export class LocalizationResources {
			/**
			 * Gets a global instance of the {@link System.CommandLine.LocalizationResources} class.
			 */
			static readonly Instance: System.CommandLine.LocalizationResources;

			/**
			 * Interpolates values into a localized string similar to Command '{0}' expects a single
			 * argument but {1} were provided.
			 */
			ExpectsOneArgument(symbolResult: System.CommandLine.Parsing.SymbolResult): string;

			/**
			 * Interpolates values into a localized string similar to No argument was provided for
			 * Command '{0}'..
			 */
			NoArgumentProvided(symbolResult: System.CommandLine.Parsing.SymbolResult): string;

			/**
			 * Interpolates values into a localized string similar to Command '{0}' expects no more
			 * than {1} arguments, but {2} were provided.
			 */
			ExpectsFewerArguments(
				token: System.CommandLine.Parsing.Token,
				providedNumberOfValues: number,
				maximumNumberOfValues: number,
			): string;

			/**
			 * Interpolates values into a localized string similar to Directory does not exist: {0}.
			 */
			DirectoryDoesNotExist(path: string): string;

			/** Interpolates values into a localized string similar to File does not exist: {0}. */
			FileDoesNotExist(filePath: string): string;

			/**
			 * Interpolates values into a localized string similar to File or directory does not
			 * exist: {0}.
			 */
			FileOrDirectoryDoesNotExist(path: string): string;

			/**
			 * Interpolates values into a localized string similar to Character not allowed in a
			 * path: {0}.
			 */
			InvalidCharactersInPath(invalidChar: System.Char): string;

			/**
			 * Interpolates values into a localized string similar to Character not allowed in a file
			 * name: {0}.
			 */
			InvalidCharactersInFileName(invalidChar: System.Char): string;

			/**
			 * Interpolates values into a localized string similar to Required argument missing for
			 * command: {0}.
			 */
			RequiredArgumentMissing(symbolResult: System.CommandLine.Parsing.SymbolResult): string;

			/**
			 * Interpolates values into a localized string similar to Required command was not
			 * provided.
			 */
			RequiredCommandWasNotProvided(): string;

			/**
			 * Interpolates values into a localized string similar to Argument '{0}' not recognized.
			 * Must be one of:{1}.
			 */
			UnrecognizedArgument(
				unrecognizedArg: string,
				allowedValues: Iterable<string> | { length: number },
			): string;

			/**
			 * Interpolates values into a localized string similar to Unrecognized command or
			 * argument '{0}'.
			 */
			UnrecognizedCommandOrArgument(arg: string): string;

			/**
			 * Interpolates values into a localized string similar to Response file not found '{0}'.
			 */
			ResponseFileNotFound(filePath: string): string;

			/**
			 * Interpolates values into a localized string similar to Error reading response file
			 * '{0}': {1}.
			 */
			ErrorReadingResponseFile(
				filePath: string,
				e: System.IO.IOException,
			): string;

			/**
			 * Interpolates values into a localized string similar to Show help and usage
			 * information.
			 */
			HelpOptionDescription(): string;

			/** Interpolates values into a localized string similar to Usage:. */
			HelpUsageTitle(): string;

			/** Interpolates values into a localized string similar to Description:. */
			HelpDescriptionTitle(): string;

			/** Interpolates values into a localized string similar to [options]. */
			HelpUsageOptions(): string;

			/** Interpolates values into a localized string similar to [command]. */
			HelpUsageCommand(): string;

			/**
			 * Interpolates values into a localized string similar to [[--] &lt;additional
			 * arguments&gt;...]].
			 */
			HelpUsageAdditionalArguments(): string;

			/** Interpolates values into a localized string similar to Arguments:. */
			HelpArgumentsTitle(): string;

			/** Interpolates values into a localized string similar to Options:. */
			HelpOptionsTitle(): string;

			/** Interpolates values into a localized string similar to (REQUIRED). */
			HelpOptionsRequiredLabel(): string;

			/** Interpolates values into a localized string similar to default. */
			HelpArgumentDefaultValueLabel(): string;

			/** Interpolates values into a localized string similar to Commands:. */
			HelpCommandsTitle(): string;

			/** Interpolates values into a localized string similar to Additional Arguments:. */
			HelpAdditionalArgumentsTitle(): string;

			/**
			 * Interpolates values into a localized string similar to Arguments passed to the
			 * application that is being run..
			 */
			HelpAdditionalArgumentsDescription(): string;

			/**
			 * Interpolates values into a localized string similar to '{0}' was not matched. Did you
			 * mean one of the following?.
			 */
			SuggestionsTokenNotMatched(token: string): string;

			/** Interpolates values into a localized string similar to Show version information. */
			VersionOptionDescription(): string;

			/**
			 * Interpolates values into a localized string similar to {0} option cannot be combined
			 * with other arguments..
			 */
			VersionOptionCannotBeCombinedWithOtherArguments(optionAlias: string): string;

			/** Interpolates values into a localized string similar to Unhandled exception: . */
			ExceptionHandlerHeader(): string;

			/**
			 * Interpolates values into a localized string similar to Cannot parse argument '{0}' as
			 * expected type {1}..
			 */
			ArgumentConversionCannotParse(
				value: string,
				expectedType: System.Type,
			): string;

			/**
			 * Interpolates values into a localized string similar to Cannot parse argument '{0}' for
			 * command '{1}' as expected type {2}..
			 */
			ArgumentConversionCannotParseForCommand(
				value: string,
				commandAlias: string,
				expectedType: System.Type,
			): string;

			/**
			 * Interpolates values into a localized string similar to Cannot parse argument '{0}' for
			 * option '{1}' as expected type {2}..
			 */
			ArgumentConversionCannotParseForOption(
				value: string,
				optionAlias: string,
				expectedType: System.Type,
			): string;
		}
	}

	export namespace System.CommandLine {
		/** A symbol defining a named parameter and a value for that parameter. */
		export class Option extends System.CommandLine.IdentifierSymbol implements
			System.CommandLine.Completions.ICompletionSource {
			/** Gets or sets the name of the argument when displayed in help. */
			ArgumentHelpName?: string;

			/** Gets or sets the arity of the option. */
			Arity: System.CommandLine.ArgumentArity;

			/** Gets or sets the name of the symbol. */
			Name: string;

			/**
			 * Gets a value that indicates whether multiple argument tokens are allowed for each
			 * option identifier token.
			 */
			AllowMultipleArgumentsPerToken: boolean;

			/**
			 * Indicates whether the option is required when its parent command is invoked.
			 *
			 * When an option is required and its parent command is invoked without it, an error
			 * results.
			 */
			IsRequired: boolean;

			/** The {@link System.Type} that the option's arguments are expected to be parsed as. */
			readonly ValueType: System.Type;

			/** Adds a validator that will be called when the option is matched by the parser. */
			AddValidator(validate: System.CommandLine.Parsing.ValidateSymbolResult$1<System.CommandLine.Parsing.OptionResult>): void;

			/** Indicates whether a given alias exists on the option, regardless of its prefix. */
			HasAliasIgnoringPrefix(alias: string): boolean;

			/** Sets the default value for the option. */
			SetDefaultValue(value: System.Object | undefined): void;

			/** Sets a delegate to invoke when the default value for the option is required. */
			SetDefaultValueFactory(getDefaultValue: System.Func$1<System.Object | undefined>): void;

			/** Gets the suggested values for command line completion. */
			GetCompletions(context: System.CommandLine.Completions.CompletionContext): Iterable<System.CommandLine.Completions.CompletionItem>;

			/** Gets completions for the symbol. */
			GetCompletions(): Iterable<System.CommandLine.Completions.CompletionItem>;
		}
	}

	export namespace System.CommandLine {
		/** Provides extension methods for {@link System.CommandLine.Option}. */
		export namespace OptionExtensions {
			/**
			 * Configures an option to accept only the specified values, and to suggest them as
			 * command line completions.
			 */
			export function FromAmong<TOption>(
				option: TOption,
				values: string[],
			): TOption;

			/** Adds completions for an option. */
			export function AddCompletions<TOption>(
				option: TOption,
				values: string[],
			): TOption;

			/** Adds completions for an option. */
			export function AddCompletions<TOption>(
				option: TOption,
				complete: System.Func$2<System.CommandLine.Completions.CompletionContext, Iterable<string>>,
			): TOption;

			/** Adds completions for an option. */
			export function AddCompletions<TOption>(
				option: TOption,
				complete: System.CommandLine.Completions.CompletionDelegate,
			): TOption;

			/** Configures an option to accept only values corresponding to an existing file. */
			export function ExistingOnly(option: System.CommandLine.Option$1<System.IO.FileInfo>): System.CommandLine.Option$1<System.IO.FileInfo>;

			/** Configures an option to accept only values corresponding to an existing directory. */
			export function ExistingOnly(option: System.CommandLine.Option$1<System.IO.DirectoryInfo>): System.CommandLine.Option$1<System.IO.DirectoryInfo>;

			/**
			 * Configures an option to accept only values corresponding to an existing file or
			 * directory.
			 */
			export function ExistingOnly(option: System.CommandLine.Option$1<System.IO.FileSystemInfo>): System.CommandLine.Option$1<System.IO.FileSystemInfo>;

			/**
			 * Configures an option to accept only values corresponding to a existing files or
			 * directories.
			 */
			export function ExistingOnly<T>(option: System.CommandLine.Option$1<T>): System.CommandLine.Option$1<T>;

			/** Configures an option to accept only values representing legal file paths. */
			export function LegalFilePathsOnly<TOption>(option: TOption): TOption;

			/**
			 * Configures an option to accept only values representing legal file names.
			 *
			 * A parse error will result, for example, if file path separators are found in the
			 * parsed value.
			 */
			export function LegalFileNamesOnly<TOption>(option: TOption): TOption;

			/**
			 * Parses a command line string value using an option.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			export function Parse(
				option: System.CommandLine.Option,
				commandLine: string,
			): System.CommandLine.Parsing.ParseResult;

			/** Parses a command line string value using an option. */
			export function Parse(
				option: System.CommandLine.Option,
				args: string[],
			): System.CommandLine.Parsing.ParseResult;
		}
	}

	export namespace System.CommandLine.OptionExtensions {
		/** Extension methods from {@link System.CommandLine.OptionExtensions} */
		export interface TOption {
			/**
			 * Configures an option to accept only the specified values, and to suggest them as
			 * command line completions.
			 */
			FromAmong<TOption>(values: string[]): TOption;
		}
	}

	export namespace System.CommandLine.OptionExtensions {
		/** Extension methods from {@link System.CommandLine.OptionExtensions} */
		export interface TOption {
			/** Adds completions for an option. */
			AddCompletions<TOption>(values: string[]): TOption;
		}
	}

	export namespace System.CommandLine.OptionExtensions {
		/** Extension methods from {@link System.CommandLine.OptionExtensions} */
		export interface TOption {
			/** Adds completions for an option. */
			AddCompletions<TOption>(complete: System.Func$2<System.CommandLine.Completions.CompletionContext, Iterable<string>>): TOption;
		}
	}

	export namespace System.CommandLine.OptionExtensions {
		/** Extension methods from {@link System.CommandLine.OptionExtensions} */
		export interface TOption {
			/** Adds completions for an option. */
			AddCompletions<TOption>(complete: System.CommandLine.Completions.CompletionDelegate): TOption;
		}
	}

	export namespace System.CommandLine.OptionExtensions {
		/** Extension methods from {@link System.CommandLine.OptionExtensions} */
		export interface TOption {
			/** Configures an option to accept only values representing legal file paths. */
			LegalFilePathsOnly<TOption>(): TOption;
		}
	}

	export namespace System.CommandLine.OptionExtensions {
		/** Extension methods from {@link System.CommandLine.OptionExtensions} */
		export interface TOption {
			/**
			 * Configures an option to accept only values representing legal file names.
			 *
			 * A parse error will result, for example, if file path separators are found in the
			 * parsed value.
			 */
			LegalFileNamesOnly<TOption>(): TOption;
		}
	}

	export namespace System.CommandLine {
		/** Extension methods from {@link System.CommandLine.OptionExtensions} */
		export interface Option {
			/**
			 * Parses a command line string value using an option.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			Parse(commandLine: string): System.CommandLine.Parsing.ParseResult;

			/** Parses a command line string value using an option. */
			Parse(args: string[]): System.CommandLine.Parsing.ParseResult;
		}
	}

	export namespace System.CommandLine {
		export function Option$(T: IType): typeof Option$1<any>;

		export class Option$1<T> extends System.CommandLine.Option implements
			System.CommandLine.Completions.ICompletionSource {
			constructor(
				name: string,
				description?: string,
			);

			constructor(
				aliases: string[],
				description?: string,
			);

			constructor(
				name: string,
				parseArgument: System.CommandLine.Parsing.ParseArgument$1<T>,
				isDefault?: boolean,
				description?: string,
			);

			constructor(
				aliases: string[],
				parseArgument: System.CommandLine.Parsing.ParseArgument$1<T>,
				isDefault?: boolean,
				description?: string,
			);

			constructor(
				name: string,
				getDefaultValue: System.Func$1<T>,
				description?: string,
			);

			constructor(
				aliases: string[],
				getDefaultValue: System.Func$1<T>,
				description?: string,
			);

			/** Gets or sets the arity of the option. */
			Arity: System.CommandLine.ArgumentArity;
		}
	}

	export namespace System.CommandLine {
		/**
		 * Represents the main action that the application performs.
		 *
		 * Use the RootCommand object without any subcommands for applications that perform one
		 * action. Add subcommands  to the root for applications that require actions identified
		 * by specific strings. For example, `dir` does not  use any subcommands. See
		 * {@link System.CommandLine.Command} for applications with multiple actions.
		 */
		export class RootCommand extends System.CommandLine.Command implements System.CommandLine.Completions.ICompletionSource {
			constructor(description?: string);

			/** The name of the currently running executable. */
			static readonly ExecutableName: string;

			/** The path to the currently running executable. */
			static readonly ExecutablePath: string;
		}
	}

	export namespace System.CommandLine {
		/** Defines a named symbol that resides in a hierarchy with parent and child symbols. */
		export class Symbol implements System.CommandLine.Completions.ICompletionSource {
			/** Gets or sets the description of the symbol. */
			Description?: string;

			/** Gets or sets the name of the symbol. */
			Name: string;

			/** Gets or sets a value indicating whether the symbol is hidden. */
			IsHidden: boolean;

			/** Gets the parent symbols. */
			readonly Parents: Iterable<System.CommandLine.Symbol>;

			/** Gets completions for the symbol. */
			GetCompletions(): Iterable<System.CommandLine.Completions.CompletionItem>;

			/** Gets the suggested values for command line completion. */
			GetCompletions(context: System.CommandLine.Completions.CompletionContext): Iterable<System.CommandLine.Completions.CompletionItem>;

			/** Returns a string that represents the current object. */
			ToString(): string;
		}
	}

	export namespace System.CommandLine.Parsing {
		/**
		 * A result produced when parsing an
		 * {@link System.CommandLine.Parsing.ArgumentResult.Argument}.
		 */
		export class ArgumentResult extends System.CommandLine.Parsing.SymbolResult {
			/** The argument to which the result applies. */
			readonly Argument: System.CommandLine.Argument;

			GetValueOrDefault(): System.Object | undefined;

			/**
			 * Gets the parsed value or the default value for
			 * {@link System.CommandLine.Parsing.ArgumentResult.Argument}.
			 */
			GetValueOrDefault<T>(): T;

			/**
			 * Specifies the maximum number of tokens to consume for the argument. Remaining tokens
			 * are passed on and can be consumed by later arguments, or will otherwise be added to
			 * {@link System.CommandLine.Parsing.ParseResult.UnmatchedTokens}
			 */
			OnlyTake(numberOfTokens: number): void;

			/** Returns a string that represents the current object. */
			ToString(): string;
		}
	}

	export namespace System.CommandLine.Parsing {
		/** Splits a string based on whitespace and quotation marks */
		export class CommandLineStringSplitter {
			/**
			 * Splits a string into a sequence of strings based on whitespace and quotation marks.
			 */
			Split(commandLine: string): Iterable<string>;
		}
	}

	export namespace System.CommandLine.Parsing {
		/**
		 * A result produced when parsing a
		 * {@link System.CommandLine.Parsing.CommandResult.Command}.
		 */
		export class CommandResult extends System.CommandLine.Parsing.SymbolResult {
			/** The command to which the result applies. */
			readonly Command: System.CommandLine.Command;

			/** The token that was parsed to specify the command. */
			readonly Token: System.CommandLine.Parsing.Token;
		}
	}

	export namespace System.CommandLine.Parsing {
		/**
		 * A result produced when parsing an
		 * {@link System.CommandLine.Parsing.OptionResult.Option}.
		 */
		export class OptionResult extends System.CommandLine.Parsing.SymbolResult {
			/** The option to which the result applies. */
			readonly Option: System.CommandLine.Option;

			/**
			 * Indicates whether the result was created implicitly and not due to the option being
			 * specified on the command line.
			 *
			 * Implicit results commonly result from options having a default value.
			 */
			readonly IsImplicit: boolean;

			/** The token that was parsed to specify the option. */
			readonly Token?: System.CommandLine.Parsing.Token;

			GetValueOrDefault(): System.Object | undefined;

			/**
			 * Gets the parsed value or the default value for
			 * {@link System.CommandLine.Parsing.OptionResult.Option}.
			 */
			GetValueOrDefault<T>(): T;
		}
	}

	export namespace System.CommandLine.Parsing {
		/**
		 * [Generic type factory] Performs custom parsing of an argument.
		 *
		 * Validation errors can be returned by setting
		 * {@link System.CommandLine.Parsing.SymbolResult.ErrorMessage}.
		 */
		export function ParseArgument$(T: IType): IType;

		/**
		 * Performs custom parsing of an argument.
		 *
		 * Validation errors can be returned by setting
		 * {@link System.CommandLine.Parsing.SymbolResult.ErrorMessage}.
		 */
		export interface ParseArgument$1<T> { (result: System.CommandLine.Parsing.ArgumentResult): T; }
	}

	export namespace System.CommandLine.Parsing {
		/** Describes an error that occurs while parsing command line input. */
		export class ParseError {
			/** A message to explain the error to a user. */
			readonly Message: string;

			/**
			 * The symbol result detailing the symbol that failed to parse and the tokens involved.
			 */
			readonly SymbolResult?: System.CommandLine.Parsing.SymbolResult;

			/** Returns a string that represents the current object. */
			ToString(): string;
		}
	}

	export namespace System.CommandLine.Parsing {
		/** Parses command line input. */
		export class Parser {
			constructor(configuration: System.CommandLine.CommandLineConfiguration);

			constructor(command: System.CommandLine.Command);

			/**
			 * Initializes a new instance of the {@link System.CommandLine.Parsing.Parser} class
			 * using the default {@link System.CommandLine.RootCommand}.
			 */
			constructor();

			/** Gets the configuration on which the parser's grammar and behaviors are based. */
			readonly Configuration: System.CommandLine.CommandLineConfiguration;

			/** Parses a list of arguments. */
			Parse(
				_arguments: readonly string[],
				rawInput?: string,
			): System.CommandLine.Parsing.ParseResult;
		}
	}

	export namespace System.CommandLine.Parsing {
		/**
		 * Describes the results of parsing a command line input based on a specific parser
		 * configuration.
		 */
		export class ParseResult {
			/** A result indicating the command specified in the command line input. */
			readonly CommandResult: System.CommandLine.Parsing.CommandResult;

			/** The parser used to produce the parse result. */
			readonly Parser: System.CommandLine.Parsing.Parser;

			/** Gets the root command result. */
			readonly RootCommandResult: System.CommandLine.Parsing.CommandResult;

			/** Gets the parse errors found while parsing command line input. */
			readonly Errors: readonly System.CommandLine.Parsing.ParseError[];

			/**
			 * Gets the directives found while parsing command line input.
			 *
			 * If {@link System.CommandLine.CommandLineConfiguration.EnableDirectives} is set to
			 * `false`, then this collection will be empty.
			 */
			readonly Directives: System.CommandLine.DirectiveCollection;

			/** Gets the tokens identified while parsing command line input. */
			readonly Tokens: readonly System.CommandLine.Parsing.Token[];

			/**
			 * Gets the list of tokens used on the command line that were not matched by the parser.
			 */
			readonly UnmatchedTokens: readonly string[];

			/**
			 * Gets the list of tokens used on the command line that were ignored by the parser.
			 *
			 * This list will contain all of the tokens following the first occurrence of a -- token
			 * if {@link System.CommandLine.CommandLineConfiguration.EnableLegacyDoubleDashBehavior}
			 * is set to `true`.
			 */
			readonly UnparsedTokens: readonly string[];

			/** Gets the completion context for the parse result. */
			GetCompletionContext(): System.CommandLine.Completions.CompletionContext;

			/** Gets the parsed or default value for the specified option. */
			GetValueForOption(option: System.CommandLine.Option): System.Object | undefined;

			/** Gets the parsed or default value for the specified argument. */
			GetValueForArgument(argument: System.CommandLine.Argument): System.Object | undefined;

			GetValueForArgument<T>(argument: System.CommandLine.Argument$1<T>): T;

			GetValueForOption<T>(option: System.CommandLine.Option$1<T>): T;

			/** Returns a string that represents the current object. */
			ToString(): string;

			/** Gets the result, if any, for the specified argument. */
			FindResultFor(argument: System.CommandLine.Argument): System.CommandLine.Parsing.ArgumentResult | undefined;

			/** Gets the result, if any, for the specified command. */
			FindResultFor(command: System.CommandLine.Command): System.CommandLine.Parsing.CommandResult | undefined;

			/** Gets the result, if any, for the specified option. */
			FindResultFor(option: System.CommandLine.Option): System.CommandLine.Parsing.OptionResult | undefined;

			/** Gets the result, if any, for the specified symbol. */
			FindResultFor(symbol: System.CommandLine.Symbol): System.CommandLine.Parsing.SymbolResult | undefined;

			/** Gets completions based on a given parse result. */
			GetCompletions(position?: number): Iterable<System.CommandLine.Completions.CompletionItem>;
		}
	}

	export namespace System.CommandLine.Parsing {
		/** Provides extension methods for parse results. */
		export namespace ParseResultExtensions {
			/** Invokes the appropriate command handler for a parsed command line input. */
			export function InvokeAsync(
				parseResult: System.CommandLine.Parsing.ParseResult,
				console?: System.CommandLine.IConsole,
			): Promise<number>;

			/** Invokes the appropriate command handler for a parsed command line input. */
			export function Invoke(
				parseResult: System.CommandLine.Parsing.ParseResult,
				console?: System.CommandLine.IConsole,
			): number;

			/** Formats a string explaining a parse result. */
			export function Diagram(parseResult: System.CommandLine.Parsing.ParseResult): string;

			/**
			 * Indicates whether a given option is present in the parse result.
			 *
			 * If the option has a default value defined, then `true` will be returned.
			 */
			export function HasOption(
				parseResult: System.CommandLine.Parsing.ParseResult,
				option: System.CommandLine.Option,
			): boolean;
		}
	}

	export namespace System.CommandLine.Parsing {
		/** Extension methods from {@link System.CommandLine.Parsing.ParseResultExtensions} */
		export interface ParseResult {
			/** Invokes the appropriate command handler for a parsed command line input. */
			InvokeAsync(console?: System.CommandLine.IConsole): Promise<number>;

			/** Invokes the appropriate command handler for a parsed command line input. */
			Invoke(console?: System.CommandLine.IConsole): number;

			/** Formats a string explaining a parse result. */
			Diagram(): string;

			/**
			 * Indicates whether a given option is present in the parse result.
			 *
			 * If the option has a default value defined, then `true` will be returned.
			 */
			HasOption(option: System.CommandLine.Option): boolean;
		}
	}

	export namespace System.CommandLine.Parsing {
		/** Provides extension methods for parsers. */
		export namespace ParserExtensions {
			/**
			 * Parses a command line string value and invokes the handler for the indicated command.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			export function Invoke(
				parser: System.CommandLine.Parsing.Parser,
				commandLine: string,
				console?: System.CommandLine.IConsole,
			): number;

			/**
			 * Parses a command line string array and invokes the handler for the indicated command.
			 */
			export function Invoke(
				parser: System.CommandLine.Parsing.Parser,
				args: string[],
				console?: System.CommandLine.IConsole,
			): number;

			/**
			 * Parses a command line string value and invokes the handler for the indicated command.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			export function InvokeAsync(
				parser: System.CommandLine.Parsing.Parser,
				commandLine: string,
				console?: System.CommandLine.IConsole,
			): Promise<number>;

			/**
			 * Parses a command line string array and invokes the handler for the indicated command.
			 */
			export function InvokeAsync(
				parser: System.CommandLine.Parsing.Parser,
				args: string[],
				console?: System.CommandLine.IConsole,
			): Promise<number>;
		}
	}

	export namespace System.CommandLine.Parsing {
		/** Extension methods from {@link System.CommandLine.Parsing.ParserExtensions} */
		export interface Parser {
			/**
			 * Parses a command line string value and invokes the handler for the indicated command.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			Invoke(
				commandLine: string,
				console?: System.CommandLine.IConsole,
			): number;

			/**
			 * Parses a command line string array and invokes the handler for the indicated command.
			 */
			Invoke(
				args: string[],
				console?: System.CommandLine.IConsole,
			): number;

			/**
			 * Parses a command line string value and invokes the handler for the indicated command.
			 *
			 * The command line string input will be split into tokens as if it had been passed on
			 * the command line.
			 */
			InvokeAsync(
				commandLine: string,
				console?: System.CommandLine.IConsole,
			): Promise<number>;

			/**
			 * Parses a command line string array and invokes the handler for the indicated command.
			 */
			InvokeAsync(
				args: string[],
				console?: System.CommandLine.IConsole,
			): Promise<number>;
		}
	}

	export namespace System.CommandLine.Parsing {
		/** A result produced during parsing for a specific symbol. */
		export class SymbolResult {
			/**
			 * An error message for this symbol result.
			 *
			 * Setting this value to a non- null during parsing will cause the parser to indicate an
			 * error for the user and prevent invocation of the command line.
			 */
			ErrorMessage?: string;

			/** Child symbol results in the parse tree. */
			readonly Children: readonly System.CommandLine.Parsing.SymbolResult[];

			/** The parent symbol result in the parse tree. */
			readonly Parent?: System.CommandLine.Parsing.SymbolResult;

			/** The symbol to which the result applies. */
			readonly Symbol: System.CommandLine.Symbol;

			/** The list of tokens associated with this symbol result during parsing. */
			readonly Tokens: readonly System.CommandLine.Parsing.Token[];

			/** Localization resources used to produce messages for this symbol result. */
			LocalizationResources: System.CommandLine.LocalizationResources;

			/**
			 * Finds a result for the specific argument anywhere in the parse tree, including parent
			 * and child symbol results.
			 */
			FindResultFor(argument: System.CommandLine.Argument): System.CommandLine.Parsing.ArgumentResult | undefined;

			/**
			 * Finds a result for the specific command anywhere in the parse tree, including parent
			 * and child symbol results.
			 */
			FindResultFor(command: System.CommandLine.Command): System.CommandLine.Parsing.CommandResult | undefined;

			/**
			 * Finds a result for the specific option anywhere in the parse tree, including parent
			 * and child symbol results.
			 */
			FindResultFor(option: System.CommandLine.Option): System.CommandLine.Parsing.OptionResult | undefined;

			GetValueForArgument<T>(argument: System.CommandLine.Argument$1<T>): T;

			GetValueForArgument(argument: System.CommandLine.Argument): System.Object | undefined;

			GetValueForOption<T>(option: System.CommandLine.Option$1<T>): T;

			GetValueForOption(option: System.CommandLine.Option): System.Object | undefined;

			/** Returns a string that represents the current object. */
			ToString(): string;
		}
	}

	export namespace System.CommandLine.Parsing {
		/** A unit of significant text on the command line. */
		export class Token {
			constructor(
				value: string | undefined,
				type: System.CommandLine.Parsing.TokenType,
				symbol: System.CommandLine.Symbol,
			);

			/** The string value of the token. */
			readonly Value: string;

			/** The type of the token. */
			readonly Type: System.CommandLine.Parsing.TokenType;

			/** Determines whether the specified object is equal to the current object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Determines whether the specified object is equal to the current object. */
			Equals(other: System.CommandLine.Parsing.Token | undefined): boolean;

			/** Serves as the default hash function. */
			GetHashCode(): number;

			/** Returns a string that represents the current object. */
			ToString(): string;
		}
	}

	export namespace System.CommandLine.Parsing {
		/** Identifies the type of a {@link System.CommandLine.Parsing.Token}. */
		export enum TokenType {
			/** An argument token. */
			Argument = 0,

			/** A command token. */
			Command = 1,

			/** An option token. */
			Option = 2,

			/** A double dash ( -- ) token, which changes the meaning of subsequent tokens. */
			DoubleDash = 3,

			/**
			 * A token following {@link System.CommandLine.Parsing.TokenType.DoubleDash} when
			 * {@link System.CommandLine.CommandLineConfiguration.EnableLegacyDoubleDashBehavior} is
			 * set to `true`.
			 */
			Unparsed = 4,

			/** A directive token. */
			Directive = 5,
		}
	}

	export namespace System.CommandLine.Parsing {
		/** Replaces a token with one or more other tokens prior to parsing. */
		export interface TryReplaceToken { (tokenToReplace: string): { result: boolean, replacementTokens?: readonly string[], errorMessage?: string }; }
	}

	export namespace System.CommandLine.Parsing {
		/**
		 * [Generic type factory] A delegate used to validate symbol results during parsing.
		 *
		 * To display an error, set {@link System.CommandLine.Parsing.SymbolResult.ErrorMessage}.
		 */
		export function ValidateSymbolResult$(T: IType): IType;

		/**
		 * A delegate used to validate symbol results during parsing.
		 *
		 * To display an error, set {@link System.CommandLine.Parsing.SymbolResult.ErrorMessage}.
		 */
		export interface ValidateSymbolResult$1<T> { (symbolResult: T): void; }
	}

	export namespace System.CommandLine.IO {
		/** Represents a console's standard error stream. */
		export interface IStandardError {
			/** The stream writer for standard error. */
			readonly Error: System.CommandLine.IO.IStandardStreamWriter;

			/** Indicates whether the standard error stream has been redirected. */
			readonly IsErrorRedirected: boolean;
		}
	}

	export namespace System.CommandLine.IO {
		/** Represents a console's standard input stream. */
		export interface IStandardIn {
			/** Gets a value indicating whether input is redirected. */
			readonly IsInputRedirected: boolean;
		}
	}

	export namespace System.CommandLine.IO {
		/** Represents a console's standard output stream. */
		export interface IStandardOut {
			/** The stream writer for standard output. */
			readonly Out: System.CommandLine.IO.IStandardStreamWriter;

			/** Indicates whether the standard output stream has been redirected. */
			readonly IsOutputRedirected: boolean;
		}
	}

	export namespace System.CommandLine.IO {
		/** Represents a standard stream that can be written to. */
		export interface IStandardStreamWriter {
			/** Writes the specified string to the stream. */
			Write(value: string | undefined): void;
		}
	}

	export namespace System.CommandLine.IO {
		/** Provides methods for working with standard streams. */
		export namespace StandardStreamWriter {
			/**
			 * Creates a {@link System.IO.TextWriter} that writes to the specified
			 * {@link System.CommandLine.IO.IStandardStreamWriter}.
			 */
			export function CreateTextWriter(writer: System.CommandLine.IO.IStandardStreamWriter): System.IO.TextWriter;

			/**
			 * Creates a {@link System.CommandLine.IO.IStandardStreamWriter} that writes to the
			 * specified {@link System.IO.TextWriter}.
			 */
			export function Create(writer: System.IO.TextWriter): System.CommandLine.IO.IStandardStreamWriter;

			/** Appends the current environment's line terminator. */
			export function WriteLine(writer: System.CommandLine.IO.IStandardStreamWriter): void;

			/**
			 * Writes the current string value, followed by the current environment's line
			 * terminator.
			 */
			export function WriteLine(
				writer: System.CommandLine.IO.IStandardStreamWriter,
				value: string,
			): void;
		}
	}

	export namespace System.CommandLine.IO {
		/** Extension methods from {@link System.CommandLine.IO.StandardStreamWriter} */
		export interface IStandardStreamWriter {
			/**
			 * Creates a {@link System.IO.TextWriter} that writes to the specified
			 * {@link System.CommandLine.IO.IStandardStreamWriter}.
			 */
			CreateTextWriter(): System.IO.TextWriter;

			/** Appends the current environment's line terminator. */
			WriteLine(): void;

			/**
			 * Writes the current string value, followed by the current environment's line
			 * terminator.
			 */
			WriteLine(value: string): void;
		}
	}

	export namespace System.CommandLine.IO {
		/** Provides access to the standard streams via {@link System.Console}. */
		export class SystemConsole implements
			System.CommandLine.IConsole,
			System.CommandLine.IO.IStandardOut,
			System.CommandLine.IO.IStandardError,
			System.CommandLine.IO.IStandardIn {
			/** Initializes a new instance of {@link System.CommandLine.IO.SystemConsole}. */
			constructor();

			/** The stream writer for standard error. */
			readonly Error: System.CommandLine.IO.IStandardStreamWriter;

			/** Indicates whether the standard error stream has been redirected. */
			readonly IsErrorRedirected: boolean;

			/** The stream writer for standard output. */
			readonly Out: System.CommandLine.IO.IStandardStreamWriter;

			/** Indicates whether the standard output stream has been redirected. */
			readonly IsOutputRedirected: boolean;

			/** Gets a value indicating whether input is redirected. */
			readonly IsInputRedirected: boolean;
		}
	}

	export namespace System.CommandLine.IO {
		/**
		 * Provides access to in-memory standard streams that are not attached to
		 * {@link System.Console}.
		 */
		export class TestConsole implements
			System.CommandLine.IConsole,
			System.CommandLine.IO.IStandardOut,
			System.CommandLine.IO.IStandardError,
			System.CommandLine.IO.IStandardIn {
			/** Initializes a new instance of {@link System.CommandLine.IO.TestConsole}. */
			constructor();

			/** The stream writer for standard error. */
			Error: System.CommandLine.IO.IStandardStreamWriter;

			/** The stream writer for standard output. */
			Out: System.CommandLine.IO.IStandardStreamWriter;

			/** Indicates whether the standard output stream has been redirected. */
			IsOutputRedirected: boolean;

			/** Indicates whether the standard error stream has been redirected. */
			IsErrorRedirected: boolean;

			/** Gets a value indicating whether input is redirected. */
			IsInputRedirected: boolean;
		}
	}

	export namespace System.CommandLine.Invocation {
		/** Defines the behavior of a command. */
		export interface ICommandHandler {
			/** Performs an action when the associated command is invoked on the command line. */
			Invoke(context: System.CommandLine.Invocation.InvocationContext): number;

			/** Performs an action when the associated command is invoked on the command line. */
			InvokeAsync(context: System.CommandLine.Invocation.InvocationContext): Promise<number>;
		}
	}

	export namespace System.CommandLine.Invocation {
		/** The result of a command handler invocation. */
		export interface IInvocationResult {
			/** Applies the result to the current invocation context. */
			Apply(context: System.CommandLine.Invocation.InvocationContext): void;
		}
	}

	export namespace System.CommandLine.Invocation {
		/**
		 * Supports command invocation by providing access to parse results and other services.
		 */
		export class InvocationContext {
			constructor(
				parseResult: System.CommandLine.Parsing.ParseResult,
				console?: System.CommandLine.IConsole,
			);

			/** The binding context for the current invocation. */
			readonly BindingContext: System.CommandLine.Binding.BindingContext;

			/** The console to which output should be written during the current invocation. */
			Console: System.CommandLine.IConsole;

			/** Enables writing help output. */
			readonly HelpBuilder: System.CommandLine.Help.HelpBuilder;

			/**
			 * The parser used to create the
			 * {@link System.CommandLine.Invocation.InvocationContext.ParseResult}.
			 */
			readonly Parser: System.CommandLine.Parsing.Parser;

			/** Provides localizable strings for help and error messages. */
			readonly LocalizationResources: System.CommandLine.LocalizationResources;

			/** The parse result for the current invocation. */
			ParseResult: System.CommandLine.Parsing.ParseResult;

			/** A value that can be used to set the exit code for the process. */
			ExitCode: number;

			/**
			 * The result of the current invocation.
			 *
			 * As the {@link System.CommandLine.Invocation.InvocationContext} is passed through the
			 * invocation pipeline to the {@link System.CommandLine.Invocation.ICommandHandler}
			 * associated with the invoked command, only the last value of this property will be the
			 * one applied.
			 */
			InvocationResult?: System.CommandLine.Invocation.IInvocationResult;

			/** Gets token to implement cancellation handling. */
			GetCancellationToken(): AbortSignal;
		}
	}

	export namespace System.CommandLine.Invocation {
		/** A delegate used for adding command handler invocation middleware. */
		export interface InvocationMiddleware { (
			context: System.CommandLine.Invocation.InvocationContext,
			next: System.Func$2<System.CommandLine.Invocation.InvocationContext, Promise<void>>,
		): Promise<void>; }
	}

	export namespace System.CommandLine.Invocation {
		/** Designates ordering of middleware in the invocation pipeline. */
		export enum MiddlewareOrder {
			/** The position in the pipeline at which the exception handler middleware is invoked. */
			ExceptionHandler = -2000,

			/** The position in the pipeline at which configuration middleware is invoked. */
			Configuration = -1000,

			/** The default position in the pipeline. */
			Default = 0,

			/** The position in the pipeline at which error reporting middleware is invoked. */
			ErrorReporting = 1000,
		}
	}

	export namespace System.CommandLine.Help {
		/** Formats output to be shown to users to describe how to use a command line tool. */
		export class HelpBuilder {
			constructor(
				localizationResources: System.CommandLine.LocalizationResources,
				maxWidth?: number,
			);

			/** Provides localizable strings for help and error messages. */
			readonly LocalizationResources: System.CommandLine.LocalizationResources;

			/** The maximum width for which to format help output. */
			readonly MaxWidth: number;

			/** Writes help output for the specified command. */
			Write(context: System.CommandLine.Help.HelpContext): void;

			/** Specifies custom help details for a specific symbol. */
			CustomizeSymbol(
				symbol: System.CommandLine.Symbol,
				firstColumnText?: System.Func$2<System.CommandLine.Help.HelpContext, string | undefined>,
				secondColumnText?: System.Func$2<System.CommandLine.Help.HelpContext, string | undefined>,
				defaultValue?: System.Func$2<System.CommandLine.Help.HelpContext, string | undefined>,
			): void;

			/** Customizes the help sections that will be displayed. */
			CustomizeLayout(getLayout: System.Func$2<System.CommandLine.Help.HelpContext, Iterable<System.CommandLine.Help.HelpSectionDelegate>>): void;

			/** Writes the specified help rows, aligning output in columns. */
			WriteColumns(
				items: readonly System.CommandLine.Help.TwoColumnHelpRow[],
				context: System.CommandLine.Help.HelpContext,
			): void;

			/** Gets a help item for the specified symbol. */
			GetTwoColumnRow(
				symbol: System.CommandLine.Symbol,
				context: System.CommandLine.Help.HelpContext,
			): System.CommandLine.Help.TwoColumnHelpRow;
		}
	}

	export namespace System.CommandLine.Help.HelpBuilder {
		export namespace Default {
			export function GetArgumentDefaultValue(argument: System.CommandLine.Argument): string;

			export function GetArgumentDescription(argument: System.CommandLine.Argument): string;

			export function GetArgumentUsageLabel(argument: System.CommandLine.Argument): string;

			export function GetIdentifierSymbolDescription(symbol: System.CommandLine.IdentifierSymbol): string;

			export function GetIdentifierSymbolUsageLabel(
				symbol: System.CommandLine.IdentifierSymbol,
				context: System.CommandLine.Help.HelpContext,
			): string;

			export function GetLayout(): Iterable<System.CommandLine.Help.HelpSectionDelegate>;

			export function SynopsisSection(): System.CommandLine.Help.HelpSectionDelegate;

			export function CommandUsageSection(): System.CommandLine.Help.HelpSectionDelegate;

			export function CommandArgumentsSection(): System.CommandLine.Help.HelpSectionDelegate;

			export function SubcommandsSection(): System.CommandLine.Help.HelpSectionDelegate;

			export function OptionsSection(): System.CommandLine.Help.HelpSectionDelegate;

			export function AdditionalArgumentsSection(): System.CommandLine.Help.HelpSectionDelegate;
		}
	}

	export namespace System.CommandLine.Help {
		/** Provides extension methods for the help builder. */
		export namespace HelpBuilderExtensions {
		}
	}

	export namespace System.CommandLine.Help {
		/** Supports formatting command line help. */
		export class HelpContext {
			constructor(
				helpBuilder: System.CommandLine.Help.HelpBuilder,
				command: System.CommandLine.Command,
				output: System.IO.TextWriter,
				parseResult?: System.CommandLine.Parsing.ParseResult,
			);

			/** The help builder for the current operation. */
			readonly HelpBuilder: System.CommandLine.Help.HelpBuilder;

			/** The result of the current parse operation. */
			readonly ParseResult: System.CommandLine.Parsing.ParseResult;

			/** The command for which help is being formatted. */
			readonly Command: System.CommandLine.Command;

			/** A text writer to write output to. */
			readonly Output: System.IO.TextWriter;
		}
	}

	export namespace System.CommandLine.Help {
		/** Specifies help formatting behavior for a section of command line help. */
		export interface HelpSectionDelegate { (context: System.CommandLine.Help.HelpContext): void; }
	}

	export namespace System.CommandLine.Help {
		/**
		 * Provides details about an item to be formatted to output in order to display
		 * two-column command line help.
		 */
		export class TwoColumnHelpRow {
			constructor(
				firstColumnText: string,
				secondColumnText: string,
			);

			/**
			 * The first column for a help entry, typically containing the name and other usage
			 * details about an option or argument.
			 */
			readonly FirstColumnText: string;

			/**
			 * The second column for a help entry, typically containing the name and other usage
			 * details about an option or argument.
			 */
			readonly SecondColumnText: string;

			/** Determines whether the specified object is equal to the current object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Determines whether the specified object is equal to the current object. */
			Equals(other: System.CommandLine.Help.TwoColumnHelpRow | undefined): boolean;

			/** Serves as the default hash function. */
			GetHashCode(): number;
		}
	}

	export namespace System.CommandLine.Completions {
		/** Supports command line completion operations. */
		export class CompletionContext {
			readonly WordToComplete: string;

			readonly ParseResult: System.CommandLine.Parsing.ParseResult;
		}
	}

	export namespace System.CommandLine.Completions {
		/** Provides command line completion. */
		export interface CompletionDelegate { (context: System.CommandLine.Completions.CompletionContext): Iterable<System.CommandLine.Completions.CompletionItem>; }
	}

	export namespace System.CommandLine.Completions {
		/** Provides details about a command line completion item. */
		export class CompletionItem {
			constructor(
				label: string,
				kind?: string,
				sortText?: string,
				insertText?: string,
				documentation?: string,
				detail?: string,
			);

			/** The label value, which is the text displayed to users. */
			readonly Label: string;

			/** The kind of completion item. */
			readonly Kind?: string;

			/** The value used to sort the completion item in a list. */
			readonly SortText: string;

			/** The text to be inserted by this completion item. */
			readonly InsertText?: string;

			/** Documentation about the completion item. */
			Documentation?: string;

			/** Additional details regarding the completion item. */
			readonly Detail?: string;

			/** Returns a string that represents the current object. */
			ToString(): string;

			/** Determines whether the specified object is equal to the current object. */
			Equals(obj: System.Object | undefined): boolean;

			/** Serves as the default hash function. */
			GetHashCode(): number;
		}
	}

	export namespace System.CommandLine.Completions {
		/** Provides completions and example values for help. */
		export interface ICompletionSource {
			/** Gets the suggested values for command line completion. */
			GetCompletions(context: System.CommandLine.Completions.CompletionContext): Iterable<System.CommandLine.Completions.CompletionItem>;
		}
	}

	export namespace System.CommandLine.Completions {
		/**
		 * Provides details for calculating completions in the context of complete, unsplit
		 * command line text.
		 */
		export class TextCompletionContext extends System.CommandLine.Completions.CompletionContext {
			/** The position of the cursor within the command line. */
			readonly CursorPosition: number;

			/**
			 * The complete text of the command line prior to splitting, including any additional
			 * whitespace.
			 */
			readonly CommandLineText: string;

			/**
			 * Creates a new instance of {@link System.CommandLine.Completions.TextCompletionContext}
			 * at the specified cursor position.
			 */
			AtCursorPosition(position: number): System.CommandLine.Completions.TextCompletionContext;
		}
	}

	export namespace System.CommandLine.Completions {
		/**
		 * Provides details for getting completions when the complete text of the original
		 * command line is not available.
		 */
		export class TokenCompletionContext extends System.CommandLine.Completions.CompletionContext {
		}
	}

	export namespace System.CommandLine.Builder {
		/** Enables composition of command line configurations. */
		export class CommandLineBuilder {
			constructor(rootCommand?: System.CommandLine.Command);

			/** The command that the builder uses the root of the parser. */
			readonly Command: System.CommandLine.Command;

			/** Creates a parser based on the configuration of the command line builder. */
			Build(): System.CommandLine.Parsing.Parser;
		}
	}

	export namespace System.CommandLine.Builder {
		/**
		 * Provides extension methods for {@link System.CommandLine.Builder.CommandLineBuilder}.
		 */
		export namespace CommandLineBuilderExtensions {
			/**
			 * Enables signaling and handling of process termination via a
			 * {@link System.Threading.CancellationToken} that can be passed to a
			 * {@link System.CommandLine.Invocation.ICommandHandler} during invocation.
			 */
			export function CancelOnProcessTermination(builder: System.CommandLine.Builder.CommandLineBuilder): System.CommandLine.Builder.CommandLineBuilder;

			/** Enables the parser to recognize command line directives. */
			export function EnableDirectives(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				value?: boolean,
			): System.CommandLine.Builder.CommandLineBuilder;

			/** Determines the behavior when parsing a double dash ( -- ) in a command line. */
			export function EnableLegacyDoubleDashBehavior(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				value?: boolean,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables the parser to recognize and expand POSIX-style bundled options.
			 *
			 * POSIX conventions recommend that single-character options be allowed to be specified
			 * together after a single - prefix. When
			 * {@link System.CommandLine.Builder.CommandLineBuilderExtensions.EnablePosixBundling(System.CommandLine.Builder.CommandLineBuilder,System.Boolean)}
			 * is set to `true`, the following command lines are equivalent: &gt; myapp -a -b -c &gt;
			 * myapp -abc If an argument is provided after an option bundle, it applies to the last
			 * option in the bundle. When
			 * {@link System.CommandLine.Builder.CommandLineBuilderExtensions.EnablePosixBundling(System.CommandLine.Builder.CommandLineBuilder,System.Boolean)}
			 * is set to `true`, all of the following command lines are equivalent: &gt; myapp -a -b
			 * -c arg &gt; myapp -abc arg &gt; myapp -abcarg
			 */
			export function EnablePosixBundling(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				value?: boolean,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Ensures that the application is registered with the dotnet-suggest tool to enable
			 * command line completions.
			 *
			 * For command line completions to work, users must install the dotnet-suggest tool as
			 * well as the appropriate shim script for their shell.
			 */
			export function RegisterWithDotnetSuggest(builder: System.CommandLine.Builder.CommandLineBuilder): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables the use of the [env:key=value] directive, allowing environment variables to be
			 * set from the command line during invocation.
			 */
			export function UseEnvironmentVariableDirective(builder: System.CommandLine.Builder.CommandLineBuilder): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Uses the default configuration.
			 *
			 * Calling this method is the equivalent to calling: builder .UseVersionOption()
			 * .UseHelp() .UseEnvironmentVariableDirective() .UseParseDirective()
			 * .UseSuggestDirective() .RegisterWithDotnetSuggest() .UseTypoCorrections()
			 * .UseParseErrorReporting() .UseExceptionHandler() .CancelOnProcessTermination();
			 */
			export function UseDefaults(builder: System.CommandLine.Builder.CommandLineBuilder): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables an exception handler to catch any unhandled exceptions thrown by a command
			 * handler during invocation.
			 */
			export function UseExceptionHandler(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				onException?: System.Action$2<System.Exception, System.CommandLine.Invocation.InvocationContext>,
				errorExitCode?: number,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Configures the application to show help when one of the following options are
			 * specified on the command line: -h /h --help -? /?
				 */
				export function UseHelp(
					builder: System.CommandLine.Builder.CommandLineBuilder,
					maxWidth?: number,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Configures the application to show help when one of the specified option aliases are
			 * used on the command line.
			 *
			 * The specified aliases will override the default values.
			 */
			export function UseHelp(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				helpAliases: string[],
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Configures the application to show help when one of the specified option aliases are
			 * used on the command line.
			 *
			 * The specified aliases will override the default values.
			 */
			export function UseHelp(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				customize: System.Action$1<System.CommandLine.Help.HelpContext>,
				maxWidth?: number,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Specifies an {@link System.CommandLine.Help.HelpBuilder} to be used to format help
			 * output when help is requested.
			 */
			export function UseHelpBuilder<TBuilder>(
				builder: TBuilder,
				getHelpBuilder: System.Func$2<System.CommandLine.Binding.BindingContext, System.CommandLine.Help.HelpBuilder>,
			): TBuilder;

			/**
			 * Adds a middleware delegate to the invocation pipeline called before a command handler
			 * is invoked.
			 */
			export function AddMiddleware(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				middleware: System.CommandLine.Invocation.InvocationMiddleware,
				order?: System.CommandLine.Invocation.MiddlewareOrder,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Adds a middleware delegate to the invocation pipeline called before a command handler
			 * is invoked.
			 */
			export function AddMiddleware(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				onInvoke: System.Action$1<System.CommandLine.Invocation.InvocationContext>,
				order?: System.CommandLine.Invocation.MiddlewareOrder,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables the use of the [parse] directive, which when specified on the command line
			 * will short circuit normal command handling and display a diagram explaining the parse
			 * result for the command line input.
			 */
			export function UseParseDirective(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				errorExitCode?: number,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Configures the command line to write error information to standard error when there
			 * are errors parsing command line input.
			 */
			export function UseParseErrorReporting(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				errorExitCode?: number,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables the use of the [suggest] directive which when specified in command line input
			 * short circuits normal command handling and writes a newline-delimited list of
			 * suggestions suitable for use by most shells to provide command line completions.
			 *
			 * The dotnet-suggest tool requires the suggest directive to be enabled for an
			 * application to provide completions.
			 */
			export function UseSuggestDirective(builder: System.CommandLine.Builder.CommandLineBuilder): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Configures the application to provide alternative suggestions when a parse error is
			 * detected.
			 */
			export function UseTypoCorrections(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				maxLevenshteinDistance?: number,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Specifies localization resources to be used when displaying help, error messages, and
			 * other user-facing strings.
			 */
			export function UseLocalizationResources(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				validationMessages: System.CommandLine.LocalizationResources,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Specifies a delegate used to replace any token prefixed with @ with zero or more other
			 * tokens, prior to parsing.
			 */
			export function UseTokenReplacer(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				replaceToken: System.CommandLine.Parsing.TryReplaceToken | undefined,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables the use of a option (defaulting to the alias --version ) which when specified
			 * in command line input will short circuit normal command handling and instead write out
			 * version information before exiting.
			 */
			export function UseVersionOption(builder: System.CommandLine.Builder.CommandLineBuilder): System.CommandLine.Builder.CommandLineBuilder;

			export function UseVersionOption(
				builder: System.CommandLine.Builder.CommandLineBuilder,
				aliases: string[],
			): System.CommandLine.Builder.CommandLineBuilder;
		}
	}

	export namespace System.CommandLine.Builder {
		/** Extension methods from {@link System.CommandLine.Builder.CommandLineBuilderExtensions} */
		export interface CommandLineBuilder {
			/**
			 * Enables signaling and handling of process termination via a
			 * {@link System.Threading.CancellationToken} that can be passed to a
			 * {@link System.CommandLine.Invocation.ICommandHandler} during invocation.
			 */
			CancelOnProcessTermination(): System.CommandLine.Builder.CommandLineBuilder;

			/** Enables the parser to recognize command line directives. */
			EnableDirectives(value?: boolean): System.CommandLine.Builder.CommandLineBuilder;

			/** Determines the behavior when parsing a double dash ( -- ) in a command line. */
			EnableLegacyDoubleDashBehavior(value?: boolean): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables the parser to recognize and expand POSIX-style bundled options.
			 *
			 * POSIX conventions recommend that single-character options be allowed to be specified
			 * together after a single - prefix. When
			 * {@link System.CommandLine.Builder.CommandLineBuilderExtensions.EnablePosixBundling(System.CommandLine.Builder.CommandLineBuilder,System.Boolean)}
			 * is set to `true`, the following command lines are equivalent: &gt; myapp -a -b -c &gt;
			 * myapp -abc If an argument is provided after an option bundle, it applies to the last
			 * option in the bundle. When
			 * {@link System.CommandLine.Builder.CommandLineBuilderExtensions.EnablePosixBundling(System.CommandLine.Builder.CommandLineBuilder,System.Boolean)}
			 * is set to `true`, all of the following command lines are equivalent: &gt; myapp -a -b
			 * -c arg &gt; myapp -abc arg &gt; myapp -abcarg
			 */
			EnablePosixBundling(value?: boolean): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Ensures that the application is registered with the dotnet-suggest tool to enable
			 * command line completions.
			 *
			 * For command line completions to work, users must install the dotnet-suggest tool as
			 * well as the appropriate shim script for their shell.
			 */
			RegisterWithDotnetSuggest(): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables the use of the [env:key=value] directive, allowing environment variables to be
			 * set from the command line during invocation.
			 */
			UseEnvironmentVariableDirective(): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Uses the default configuration.
			 *
			 * Calling this method is the equivalent to calling: builder .UseVersionOption()
			 * .UseHelp() .UseEnvironmentVariableDirective() .UseParseDirective()
			 * .UseSuggestDirective() .RegisterWithDotnetSuggest() .UseTypoCorrections()
			 * .UseParseErrorReporting() .UseExceptionHandler() .CancelOnProcessTermination();
			 */
			UseDefaults(): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables an exception handler to catch any unhandled exceptions thrown by a command
			 * handler during invocation.
			 */
			UseExceptionHandler(
				onException?: System.Action$2<System.Exception, System.CommandLine.Invocation.InvocationContext>,
				errorExitCode?: number,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Configures the application to show help when one of the following options are
			 * specified on the command line: -h /h --help -? /?
				 */
				UseHelp(maxWidth?: number): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Configures the application to show help when one of the specified option aliases are
			 * used on the command line.
			 *
			 * The specified aliases will override the default values.
			 */
			UseHelp(helpAliases: string[]): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Configures the application to show help when one of the specified option aliases are
			 * used on the command line.
			 *
			 * The specified aliases will override the default values.
			 */
			UseHelp(
				customize: System.Action$1<System.CommandLine.Help.HelpContext>,
				maxWidth?: number,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Adds a middleware delegate to the invocation pipeline called before a command handler
			 * is invoked.
			 */
			AddMiddleware(
				middleware: System.CommandLine.Invocation.InvocationMiddleware,
				order?: System.CommandLine.Invocation.MiddlewareOrder,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Adds a middleware delegate to the invocation pipeline called before a command handler
			 * is invoked.
			 */
			AddMiddleware(
				onInvoke: System.Action$1<System.CommandLine.Invocation.InvocationContext>,
				order?: System.CommandLine.Invocation.MiddlewareOrder,
			): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables the use of the [parse] directive, which when specified on the command line
			 * will short circuit normal command handling and display a diagram explaining the parse
			 * result for the command line input.
			 */
			UseParseDirective(errorExitCode?: number): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Configures the command line to write error information to standard error when there
			 * are errors parsing command line input.
			 */
			UseParseErrorReporting(errorExitCode?: number): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables the use of the [suggest] directive which when specified in command line input
			 * short circuits normal command handling and writes a newline-delimited list of
			 * suggestions suitable for use by most shells to provide command line completions.
			 *
			 * The dotnet-suggest tool requires the suggest directive to be enabled for an
			 * application to provide completions.
			 */
			UseSuggestDirective(): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Configures the application to provide alternative suggestions when a parse error is
			 * detected.
			 */
			UseTypoCorrections(maxLevenshteinDistance?: number): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Specifies localization resources to be used when displaying help, error messages, and
			 * other user-facing strings.
			 */
			UseLocalizationResources(validationMessages: System.CommandLine.LocalizationResources): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Specifies a delegate used to replace any token prefixed with @ with zero or more other
			 * tokens, prior to parsing.
			 */
			UseTokenReplacer(replaceToken: System.CommandLine.Parsing.TryReplaceToken | undefined): System.CommandLine.Builder.CommandLineBuilder;

			/**
			 * Enables the use of a option (defaulting to the alias --version ) which when specified
			 * in command line input will short circuit normal command handling and instead write out
			 * version information before exiting.
			 */
			UseVersionOption(): System.CommandLine.Builder.CommandLineBuilder;

			UseVersionOption(aliases: string[]): System.CommandLine.Builder.CommandLineBuilder;
		}
	}

	export namespace System.CommandLine.Builder.CommandLineBuilderExtensions {
		/** Extension methods from {@link System.CommandLine.Builder.CommandLineBuilderExtensions} */
		export interface TBuilder {
			/**
			 * Specifies an {@link System.CommandLine.Help.HelpBuilder} to be used to format help
			 * output when help is requested.
			 */
			UseHelpBuilder<TBuilder>(getHelpBuilder: System.Func$2<System.CommandLine.Binding.BindingContext, System.CommandLine.Help.HelpBuilder>): TBuilder;
		}
	}

	export namespace System.CommandLine.Binding {
		/** [Generic type factory] Supports binding of custom types. */
		export function BinderBase$(T: IType): typeof BinderBase$1<any>;

		/** Supports binding of custom types. */
		export class BinderBase$1<T> {
		}
	}

	export namespace System.CommandLine.Binding {
		/**
		 * Creates object instances based on command line parser results, injected services, and
		 * other value sources.
		 */
		export class BindingContext {
			/** The parse result for the current invocation. */
			readonly ParseResult: System.CommandLine.Parsing.ParseResult;

			/** The console to which output should be written during the current invocation. */
			readonly Console: System.CommandLine.IConsole;

			GetService(serviceType: System.Type): System.Object | undefined;

			/** Adds the specified service factory to the binding context. */
			AddService(
				serviceType: System.Type,
				factory: System.Func$2<unknown, System.Object>,
			): void;

			/** Adds the specified service factory to the binding context. */
			AddService<T>(factory: System.Func$2<unknown, T>): void;
		}
	}

	export namespace System.CommandLine.Binding {
		/** A value created by binding command line input. */
		export class BoundValue extends System.ValueType {
			/** The descriptor for the bound value. */
			readonly ValueDescriptor: System.CommandLine.Binding.IValueDescriptor;

			/** The source from which the value was bound. */
			readonly ValueSource: System.CommandLine.Binding.IValueSource;

			/** The value bound from the specified source. */
			readonly Value?: System.Object;

			/** Returns the fully qualified type name of this instance. */
			ToString(): string;
		}
	}

	export namespace System.CommandLine.Binding {
		/** Describes and provides access to a bindable named value. */
		export interface IValueDescriptor {
			/** The name of the value. */
			readonly ValueName: string;

			/** The type of the value. */
			readonly ValueType: System.Type;

			/** Gets a value determining whether there is a default value. */
			readonly HasDefaultValue: boolean;

			/** Gets the default value, if any. */
			GetDefaultValue(): System.Object | undefined;
		}
	}

	export namespace System.CommandLine.Binding {
		export function IValueDescriptor$(T: IType): IType;

		export interface IValueDescriptor$1<T> extends System.CommandLine.Binding.IValueDescriptor {
		}
	}

	export namespace System.CommandLine.Binding {
		/**
		 * Binds a value from a {@link System.CommandLine.Binding.BindingContext} based on a
		 * {@link System.CommandLine.Binding.IValueDescriptor}.
		 */
		export interface IValueSource {
			TryGetValue(
				valueDescriptor: System.CommandLine.Binding.IValueDescriptor,
				bindingContext: System.CommandLine.Binding.BindingContext,
			): System.Object | undefined;
		}
	}
}
