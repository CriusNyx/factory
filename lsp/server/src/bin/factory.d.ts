// Generated for: factory 1.0.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.8.0.0
/* eslint-disable */

import './System.Runtime';
import './GenParse';

declare module 'node-api-dotnet' {

	export namespace Resources {
		export function GetPathForResource(localPath: string): string;
	}

	export class RecipeSearchRequest {
		constructor(
			recipe: RecipeValue,
			quantity: System.Decimal,
		);
	}

	export class RecipeSearchRequestArg extends FactVal {
		constructor();

		static CreateArgFromRawValue(value: System.Object): RecipeSearchRequestArg | undefined;
	}

	export class RecipeSearchRequestQuantityArg extends RecipeSearchRequestArg {
		constructor(quantity: System.Decimal);
	}

	export class RecipeSearchRequestTallyArg extends RecipeSearchRequestArg {
		constructor(itemIdentifier: string);
	}

	export class RecipeBalance {
		constructor(elements: RecipeBalanceElement[]);

		static Create(root: RecipeSearchNode): RecipeBalance;

		GetValueForIdentifier(identifier: string): System.Decimal;
	}

	export class RecipeBalanceElement extends System.ValueType {
		constructor(
			identifier: string,
			quantity: System.Decimal,
		);

		Clone(
			identifier?: string,
			quantity?: System.Decimal,
		): RecipeBalanceElement;
	}

	export namespace RecipeSearch {
		export function Search(request: RecipeSearchRequest): RecipeSearchResult;

		export function ResolveRecipe(
			recipeValue: RecipeValue,
			amount: System.Decimal,
		): RecipeSearchNode | undefined;

		export function MakeResult(
			input: [Recipe | undefined, string | undefined, System.Decimal],
			context: RecipeValue,
		): RecipeSearchNode | undefined;

		export function MakeBiproducts(
			recipe: Recipe | undefined,
			quantity: System.Decimal,
		): RecipeSearchNode[];

		export function ResolveRecipe(
			itemIdentifier: string,
			context: RecipeValue,
			amount: System.Decimal,
		): [Recipe | undefined, string | undefined, System.Decimal];
	}

	export class RecipeSearchNode {
		constructor(
			recipe: Recipe,
			quantity: System.Decimal,
			children: RecipeSearchNode[],
			item: Item,
		);

		constructor(
			nodeName: string,
			quantity: System.Decimal,
			item: Item,
		);

		constructor(
			quantity: System.Decimal,
			nodeName: string | undefined,
			recipe: Recipe | undefined,
			item: Item | undefined,
			children: RecipeSearchNode[],
		);

		ToString(): string;

		PrintTree(): string;

		FormatQuantity(): string;

		static Crawl(
			root: RecipeSearchNode,
			visitor: System.Action$2<RecipeSearchNode, number>,
		): void;
	}

	export class RecipeSearchResult extends FactVal {
		constructor(
			request: RecipeSearchRequest,
			root: RecipeSearchNode,
		);

		readonly Recipe: RecipeValue;

		readonly Total: NumVal;

		ToString(): string;
	}

	export namespace SearchExtensions {
		export function Balance(
			result: RecipeSearchResult,
			hasInitialQuantity: boolean,
		): RecipeSearchResult;

		export function Multiply(
			node: RecipeSearchNode,
			value: System.Decimal,
		): RecipeSearchNode;
	}

	/** Extension methods from {@link .SearchExtensions} */
	export interface RecipeSearchResult {
		Balance(hasInitialQuantity: boolean): RecipeSearchResult;
	}

	/** Extension methods from {@link .SearchExtensions} */
	export interface RecipeSearchNode {
		Multiply(value: System.Decimal): RecipeSearchNode;
	}

	export class CommandLineOptions {
		constructor();

		file: string;

		outFile: string;

		dir: string;

		outDir: string;

		stream: boolean;

		ast: boolean;

		test: boolean;

		lexons: boolean;

		transform: boolean;

		debugGrammar: boolean;

		static Create(args: string[]): CommandLineOptions;

		ToString(): string;
	}

	export class Docs {
		constructor();
	}

	export class Item {
		constructor();

		readonly identifier: string;

		ComputeUIConversionRate(): System.Decimal;
	}

	export namespace ItemForm {
	}

	export class Quantity {
		constructor(amount: System.Decimal);

		readonly Amount: System.Decimal;

		readonly item?: Item;

		readonly identifier: string;

		ToString(): string;

		ToString(productionRate: System.Decimal): string;

		static GetDisplayName(quantity: Quantity | undefined): string;
	}

	export class Recipe extends FactVal implements IFunc {
		constructor();

		readonly isAlternative: boolean;

		readonly primaryProductClass: string;

		readonly primaryProduct: Item;

		readonly identifier: string;

		readonly isMachineRecipe: boolean;

		ToString(): string;

		Invoke(_arguments: ArrayVal): FactVal;
	}

	export class FactoryParseException extends ParseException$1<Factory.Parsing.FactoryLexon> {
		constructor(
			sourceLocation: string,
			sourceCode: string,
			lexon: GenParse.Lexing.Lexon$1<Factory.Parsing.FactoryLexon>,
		);
	}

	export class NoSourceFileException extends System.Exception {
		constructor();
	}

	export class OutDirException extends System.Exception {
		constructor();
	}

	export class ExecutionContext {
		constructor(
			standardIn: System.IO.TextReader,
			standardOut: System.IO.TextWriter,
		);

		constructor();

		Resolve(identifier: SymbolVal): FactVal | undefined;

		Assign(
			identifier: string,
			val: FactVal,
		): void;

		dispose(): void;
	}

	export interface ISpread {
		Spread(): ArrayVal;
	}

	export interface IUnfold {
		Unfold(): FactVal[];
	}

	export class RuntimeAssertException extends System.Exception {
		constructor(message: string);
	}

	export namespace RuntimeAssert {
		export function ASTNodeType(
			astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>,
			type: string,
		): void;
	}

	export class RecipeInvocation {
		constructor(
			recipeValue: RecipeValue,
			quantity?: System.Decimal,
			hasQuantityValue?: boolean,
		);

		Amend(factVal: FactVal): RecipeInvocation;

		Clone(
			recipeValue?: RecipeValue,
			quantity?: System.Decimal,
		): RecipeInvocation;

		Invoke(): FactVal;

		static InvokeRecipe(
			recipe: FactVal,
			invocationParams: ArrayVal,
		): FactVal;
	}

	export class AssignExpNode implements
		ProgramExp,
		LanguageNode {
		constructor();

		Evaluate(context: ExecutionContext): [FactVal | undefined, ExecutionContext];

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;
	}

	export class ChainContinueTransformerNode {
		constructor();

		Transform(): System.Object;
	}

	export interface ChainNode extends LanguageNode {
		Evaluate(
			target: FactVal,
			context: ExecutionContext,
		): FactVal;

		GetIdentifier(): string;
	}

	export class DerefNode implements
		LanguageNode,
		ChainNode {
		constructor();

		Evaluate(
			target: FactVal,
			context: ExecutionContext,
		): FactVal;

		static EvaluateDereference(
			target: FactVal,
			fieldName: string,
		): FactVal;

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;

		GetIdentifier(): string;
	}

	export class ExpChainNode implements
		LanguageNode,
		ValueNode {
		constructor();

		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];

		GetReference(context: ExecutionContext): RefVal;

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;
	}

	export class InvocationNode implements
		LanguageNode,
		ChainNode {
		constructor(astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>);

		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;

		Evaluate(
			target: FactVal,
			context: ExecutionContext,
		): FactVal;

		GetIdentifier(): string;
	}

	export class InvocationParamSetTransformerNode {
		constructor();

		Transform(): System.Object;
	}

	export interface LanguageNode {
	}

	export class PrintExpNode implements
		ProgramExp,
		LanguageNode {
		constructor();

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;

		Evaluate(context: ExecutionContext): [FactVal | undefined, ExecutionContext];
	}

	export class ProgramNode implements LanguageNode {
		constructor();

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;

		Evaluate(executionContext: ExecutionContext): void;

		ToTree(): string;
	}

	export interface ProgramExp {
		Evaluate(context: ExecutionContext): [FactVal | undefined, ExecutionContext];
	}

	export class AltExpNode extends RecipeExpNode implements
		LanguageNode,
		ValueNode {
		constructor(astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>);

		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;
	}

	export class InExpNode extends RecipeExpNode implements
		LanguageNode,
		ValueNode {
		constructor(astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>);

		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;
	}

	export class LimitExpNode extends RecipeExpNode implements
		LanguageNode,
		ValueNode {
		constructor(astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>);

		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];
	}

	export class LimitValueExpNode implements LanguageNode {
		constructor();

		Evaluate(context: ExecutionContext): FactVal;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;
	}

	export class OutExpNode extends RecipeExpNode implements
		LanguageNode,
		ValueNode {
		constructor(astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>);

		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;
	}

	export class RecipeExpNode implements
		LanguageNode,
		ValueNode {
		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];
	}

	export class RecipeNode implements
		LanguageNode,
		ProgramExp {
		constructor();

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;
	}

	export class TallyExpNode extends RecipeExpNode implements
		LanguageNode,
		ValueNode {
		constructor(astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>);

		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		ToString(): string;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;
	}

	export class ObjectRefVal implements RefVal {
		constructor(
			owner: FactVal,
			identifier: string,
		);

		Set(factVal: FactVal): void;
	}

	export interface RefVal {
		Set(factVal: FactVal): void;
	}

	export class ScopeRefVal implements RefVal {
		constructor(
			context: ExecutionContext,
			identifier: string,
		);

		Set(factVal: FactVal): void;
	}

	export class SpreadExpNode extends RecipeExpNode implements
		LanguageNode,
		ValueNode {
		constructor(astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>);

		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;
	}

	export class SymbolNode implements
		LanguageNode,
		ValueNode {
		constructor(astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>);

		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		readonly symbolName: string;

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;

		Evaluate(): SymbolVal;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];

		ToString(): string;
	}

	export class LiteralExpNode implements LanguageNode {
		constructor();

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;
	}

	export interface LiteralNode extends
		LanguageNode,
		ValueNode {
	}

	export class NumberLiteralNode implements
		LiteralNode,
		LanguageNode,
		ValueNode {
		constructor(astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>);

		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;

		ToString(): string;
	}

	export class StringLiteralNode implements
		LanguageNode,
		ValueNode {
		constructor();

		astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		GetChildren(): Iterable<GenParse.Util.Formatting.ITree$1<LanguageNode>>;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];
	}

	export interface ValueNode extends LanguageNode {
		readonly astNode: GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon>;

		Evaluate(context: ExecutionContext): [FactVal, ExecutionContext];
	}

	export namespace ValueNodeExtensions {
	}

	export enum FactorySemanticModifier {
		none = 0,

		readonly = 1,
	}

	export namespace LexonExtensions {
		export function GetSemanticType(lexon: GenParse.Lexing.Lexon$1<Factory.Parsing.FactoryLexon>): Factory.Parsing.FactorySemanticType;

		export function GetSemanticModifier(lexon: GenParse.Lexing.Lexon$1<Factory.Parsing.FactoryLexon>): FactorySemanticModifier;
	}

	export class ArrayVal extends FactVal {
		constructor(array: FactVal[]);

		ToString(): string;

		UnfoldAll(): ArrayVal;
	}

	export class ExposeMemberAttribute extends System.Attribute {
		constructor(name: string);
	}

	export class FactVal {
	}

	export namespace FactValExtensions {
		export function IsLimitVal(factVal: FactVal): boolean;

		export function ToLimitVal(factVal: FactVal): [System.Decimal, string];

		export function ConvertToType(
			factVal: FactVal,
			type: System.Type,
		): System.Object;
	}

	/** Extension methods from {@link .FactValExtensions} */
	export interface FactVal {
		IsLimitVal(): boolean;

		ToLimitVal(): [System.Decimal, string];

		ConvertToType(type: System.Type): System.Object;
	}

	export class BoolVal extends FactVal {
		constructor(value: boolean);

		Equals(obj: System.Object | undefined): boolean;

		GetHashCode(): number;
	}

	export class FuncVal extends FactVal implements IFunc {
		constructor(func: System.Func$2<ArrayVal, FactVal>);

		Invoke(_arguments: ArrayVal): FactVal;

		static InvokeCSharpMethod(
			target: System.Object,
			methodInfo: System.Reflection.MethodInfo,
			_arguments: ArrayVal,
		): FactVal | undefined;
	}

	export interface IFunc {
		Invoke(_arguments: ArrayVal): FactVal;
	}

	export class NumVal extends FactVal {
		constructor(value: System.Decimal);

		ToString(): string;
	}

	export class PairVal extends FactVal {
		constructor(
			item1: FactVal,
			item2: FactVal,
		);

		Deconstruct(): { item1: FactVal, item2: FactVal };
	}

	export class RecipeValue extends FactVal implements
		ISpread,
		IFunc {
		constructor(
			recipeName: string,
			_arguments?: ArrayVal,
		);

		ToString(): string;

		AmendInvocation(arrayVal: ArrayVal): RecipeValue;

		Amend(factVal: FactVal): RecipeValue;

		Break(): void;

		Clone(
			recipeName?: string,
			_arguments?: ArrayVal,
		): RecipeValue;

		static FactValModifiesRecipeVal(factVal: FactVal): boolean;

		Spread(): ArrayVal;

		Invoke(_arguments: ArrayVal): FactVal;
	}

	export class SpreadVal extends FactVal implements IUnfold {
		constructor(arr: ArrayVal);

		Unfold(): FactVal[];
	}

	export class StringVal extends FactVal {
		constructor(value: string);

		ToString(): string;
	}

	export class SymbolVal extends FactVal {
		constructor(symbol: string);

		Equals(obj: System.Object | undefined): boolean;

		GetHashCode(): number;

		ToString(): string;
	}

	export class TallyVal extends SymbolVal {
		constructor(
			symbolVal: string,
			inline: boolean,
		);

		Equals(obj: System.Object | undefined): boolean;

		GetHashCode(): number;
	}

	export enum ValType {
		input = 0,

		output = 1,

		alt = 2,

		tally = 3,

		limit = 4,
	}

	export class TypedFactVal extends FactVal {
		constructor(
			type: ValType,
			value: FactVal,
		);

		Equals(obj: System.Object | undefined): boolean;

		GetHashCode(): number;

		ToString(): string;
	}

	export namespace ValExtensions {
		export function ToSymbolVal(str: string): SymbolVal;

		export function AsSymbolVal(factVal: FactVal): SymbolVal;

		export function ToNumVal(num: System.Decimal): NumVal;

		export function AsArrayVal(factVal: FactVal): ArrayVal;

		export function AsFactVal(value: System.Object): FactVal;

		export function ToArrayVal(factVal: FactVal[]): ArrayVal;

		export function Map(
			arrayVal: ArrayVal,
			func: System.Func$2<FactVal, FactVal>,
		): ArrayVal;

		export function Push(
			arrVal: ArrayVal,
			factVal: FactVal,
		): ArrayVal;

		export function PushRange(
			arrVal: ArrayVal,
			arrayVal: ArrayVal,
		): ArrayVal;

		export function PushOrReplace(
			arrVal: ArrayVal,
			other: FactVal,
			evaluate?: System.Func$2<FactVal, boolean>,
		): ArrayVal;

		export function Distinct(arrVal: ArrayVal): ArrayVal;

		export function Filter(
			arrVal: ArrayVal,
			func: System.Func$2<FactVal, boolean>,
		): ArrayVal;

		export function FilterType(
			arrVal: ArrayVal,
			type: ValType,
		): ArrayVal;

		export function ExtractSymbolsOfType(
			arrVal: ArrayVal,
			type: ValType,
		): string[];
	}

	export namespace System {
		/** Extension methods from {@link .ValExtensions} */
		export interface String {
			ToSymbolVal(): SymbolVal;
		}
	}

	/** Extension methods from {@link .ValExtensions} */
	export interface FactVal {
		AsSymbolVal(): SymbolVal;

		AsArrayVal(): ArrayVal;
	}

	export namespace System {
		/** Extension methods from {@link .ValExtensions} */
		export interface Object {
			AsFactVal(): FactVal;
		}
	}

	/** Extension methods from {@link .ValExtensions} */
	export interface ArrayVal {
		Map(func: System.Func$2<FactVal, FactVal>): ArrayVal;

		Push(factVal: FactVal): ArrayVal;

		PushRange(arrayVal: ArrayVal): ArrayVal;

		PushOrReplace(
			other: FactVal,
			evaluate?: System.Func$2<FactVal, boolean>,
		): ArrayVal;

		Distinct(): ArrayVal;

		Filter(func: System.Func$2<FactVal, boolean>): ArrayVal;

		FilterType(type: ValType): ArrayVal;

		ExtractSymbolsOfType(type: ValType): string[];
	}

	export namespace Factory {
		export namespace FactoryAnalytics {
			export function AnalyzeSemanticTokens(sourceCode: string): Factory.FactorySemanticToken[];

			export function AnalyzeProgram(sourceCode: string): void;

			export function GetSemanticTypes(): string[];

			export function GetSemanticModifiers(): string[];

			export function AnalyzeErrors(sourceCode: string): void;
		}
	}

	export namespace Factory {
		export class FactorySemanticToken {
			constructor(
				position: number,
				length: number,
				semanticType: Factory.Parsing.FactorySemanticType,
				modifier: number,
			);

			position: number;

			length: number;

			semanticType: Factory.Parsing.FactorySemanticType;

			modifier: number;

			ToString(): string;
		}
	}

	export namespace Factory.Parsing {
		export class FactoryLexer {
			constructor();

			static LexFactory(code: string): GenParse.Lexing.Lexon$1<Factory.Parsing.FactoryLexon>[];
		}
	}

	export namespace Factory.Parsing {
		export enum FactoryLexon {
			comment = 0,

			whitespace = 1,

			dot = 2,

			comma = 3,

			openParen = 4,

			closeParen = 5,

			equalSign = 6,

			spread = 7,

			letKeyword = 8,

			recipeKeyword = 9,

			altKeyword = 10,

			outKeyword = 11,

			inKeyword = 12,

			printKeyword = 13,

			tallyKeyword = 14,

			inlineKeyword = 15,

			limitKeyword = 16,

			numberLiteral = 17,

			stringLiteral = 18,

			symbol = 19,

			None = 20,
		}
	}

	export namespace Factory.Parsing {
		export namespace FactoryParser {
			export var GrammarSource: string;

			export const ProgramLexonHeads: Factory.Parsing.FactoryLexon[];

			export const RecipeExpLexonHeads: Factory.Parsing.FactoryLexon[];

			export function GenerateFactoryParser(): GenParse.Parsing.Parser$1<Factory.Parsing.FactoryLexon>;

			export function Parse(
				sourceCode: string,
				recover?: boolean,
			): GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon> | undefined;

			export function Parse(
				lexons: GenParse.Lexing.Lexon$1<Factory.Parsing.FactoryLexon>[],
				forgiving?: boolean,
			): GenParse.Parsing.ASTNode$1<Factory.Parsing.FactoryLexon> | undefined;
		}
	}

	export namespace Factory.Parsing {
		export enum FactorySemanticType {
			whitespace = 0,

			comment = 1,

			operator = 2,

			keyword = 3,

			modifier = 4,

			number = 5,

			string = 6,

			variable = 7,
		}
	}
}
